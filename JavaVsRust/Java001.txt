Date 18 October 2024
Friday

Key ideas

- Human minds process pyramids better
- Hence LLMs also process pyramids better

Whatever we might want to do

problem solving can be at the level of random conversations & data collections, but problem communication shall always be like a pyramid

3 months
- we want to master basic backend
- learn about a lot of computer science broad peripheral concepts which surround backend development
- going deep is not the goal, but breezing fast is, because he LLMs can accelerate our own progression

--- Session 1 ---

Q1: How to spin up a simple server in Java which prints "Hello World" when I press tell me something button

and how does it work?

A1: 



"Hey, ever wondered how your favorite websites magically appear when you click a button? Let's build our own mini-internet magic!"

Picture this: You're at a fancy restaurant. You press a button, and voila! A waiter appears with your order. That's exactly what we're going to do with our Java server, but instead of food, it'll serve up a "Hello World" message!

Let's break it down:

1. 🏗️ Setting up our kitchen (development environment):
   - Install Java Development Kit (JDK) and Maven in one go:
     ```bash
     sudo apt update && sudo apt install -y openjdk-11-jdk maven
     ```
   - Create a Spring Boot project:
     ```bash
        cd /home/amuldotexe/Desktop/GitHub202410/pensieve/JavaVsRust/javaProj001
        mvn archetype:generate -DgroupId=com.example -DartifactId=hello-world -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false
        cd hello-world
     ```
   - Update the pom.xml file with Spring Boot configuration (as shown in the previous response)
   - Organize your project structure:
     ```bash
     // The keyword 'example' is used here to follow the convention of using 'com.example' as a placeholder domain in sample code.
     // If it was 'low-drama.com', the folder names would be 'com/lowdrama/helloworld'.

     mkdir -p src/main/java/com/example/helloworld/controller
     mkdir -p src/main/java/com/example/helloworld/service
     mkdir -p src/main/java/com/example/helloworld/repository
     mkdir -p src/main/resources
     mkdir -p src/test/java/com/example/helloworld
     ```

2. 🏛️ Spring Boot Application Structure

Let's visualize the structure of our Spring Boot application:

```
Spring Boot Application Structure
┌─────────────────────────────────────────────────────────────┐
│                   Spring Boot Application                   │
│                                                             │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐      │
│  │  Controller │    │   Service   │    │ Repository  │      │
│  │    Layer    │◄───│    Layer    │◄───│    Layer    │      │
│  └─────────────┘    └─────────────┘    └─────────────┘      │
│         ▲                  ▲                  ▲             │
│         │                  │                  │             │
│         │                  │                  │             │
│  ┌─────────────────────────────────────────────────────┐    │
│  │                  Spring Boot Core                   │    │
│  │  (Auto-configuration, Dependency Injection, etc.)   │    │
│  └─────────────────────────────────────────────────────┘    │
│                              ▲                              │
└──────────────────────────────│──────────────────────────────┘
                                │
                         ┌─────────────┐
                         │    JVM      │
                         └─────────────┘
```

- Can we say that controller is the like the control tower of an airport which tells you where your airline needs to go or whom does it need to talk to?
    - The URL is built up of prefix.domain-name.country-suffix/some-path/some-more-path and the person who knows where this URL should hit is the controller - it is like a first point of contact for the backend application
    - Everythign for the controller is like something whcih is sent by the frontend of the application

- In a simple web application, the controller routes hands the baton to the service layer - which is basically a class in Java which has the business logic of what to do with the parameters or any data received from the controller - it then does SOMETHING with it - can be from transformation to denial - but it will hand it back to the controller
    - Service layer is the business logic layer

- When we look at data which is permenntn, needs to be edited, destroyed, aggregated, persisted or other wise held on to in our servers for long term - it is NOT a transient message - it is something worth storing for longer - then it is the repository layer most likely implmented in the following types of data stores
    - Relational Databases (SQL): MySQL, PostgreSQL, MS SQL Server, Oracle
    - Document-Oriented Databases (NoSQL): MongoDB, CouchDB
    - Key-Value Stores (NoSQL): Redis, Amazon DynamoDB, Riak
    - Wide-Column Stores (NoSQL): Apache Cassandra, Google Bigtable, HBase
    - Graph Databases: Neo4J, OrientDB, ArangoDB
    - Object-Oriented Databases: Couchbase, ObjectStore
    - In-Memory Databases: Redis, Memcached
    - Time Series Databases: InfluxDB, Druid, eXtremeDB
    - Search Engines: Elasticsearch, Solr
    - Cloud Databases: Microsoft Azure SQL Database, Amazon RDS, Oracle Autonomous Database
    - Columnar Databases: Google BigQuery, MariaDB, Azure SQL Data Warehouse
    - Hierarchical Databases: IBM IMS, Windows Registry
    - Rust Aligned Databases:
        - SQL: sqlx (PostgreSQL, MySQL, SQLite), diesel (PostgreSQL, SQLite, MySQL)
        - NoSQL: mongodb (MongoDB), redis (Redis)
        - Time Series: influx_db_client (InfluxDB)
        - Key-Value: sled, rocksdb, leveldb
        - Graph: cassandra-cpp (Cassandra)
    - Each of these has their pros and cons, you have to think of them as different kind of arrows which Arjuna had in his kamaan, and each one is relevant for a specific use case, you cannot spend a brahmastra to kill a fly, just like you would not use a simple wooden arrow to try to kill duryodhana, you have to realize that context is everything, and the choice of the database is heavily driven by the use case at hand according to what user experience we want to create in the context of the business we are in
        - simplest example is if you want a lot of agggreation types queries showing up in your application then the NoSQL thing is not for you, you need an RDBMS to run blazing fast aggreation queries of some type

💡 Insight: This layered architecture promotes separation of concerns, making your code more modular and easier to maintain.

3. 🧩 Components Explained

a) Controller Layer:
   - Acts as the waiter in our restaurant analogy
   - Handles HTTP requests and defines API endpoints
   - Example:
     ```java
     @RestController
     public class HelloController {
         @GetMapping("/hello")
         public String sayHello() {
             return "Hello, World!";
         }
     }
     ```

b) Service Layer:
   - The chef in our restaurant
   - Contains business logic
   - Example:
     ```java
     @Service
     public class HelloService {
         public String getGreeting() {
             return "Hello, World!";
         }
     }
     ```

c) Repository Layer:
   - Like the pantry in our restaurant
   - Handles data access and storage
   - Not always necessary for simple applications

d) Spring Boot Core:
   - The restaurant's management system
   - Handles auto-configuration, dependency injection, etc.

4. 🚀 Running the Application

```bash
cd /home/amuldotexe/Desktop/GitHub202410/pensieve/JavaVsRust/javaProj001/hello-world
mvn spring-boot:run
```

Access the application at: http://localhost:8080/hello

5. 🎭 Design Choice: Why This Structure?

Imagine building a skyscraper. You don't just throw all the materials together; you create a structured plan with different levels and systems. Similarly, this Spring Boot structure:

- Separates concerns: Each layer has a specific job, like different departments in a company
- Promotes modularity: Easy to modify or replace individual components
- Enhances testability: You can test each layer independently
- Improves scalability: As your app grows, the structure accommodates new features easily

6. 🔍 Key Learnings

- Spring Boot simplifies Java application setup
- The layered architecture promotes clean, maintainable code
- Each component (Controller, Service, Repository) has a specific role
- This structure is overkill for a simple "Hello World", but sets the foundation for more complex applications

Remember, just like in physics where simple principles lead to complex phenomena, these basic Spring Boot concepts are the building blocks for sophisticated web applications!

-----------------------

   cd /home/amuldotexe/Desktop/GitHub202410/pensieve/JavaVsRust/javaProj001/hello-world

   mvn spring-boot:run

   http://localhost:8080/hello

------


Key learnings




