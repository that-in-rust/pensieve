
Quick crash course on Rust - Syntax & Basic Components Checklist:

@Web[https://doc.rust-lang.org/book/]
1. Getting Started
   - [ ] Installation: Set up Rust development environment
   - [ ] Hello, World!: Write and run your first Rust program
   - [ ] Hello, Cargo!: Learn to use Cargo, Rust's package manager

2. Programming Concepts
   - [ ] Variables and Mutability
     - [ ] Immutable variables with `let`
     - [ ] Mutable variables with `let mut`
     - [ ] Constants with `const`
   - [ ] Data Types
     - [ ] Scalar types: integers, floating-point numbers, booleans, and characters
     - [ ] Compound types: tuples and arrays
   - [ ] Functions
     - [ ] Function definitions with `fn`
     - [ ] Parameters and return values
   - [ ] Comments
     - [ ] Single-line comments with `//`
     - [ ] Multi-line comments with `/* */`
   - [ ] Control Flow
     - [ ] `if` expressions
     - [ ] Loops: `loop`, `while`, and `for`

3. Understanding Ownership
   - [ ] Ownership Rules
   - [ ] Variable Scope
   - [ ] The `String` Type
   - [ ] Memory and Allocation
   - [ ] Move semantics
   - [ ] Clone
   - [ ] Stack-Only Data: Copy
   - [ ] Ownership and Functions
   - [ ] Return Values and Scope

4. References and Borrowing
   - [ ] References
   - [ ] Mutable References
   - [ ] Rules of References
   - [ ] The Slice Type

5. Structs and Enums
   - [ ] Defining and Instantiating Structs
   - [ ] Method Syntax
   - [ ] Associated Functions
   - [ ] Defining Enums
   - [ ] The `Option` Enum

6. Pattern Matching
   - [ ] The `match` Control Flow Operator
   - [ ] Patterns That Bind to Values
   - [ ] Matching with `Option<T>`
      "Ever played 'Hide and Seek' where sometimes you find your friend, and sometimes you don't? That's Option<T> in a nutshell!"

      Imagine you're a detective trying to find a missing person. Sometimes you find them (that's `Some(T)`), and sometimes you don't (that's `None`). Rust's `Option<T>` is like your investigation report - it always tells you clearly whether you found the person or not.

      üí° Insight: `Option<T>` and pattern matching form the backbone of Rust's null safety, eliminating null pointer exceptions.

      üîç Design Choice: Rust uses `Option<T>` instead of null values to make absence of value explicit and force handling of both cases.

      Code example with annotations:
      ```rust
      fn find_person(name: &str) -> Option<u32> {
      //  |           |      |        |
      //  |           |      |        Return type: Option<u32>
      //  |           |      Parameter: &str (string slice)
      //  |           Function name
      //  Function declaration keyword
          let people = vec![("Alice", 30), ("Bob", 25), ("Charlie", 35)];
          //  |        |     |                                        |
          //  |        |     Vector of tuples                         |
          //  |        Vector creation macro                          |
          //  Variable declaration                                    Semicolon
          
          for (person, age) in people {
          //  |          |    |    |
          //  |          |    |    Vector to iterate over
          //  |          |    'in' keyword for iteration
          //  |          Tuple unpacking
          //  'for' loop keyword
              if person == name {
              // |       |
              // |       Comparison operator
              // 'if' condition
                  return Some(age);  // Person found, return their age
                  //     |     |
                  //     |     Value wrapped in Some
                  //     Some variant of Option
              }
          }
          
          None  // Person not found
          // | 
          // None variant of Option (implicitly returned)
      }
      ```

      fn main() {
          let names = vec!["Alice", "David", "Bob"];
          
          for name in names {
              match find_person(name) {
                  Some(age) => println!("{} is {} years old", name, age),
                  None => println!("{} was not found", name),
              }
          }
      }
      ```

      This code demonstrates:
      1. Defining a function that returns an `Option<T>`
      2. Using `match` to handle both `Some` and `None` cases
      3. Safely working with potentially absent values

      Try it out: Modify the `find_person` function to return more information, like `Option<(u32, String)>` for age and occupation.

7. Modules and Crates
   - [ ] Packages and Crates
   - [ ] Defining Modules to Control Scope and Privacy
   - [ ] Paths for Referring to an Item in the Module Tree
   - [ ] The `use` Keyword
   - [ ] Separating Modules into Different Files

8. Common Collections
   - [ ] Vectors
      "Imagine you're organizing a party and your guest list keeps growing. That's exactly what a Vector does - it's a dynamic party list that grows with your needs!"

      Picture a magical, expandable bookshelf. You start with a few books, but as your collection grows, the shelf automatically expands to fit more. That's how Vectors work in Rust!

      üí° Insight: Vectors in Rust combine the flexibility of dynamic arrays with the performance of contiguous memory allocation.

      üîç Design Choice: Rust's Vec<T> uses a smart growth strategy, typically doubling its capacity when full, to balance memory usage and reallocation frequency.

      Code example with annotations:
      ```rust
      fn main() {
          // Create a new, empty vector
          let mut party_guests: Vec<String> = Vec::new();

          // Add guests to our party (push to the vector)
          party_guests.push(String::from("Alice"));
          party_guests.push(String::from("Bob"));
          party_guests.push(String::from("Charlie"));

          println!("Current guest list: {:?}", party_guests);
          // üì¶ Output: Current guest list: ["Alice", "Bob", "Charlie"]

          // Oh no, Bob can't make it! Let's remove him (pop from the vector)
          if let Some(leaving_guest) = party_guests.pop() {
              println!("{} can't make it to the party", leaving_guest);
              // üî§ Output: Charlie can't make it to the party
          }

          // Let's check how many guests we have now
          println!("Number of guests: {}", party_guests.len());
          // üìä Output: Number of guests: 2

          // We can also access guests by their index
          if let Some(first_guest) = party_guests.get(0) {
              println!("First guest to arrive: {}", first_guest);
              // üéÅ Output: First guest to arrive: Alice
          }

          // Let's print our final guest list
          println!("Final guest list:");
          for (index, guest) in party_guests.iter().enumerate() {
              println!("{}. {}", index + 1, guest);
          }
          // üì¶ Output:
          // Final guest list:
          // 1. Alice
          // 2. Bob
      }
      ```

      This code demonstrates:
      1. Creating a new Vector
      2. Adding elements (push)
      3. Removing elements (pop)
      4. Checking the length
      5. Accessing elements by index
      6. Iterating over the Vector

      Try it out: Modify the code to add a VIP section to your party. Create a second Vector for VIP guests and experiment with methods like `extend` to combine the lists.
   - [ ] Strings
   - [x] Hash Maps

   Hey there! Let's dive into Rust's HashMaps. They're like a super-smart dictionary where you can store key-value pairs.

   Basic syntax:
   ```rust
   use std::collections::HashMap;

   let mut map = HashMap::new();
   map.insert(key, value);
   ```

   Example 1: Fruit Inventory
   ```rust
   let mut fruits = HashMap::new();
   fruits.insert("apple", 5);
   fruits.insert("banana", 3);

   // Visual representation:
   //  +--------+-------+
   //  |  Key   | Value |
   //  +--------+-------+
   //  | apple  |   5   |
   //  | banana |   3   |
   //  +--------+-------+
   ```

   Example 2: User Scores
   ```rust
   let mut scores = HashMap::new();
   scores.insert(String::from("Alice"), 100);
   scores.insert(String::from("Bob"), 85);

   // Accessing values
   if let Some(score) = scores.get("Alice") {
       println!("Alice's score: {}", score);
   }

   // Visual representation:
   //  +-------+-------+
   //  |  Key  | Value |
   //  +-------+-------+
   //  | Alice |  100  |
   //  | Bob   |   85  |
   //  +-------+-------+
   ```

   Remember, HashMaps are unordered, so the order of elements might vary. They're super efficient for lookups, which is why they're used so often in Rust programming!

   @Web [Source](https://doc.rust-lang.org/rust-by-example/std/hash.html)

9. Error Handling
   - [ ] Unrecoverable Errors with `panic!`
   - [ ] Recoverable Errors with `Result`
   - [ ] To `panic!` or Not to `panic!`

10. Generic Types, Traits, and Lifetimes
    - [ ] Generic Data Types
        "Hey, can you make this function work for any type?" 
        "Sure! Let me show you the magic of generics in Rust."

        Imagine you're designing a Swiss Army knife. Instead of creating separate tools for each type, you create a single, adaptable tool that works with many types. That's what generics do in programming!

        ```rust
        fn largest<T: PartialOrd>(list: &[T]) -> &T {
            // T: PartialOrd means T implements the PartialOrd trait
            // This is similar to saying T is "comparable" in other languages
            // It's like T has a < operator, so we can compare items
            
            // &[T] is a slice of T, similar to T[] in languages like Java or C#
            // -> &T means we return a reference to a T, not the T itself
            let mut largest = &list[0];
            
            for item in list {
                if item > largest {
                    largest = item;
                }
            }

            println!("The largest item is: {:?}", largest);
            largest
        }

        fn main() {
            let numbers = vec![34, 50, 25, 100, 65];
            let result = largest(&numbers);
            println!("The largest number is {}", result);

            let chars = vec!['y', 'm', 'a', 'q'];
            let result = largest(&chars);
            println!("The largest char is {}", result);
        }
        ```

        ‚Üë See that `<T: PartialOrd>`? It's like saying "This function works with any type T that can be compared".
          The `largest` function can now work with numbers, characters, or any type that can be ordered!

        üîç Design Choice: Rust's generics are monomorphized at compile time, meaning there's no runtime cost for using them. This is different from languages like Java where generics are implemented through type erasure.

        Imagine you're a chef preparing for a big dinner party. In Java, it's like you have a single, all-purpose kitchen tool that you use for every dish. You adapt on the fly, but it's not always efficient. That's type erasure - one tool trying to do everything.

        Now, Rust is more like having a magical kitchen where, as you plan each dish, custom tools appear specifically for that recipe. When you compile your Rust code, it's as if the kitchen creates a perfect, specialized tool for each generic type you use. This is monomorphization.

        So, when you run your Rust program, it's like cooking with a kitchen full of perfectly tailored tools. Everything's faster and more efficient because each tool (or function) is exactly what you need for each specific type.

        This is why Rust's approach is often faster: instead of figuring things out as you go (runtime), all the specialized versions are ready to go from the start. It's like the difference between improvising a meal and having everything mise en place!

        üí° Insight: Generics allow you to write flexible, reusable code without sacrificing performance. They're the foundation for many of Rust's powerful abstractions.

        Try it out: Implement a generic `Point` struct that can work with different numeric types!
    - [ ] Traits: Defining Shared Behavior
    - [ ] Validating References with Lifetimes

@Web[https://doc.rust-lang.org/rust-by-example/]
11. Advanced Features
    - [ ] Unsafe Rust
    - [ ] Advanced Traits
    - [ ] Advanced Types
    - [ ] Advanced Functions and Closures
    - [ ] Macros

12. Cargo and crates.io
    - [ ] Release Profiles
    - [ ] Publishing to crates.io
    - [ ] Cargo Workspaces
    - [ ] Installing Binaries from crates.io
    - [ ] Extending Cargo with Custom Commands

13. Asynchronous Programming
    - [ ] Async/Await syntax
    - [ ] Futures
    - [ ] Pinning

14. Testing
    - [ ] Writing and Running Tests
    - [ ] Test Organization
    - [ ] Integration Tests

15. Smart Pointers
    - [ ] `Box<T>`
    - [ ] `Rc<T>`
    - [ ] `RefCell<T>` and the Interior Mutability Pattern

16. Concurrency
    - [ ] Threads
    - [ ] Message Passing
    - [ ] Shared State Concurrency

17. Object-Oriented Programming Features
    - [ ] Characteristics of Object-Oriented Languages
    - [ ] Trait Objects for Different Types
    - [ ] Object-Oriented Design Pattern Implementation

18. Pattern Matching (Advanced)
    - [ ] All the Places Patterns Can Be Used
    - [ ] Refutability: Whether a Pattern Might Fail to Match
    - [ ] Pattern Syntax

19. Unsafe Rust (Advanced)
    - [ ] Unsafe Superpowers
    - [ ] Calling an Unsafe Function or Method
    - [ ] Creating a Safe Abstraction over Unsafe Code
    - [ ] Using `extern` Functions to Call External Code
    - [ ] Accessing or Modifying a Mutable Static Variable
    - [ ] Implementing an Unsafe Trait
    - [ ] Accessing Fields of a Union

20. Advanced Project: Building a Multithreaded Web Server
    - [ ] Building a Single-Threaded Web Server
    - [ ] Turning it into a Multithreaded Server
    - [ ] Graceful Shutdown and Cleanup

