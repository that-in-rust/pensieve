04 Nov 2024 0800 hrs

Monday

we will note down all the concepts that we are learning in this project

let's start with what scares us the most:
async programming in rust


Imagine you're playing a video game and need to load a big map.
With a normal function, the game would freeze until loading finishes.
But with async, the game keeps running while the map loads in the background!

That's why we use async here - reading ZIP files can be slow,
but we don't want to freeze the whole program while we wait.
The async function lets other code run while we're reading the ZIP.

Normal:     Async:
  [WAIT]      [Other]
  [WAIT]  vs  [Other]
  [WAIT]      [Other]
  [Done]      [Done]


Explain the tokio spawn_blocking function using this example - what does this code do?

```rust
        let analysis = tokio::task::spawn_blocking(move || -> Result<ZipAnalysis> {
        //  ┌─────────┐  ┌────────────────────┐  ┌───────────────────────────┐
        //  │ Store   │  │ Create new thread  │  │ Closure that will run     │
        //  │ result  │  │ for blocking work  │  │ in the new thread         │
        //  └─────────┘  └────────────────────┘  └───────────────────────────┘
        //                                              ↓
        //                                       ┌─────────────────┐
        //                                       │ move = take     │
        //                                       │ ownership of    │
        //                                       │ used variables  │
        //                                       └─────────────────┘
        }).await??;  
        //  ↑   ↑↑
        //  │   │└─ Handle Result from ZipAnalysis
        //  │   └── Handle thread errors
        //  └────── Wait for thread to finish
```
The closure part is: move || -> Result<ZipAnalysis>
  ┌────┐ ┌┐ ┌─────────────────────┐
  │move│ ││ │Return type          │ 
  │    │ ││ │(Result<ZipAnalysis>)│
  └────┘ └┘ └─────────────────────┘
    ↑     ↑
    │     └─ Empty params list ||
    └─ Keyword to take ownership

what does an empty params list mean for a closure?

it means the closure takes no parameters - it will just execute its body using only captured variables from the outer scope. in our case, it uses zip_path which it captured, but doesn't need any additional inputs.


Future explained:
spawn_blocking returns a JoinHandle<Result<ZipAnalysis>>

JoinHandle is a type from tokio that represents an asynchronous task running in the background. It lets us:
- Check if task completed
- Get result when done
- Cancel task if needed
- Handle errors if task panics

JoinHandle isn't shown in the closure syntax because it's the implicit return type of spawn_blocking itself. The closure syntax only shows what WE provide (the move closure returning Result<ZipAnalysis>). spawn_blocking then wraps our closure's return type in JoinHandle automatically.

Think of it like this:
spawn_blocking: Fn(closure) -> JoinHandle<closure_return_type>
In our case:
spawn_blocking: Fn(closure) -> JoinHandle<Result<ZipAnalysis>>

Result<ZipAnalysis> means the task will either return:
- Ok(ZipAnalysis) - Success with ZIP analysis data
- Err(e) - An error occurred during analysis
JoinHandle is a Future that resolves when thread completes
Like an IOU that will eventually contain our analysis
IOU = "I Owe You" - a promise to deliver something later
Just like a real IOU promises future payment, 
this promises future data when the thread finishes
We .await it to get the actual value when ready

In tokio:
- task is a module that provides task management utilities
- spawn_blocking is a function that runs blocking code in a dedicated thread pool
so it doesn't block tokio's async event loop

now we will store in analysis variable the result of the spawn_blocking 

but what is spawn_blocking - is it a function or a closure?

spawn_blocking is a function that takes a closure as an argument and returns a future

Closures vs Functions:
Functions:
  fn add(x: i32) { x + 1 }
  - Standalone, can't capture variables
  - Must declare types

Closures:
  let add = |x| { x + 1 };
  - Can capture variables from scope i.e. it can use variables which are not passed to it as parameters
  - Type inference
  - Syntax: |params| { body }

Here we use a closure because:
1. We need to capture zip_path from outer scope
2. It's a one-off task specific to this context
3. We need move semantics to transfer ownership to new thread

A thread pool is like a team of workers waiting for jobs
Instead of creating/destroying threads for each task (expensive!)
The pool keeps some threads ready to handle work as it comes in
When one worker finishes, they go back to the pool to wait for the next job
This keeps the main async thread free to handle other tasks

In this example:
1. spawn_blocking creates new thread to read ZIP file (blocking I/O)
2. move closure captures zip_path and owns it in new thread
3. Returns Result<ZipAnalysis> when done
4. First ? handles JoinError if thread panics
5. Second ? handles Result from ZipAnalysis
