04 Nov 2024 0800 hrs

Monday

we will note down all the concepts that we are learning in this project

let's start with what scares us the most:
async programming in rust


Imagine you're playing a video game and need to load a big map.
With a normal function, the game would freeze until loading finishes.
But with async, the game keeps running while the map loads in the background!

That's why we use async here - reading ZIP files can be slow,
but we don't want to freeze the whole program while we wait.
The async function lets other code run while we're reading the ZIP.

Normal:     Async:
  [WAIT]      [Other]
  [WAIT]  vs  [Other]
  [WAIT]      [Other]
  [Done]      [Done]


Explain the tokio spawn_blocking function using this example - what does this code do?

```rust
        let analysis = tokio::task::spawn_blocking(move || -> Result<ZipAnalysis> {
            //      |                |        |     |      |
            //      |                |        |     |      Return type
            //      |                |        |     Closure start
            //      |                |        move keyword for ownership
            //      |                Spawn blocking operation
            //      Store result
        }).await??;

        // spawn_blocking is used for CPU-intensive tasks that would block the async runtime
        // It runs the closure in a separate thread pool optimized for blocking operations
        // This keeps the main async thread free to handle other tasks
        
        // In this example:
        // 1. spawn_blocking creates new thread to read ZIP file (blocking I/O)
        // 2. move closure captures zip_path and owns it in new thread
        // 3. Returns Result<ZipAnalysis> when done
        // 4. First ? handles JoinError if thread panics
        // 5. Second ? handles Result from ZipAnalysis
```
