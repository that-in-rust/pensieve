Q1: Give me a comprehensive list of all the data types in Java
Q2: How are these data types stored in memory?
Q3: How is this different from Rust? Give all parallels and differences



Java Data Types Overview:

1. Primitive Data Types
   ├── Numeric Types
   │   ├── Integer Types
   │   │   ├── byte  (8-bit)  [-128 to 127]
   │   │   ├── short (16-bit) [-32,768 to 32,767]
   │   │   ├── int   (32-bit) [-2^31 to 2^31-1]
   │   │   └── long  (64-bit) [-2^63 to 2^63-1]
   │   │
   │   └── Floating-Point Types
   │       ├── float  (32-bit) [~3.4e-038 to 3.4e+038]
   │       └── double (64-bit) [~1.7e-308 to 1.7e+308]
   │
   ├── char (16-bit Unicode) ['\u0000' to '\uffff']
   └── boolean (true/false)

Rust Data Types Overview:

1. Scalar Types
   ├── Integer Types
   │   ├── Signed
   │   │   ├── i8   (8-bit)  [-128 to 127]
   │   │   ├── i16  (16-bit) [-32,768 to 32,767]
   │   │   ├── i32  (32-bit) [-2^31 to 2^31-1]
   │   │   ├── i64  (64-bit) [-2^63 to 2^63-1]
   │   │   └── i128 (128-bit)[-2^127 to 2^127-1]
   │   │
   │   └── Unsigned
   │       ├── u8   (8-bit)  [0 to 255]
   │       ├── u16  (16-bit) [0 to 65,535]
   │       ├── u32  (32-bit) [0 to 2^32-1]
   │       ├── u64  (64-bit) [0 to 2^64-1]
   │       └── u128 (128-bit)[0 to 2^128-1]
   │
   ├── Floating-Point Types
   │   ├── f32 (32-bit IEEE-754)
   │   └── f64 (64-bit IEEE-754)
   │
   ├── char (32-bit Unicode) [0x0000 to 0x10FFFF]
   └── bool (true/false)

Memory Storage Differences:
Q: Can you explain Java's memory model?
A: Java's memory model is divided into two main areas - Stack and Heap. Other memory segments exist in different languages:




2. Text/Code Segment
   - Stores program instructions
   - Read-only, shared between processes
   - Common in C/C++, Assembly

3. Register Memory
   - Ultra-fast CPU registers
   - Used heavily in Assembly
   - Some C compilers use register keyword

4. Memory-mapped I/O
   - Maps hardware to memory addresses
   - Used in embedded systems
   - Common in C for microcontrollers

Rust primarily uses Stack/Heap like Java, but allows unsafe code to access raw memory addresses when needed.

Q: What's stored in the Stack memory IN Java?
A: The Stack memory contains:
- Primitive values (like int, boolean) stored directly
- References/pointers to objects on the heap
- Method frames with local variables and parameters
Each thread gets its own stack, making it thread-safe
Memory is automatically managed as methods are called/returned

Q: What about the Heap memory in Java?
A: The Heap is where:
- All objects live (including arrays)
- String pool for string interning
- Static variables are stored
- Memory is shared between all threads
- Garbage collection happens to clean unused objects

Q: How does garbage collection work with this model in Java?
A: The GC tracks object references from Stack -> Heap. When an object has no more references pointing to it from the Stack or other live Heap objects, it becomes eligible for garbage collection.

Q: What are some common memory issues to watch for in Java?
A: Key things to consider:
- Memory leaks from holding references longer than needed
- Stack overflow from deep recursion
- Heap fragmentation from lots of object creation/deletion
- Thread synchronization when sharing heap objects

Rust Memory Model:
├── Stack Memory (Default)
│   ├── Fixed-size types
│   ├── Primitive types
│   ├── Arrays with known size
│   └── Struct instances
│
│   Rust's focus on compile-time memory allocation:
│   ├── Pros:
│   │   ├── Zero runtime overhead for memory management
│   │   ├── No unexpected allocations/deallocations
│   │   ├── Better performance predictability
│   │   └── Easier to reason about memory usage
│   │
│   └── Cons:
│       ├── Less flexibility than Java's runtime allocation
│       ├── More upfront design complexity
│       ├── Dynamic sizing requires explicit heap types
│       └── Steeper learning curve for developers
│
└── Heap Memory (When needed)
    ├── Box<T> - explicit heap allocation
    ├── Vec<T> - dynamic arrays
    ├── String - dynamic text
    ├── Dynamic dispatch objects
    └── Types with unknown size

Key Differences:
├── Java GC vs Rust ownership (RAII model of C++)
├── Java implicit vs Rust explicit heap allocation
│   │
    Java Example:
    ```java
    // Implicit heap allocation - Java handles it automatically
    String name = "Alice";  // Allocated on heap
    List<Integer> nums = new ArrayList<>();  // Allocated on heap
    ```

    Rust Example:  
    ```rust
    // Explicit heap allocation using Box, Vec, String
    // String - For text that needs to grow/shrink
    // Java: String str = "Alice" (implicitly heap allocated)
    // Rust: For fixed-size strings, use &str or [u8; N] array
    let fixed_str: &str = "Alice";        // String slice (borrowed reference)
    //  |          |      |
    //  |          |      String literal (stored in read-only memory)
    //  |          Type annotation: string slice reference
    //  Variable binding

    // This is quite different from Java's String model:
    // 1. In Java, String is always heap allocated, even literals
    //    get interned into a string pool on heap
    // 2. Java String is mutable internally but appears immutable
    //    via its API. Rust &str is truly immutable
    // 3. Java has no distinction between owned vs borrowed strings
    //    while Rust separates:
    //    - &str: borrowed view into string data (like a window)
    //         Memory:  [H][e][l][l][o]  ← String data
    //                   ↑
    //         &str ────┘ (just looks at data) - This is called a "fat pointer" or "wide pointer"
    //         because it contains both the address and length. C++ has std::string_view (C++17)
    //         which is similar. Java has no direct equivalent but CharSequence interface provides some similar functionality. Go has string slices that work similarly.
    //                    
    //         &str is a primitive type (like &[T]) that contains:
    //         (&[T] is Rust's way of saying "a borrowed view into an array of type T"
    //         where T could be any type like numbers, characters etc.
    //         Think of it like a pair of binoculars - you can look at the array
    //         but can't modify it. The & means "borrowing/viewing" and [T] means
    //         "array of type T")
    //         ┌─────┬─────┐
    //         │ ptr │ len │  Two words on stack
    //         └──┬──┴─────┘
    //            │    
    //            └─→ Points to data (which could be in various places)
    //                - String literals (&'static str) → Read-only data segment
    //                - Slices of String → Heap
    //                - Stack string arrays → Stack
    //         
    //         Think of &str like a library card:
    //         - The card itself (ptr+len) is cheap and lives on stack
    //         - It lets you VIEW but not modify the actual book
    //         - The book (string data) can be in read-only memory (for literals),
    //           on the heap (for String slices), or on the stack (for array slices)
    //         - You must return the card (satisfy the borrow checker)
    //           before the book (data) can be changed/moved/dropped
    //
    //    - String: owned heap string that can be modified
    //         Memory:  ┌─────┬─────┬─────┐
    //         Stack:   │ ptr │ len │ cap │ String struct
    //                  └──┬──┴─────┴─────┘
    //                     │
    //                     ▼ 
    //         Heap:   [H][e][l][l][o]  (owns and can modify data)
    // 4. Java strings use UTF-16 encoding internally
    //    Rust uses UTF-8 which is more memory efficient
    //    for ASCII-heavy text
    //
    //    This design choice stems from historical context:
    //    - Java (1995) chose UTF-16 when Unicode was expected
    //      to fit in 16 bits. When Unicode expanded beyond
    //      that, Java had to use surrogate pairs, making the
    //      encoding less efficient
    //    - Rust (2010) chose UTF-8 because by then it was clear
    //      that variable-width encoding was better for web/systems
    //      programming where ASCII dominates and Unicode support
    //      is still needed

    let fixed_arr: [u8; 5] = *b"Alice";   // Fixed-size byte array
    //  |          |   |    | |
    //  |          |   |    | Byte string literal
    //  |          |   |    Dereference operator 
    //  |          |   Array size
    //  |          Array type (8-bit unsigned integers)
    //  Variable binding
    //
    // Let's break this down:
    //
    // 1. let fixed_arr - This creates a new variable named fixed_arr. Think of 'let' 
    //    like saying "I want to create a new container for some data"
    //
    // 2. : [u8; 5] - This is the type annotation. It's like saying:
    //    - u8: "I want to store numbers from 0-255" (unsigned 8-bit integers)
    //    - [u8; 5]: "I want exactly 5 of these numbers in a fixed array"
    //    It's like declaring a box that can hold exactly 5 small numbers
    //
    // 3. *b"Alice" - This is actually two parts:

    //    - b"Alice": Creates a byte string literal - converts "Alice" into its ASCII bytes. Think of this like taking the word "Alice" and converting each letter into its numeric ASCII code (A=65, l=108, i=105, c=99, e=101). The b prefix tells Rust "treat this string as raw bytes" instead of Unicode text. It's like telling Rust "I just want the basic computer codes for these letters, nothing fancy"

    //    - The * in front: "Take what's inside this byte string and copy it"
    //    It's like taking a sticker that says "Alice" and peeling off just the letters
    //
    // So all together, it's creating a fixed array of 5 bytes containing the ASCII 
    // values for "Alice". Each letter takes one byte (like A=65, l=108, etc.)

    let name = String::from("Alice");  // Heap-allocated String
    //  |     |        |
    //  |     |        Static method to create String from literal
    //  |     Type constructor
    //  Variable binding
    
    // Vec - Dynamic array that can grow/shrink
    // Java: ArrayList<Integer> list = new ArrayList<>()
    // Rust: Must be explicit about heap usage
    let nums: Vec<i32> = Vec::new();   // Heap allocated, growable array
    
    // Box - Single value on heap, fixed size
    // Java: Integer num = new Integer(42) (pre Java 5)
    // Rust: Useful when you need:
    // 1. A value with unknown size at compile time
    // 2. Large data you don't want on stack
    // 3. To transfer ownership of data
    let boxed = Box::new(42);          // Single heap allocated integer

    // Stack allocations
    // Primitive Types (Fixed size, stored on stack)
    let x: i32 = 42;                  // 32-bit integer
    let f: f64 = 3.14;                // 64-bit float
    let b: bool = true;               // Boolean
    let c: char = 'A';                // 32-bit Unicode character

    // Fixed-size Arrays (Size known at compile time)
    let arr: [i32; 4] = [1,2,3,4];    // [type; size]
    //     ▲      ▲      ▲
    //     │      │      Values
    //     │      Array size
    //     Element type

    // Tuples (Fixed size, mixed types)
    let tuple = (1, true, 3.14);      // Grouped values
    //          ▲  ▲     ▲
    //          i32 bool f64
    let (x,y,z) = tuple;              // Destructuring

    // Custom Types
    let point = Point {x: 1, y: 2};   // Stack-allocated struct
    let choice = Some(42);            // Enum variant
    
    // References/Slices (Fat pointers on stack)
    let slice = &arr[0..2];           // Points to array segment
    //          ▲    ▲
    //          │    Range syntax
    //          Reference
    ```

    Impact:
│   │   Java:                      Rust:
│   │   ┌─────────────┐           ┌─────────────┐
│   │   │ Easy to use │           │ More control│
│   │   │ Less code   │ ←vs→      │ Predictable │
│   │   │ Hidden cost │           │ Explicit    │
│   │   └─────────────┘           └─────────────┘
├── Java reference counting vs Rust borrow checking
└── Java shared memory vs Rust controlled sharing

Key Differences:
- Rust has no implicit type conversion, hence type safety is higher
- Rust integers can be unsigned
- Rust chars are 32-bit vs Java's 16-bit
- Rust has 128-bit integers
- Rust has no null equivalent, using Option<T> instead. This was a deliberate design choice to prevent null pointer exceptions that plague Java. Option forces explicit handling of missing values at compile time, leading to more robust code but requiring more upfront thought about error cases. This impacts the ecosystem by making APIs more explicit about which values can be missing
- All Rust types have a known size at compile time

2. Reference Data Types
   ├── Classes
   │   ├── String
   │   ├── Arrays
   │   └── User-defined classes
   │
   ├── Interfaces
   │
   └── Collection Types
       ├── List
       │   ├── ArrayList
       │   ├── LinkedList
       │   └── Vector
       │
       ├── Set
       │   ├── HashSet
       │   ├── LinkedHashSet
       │   └── TreeSet
       │
       ├── Queue
       │   ├── PriorityQueue
       │   └── Deque
       │
       └── Map
           ├── HashMap
           ├── LinkedHashMap
           ├── TreeMap
           └── Hashtable

3. Special Types
   ├── null (represents absence of value)
   └── void (represents no type/return value)

Key Characteristics:
- Primitive types are stored directly in stack memory
- Reference types store object references in stack, actual objects in heap
- Primitive types have corresponding wrapper classes (Integer, Double, etc.)
- Arrays are fixed-size but can hold both primitive and reference types



========================================
Data Segment
========================================

1. Data Segment (Static/Global)
   - Java: static fields stored in special area of heap
   - Rust: static/const items stored in data segment
   - Java Example:
     public class Example {
         static int counter = 0; // Stored in heap
         static final int MAX = 100; // Stored in data segment
     }
   - Rust Example:
     static COUNTER: AtomicI32 = AtomicI32::new(0); // Data segment
     const MAX: i32 = 100; // Embedded in binary

Memory Models Compared:

Java vs Rust Memory Layout:
┌─────────────────────┐      ┌─────────────────────┐
│       Java          │      │        Rust         │
├─────────────────────┤      ├─────────────────────┤
│    Stack Memory     │      │    Stack Memory     │
│  ┌───────────────┐  │      │  ┌───────────────┐  │
│  │ Method Frames │  │      │  │ Stack Frames  │  │
│  │ Local Vars    │  │      │  │ Local Vars    │  │
│  │ Primitives    │  │      │  │ Fixed-size    │  │
│  │ References ───┼──┼─────▶│  │ Values        │  │
│  └───────────────┘  │      │  └───────────────┘  │
│                     │      │                     │
│    Heap Memory      │      │    Heap Memory      │
│  ┌───────────────┐  │      │  ┌───────────────┐  │
│  │   Objects     │  │      │  │ Box<T>        │  │
│  │   Arrays      │  │      │  │ Vec<T>        │  │
│  │   Strings     │  │      │  │ String        │  │
│  └───────────────┘  │      │  └───────────────┘  │
│                     │      │                     │
│   Data Segment      │      │   Data Segment      │
│  ┌───────────────┐  │      │  ┌───────────────┐  │
│  │ static fields │  │      │  │ static items  │  │
│  │ class data    │  │      │  │ const values  │  │
│  └───────────────┘  │      │  └───────────────┘  │
└─────────────────────┘      └─────────────────────┘

Key Differences:
1. Stack Memory:
   Java: Only primitives & references    Rust: Most data by default
   Java: GC manages cleanup             Rust: Deterministic cleanup
   
2. Heap Memory:  
   Java: All objects                    Rust: Only when needed
   Java: GC managed                     Rust: Ownership based
   
3. Data Segment:

    Memory Layout Visualization:
    ┌─────────────────────────────────┐
    │          Data Segment           │
    │                                 │
    │    Read-only Data (.rodata)     │
    │  ┌─────────────────────────┐    │
    │  │ String literals         │    │
    │  │ Const values            │    │
    │  └─────────────────────────┘    │
    │                                 │
    │    Initialized Data (.data)     │
    │  ┌─────────────────────────┐    │
    │  │ Static variables        │    │
    │  │ Global variables        │    │
    │  └─────────────────────────┘    │
    │                                 │
    │  Uninitialized Data (.bss)      │
    │  ┌─────────────────────────┐    │
    │  │ Static vars = 0/null    │    │
    │  │ Global vars = 0/null    │    │
    │  └─────────────────────────┘    │
    └─────────────────────────────────┘

    Java:                             Rust:
    - Class metadata                  - Static items
    - Static final fields             - Const values  
    - JVM manages at runtime          - Fixed at compile time
    - Garbage collected               - Never changes during runtime

4. Data Segment Advantages:
   Java:
   - Stores class metadata in read-only memory
   - String literals shared between threads
   - Static final fields optimized by JVM
   - No GC overhead for constants
   
   Rust:
   - Const values baked into binary
   - Static items have zero runtime cost
   - Thread-safe by default
   - Predictable memory usage

5. Data Segment Disadvantages:
   Java:
   - Fixed size at startup
   - Increases binary size (packed into executable, unlike stack/heap which are runtime allocations)
   - Class loading overhead
   - Limited to compile-time constants
   
   Rust:
   - Values must be known at compile time
   - No runtime modification
   - Increases binary size
   - Global state can be unsafe

Smart Use Cases (SDE2 Level):
1. String Interning
   - Store frequently used strings in .rodata
   - Zero copy between threads
   - Faster string comparisons
   
2. Lookup Tables
   - Static arrays of constants
   - Zero initialization cost
   - Cache-friendly access patterns
   
3. Configuration Constants
   - Compile-time validation
   - No runtime parsing overhead
   - Guaranteed immutability

4. Memory-Mapped Files
   - Map file contents to .data
   - Zero-copy I/O operations
   - Share between processes

