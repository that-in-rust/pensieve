Directory structure:
└── sunface-rust-course/
    ├── README.md
    ├── book.toml
    ├── deploy.sh
    ├── genpdf.sh
    ├── assets/
    │   ├── bigPicture.js
    │   ├── CNAME
    │   ├── custom.js
    │   ├── sitemap.xml
    │   ├── rustlings-zh/
    │   │   ├── README.md
    │   │   ├── Cargo.toml
    │   │   ├── CHANGELOG.md
    │   │   ├── CONTRIBUTING.md
    │   │   ├── default_out.txt
    │   │   ├── info.toml
    │   │   ├── install.ps1
    │   │   ├── install.sh
    │   │   ├── LICENSE
    │   │   ├── .all-contributorsrc
    │   │   ├── .clog.toml
    │   │   ├── .editorconfig
    │   │   ├── .gitpod.yml
    │   │   ├── .replit
    │   │   ├── exercises/
    │   │   │   ├── README.md
    │   │   │   ├── quiz1.rs
    │   │   │   ├── quiz2.rs
    │   │   │   ├── quiz3.rs
    │   │   │   ├── quiz4.rs
    │   │   │   ├── advanced_errors/
    │   │   │   │   ├── advanced_errs1.rs
    │   │   │   │   └── advanced_errs2.rs
    │   │   │   ├── clippy/
    │   │   │   │   ├── README.md
    │   │   │   │   ├── clippy1.rs
    │   │   │   │   └── clippy2.rs
    │   │   │   ├── collections/
    │   │   │   │   ├── README.md
    │   │   │   │   ├── hashmap1.rs
    │   │   │   │   ├── hashmap2.rs
    │   │   │   │   ├── vec1.rs
    │   │   │   │   └── vec2.rs
    │   │   │   ├── conversions/
    │   │   │   │   ├── README.md
    │   │   │   │   ├── as_ref_mut.rs
    │   │   │   │   ├── from_into.rs
    │   │   │   │   ├── from_str.rs
    │   │   │   │   ├── try_from_into.rs
    │   │   │   │   └── using_as.rs
    │   │   │   ├── enums/
    │   │   │   │   ├── README.md
    │   │   │   │   ├── enums1.rs
    │   │   │   │   ├── enums2.rs
    │   │   │   │   └── enums3.rs
    │   │   │   ├── error_handling/
    │   │   │   │   ├── README.md
    │   │   │   │   ├── errors1.rs
    │   │   │   │   ├── errors2.rs
    │   │   │   │   ├── errors3.rs
    │   │   │   │   ├── errors4.rs
    │   │   │   │   ├── errors5.rs
    │   │   │   │   └── errors6.rs
    │   │   │   ├── functions/
    │   │   │   │   ├── README.md
    │   │   │   │   ├── functions1.rs
    │   │   │   │   ├── functions2.rs
    │   │   │   │   ├── functions3.rs
    │   │   │   │   ├── functions4.rs
    │   │   │   │   └── functions5.rs
    │   │   │   ├── generics/
    │   │   │   │   ├── README.md
    │   │   │   │   ├── generics1.rs
    │   │   │   │   ├── generics2.rs
    │   │   │   │   └── generics3.rs
    │   │   │   ├── if/
    │   │   │   │   ├── README.md
    │   │   │   │   ├── if1.rs
    │   │   │   │   └── if2.rs
    │   │   │   ├── macros/
    │   │   │   │   ├── README.md
    │   │   │   │   ├── macros1.rs
    │   │   │   │   ├── macros2.rs
    │   │   │   │   ├── macros3.rs
    │   │   │   │   └── macros4.rs
    │   │   │   ├── modules/
    │   │   │   │   ├── README.md
    │   │   │   │   ├── modules1.rs
    │   │   │   │   ├── modules2.rs
    │   │   │   │   └── modules3.rs
    │   │   │   ├── move_semantics/
    │   │   │   │   ├── README.md
    │   │   │   │   ├── move_semantics1.rs
    │   │   │   │   ├── move_semantics2.rs
    │   │   │   │   ├── move_semantics3.rs
    │   │   │   │   ├── move_semantics4.rs
    │   │   │   │   └── move_semantics5.rs
    │   │   │   ├── option/
    │   │   │   │   ├── README.md
    │   │   │   │   ├── option1.rs
    │   │   │   │   ├── option2.rs
    │   │   │   │   └── option3.rs
    │   │   │   ├── primitive_types/
    │   │   │   │   ├── README.md
    │   │   │   │   ├── primitive_types1.rs
    │   │   │   │   ├── primitive_types2.rs
    │   │   │   │   ├── primitive_types3.rs
    │   │   │   │   ├── primitive_types4.rs
    │   │   │   │   ├── primitive_types5.rs
    │   │   │   │   └── primitive_types6.rs
    │   │   │   ├── standard_library_types/
    │   │   │   │   ├── README.md
    │   │   │   │   ├── arc1.rs
    │   │   │   │   ├── box1.rs
    │   │   │   │   ├── iterators1.rs
    │   │   │   │   ├── iterators2.rs
    │   │   │   │   ├── iterators3.rs
    │   │   │   │   ├── iterators4.rs
    │   │   │   │   └── iterators5.rs
    │   │   │   ├── strings/
    │   │   │   │   ├── README.md
    │   │   │   │   ├── strings1.rs
    │   │   │   │   └── strings2.rs
    │   │   │   ├── structs/
    │   │   │   │   ├── README.md
    │   │   │   │   ├── structs1.rs
    │   │   │   │   ├── structs2.rs
    │   │   │   │   └── structs3.rs
    │   │   │   ├── tests/
    │   │   │   │   ├── README.md
    │   │   │   │   ├── tests1.rs
    │   │   │   │   ├── tests2.rs
    │   │   │   │   └── tests3.rs
    │   │   │   ├── threads/
    │   │   │   │   ├── README.md
    │   │   │   │   └── threads1.rs
    │   │   │   ├── traits/
    │   │   │   │   ├── README.md
    │   │   │   │   ├── traits1.rs
    │   │   │   │   └── traits2.rs
    │   │   │   └── variables/
    │   │   │       ├── README.md
    │   │   │       ├── variables1.rs
    │   │   │       ├── variables2.rs
    │   │   │       ├── variables3.rs
    │   │   │       ├── variables4.rs
    │   │   │       ├── variables5.rs
    │   │   │       └── variables6.rs
    │   │   ├── src/
    │   │   │   ├── exercise.rs
    │   │   │   ├── main.rs
    │   │   │   ├── run.rs
    │   │   │   ├── ui.rs
    │   │   │   └── verify.rs
    │   │   └── tests/
    │   │       ├── integration_tests.rs
    │   │       └── fixture/
    │   │           ├── failure/
    │   │           │   ├── compFailure.rs
    │   │           │   ├── compNoExercise.rs
    │   │           │   ├── info.toml
    │   │           │   ├── testFailure.rs
    │   │           │   └── testNotPassed.rs
    │   │           ├── state/
    │   │           │   ├── finished_exercise.rs
    │   │           │   ├── info.toml
    │   │           │   ├── pending_exercise.rs
    │   │           │   └── pending_test_exercise.rs
    │   │           └── success/
    │   │               ├── compSuccess.rs
    │   │               ├── info.toml
    │   │               └── testSuccess.rs
    │   └── writing-material/
    │       ├── books.md
    │       ├── courses.md
    │       ├── demos_for_learning.md
    │       ├── good-sourcecode.md
    │       ├── 读者疑惑的点记录.md
    │       ├── posts/
    │       │   ├── atomic.md
    │       │   ├── attributes.md
    │       │   ├── file.md
    │       │   ├── function_signature.md
    │       │   ├── generics.md
    │       │   ├── hashmap.md
    │       │   ├── identifier.md
    │       │   ├── images.md
    │       │   ├── interview.md
    │       │   ├── io.md
    │       │   ├── Iterator.md
    │       │   ├── lifetime.md
    │       │   ├── lifetime_elision_rules.md
    │       │   ├── non-lexical-lifetime.md
    │       │   ├── operators.md
    │       │   ├── package.md
    │       │   ├── performance.md
    │       │   ├── plugins.md
    │       │   ├── reference.md
    │       │   ├── rust-analyser.md
    │       │   ├── self-referential.md
    │       │   ├── SIMD.md
    │       │   ├── string.md
    │       │   ├── system_command.md
    │       │   ├── threads.md
    │       │   ├── to_resolved.md
    │       │   ├── tokio.md
    │       │   ├── trivia.md
    │       │   ├── wasm.md
    │       │   ├── fight-with-compiler-check/
    │       │   │   ├── borrow.md
    │       │   │   └── generic.md
    │       │   └── tests/
    │       │       ├── doc_test.md
    │       │       ├── integration_test.md
    │       │       ├── misc.md
    │       │       └── unit_test.md
    │       └── style_guide/
    │           ├── coding.md
    │           └── naming.md
    ├── ci/
    │   └── copy-assets.sh
    ├── src/
    │   ├── about-book.md
    │   ├── beat-ai.md
    │   ├── community.md
    │   ├── github.md
    │   ├── index-list.md
    │   ├── into-rust.md
    │   ├── practice.md
    │   ├── rust-weekly.md
    │   ├── rustt.md
    │   ├── rusty-book.md
    │   ├── some-thoughts.md
    │   ├── SUMMARY.md
    │   ├── advance/
    │   │   ├── errors.md
    │   │   ├── global-variable.md
    │   │   ├── hrtb.md
    │   │   ├── intro.md
    │   │   ├── macro.md
    │   │   ├── simd.md
    │   │   ├── async/
    │   │   │   ├── async-await.md
    │   │   │   ├── future-excuting.md
    │   │   │   ├── getting-started.md
    │   │   │   ├── intro.md
    │   │   │   ├── multi-futures-simultaneous.md
    │   │   │   ├── pain-points-and-workarounds.md
    │   │   │   ├── pin-unpin.md
    │   │   │   └── web-server.md
    │   │   ├── circle-self-ref/
    │   │   │   ├── circle-reference.md
    │   │   │   ├── intro.md
    │   │   │   └── self-referential.md
    │   │   ├── concurrency-with-threads/
    │   │   │   ├── concurrency-parallelism.md
    │   │   │   ├── intro.md
    │   │   │   ├── message-passing.md
    │   │   │   ├── races.md
    │   │   │   ├── ref-counter-lock.md
    │   │   │   ├── send-sync.md
    │   │   │   ├── sync1.md
    │   │   │   ├── sync2.md
    │   │   │   └── thread.md
    │   │   ├── difficulties/
    │   │   │   └── pointer.md
    │   │   ├── functional-programing/
    │   │   │   ├── closure.md
    │   │   │   ├── intro.md
    │   │   │   └── iterator.md
    │   │   ├── into-types/
    │   │   │   ├── converse.md
    │   │   │   ├── custom-type.md
    │   │   │   ├── enum-int.md
    │   │   │   ├── intro.md
    │   │   │   └── sized.md
    │   │   ├── lifetime/
    │   │   │   ├── advance.md
    │   │   │   ├── intro.md
    │   │   │   ├── misconceptions.md
    │   │   │   └── static.md
    │   │   ├── smart-pointer/
    │   │   │   ├── box.md
    │   │   │   ├── cell-refcell.md
    │   │   │   ├── deref.md
    │   │   │   ├── drop.md
    │   │   │   ├── intro.md
    │   │   │   └── rc-arc.md
    │   │   └── unsafe/
    │   │       ├── inline-asm.md
    │   │       ├── intro.md
    │   │       ├── superpowers.md
    │   │       └── ub.md
    │   ├── advance-practice/
    │   │   ├── async.md
    │   │   ├── bridging-with-sync.md
    │   │   ├── channels.md
    │   │   ├── design-pattern.md
    │   │   ├── frame.md
    │   │   ├── getting-startted.md
    │   │   ├── graceful-shutdown.md
    │   │   ├── intro.md
    │   │   ├── io.md
    │   │   ├── overview.md
    │   │   ├── select.md
    │   │   ├── shared-state.md
    │   │   ├── spawning.md
    │   │   └── stream.md
    │   ├── advance-practice1/
    │   │   ├── graceful-shutdown.md
    │   │   ├── intro.md
    │   │   ├── multi-threads.md
    │   │   └── web-server.md
    │   ├── appendix/
    │   │   ├── derive.md
    │   │   ├── difficulties.md
    │   │   ├── expressions.md
    │   │   ├── intro.md
    │   │   ├── keywords.md
    │   │   ├── operators.md
    │   │   ├── prelude.md
    │   │   ├── rust-version.md
    │   │   └── rust-versions/
    │   │       ├── 1.58.md
    │   │       ├── 1.59.md
    │   │       ├── 1.60.md
    │   │       ├── 1.61.md
    │   │       ├── 1.62.md
    │   │       ├── 1.63.md
    │   │       ├── 1.64.md
    │   │       ├── 1.65.md
    │   │       ├── 1.66.md
    │   │       ├── 1.67.md
    │   │       ├── 1.68.md
    │   │       ├── 1.69.md
    │   │       ├── 1.70.md
    │   │       ├── 1.71.md
    │   │       ├── 1.72.md
    │   │       ├── 1.73.md
    │   │       ├── 1.74.md
    │   │       ├── 1.75.md
    │   │       ├── 1.76.md
    │   │       ├── 1.77.md
    │   │       ├── 1.78.md
    │   │       ├── 1.79.md
    │   │       ├── 1.80.md
    │   │       ├── 1.81.md
    │   │       ├── 1.82.md
    │   │       ├── 1.83.md
    │   │       ├── 1.84.md
    │   │       ├── 1.85.md
    │   │       ├── 1.86.md
    │   │       ├── 1.87.md
    │   │       ├── 1.88.md
    │   │       ├── 1.89.md
    │   │       └── intro.md
    │   ├── basic/
    │   │   ├── comment.md
    │   │   ├── flow-control.md
    │   │   ├── formatted-output.md
    │   │   ├── intro.md
    │   │   ├── lifetime.md
    │   │   ├── method.md
    │   │   ├── variable.md
    │   │   ├── base-type/
    │   │   │   ├── char-bool.md
    │   │   │   ├── function.md
    │   │   │   ├── index.md
    │   │   │   ├── numbers.md
    │   │   │   └── statement-expression.md
    │   │   ├── collections/
    │   │   │   ├── hashmap.md
    │   │   │   ├── intro.md
    │   │   │   └── vector.md
    │   │   ├── compound-type/
    │   │   │   ├── array.md
    │   │   │   ├── enum.md
    │   │   │   ├── intro.md
    │   │   │   ├── string-slice.md
    │   │   │   ├── struct.md
    │   │   │   └── tuple.md
    │   │   ├── crate-module/
    │   │   │   ├── crate.md
    │   │   │   ├── intro.md
    │   │   │   ├── module.md
    │   │   │   └── use.md
    │   │   ├── match-pattern/
    │   │   │   ├── all-patterns.md
    │   │   │   ├── intro.md
    │   │   │   ├── match-if-let.md
    │   │   │   ├── option.md
    │   │   │   └── pattern-match.md
    │   │   ├── ownership/
    │   │   │   ├── borrowing.md
    │   │   │   ├── index.md
    │   │   │   └── ownership.md
    │   │   ├── result-error/
    │   │   │   ├── intro.md
    │   │   │   ├── panic.md
    │   │   │   └── result.md
    │   │   └── trait/
    │   │       ├── advance-trait.md
    │   │       ├── generic.md
    │   │       ├── intro.md
    │   │       ├── trait-object.md
    │   │       └── trait.md
    │   ├── basic-practice/
    │   │   ├── base-features.md
    │   │   ├── envs.md
    │   │   ├── intro.md
    │   │   ├── iterators.md
    │   │   ├── refactoring.md
    │   │   ├── stderr.md
    │   │   └── tests.md
    │   ├── cargo/
    │   │   ├── getting-started.md
    │   │   ├── git-auth.md
    │   │   ├── intro.md
    │   │   ├── guide/
    │   │   │   ├── build-cache.md
    │   │   │   ├── cargo-cache.md
    │   │   │   ├── cargo-toml-lock.md
    │   │   │   ├── dependencies.md
    │   │   │   ├── download-package.md
    │   │   │   ├── intro.md
    │   │   │   ├── package-layout.md
    │   │   │   ├── tests-ci.md
    │   │   │   └── why-exist.md
    │   │   └── reference/
    │   │       ├── cargo-target.md
    │   │       ├── configuration.md
    │   │       ├── deps-overriding.md
    │   │       ├── env.md
    │   │       ├── intro.md
    │   │       ├── manifest.md
    │   │       ├── package-id.md
    │   │       ├── profile.md
    │   │       ├── profiles.md
    │   │       ├── publishing-on-crates.io.md
    │   │       ├── specify-deps.md
    │   │       ├── workspaces.md
    │   │       ├── build-script/
    │   │       │   ├── examples.md
    │   │       │   └── intro.md
    │   │       └── features/
    │   │           ├── examples.md
    │   │           └── intro.md
    │   ├── compiler/
    │   │   ├── intro.md
    │   │   ├── fight-with-compiler/
    │   │   │   ├── intro.md
    │   │   │   ├── phantom-data.md
    │   │   │   ├── unconstrained.md
    │   │   │   ├── borrowing/
    │   │   │   │   ├── borrow-distinct-fields-of-struct.md
    │   │   │   │   ├── intro.md
    │   │   │   │   └── ref-exist-in-out-fn.md
    │   │   │   └── lifetime/
    │   │   │       ├── closure-with-static.md
    │   │   │       ├── intro.md
    │   │   │       ├── loop.md
    │   │   │       ├── too-long1.md
    │   │   │       └── too-long2.md
    │   │   └── pitfalls/
    │   │       ├── arithmetic-overflow.md
    │   │       ├── closure-with-lifetime.md
    │   │       ├── index.md
    │   │       ├── iterator-everywhere.md
    │   │       ├── lazy-iterators.md
    │   │       ├── main-with-channel-blocked.md
    │   │       ├── multiple-mutable-references.md
    │   │       ├── stack-overflow.md
    │   │       ├── the-disabled-mutability.md
    │   │       ├── use-vec-in-for.md
    │   │       ├── utf8-performance.md
    │   │       └── weird-ranges.md
    │   ├── difficulties/
    │   │   ├── cow.md
    │   │   ├── eq.md
    │   │   ├── intro.md
    │   │   ├── lifetime.md
    │   │   ├── move-copy.md
    │   │   ├── pointer.md
    │   │   ├── slice.md
    │   │   └── string.md
    │   ├── first-try/
    │   │   ├── cargo.md
    │   │   ├── editor.md
    │   │   ├── hello-world.md
    │   │   ├── installation.md
    │   │   ├── intro.md
    │   │   ├── slowly-downloading.md
    │   │   └── sth-you-should-not-do.md
    │   ├── libraries/
    │   │   ├── intro.md
    │   │   ├── command/
    │   │   │   ├── intro.md
    │   │   │   └── structopt.md
    │   │   ├── http/
    │   │   │   ├── intro.md
    │   │   │   └── reqwest.md
    │   │   └── json/
    │   │       ├── intro.md
    │   │       └── serde.md
    │   ├── logs/
    │   │   ├── about-log.md
    │   │   ├── intro.md
    │   │   ├── log.md
    │   │   ├── tracing-logger.md
    │   │   ├── tracing.md
    │   │   └── observe/
    │   │       ├── about-observe.md
    │   │       ├── intro.md
    │   │       └── trace.md
    │   ├── practice/
    │   │   ├── best-pratice.md
    │   │   ├── interview.md
    │   │   ├── intro.md
    │   │   ├── naming.md
    │   │   └── third-party-libs.md
    │   ├── profiling/
    │   │   ├── intro.md
    │   │   ├── compiler/
    │   │   │   ├── attributes.md
    │   │   │   ├── intro.md
    │   │   │   ├── llvm.md
    │   │   │   ├── phantom-data.md
    │   │   │   ├── speed-up.md
    │   │   │   └── optimization/
    │   │   │       ├── intro.md
    │   │   │       └── option.md
    │   │   ├── memory/
    │   │   │   ├── allocation.md
    │   │   │   ├── intro.md
    │   │   │   ├── layout.md
    │   │   │   ├── pointer-ref.md
    │   │   │   ├── uninit.md
    │   │   │   └── virtual.md
    │   │   ├── performance/
    │   │   │   ├── allocator.md
    │   │   │   ├── calculate.md
    │   │   │   ├── clone-copy.md
    │   │   │   ├── cpu-cache.md
    │   │   │   ├── deep-into-move.md
    │   │   │   ├── early-optimise.md
    │   │   │   ├── enum.md
    │   │   │   ├── heap-stack.md
    │   │   │   ├── intro.md
    │   │   │   ├── runtime-check.md
    │   │   │   ├── string.md
    │   │   │   └── tools.md
    │   │   └── profiling/
    │   │       └── performance/
    │   │           └── benchmark.md
    │   ├── std/
    │   │   ├── hashmap.md
    │   │   ├── intro.md
    │   │   ├── iterator.md
    │   │   ├── search.md
    │   │   └── vector.md
    │   ├── templates/
    │   │   ├── intro.md
    │   │   ├── files/
    │   │   │   ├── dir.md
    │   │   │   └── intro.md
    │   │   └── http/
    │   │       └── intro.md
    │   ├── test/
    │   │   ├── assertion.md
    │   │   ├── benchmark.md
    │   │   ├── ci.md
    │   │   ├── intro.md
    │   │   ├── unit-integration-test.md
    │   │   └── write-tests.md
    │   ├── too-many-lists/
    │   │   ├── do-we-need-it.md
    │   │   ├── intro.md
    │   │   ├── advanced-lists/
    │   │   │   ├── double-singly.md
    │   │   │   ├── intro.md
    │   │   │   ├── stack-allocated.md
    │   │   │   └── unsafe-deque.md
    │   │   ├── bad-stack/
    │   │   │   ├── basic-operations.md
    │   │   │   ├── final-code.md
    │   │   │   ├── intro.md
    │   │   │   └── layout.md
    │   │   ├── deque/
    │   │   │   ├── final-code.md
    │   │   │   ├── intro.md
    │   │   │   ├── iterator.md
    │   │   │   ├── layout.md
    │   │   │   ├── peek.md
    │   │   │   └── symmetric.md
    │   │   ├── ok-stack/
    │   │   │   ├── intro.md
    │   │   │   ├── iter.md
    │   │   │   ├── itermut.md
    │   │   │   ├── peek.md
    │   │   │   └── type-optimizing.md
    │   │   ├── persistent-stack/
    │   │   │   ├── drop-arc.md
    │   │   │   ├── intro.md
    │   │   │   └── layout.md
    │   │   ├── production-unsafe-deque/
    │   │   │   ├── basics.md
    │   │   │   ├── boring-combinatorics.md
    │   │   │   ├── drop-and-panic-safety.md
    │   │   │   ├── filling-in-random-bits.md
    │   │   │   ├── final-code.md
    │   │   │   ├── implementing-cursors.md
    │   │   │   ├── intro.md
    │   │   │   ├── layout.md
    │   │   │   ├── send-sync-and-compile-tests.md
    │   │   │   ├── testing-cursors.md
    │   │   │   ├── testing.md
    │   │   │   └── variance-and-phantomData.md
    │   │   └── unsafe-queue/
    │   │       ├── basics.md
    │   │       ├── extra-junk.md
    │   │       ├── final-code.md
    │   │       ├── intro.md
    │   │       ├── layout.md
    │   │       ├── layout2.md
    │   │       ├── miri.md
    │   │       ├── stacked-borrow.md
    │   │       └── testing-stacked-borrow.md
    │   └── usecases/
    │       ├── aws-rust.md
    │       └── intro.md
    ├── theme/
    │   ├── index1.hbs
    │   └── style.css
    └── .github/
        └── workflows/
            ├── ci.yml
            └── deploy.yml

================================================
FILE: README.md
================================================
<h1 align="center">Rust语言圣经</h1>

<div align="center">
    <img src="https://github.com/sunface/rust-course/blob/main/assets/banner.jpg?raw=true">
</div>
   
<div align="center">

[![studyrut](https://img.shields.io/badge/RustCn社区-orange)](https://github.com/rustlang-cn) [![Stars Count](https://img.shields.io/github/stars/sunface/rust-course?style=flat)](https://github.com/sunface/rust-course/stargazers)
[![](https://img.shields.io/github/issues-pr-closed-raw/sunface/rust-course.svg?style=flat)](https://github.com/sunface/rust-course/issues)
[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/ines/spacy-course/master)

<!-- <a href="https://www.zhihu.com/column/c_1452781034895446017">
  <img alt="Sunface | 知乎" height="20px" width="20px" src="https://github.com/sunface/rust-course/blob/main/assets/zhihu.jpg">
</a> -->

</div>

**号外号外，特大新闻！本书苦作者久矣，准备自我革命了，欢迎大家跟鄙书一起向作者拍砖**: https://github.com/sunface/rust-course/issues/1563


## 教程简介

- 在线阅读: https://course.rs

**`Rust语言圣经`**涵盖从**入门到精通**所需的 Rust 知识，目录及内容都经过深思熟虑的设计，同时语言生动幽默，行文流畅自如，摆脱技术书籍常有的机器味和晦涩感。

- **深入度**，在基础教学的同时，提供了深入剖析。浅尝辄止并不能让我们站上紫禁之巅

- **专题内容**，将 Rust 高级内容通过专题的形式一一呈现，内容内聚性极强，例如性能优化、手把手实现链表、Cargo 和 Tokio 使用指南、async 异步编程、标准库解析、WASM 等等

- **内容索引**，作为一本工具书，优秀的索引能力非常重要，遗忘不可怕，找不到才可怕

- **规避陷阱和对抗编译器**，只有真的上手写过一长段时间 Rust 项目，才知道该如何规避常见的陷阱以及解决一些难搞的编译器错误，而本书将帮助你大大缩短这个过程，提前规避这些问题

- **[Cookbook](https://rusty.course.rs)**，涵盖多个应用场景的实战代码片段，程序员上网查询文件操作、正则解析、数据库操作是常事，没有人能记住所有代码，而 Cookbook 可解君忧，Ctrl + C/V 走天下

- **[配套练习题](https://github.com/sunface/rust-by-practice)**，像学习一门大学课程一样学习 Rust 是一种什么感觉？_Rust 语言圣经 + Rust 语言实战_ 双剑合璧，给你最极致的学习体验

总之在写作过程中我们始终铭记初心：为中国用户打造一门**全面的、深入的、持续更新的** Rust 教程。 新手用来入门，老手用来提高，高手用来提升生产力。

## 🏆 贡献者

非常感谢本教程的[所有贡献者](https://github.com/sunface/rust-course/graphs/contributors)，正是有了你们，才有了现在的高质量 Rust 教程!

<br />

🏆

<table>
    <tbody>
    <tr>
        <td align="center">
            <a href="https://github.com/EluvK">
                <img src="https://avatars.githubusercontent.com/u/36977935?v=4" width="160px" alt=""/>
                <br />
                <sub><b>EluvK</b></sub>
            </a>
        </td>
        <td align="center">
            <a href="https://github.com/AllanDowney">
                <img src="https://avatars.githubusercontent.com/u/82752697?v=4?s=100"  width="160px" alt=""/>
                <br />
                <sub><b>AllanDowney</b></sub>
            </a>
        </td>
    </tr>
    </tbody>
</table>

<br />

🏅

<table>
    <tbody>
    <tr>
        <td align="center">
            <a href="https://github.com/SUN-LG">
                <img src="https://avatars.githubusercontent.com/u/15073915?v=4" width="100px" alt=""/>
                <br />
                <sub><b>孙立刚</b></sub>
            </a>
        </td>
        <td align="center">
            <a href="https://github.com/JesseAtSZ">
                <img src="https://avatars.githubusercontent.com/u/35264598?v=4?s=100" width="100px" alt=""/>
                <br />
                <sub><b>JesseAtSZ</b></sub>
            </a>
        </td>
        <td align="center">
            <a href="https://github.com/Rustln">
                <img src="https://avatars.githubusercontent.com/u/100085326?v=4?s=100" width="100px" alt=""/>
                <br />
                <sub><b>Rustln</b></sub>
            </a>
        </td>
        <td align="center">
            <a href="https://github.com/1132719438">
                <img src="https://avatars.githubusercontent.com/u/10138791?v=4?s=100" width="100px" alt=""/>
                <br />
                <sub><b>1132719438</b></sub>
            </a>
        </td>
    </tr>
    </tbody>
</table>

## 创作感悟

截至目前，Rust 语言圣经已写了 170 余章，110 余万字，历经 800 多个小时，每一个章节都是手动写就，没有任何机翻和质量上的妥协( 相信深入阅读过的读者都能体会到这一点 )。

曾经有读者问过 "这么好的书为何要开源，而不是出版?"，原因很简单：**只有完全开源才能完美地呈现出我想要的教学效果**。

总之，Rust 要在国内真正发展起来，必须得有一些追逐梦想的人在做着不计付出的事情，而我希望自己能贡献一份微薄之力。

但是要说完全无欲无求，那也是不可能的，看到项目多了一颗 🌟，那感觉...棒极了，因为它代表了读者的认可和称赞。

你们用指尖绘制的星空，那里繁星点点，每一颗都在鼓励着怀揣着开源梦想的程序员披荆斩棘、不断前行，不夸张的说，没有你们，开源世界就没有星光，自然也就不会有今天的开源盛世。

因此，**我恳请大家，如果觉得书还可以，就在你的指尖星空绘制一颗新的 🌟，指引我们继续砥砺前行**。这个人世间，因善意而美好。

最后，能通过开源在茫茫人海中与大家相识，这感觉真好 :D

## 开源协议

在开源版权上，我们选择了 [No License](https://choosealicense.com/no-permission/)，这意味着读者可以随意的 fork 和阅读，但是**不能私下修改后再包装分发**，如果有这方面的需求，请联系我们，望理解。

## 借鉴的书籍

站在巨人的肩膀上，能帮我们看的更远，特此感谢以下巨人：

- [Rust Book](https://doc.rust-lang.org/book)
- [Rust nomicon](https://doc.rust-lang.org/nomicon/intro.html)
- [Async Rust](https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html)
- 详细清单参见 [这里](./assets/writing-material/books.md)

因为它们绝大部分是支持 APACHE + MIT 双协议的，因此我们选择了遵循其中的 MIT 协议，并在这里统一对借鉴的书籍进行说明。

## 社区 & 读者交流

- 知乎: [孙飞 Sunface](https://www.zhihu.com/people/iSunface)
- RustCn 微信交流 2 群：<img src="https://github.com/sunface/rust-course/assets/7036754/a84ec7e5-30b1-48da-9352-95503aa61a8f" width="200" /> 



- 微信公众号: 扫描下面的二维码关注公众号 `Rust语言中文网`

<img src="https://github.com/sunface/rust-course/blob/main/assets/studyrust公众号.png?raw=true" />



================================================
FILE: book.toml
================================================
[rust]
edition = "2021"   #在线运行用2021版本的

[book]
authors = ["sunface"]
language = "zh-CN"
title = "Rust语言圣经(Rust Course)"
src = "src"

[output.html]
additional-css = ["theme/style.css"]
additional-js = ["assets/custom.js", "assets/bigPicture.js"]
git-repository-url = "https://github.com/sunface/rust-course"
edit-url-template = "https://github.com/sunface/rust-course/edit/main/{path}"

[output.html.playground]
editable = true
copy-js = true
# line-numbers = true

[output.html.fold]
enable = true
level = 0



================================================
FILE: deploy.sh
================================================
## this script deploys the static website of course.rs to github pages

## build static website for book
mdbook build
## copy CNAME info to book dir
cp ./assets/CNAME ./book/
cp ./assets/*.html ./book/
cp ./assets/sitemap.xml ./book/

## init git repo
cd book
git init
git config user.name "sunface"
git config user.email "cto@188.com"
git add .
git commit -m 'deploy'
git branch -M gh-pages
git remote add origin https://github.com/sunface/rust-course

## push to github pages
git push -u -f origin gh-pages



================================================
FILE: genpdf.sh
================================================
#! /bin/sh

###########################################################
# Description:
#   This script write for mdbook project to generate pdf
###########################################################

cargo install mdbook mdbook-pdf
hasPdfSec=$(grep "output.pdf" ./book.toml)

if [ "$hasPdfSec" = "" ]; then
    echo "===>>> Backup book.toml file..."
    cp book.toml book.toml.bak
    cat >> book.toml << EOF

[output.pdf]
scale = 1
paper-width = 10
paper-height = 12
margin-top = 1
margin-bottom = 1
margin-left = 1
[output.pdf-outline]
EOF
fi
echo "===>>> Start build pdf..."
mdbook build
today=$(date +%Y%m%d)
echo "===>>> PDF rename to rust-curse-$today.pdf"
mv book/pdf/output.pdf rust-course.pdf
if [ -f book.toml.bak ]; then
    echo "===>>> Reverse book.toml file..."
    mv book.toml.bak book.toml
fi
exit 0



================================================
FILE: assets/bigPicture.js
================================================
var BigPicture=function(){var t,n,e,o,i,r,a,c,p,s,l,d,u,f,m,b,g,h,x,v,y,w,_,T,k,M,S,L,E,A,H,z,I,C=[],D={},O="appendChild",N="createElement",V="removeChild";function W(){var n=t.getBoundingClientRect();return"transform:translate3D("+(n.left-(e.clientWidth-n.width)/2)+"px, "+(n.top-(e.clientHeight-n.height)/2)+"px, 0) scale3D("+t.clientWidth/o.clientWidth+", "+t.clientHeight/o.clientHeight+", 0)"}function q(t){var n=A.length-1;if(!u){if(t>0&&E===n||t<0&&!E){if(!I.loop)return j(i,""),void setTimeout(j,9,i,"animation:"+(t>0?"bpl":"bpf")+" .3s;transition:transform .35s");E=t>0?-1:n+1}if([(E=Math.max(0,Math.min(E+t,n)))-1,E,E+1].forEach(function(t){if(t=Math.max(0,Math.min(t,n)),!D[t]){var e=A[t].src,o=document[N]("IMG");o.addEventListener("load",F.bind(null,e)),o.src=e,D[t]=o}}),D[E].complete)return B(t);u=1,j(m,"opacity:.4;"),e[O](m),D[E].onload=function(){y&&B(t)},D[E].onerror=function(){A[E]={error:"Error loading image"},y&&B(t)}}}function B(n){u&&(e[V](m),u=0);var r=A[E];if(r.error)alert(r.error);else{var a=e.querySelector("img:last-of-type");j(i=o=D[E],"animation:"+(n>0?"bpfl":"bpfr")+" .35s;transition:transform .35s"),j(a,"animation:"+(n>0?"bpfol":"bpfor")+" .35s both"),e[O](i),r.el&&(t=r.el)}H.innerHTML=E+1+"/"+A.length,X(A[E].caption),M&&M([i,A[E]])}function P(){var t,n,e=.95*window.innerHeight,o=.95*window.innerWidth,i=I.dimensions||[1920,1080],r=i[0],a=i[1],p=a/r;p>e/o?n=(t=Math.min(a,e))/p:t=(n=Math.min(r,o))*p,c.style.cssText+="width:"+n+"px;height:"+t+"px;"}function G(t){~[1,4].indexOf(o.readyState)?(U(),setTimeout(function(){o.play()},99)):o.error?U(t):f=setTimeout(G,35,t)}function R(n){I.noLoader||(n&&j(m,"top:"+t.offsetTop+"px;left:"+t.offsetLeft+"px;height:"+t.clientHeight+"px;width:"+t.clientWidth+"px"),t.parentElement[n?O:V](m),u=n)}function X(t){t&&(g.innerHTML=t),j(b,"opacity:"+(t?"1;pointer-events:auto":"0"))}function F(t){!~C.indexOf(t)&&C.push(t)}function U(t){if(u&&R(),T&&T(),"string"==typeof t)return $(),I.onError?I.onError():alert("Error: The requested "+t+" could not be loaded.");_&&F(s),o.style.cssText+=W(),j(e,"opacity:1;pointer-events:auto"),k=setTimeout(k,410),v=1,y=!!A,setTimeout(function(){o.style.cssText+="transition:transform .35s;transform:none",h&&setTimeout(X,250,h)},60)}function Y(t){var n=t?t.target:e,i=[b,x,r,a,g,L,S,m];n.blur(),w||~i.indexOf(n)||(o.style.cssText+=W(),j(e,"pointer-events:auto"),setTimeout($,350),clearTimeout(k),v=0,w=1)}function $(){if((o===c?p:o).removeAttribute("src"),document.body[V](e),e[V](o),j(e,""),j(o,""),X(0),y){for(var t=e.querySelectorAll("img"),n=0;n<t.length;n++)e[V](t[n]);u&&e[V](m),e[V](H),y=A=0,D={},z||e[V](S),z||e[V](L),i.onload=U,i.onerror=U.bind(null,"image")}I.onClose&&I.onClose(),w=u=0}function j(t,n){t.style.cssText=n}return function(w){var D;return n||function(){var t;function s(t){var n=document[N]("button");return n.className=t,n.innerHTML='<svg viewBox="0 0 48 48"><path d="M28 24L47 5a3 3 0 1 0-4-4L24 20 5 1a3 3 0 1 0-4 4l19 19L1 43a3 3 0 1 0 4 4l19-19 19 19a3 3 0 0 0 4 0v-4L28 24z"/></svg>',n}function d(t,n){var e=document[N]("button");return e.className="bp-lr",e.innerHTML='<svg viewBox="0 0 129 129" height="70" fill="#fff"><path d="M88.6 121.3c.8.8 1.8 1.2 2.9 1.2s2.1-.4 2.9-1.2a4.1 4.1 0 0 0 0-5.8l-51-51 51-51a4.1 4.1 0 0 0-5.8-5.8l-54 53.9a4.1 4.1 0 0 0 0 5.8l54 53.9z"/></svg>',j(e,n),e.onclick=function(n){n.stopPropagation(),q(t)},e}var f=document[N]("STYLE");f.innerHTML="#bp_caption,#bp_container{bottom:0;left:0;right:0;position:fixed;opacity:0}#bp_container>*,#bp_loader{position:absolute;right:0;z-index:10}#bp_container,#bp_caption,#bp_container svg{pointer-events:none}#bp_container{top:0;z-index:9999;background:rgba(0,0,0,.7);opacity:0;transition:opacity .35s}#bp_loader{top:0;left:0;bottom:0;display:flex;align-items:center;cursor:wait;background:0;z-index:9}#bp_loader svg{width:50%;max-width:300px;max-height:50%;margin:auto;animation:bpturn 1s infinite linear}#bp_aud,#bp_container img,#bp_sv,#bp_vid{user-select:none;max-height:96%;max-width:96%;top:0;bottom:0;left:0;margin:auto;box-shadow:0 0 3em rgba(0,0,0,.4);z-index:-1}#bp_sv{background:#111}#bp_sv svg{width:66px}#bp_caption{font-size:.9em;padding:1.3em;background:rgba(15,15,15,.94);color:#fff;text-align:center;transition:opacity .3s}#bp_aud{width:650px;top:calc(50% - 20px);bottom:auto;box-shadow:none}#bp_count{left:0;right:auto;padding:14px;color:rgba(255,255,255,.7);font-size:22px;cursor:default}#bp_container button{position:absolute;border:0;outline:0;background:0;cursor:pointer;transition:all .1s}#bp_container>.bp-x{padding:0;height:41px;width:41px;border-radius:100%;top:8px;right:14px;opacity:.8;line-height:1}#bp_container>.bp-x:focus,#bp_container>.bp-x:hover{background:rgba(255,255,255,.2)}.bp-x svg,.bp-xc svg{height:21px;width:20px;fill:#fff;vertical-align:top;}.bp-xc svg{width:16px}#bp_container .bp-xc{left:2%;bottom:100%;padding:9px 20px 7px;background:#d04444;border-radius:2px 2px 0 0;opacity:.85}#bp_container .bp-xc:focus,#bp_container .bp-xc:hover{opacity:1}.bp-lr{top:50%;top:calc(50% - 130px);padding:99px 0;width:6%;background:0;border:0;opacity:.4;transition:opacity .1s}.bp-lr:focus,.bp-lr:hover{opacity:.8}@keyframes bpf{50%{transform:translatex(15px)}100%{transform:none}}@keyframes bpl{50%{transform:translatex(-15px)}100%{transform:none}}@keyframes bpfl{0%{opacity:0;transform:translatex(70px)}100%{opacity:1;transform:none}}@keyframes bpfr{0%{opacity:0;transform:translatex(-70px)}100%{opacity:1;transform:none}}@keyframes bpfol{0%{opacity:1;transform:none}100%{opacity:0;transform:translatex(-70px)}}@keyframes bpfor{0%{opacity:1;transform:none}100%{opacity:0;transform:translatex(70px)}}@keyframes bpturn{0%{transform:none}100%{transform:rotate(360deg)}}@media (max-width:600px){.bp-lr{font-size:15vw}}",document.head[O](f),(e=document[N]("DIV")).id="bp_container",e.onclick=Y,l=s("bp-x"),e[O](l),"ontouchstart"in window&&(z=1,e.ontouchstart=function(n){var e=n.changedTouches;t=e[0].pageX},e.ontouchmove=function(t){t.preventDefault()},e.ontouchend=function(n){var e=n.changedTouches;if(y){var o=e[0].pageX-t;o<-30&&q(1),o>30&&q(-1)}}),i=document[N]("IMG"),(r=document[N]("VIDEO")).id="bp_vid",r.setAttribute("playsinline",1),r.controls=1,r.loop=1,(a=document[N]("audio")).id="bp_aud",a.controls=1,a.loop=1,(H=document[N]("span")).id="bp_count",(b=document[N]("DIV")).id="bp_caption",(x=s("bp-xc")).onclick=X.bind(null,0),b[O](x),g=document[N]("SPAN"),b[O](g),e[O](b),S=d(1,"transform:scalex(-1)"),L=d(-1,"left:0;right:auto"),(m=document[N]("DIV")).id="bp_loader",m.innerHTML='<svg viewbox="0 0 32 32" fill="#fff" opacity=".8"><path d="M16 0a16 16 0 0 0 0 32 16 16 0 0 0 0-32m0 4a12 12 0 0 1 0 24 12 12 0 0 1 0-24" fill="#000" opacity=".5"/><path d="M16 0a16 16 0 0 1 16 16h-4A12 12 0 0 0 16 4z"/></svg>',(c=document[N]("DIV")).id="bp_sv",(p=document[N]("IFRAME")).setAttribute("allowfullscreen",1),p.allow="autoplay; fullscreen",p.onload=function(){return c[V](m)},j(p,"border:0;position:absolute;height:100%;width:100%;left:0;top:0"),c[O](p),i.onload=U,i.onerror=U.bind(null,"image"),window.addEventListener("resize",function(){y||u&&R(1),o===c&&P()}),document.addEventListener("keyup",function(t){var n=t.keyCode;27===n&&v&&Y(),y&&(39===n&&q(1),37===n&&q(-1),38===n&&q(10),40===n&&q(-10))}),document.addEventListener("keydown",function(t){y&&~[37,38,39,40].indexOf(t.keyCode)&&t.preventDefault()}),document.addEventListener("focus",function(t){v&&!e.contains(t.target)&&(t.stopPropagation(),l.focus())},1),n=1}(),u&&(clearTimeout(f),$()),I=w,d=w.ytSrc||w.vimeoSrc,T=w.animationStart,k=w.animationEnd,M=w.onChangeImage,_=0,h=(t=w.el).getAttribute("data-caption"),w.gallery?function(n,r){var a=I.galleryAttribute||"data-bp";if(Array.isArray(n))A=n,h=n[E=r||0].caption;else{var c=(A=[].slice.call("string"==typeof n?document.querySelectorAll(n+" ["+a+"]"):n)).indexOf(t);E=0===r||r?r:-1!==c?c:0,A=A.map(function(t){return{el:t,src:t.getAttribute(a),caption:t.getAttribute("data-caption")}})}_=1,!~C.indexOf(s=A[E].src)&&R(1),A.length>1?(e[O](H),H.innerHTML=E+1+"/"+A.length,z||(e[O](S),e[O](L))):A=0,(o=i).src=s}(w.gallery,w.position):d||w.iframeSrc?(o=c,I.ytSrc?W="https://www.youtube.com/embed/"+d+"?html5=1&rel=0&playsinline=1&autoplay=1":I.vimeoSrc?W="https://player.vimeo.com/video/"+d+"?autoplay=1":I.iframeSrc&&(W=I.iframeSrc),j(m,""),c[O](m),p.src=W,P(),setTimeout(U,9)):w.imgSrc?(_=1,!~C.indexOf(s=w.imgSrc)&&R(1),(o=i).src=s):w.audio?(R(1),(o=a).src=w.audio,G("audio file")):w.vidSrc?(R(1),w.dimensions&&j(r,"width:"+w.dimensions[0]+"px"),D=w.vidSrc,Array.isArray(D)?(o=r.cloneNode(),D.forEach(function(t){var n=document[N]("SOURCE");n.src=t,n.type="video/"+t.match(/.(\w+)$/)[1],o[O](n)})):(o=r).src=D,G("video")):(o=i).src="IMG"===t.tagName?t.src:window.getComputedStyle(t).backgroundImage.replace(/^url|[(|)|'|"]/g,""),e[O](o),document.body[O](e),{close:Y,next:function(){return q(1)},prev:function(){return q(-1)}};var W}}();


================================================
FILE: assets/CNAME
================================================
course.rs


================================================
FILE: assets/custom.js
================================================
var initAll = function () {
    var path = window.location.pathname;
    if (path.endsWith("/print.html")) {
        return;
    }

    var images = document.querySelectorAll("main img")
    Array.prototype.forEach.call(images, function (img) {
        img.addEventListener("click", function () {
            BigPicture({
                el: img,
            });
        });
    });

    // Un-active everything when you click it
    Array.prototype.forEach.call(document.getElementsByClassName("pagetoc")[0].children, function (el) {
        el.addEventHandler("click", function () {
            Array.prototype.forEach.call(document.getElementsByClassName("pagetoc")[0].children, function (el) {
                el.classList.remove("active");
            });
            el.classList.add("active");
        });
    });

    var updateFunction = function () {
        var id = null;
        var elements = document.getElementsByClassName("header");
        Array.prototype.forEach.call(elements, function (el) {
            if (window.pageYOffset >= el.offsetTop) {
                id = el;
            }
        });

        Array.prototype.forEach.call(document.getElementsByClassName("pagetoc")[0].children, function (el) {
            el.classList.remove("active");
        });

        Array.prototype.forEach.call(document.getElementsByClassName("pagetoc")[0].children, function (el) {
            if (id == null) {
                return;
            }
            if (id.href.localeCompare(el.href) == 0) {
                el.classList.add("active");
            }
        });
    };

    var pagetoc = document.getElementsByClassName("pagetoc")[0];
    var elements = document.getElementsByClassName("header");
    Array.prototype.forEach.call(elements, function (el) {
        var link = document.createElement("a");

        // Indent shows hierarchy
        var indent = "";
        switch (el.parentElement.tagName) {
            case "H1":
                return;
            case "H3":
                indent = "20px";
                break;
            case "H4":
                indent = "40px";
                break;
            default:
                break;
        }

        link.appendChild(document.createTextNode(el.text));
        link.style.paddingLeft = indent;
        link.href = el.href;
        pagetoc.appendChild(link);
    });
    updateFunction.call();

    // Handle active elements on scroll
    window.addEventListener("scroll", updateFunction);

    document.getElementById("theme-list").addEventListener("click", function (e) {
        var iframe = document.querySelector('.giscus-frame');
        if (!iframe) return;
        var theme;
        if (e.target.className === "theme") {
            theme = e.target.id;
        } else {
            return;
        }

        // 若当前 mdbook 主题不是 Light 或 Rust ，则将 giscuz 主题设置为 transparent_dark
        var giscusTheme = "light"
        if (theme != "light" && theme != "rust") {
            giscusTheme = "transparent_dark";
        }

        var msg = {
            setConfig: {
                theme: giscusTheme
            }
        };
        iframe.contentWindow.postMessage({ giscus: msg }, 'https://giscus.app');
    });
    
    pagePath = pagePath.replace("index.md", "");
    pagePath = pagePath.replace(".md", "");
    if (pagePath.length > 0) {
        if (pagePath.charAt(pagePath.length-1) == "/"){
            pagePath = pagePath.substring(0, pagePath.length-1)
        }
    }else {
        pagePath = "index"
    }

    // add visitors count
    var ele = document.createElement("div");
    ele.setAttribute("align","center");
    var count = document.createElement("img")
    count.setAttribute("src", "https://visitor-badge.glitch.me/badge?page_id=" + path);
    ele.appendChild(count);
    var divider =document.createElement("hr")

    document.getElementById("giscus-container").appendChild(ele);
    document.getElementById("giscus-container").appendChild(divider);

    // 选取浏览器默认使用的语言
    // const lang = navigator.language || navigator.userLanguage

    // 若当前 mdbook 主题为 Light 或 Rust ，则将 giscuz 主题设置为 light
    var theme = "transparent_dark";
    const themeClass = document.getElementsByTagName("html")[0].className;
    if (themeClass.indexOf("light") != -1 || themeClass.indexOf("rust") != -1) {
        theme = "light"
    }

    var script = document.createElement("script")
    script.type = "text/javascript";
    script.src = "https://giscus.app/client.js";
    script.async = true;
    script.crossOrigin = "anonymous";
    script.setAttribute("data-repo", "sunface/rust-course");
    script.setAttribute("data-repo-id", "MDEwOlJlcG9zaXRvcnkxNDM4MjIwNjk=");
    script.setAttribute("data-category", "章节评论区");
    script.setAttribute("data-category-id", "DIC_kwDOCJKM9c4COQcP");
    script.setAttribute("data-mapping", "specific");
    script.setAttribute("data-term", pagePath);
    script.setAttribute("data-reactions-enabled", "1");
    script.setAttribute("data-emit-metadata", "0");
    script.setAttribute("data-input-position", "top");
    script.setAttribute("data-theme", theme);
    // script.setAttribute("data-lang", lang);
    // 预先加载评论会更好，这样用户读到那边时，评论就加载好了
    // script.setAttribute("data-loading", "lazy");
    document.getElementById("giscus-container").appendChild(script);



};

window.addEventListener('load', initAll);


================================================
FILE: assets/sitemap.xml
================================================
﻿<?xml version='1.0' encoding='UTF-8'?>
<urlset>
<url>
<loc><![CDATA[http://course.rs]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/about-book.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/comment.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/crate-module/crate.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/crate-module/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/crate-module/module.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/crate-module/use.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/custom-type.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/formatted-output.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/functional-programing/closure.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/functional-programing/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/functional-programing/iterator.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/global-variable.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/hrtb.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/lifetime.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/lifetime/advance.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/lifetime/basic.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/lifetime/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/multi-threads/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/multi-threads/message-passing.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/multi-threads/races.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/multi-threads/ref-counter-lock.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/multi-threads/send-sync.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/multi-threads/thread.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/smart-pointer/box.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/smart-pointer/cell.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/smart-pointer/deref-drop.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/smart-pointer/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/smart-pointer/rc-refcell.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/advance/smart-pointer/self-referrence.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/appendix/derive.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/appendix/difficulties.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/appendix/expressions.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/appendix/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/appendix/keywords]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/appendix/keywords.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/appendix/operators.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/appendix/prelude.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/appendix/rust-version.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/base-type/char-bool.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/base-type/function.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/base-type/index.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/base-type/numbers]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/base-type/numbers.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/base-type/statement-expression.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/collections/hashmap.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/collections/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/collections/vector.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/compound-type/array]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/compound-type/array.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/compound-type/enum.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/compound-type/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/compound-type/string-slice]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/compound-type/string-slice.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/compound-type/struct.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/compound-type/tuple.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/converse.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/errors/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/exception-error.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/first-try/cargo.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/flow-control.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/match-pattern/all-patterns.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/match-pattern/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/match-pattern/match-if-let]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/match-pattern/match-if-let.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/match-pattern/option.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/match-pattern/pattern-match.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/method.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/ownership/borrowing.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/ownership/index.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/ownership/ownership.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/result-error/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/result-error/panic.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/result-error/result.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/trait/advance-trait.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/trait/generic]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/trait/generic.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/trait/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/trait/trait]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/trait/trait-object]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/trait/trait-object.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/trait/trait.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/basic/variable.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/build-js.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/cache.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/cargo-toml-lock.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/commands.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/dependency.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/feature.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/layout.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/manifest.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/profile.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/version.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/toolchains/cargo/workspace.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/cdn-cgi/l/email-protection]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/compiler/attributes.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/compiler/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/compiler/speed-up.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/compiler/spped-up.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/core/ownership.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/errors/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/errors/panic-codes.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/errors/panic.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/errors/pretty-format.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/errors/simplify.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/errors/user-define.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/fight-with-compiler/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/fight-with-compiler/lifetime/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/fight-with-compiler/lifetime/loop.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/fight-with-compiler/lifetime/too-long1.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/fight-with-compiler/lifetime/too-long2.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/fight-with-compiler/phantom-data.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/fight-with-compiler/unconstrained.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/first-try/cargo.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/first-try/editor.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/first-try/hello-world.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/first-try/installation.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/first-try/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/into-rust.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/libraries/command/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/libraries/command/structopt.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/libraries/http/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/libraries/http/reqwest.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/libraries/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/libraries/json/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/libraries/json/serde.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/macro/intro]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/macro/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/macro/procedure-macro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/memory/allocation.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/memory/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/memory/layout.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/memory/pointer-ref.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/memory/uninit.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/memory/virtual.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/monitor/apm.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/monitor/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/monitor/log.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/monitor/observability.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/async-await.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/future/future.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/future/into.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/future/multi-futures.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/future/system-io.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/future/task-excutor.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/future/task-schedule.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/future/workarounds.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/http.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/pin-unpin.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/tokio/basic.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/tokio/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/async/tokio/stream.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/concurrency-parallelism.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/networking/tcp.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/object-oriented/characteristics.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/object-oriented/design-pattern.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/object-oriented/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/object-oriented/trait-object.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/performance/benchmark.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/performance/calculate.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/performance/clone-copy.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/performance/cpu-cache.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/performance/deep-into-move.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/performance/early-optimise.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/performance/heap-stack.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/performance/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/performance/runtime-check.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/performance/tools.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/pitfalls/arithmetic-overflow.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/pitfalls/closure-with-lifetime.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/pitfalls/index.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/pitfalls/lazy-iterators.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/pitfalls/multiple-mutable-references.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/pitfalls/stack-overflow.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/pitfalls/the-disabled-mutability.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/pitfalls/use-vec-in-for.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/pitfalls/weird-ranges.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/practice/best-pratice.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/practice/coding-tips.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/practice/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/practice/third-party-libs.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/print.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/std/hashmap.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/std/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/std/iterator.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/std/search.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/std/vector.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/style-guide/clippy.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/style-guide/code.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/style-guide/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/style-guide/mark.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/style-guide/naming.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/test/benchmark.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/test/ci.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/test/intergration.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/test/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/test/unit.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/traits/as-ref-as-mut.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/traits/borrow-family.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/traits/cow.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/traits/deref.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/traits/eq.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/traits/from-into.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/traits/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/unsafe/ffi.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/unsafe/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/unsafe/modify-global-var.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/unsafe/raw-pointer.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/unsafe/ub.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/web/intro.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
<url>
<loc><![CDATA[http://course.rs/web/serialization.html]]></loc>
<lastmod>2021-12-30</lastmod>
<changefreq>weekly</changefreq>
</url>
</urlset>


================================================
FILE: assets/rustlings-zh/README.md
================================================
[Binary file]


================================================
FILE: assets/rustlings-zh/Cargo.toml
================================================
[package]
name = "rustlings"
version = "4.6.0"
authors = []
edition = "2021"

[dependencies]
argh = "0.1.4"
indicatif = "0.10.3"
console = "0.7.7"
notify = "4.0.15"
toml = "0.4.10"
regex = "1.5.5"
serde = {version = "1.0.10", features = ["derive"]}

[[bin]]
name = "rustlings"
path = "src/main.rs"

[dev-dependencies]
assert_cmd = "0.11.0"
predicates = "1.0.1"
glob = "0.3.0"



================================================
FILE: assets/rustlings-zh/CHANGELOG.md
================================================
<a name="4.6.0"></a>
## 4.6.0 (2021-09-25)


#### Features

*   add advanced_errs2 ([abd6b70c](https://github.com/rust-lang/rustlings/commit/abd6b70c72dc6426752ff41f09160b839e5c449e))
*   add advanced_errs1 ([882d535b](https://github.com/rust-lang/rustlings/commit/882d535ba8628d5e0b37e8664b3e2f26260b2671))
*   Add a farewell message when quitting `watch` ([1caef0b4](https://github.com/rust-lang/rustlings/commit/1caef0b43494c8b8cdd6c9260147e70d510f1aca))
*   add more watch commands ([a7dc080b](https://github.com/rust-lang/rustlings/commit/a7dc080b95e49146fbaafe6922a6de2f8cb1582a), closes [#842](https://github.com/rust-lang/rustlings/issues/842))
* **modules:**  update exercises, add modules3 (#822) ([dfd2fab4](https://github.com/rust-lang/rustlings/commit/dfd2fab4f33d1bf59e2e5ee03123c0c9a67a9481))
* **quiz1:**  add default function name in comment (#838) ([0a11bad7](https://github.com/rust-lang/rustlings/commit/0a11bad71402b5403143d642f439f57931278c07))

#### Bug Fixes

*   Correct small typo in exercises/conversions/from_str.rs ([86cc8529](https://github.com/rust-lang/rustlings/commit/86cc85295ae36948963ae52882e285d7e3e29323))
* **cli:**  typo in exercise.rs (#848) ([06d5c097](https://github.com/rust-lang/rustlings/commit/06d5c0973a3dffa3c6c6f70acb775d4c6630323c))
* **from_str, try_from_into:**  custom error types ([2dc93cad](https://github.com/rust-lang/rustlings/commit/2dc93caddad43821743e4903d89b355df58d7a49))
* **modules2:**  fix typo (#835) ([1c3beb0a](https://github.com/rust-lang/rustlings/commit/1c3beb0a59178c950dc05fe8ee2346b017429ae0))
* **move_semantics5:**
  *  change &mut *y to &mut x (#814) ([d75759e8](https://github.com/rust-lang/rustlings/commit/d75759e829fdcd64ef071cf4b6eae2a011a7718b))
  *  Clarify instructions ([df25684c](https://github.com/rust-lang/rustlings/commit/df25684cb79f8413915e00b5efef29369849cef1))
* **quiz1:**  Fix inconsistent wording (#826) ([03131a3d](https://github.com/rust-lang/rustlings/commit/03131a3d35d9842598150f9da817f7cc26e2669a))



<a name="4.5.0"></a>
## 4.5.0 (2021-07-07)


#### Features

*   Add move_semantics5 exercise. (#746) ([399ab328](https://github.com/rust-lang/rustlings/commit/399ab328d8d407265c09563aa4ef4534b2503ff2))
* **cli:**  Add "next" to run the next unsolved exercise. (#785) ([d20e413a](https://github.com/rust-lang/rustlings/commit/d20e413a68772cd493561f2651cf244e822b7ca5))

#### Bug Fixes

*   rename result1 to errors4 ([50ab289d](https://github.com/rust-lang/rustlings/commit/50ab289da6b9eb19a7486c341b00048c516b88c0))
*   move_semantics5 hints ([1b858285](https://github.com/rust-lang/rustlings/commit/1b85828548f46f58b622b5e0c00f8c989f928807))
*   remove trailing whitespaces from iterators1 ([4d4fa774](https://github.com/rust-lang/rustlings/commit/4d4fa77459392acd3581c6068aa8be9a02de12fc))
*   add hints to generics1 and generics2 exercises ([31457940](https://github.com/rust-lang/rustlings/commit/31457940846b3844d78d4a4d2b074bc8d6aaf1eb))
*   remove trailing whitespace ([d9b69bd1](https://github.com/rust-lang/rustlings/commit/d9b69bd1a0a7a99f2c0d80933ad2eea44c8c71b2))
* **installation:**  first PowerShell command ([aa9a943d](https://github.com/rust-lang/rustlings/commit/aa9a943ddf3ae260782e73c26bcc9db60e5894b6))
* **iterators5:**  derive Clone, Copy ([91fc9e31](https://github.com/rust-lang/rustlings/commit/91fc9e3118f4af603c9911698cc2a234725cb032))
* **quiz1:**  Updated question description (#794) ([d8766496](https://github.com/rust-lang/rustlings/commit/d876649616cc8a8dd5f539f8bc1a5434b960b1e9))
* **try_from_into, from_str:**  hints for dyn Error ([11d2cf0d](https://github.com/rust-lang/rustlings/commit/11d2cf0d604dee3f5023c17802d69438e69fa50e))
* **variables5:**  confine the answer further ([48ffcbd2](https://github.com/rust-lang/rustlings/commit/48ffcbd2c4cc4d936c2c7480019190f179813cc5))



<a name="4.4.0"></a>
## 4.4.0 (2021-04-24)


#### Bug Fixes

*   Fix spelling error in main.rs ([91ee27f2](https://github.com/rust-lang/rustlings/commit/91ee27f22bd3797a9db57e5fd430801c170c5db8))
*   typo in default out text ([644c49f1](https://github.com/rust-lang/rustlings/commit/644c49f1e04cbb24e95872b3a52b07d692ae3bc8))
* **collections:**  Naming exercises for vectors and hashmap ([bef39b12](https://github.com/rust-lang/rustlings/commit/bef39b125961310b34b34871e480a82e82af4678))
* **from_str:**
  *  Correct typos ([5f7c89f8](https://github.com/rust-lang/rustlings/commit/5f7c89f85db1f33da01911eaa479c3a2d4721678))
  *  test for error instead of unwrap/should_panic ([15e71535](https://github.com/rust-lang/rustlings/commit/15e71535f37cfaed36e22eb778728d186e2104ab))
  *   use trait objects for from_str ([c3e7b831](https://github.com/rust-lang/rustlings/commit/c3e7b831786c9172ed8bd5d150f3c432f242fba9))
* **functions3:**  improve function argument type (#687) ([a6509cc4](https://github.com/rust-lang/rustlings/commit/a6509cc4d545d8825f01ddf7ee37823b372154dd))
* **hashmap2:**  Update incorrect assertion (#660) ([72aaa15e](https://github.com/rust-lang/rustlings/commit/72aaa15e6ab4b72b3422f1c6356396e20a2a2bb8))
* **info:**  Fix typo (#635) ([cddc1e86](https://github.com/rust-lang/rustlings/commit/cddc1e86e7ec744ee644cc774a4887b1a0ded3e8))
* **iterators2:**  Moved errors out of tests. ([baf4ba17](https://github.com/rust-lang/rustlings/commit/baf4ba175ba6eb92989e3dd54ecbec4bedc9a863), closes [#359](https://github.com/rust-lang/rustlings/issues/359))
* **iterators3:**  Enabled iterators3.rs to run without commented out tests. ([c6712dfc](https://github.com/rust-lang/rustlings/commit/c6712dfccd1a093e590ad22bbc4f49edc417dac0))
* **main:**  Let find_exercise work with borrows ([347f30bd](https://github.com/rust-lang/rustlings/commit/347f30bd867343c5ace1097e085a1f7e356553f7))
* **move_semantics4:**
  *  Remove redundant "instead" (#640) ([cc266d7d](https://github.com/rust-lang/rustlings/commit/cc266d7d80b91e79df3f61984f231b7f1587218e))
  *  Small readbility improvement (#617) ([10965920](https://github.com/rust-lang/rustlings/commit/10965920fbdf8a1efc85bed869e55a1787006404))
* **option2:**  Rename uninformative variables (#675) ([b4de6594](https://github.com/rust-lang/rustlings/commit/b4de6594380636817d13c2677ec6f472a964cf43))
* **quiz3:**  Force an answer to Q2 (#672) ([0d894e6f](https://github.com/rust-lang/rustlings/commit/0d894e6ff739943901e1ae8c904582e5c2f843bd))
* **structs:**  Add 5.3 to structs/README (#652) ([6bd791f2](https://github.com/rust-lang/rustlings/commit/6bd791f2f44aa7f0ad926df767f6b1fa8f12a9a9))
* **structs2:**  correct grammar in hint (#663) ([ebdb66c7](https://github.com/rust-lang/rustlings/commit/ebdb66c7bfb6d687a14cc511a559a222e6fc5de4))
* **structs3:**
  * reword heading comment (#664) ([9f3e8c2d](https://github.com/rust-lang/rustlings/commit/9f3e8c2dde645e5264c2d2200e68842b5f47bfa3))
  *   add check to prevent naive implementation of is_international ([05a753fe](https://github.com/rust-lang/rustlings/commit/05a753fe6333d36dbee5f68c21dec04eacdc75df))
* **threads1:**  line number correction ([7857b0a6](https://github.com/rust-lang/rustlings/commit/7857b0a689b0847f48d8c14cbd1865e3b812d5ca))
* **try_from_into:**  use trait objects ([2e93a588](https://github.com/rust-lang/rustlings/commit/2e93a588e0abe8badb7eafafb9e7d073c2be5df8))

#### Features

*   Replace clap with argh ([7928122f](https://github.com/rust-lang/rustlings/commit/7928122fcef9ca7834d988b1ec8ca0687478beeb))
*   Replace emojis when NO_EMOJI env variable present ([8d62a996](https://github.com/rust-lang/rustlings/commit/8d62a9963708dbecd9312e8bcc4b47049c72d155))
*   Added iterators5.rs exercise. ([b29ea17e](https://github.com/rust-lang/rustlings/commit/b29ea17ea94d1862114af2cf5ced0e09c197dc35))
* **arc1:**  Add more details to description and hint (#710) ([81be4044](https://github.com/rust-lang/rustlings/commit/81be40448777fa338ebced3b0bfc1b32d6370313))
* **cli:**  Improve the list command with options, and then some ([8bbe4ff1](https://github.com/rust-lang/rustlings/commit/8bbe4ff1385c5c169c90cd3ff9253f9a91daaf8e))
* **list:**
  *  updated progress percentage ([1c6f7e4b](https://github.com/rust-lang/rustlings/commit/1c6f7e4b7b9b3bd36f4da2bb2b69c549cc8bd913))
  *  added progress info ([c0e3daac](https://github.com/rust-lang/rustlings/commit/c0e3daacaf6850811df5bc57fa43e0f249d5cfa4))



<a name="4.3.0"></a>
## 4.3.0 (2020-12-29)

#### Features

*   Rewrite default out text ([44d39112](https://github.com/rust-lang/rustlings/commit/44d39112ff122b29c9793fe52e605df1612c6490))
*   match exercise order to book chapters (#541) ([033bf119](https://github.com/rust-lang/rustlings/commit/033bf1198fc8bfce1b570e49da7cde010aa552e3))
*   Crab? (#586) ([fa9f522b](https://github.com/rust-lang/rustlings/commit/fa9f522b7f043d7ef73a39f003a9272dfe72c4f4))
*   add "rustlings list" command ([838f9f30](https://github.com/rust-lang/rustlings/commit/838f9f30083d0b23fd67503dcf0fbeca498e6647))
* **try_from_into:**  remove duplicate annotation ([04f1d079](https://github.com/rust-lang/rustlings/commit/04f1d079aa42a2f49af694bc92c67d731d31a53f))

#### Bug Fixes

*   update structs README ([bcf14cf6](https://github.com/rust-lang/rustlings/commit/bcf14cf677adb3a38a3ac3ca53f3c69f61153025))
*   added missing exercises to info.toml ([90cfb6ff](https://github.com/rust-lang/rustlings/commit/90cfb6ff28377531bfc34acb70547bdb13374f6b))
*   gives a bit more context to magic number ([30644c9a](https://github.com/rust-lang/rustlings/commit/30644c9a062b825c0ea89435dc59f0cad86b110e))
* **functions2:**  Change signature to trigger precise error message: (#605) ([0ef95947](https://github.com/rust-lang/rustlings/commit/0ef95947cc30482e63a7045be6cc2fb6f6dcb4cc))
* **structs1:**  Adjust wording (#573) ([9334783d](https://github.com/rust-lang/rustlings/commit/9334783da31d821cc59174fbe8320df95828926c))
* **try_from_into:**
  *  type error ([4f4cfcf3](https://github.com/rust-lang/rustlings/commit/4f4cfcf3c36c8718c7c170c9c3a6935e6ef0618c))
  *  Update description (#584) ([96347df9](https://github.com/rust-lang/rustlings/commit/96347df9df294f01153b29d9ad4ba361f665c755))
* **vec1:**  Have test compare every element in a and v ([9b6c6293](https://github.com/rust-lang/rustlings/commit/9b6c629397b24b944f484f5b2bbd8144266b5695))

<a name="4.2.0"></a>
## 4.2.0 (2020-11-07)

#### Features

*   Add HashMap exercises ([633c00cf](https://github.com/rust-lang/rustlings/commit/633c00cf8071e1e82959a3010452a32f34f29fc9))
*   Add Vec exercises ([0c12fa31](https://github.com/rust-lang/rustlings/commit/0c12fa31c57c03c6287458a0a8aca7afd057baf6))
* **primitive_types6:**  Add a test (#548) ([2b1fb2b7](https://github.com/rust-lang/rustlings/commit/2b1fb2b739bf9ad8d6b7b12af25fee173011bfc4))
* **try_from_into:**  Add tests (#571) ([95ccd926](https://github.com/rust-lang/rustlings/commit/95ccd92616ae79ba287cce221101e0bbe4f68cdc))

#### Bug Fixes

*   log error output when inotify limit is exceeded ([d61b4e5a](https://github.com/rust-lang/rustlings/commit/d61b4e5a13b44d72d004082f523fa1b6b24c1aca))
*   more unique temp_file ([5643ef05](https://github.com/rust-lang/rustlings/commit/5643ef05bc81e4a840e9456f4406a769abbe1392))
* **installation:**  Update the MinRustVersion ([21bfb2d4](https://github.com/rust-lang/rustlings/commit/21bfb2d4777429c87d8d3b5fbf0ce66006dcd034))
* **iterators2:**  Update description (#578) ([197d3a3d](https://github.com/rust-lang/rustlings/commit/197d3a3d8961b2465579218a6749b2b2cefa8ddd))
* **primitive_types6:**
  *  remove 'unused doc comment' warning ([472d8592](https://github.com/rust-lang/rustlings/commit/472d8592d65c8275332a20dfc269e7ac0d41bc88))
  *  missing comma in test ([4fb230da](https://github.com/rust-lang/rustlings/commit/4fb230daf1251444fcf29e085cee222a91f8a37e))
* **quiz3:**  Second test is for odd numbers, not even. (#553) ([18e0bfef](https://github.com/rust-lang/rustlings/commit/18e0bfef1de53071e353ba1ec5837002ff7290e6))

<a name="4.1.0"></a>
## 4.1.0 (2020-10-05)

#### Bug Fixes

*   Update rustlings version in Cargo.lock ([1cc40bc9](https://github.com/rust-lang/rustlings/commit/1cc40bc9ce95c23d56f6d91fa1c4deb646231fef))
* **arc1:**  index mod should equal thread count ([b4062ef6](https://github.com/rust-lang/rustlings/commit/b4062ef6993e80dac107c4093ea85166ad3ee0fa))
* **enums3:**  Update Message::ChangeColor to take a tuple. (#457) ([4b6540c7](https://github.com/rust-lang/rustlings/commit/4b6540c71adabad647de8a09e57295e7c7c7d794))
* **exercises:**  adding question mark to quiz2 ([101072ab](https://github.com/rust-lang/rustlings/commit/101072ab9f8c80b40b8b88cb06cbe38aca2481c5))
* **generics3:**  clarify grade change ([47f7672c](https://github.com/rust-lang/rustlings/commit/47f7672c0307732056e7426e81d351f0dd7e22e5))
* **structs3:**  Small adjustment of variable name ([114b54cb](https://github.com/rust-lang/rustlings/commit/114b54cbdb977234b39e5f180d937c14c78bb8b2))
* **using_as:**  Add test so that proper type is returned. (#512) ([3286c5ec](https://github.com/rust-lang/rustlings/commit/3286c5ec19ea5fb7ded81d047da5f8594108a490))

#### Features

*   Added iterators1.rs exercise ([9642f5a3](https://github.com/rust-lang/rustlings/commit/9642f5a3f686270a4f8f6ba969919ddbbc4f7fdd))
*   Add ability to run rustlings on repl.it (#471) ([8f7b5bd0](https://github.com/rust-lang/rustlings/commit/8f7b5bd00eb83542b959830ef55192d2d76db90a))
*   Add gitpod support (#473) ([4821a8be](https://github.com/rust-lang/rustlings/commit/4821a8be94af4f669042a06ab917934cfacd032f))
*   Remind the user of the hint option (#425) ([816b1f5e](https://github.com/rust-lang/rustlings/commit/816b1f5e85d6cc6e72673813a85d0ada2a8f84af))
*   Remind the user of the hint option (#425) ([9f61db5d](https://github.com/rust-lang/rustlings/commit/9f61db5dbe38538cf06571fcdd5f806e7901e83a))
* **cli:**  Added 'cls' command to 'watch' mode (#474) ([4f2468e1](https://github.com/rust-lang/rustlings/commit/4f2468e14f574a93a2e9b688367b5752ed96ae7b))
* **try_from_into:**  Add insufficient length test (#469) ([523d18b8](https://github.com/rust-lang/rustlings/commit/523d18b873a319f7c09262f44bd40e2fab1830e5))

<a name="4.0.0"></a>
## 4.0.0 (2020-07-08)

#### Breaking Changes

*   Add a --nocapture option to display test harnesses' outputs ([8ad5f9bf](https://github.com/rust-lang/rustlings/commit/8ad5f9bf531a4848b1104b7b389a20171624c82f))
*   Rename test to quiz, fixes #244 ([010a0456](https://github.com/rust-lang/rustlings/commit/010a04569282149cea7f7a76fc4d7f4c9f0f08dd))

#### Features

*   Add traits README ([173bb141](https://github.com/rust-lang/rustlings/commit/173bb14140c5530cbdb59e53ace3991a99d804af))
*   Add box1.rs exercise ([7479a473](https://github.com/rust-lang/rustlings/commit/7479a4737bdcac347322ad0883ca528c8675e720))
*   Rewrite try_from_into (#393) ([763aa6e3](https://github.com/rust-lang/rustlings/commit/763aa6e378a586caae2d8d63755a85eeba227933))
*   Add if2 exercise ([1da84b5f](https://github.com/rust-lang/rustlings/commit/1da84b5f7c489f65bd683c244f13c7d1ee812df0))
*   Added exercise structs3.rs ([b66e2e09](https://github.com/rust-lang/rustlings/commit/b66e2e09622243e086a0f1258dd27e1a2d61c891))
*   Add exercise variables6 covering const (#352) ([5999acd2](https://github.com/rust-lang/rustlings/commit/5999acd24a4f203292be36e0fd18d385887ec481))

#### Bug Fixes

*   Change then to than ([ddd98ad7](https://github.com/rust-lang/rustlings/commit/ddd98ad75d3668fbb10eff74374148aa5ed2344d))
*   rename quiz1 to tests1 in info (#420) ([0dd1c6ca](https://github.com/rust-lang/rustlings/commit/0dd1c6ca6b389789e0972aa955fe17aa15c95f29))
*   fix quiz naming inconsistency (#421) ([5563adbb](https://github.com/rust-lang/rustlings/commit/5563adbb890587fc48fbbc9c4028642687f1e85b))
*   confine the user further in variable exercises ([06ef4cc6](https://github.com/rust-lang/rustlings/commit/06ef4cc654e75d22a526812919ee49b8956280bf))
*   update iterator and macro text for typos and clarity ([95900828](https://github.com/rust-lang/rustlings/commit/959008284834bece0196a01e17ac69a7e3590116))
*   update generics2       closes #362 ([964c974a](https://github.com/rust-lang/rustlings/commit/964c974a0274199d755073b917c2bc5da0c9b4f1))
*   confusing comment in conversions/try_from_into.rs ([c9e4f2cf](https://github.com/rust-lang/rustlings/commit/c9e4f2cfb4c48d0b7451263cfb43b9426438122d))
* **arc1:**  Passively introduce attributes (#429) ([113cdae2](https://github.com/rust-lang/rustlings/commit/113cdae2d4e4c55905e8056ad326ede7fd7de356))
* **box1:**  fix comment typo (#426) ([bb2ca251](https://github.com/rust-lang/rustlings/commit/bb2ca251106b27a7272d9a30872904dd1376654c))
* **errorsn:**  Try harder to confine the user. (#388) ([2b20c8a0](https://github.com/rust-lang/rustlings/commit/2b20c8a0f5774d07c58d110d75879f33fc6273b5))
* **from_into.rs:**  typo ([a901499e](https://github.com/rust-lang/rustlings/commit/a901499ededd3ce1995164700514fe4e9a0373ea))
* **generics2:**  Guide students to the answer (#430) ([e6bd8021](https://github.com/rust-lang/rustlings/commit/e6bd8021d9a7dd06feebc30c9d5f953901d7b419))
* **installation:**
  *  Provide a backup git reference when tag can't be curl ([9e4fb100](https://github.com/rust-lang/rustlings/commit/9e4fb1009f1c9e3433915c03e22c2af422e5c5fe))
  *  Check if python is available while checking for git,rustc and cargo ([9cfb617d](https://github.com/rust-lang/rustlings/commit/9cfb617d5b0451b4b51644a1298965390cda9884))
* **option1:**
  *  Don't add only zeros to the numbers array ([cce6a442](https://github.com/rust-lang/rustlings/commit/cce6a4427718724a9096800754cd3abeca6a1580))
  *  Add cast to usize, as it is confusing in the context of an exercise about Option ([f6cffc7e](https://github.com/rust-lang/rustlings/commit/f6cffc7e487b42f15a6f958e49704c93a8d4465b))
* **option2:**  Add TODO to comments (#400) ([10967bce](https://github.com/rust-lang/rustlings/commit/10967bce57682812dc0891a9f9757da1a9d87404))
* **options1:**  Add hint about Array Initialization (#389) ([9f75554f](https://github.com/rust-lang/rustlings/commit/9f75554f2a30295996f03f0160b98c0458305502))
* **test2:**  name of type String and &str (#394) ([d6c0a688](https://github.com/rust-lang/rustlings/commit/d6c0a688e6a96f93ad60d540d4b326f342fc0d45))
* **variables6:**  minor typo (#419) ([524e17df](https://github.com/rust-lang/rustlings/commit/524e17df10db95f7b90a0f75cc8997182a8a4094))

<a name="3.0.0"></a>
## 3.0.0 (2020-04-11)

#### Breaking Changes

* make "compile" exercises print output (#278) ([3b6d5c](https://github.com/fmoko/rustlings/commit/3b6d5c3aaa27a242a832799eb66e96897d26fde3))

#### Bug Fixes

* **primitive_types:** revert primitive_types4 (#296) ([b3a3351e](https://github.com/rust-lang/rustlings/commit/b3a3351e8e6a0bdee07077d7b0382953821649ae))
* **run:**  compile clippy exercise files (#295) ([3ab084a4](https://github.com/rust-lang/rustlings/commit/3ab084a421c0f140ae83bf1fc3f47b39342e7373))
* **conversions:**
  * add additional test to meet exercise rules (#284) ([bc22ec3](https://github.com/fmoko/rustlings/commit/bc22ec382f843347333ef1301fc1bad773657f38))
  * remove duplicate not done comment (#292) ([dab90f](https://github.com/fmoko/rustlings/commit/dab90f7b91a6000fe874e3d664f244048e5fa342))
* don't hardcode documentation version for traits (#288) ([30e6af](https://github.com/fmoko/rustlings/commit/30e6af60690c326fb5d3a9b7335f35c69c09137d))

#### Features

*   add Option2 exercise (#290) ([86b5c08b](https://github.com/rust-lang/rustlings/commit/86b5c08b9bea1576127a7c5f599f5752072c087d))
*   add exercise for option (#282) ([135e5d47](https://github.com/rust-lang/rustlings/commit/135e5d47a7c395aece6f6022117fb20c82f2d3d4))
*   add new exercises for generics (#280) ([76be5e4e](https://github.com/rust-lang/rustlings/commit/76be5e4e991160f5fd9093f03ee2ba260e8f7229))
* **ci:**  add buildkite config ([b049fa2c](https://github.com/rust-lang/rustlings/commit/b049fa2c84dba0f0c8906ac44e28fd45fba51a71))

<a name="2.2.1"></a>
### 2.2.1 (2020-02-27)

#### Bug Fixes

*   Re-add cloning the repo to install scripts ([3d9b03c5](https://github.com/rust-lang/rustlings/commit/3d9b03c52b8dc51b140757f6fd25ad87b5782ef5))

#### Features

*   Add clippy lints (#269) ([1e2fd9c9](https://github.com/rust-lang/rustlings/commit/1e2fd9c92f8cd6e389525ca1a999fca4c90b5921))

<a name="2.2.0"></a>
## 2.2.0 (2020-02-25)


#### Bug Fixes

*   Update deps to version compatable with aarch64-pc-windows (#263) ([19a93428](https://github.com/rust-lang/rustlings/commit/19a93428b3c73d994292671f829bdc8e5b7b3401))
* **docs:**
  * Added a necessary step to Windows installation process (#242) ([3906efcd](https://github.com/rust-lang/rustlings/commit/3906efcd52a004047b460ed548037093de3f523f))
  * Fixed mangled sentence from book; edited for clarity (#266) ([ade52ff](https://github.com/rust-lang/rustlings/commit/ade52ffb739987287ddd5705944c8777705faed9))
  * Updated iterators readme to account for iterators4 exercise (#273) ([bec8e3a](https://github.com/rust-lang/rustlings/commit/bec8e3a644cbd88db1c73ea5f1d8a364f4a34016))
* **installation:**  make fatal errors more obvious (#272) ([17d0951e](https://github.com/rust-lang/rustlings/commit/17d0951e66fda8e11b204d5c4c41a0d5e22e78f7))
* **iterators2:**
  *  Remove reference to missing iterators2.rs (#245) ([419f7797](https://github.com/rust-lang/rustlings/commit/419f7797f294e4ce6a2b883199731b5bde77d262))
* **as_ref_mut:** Enable a test and improve per clippy's suggestion (#256) ([dfdf809](https://github.com/rust-lang/rustlings/commit/dfdf8093ebbd4145864995627b812780de52f902))
* **tests1:**
  * Change test command ([fe10e06c](https://github.com/rust-lang/rustlings/commit/fe10e06c3733ddb4a21e90d09bf79bfe618e97ce)
  * Correct test command in tests1.rs comment (#263) ([39fa7ae](https://github.com/rust-lang/rustlings/commit/39fa7ae8b70ad468da49b06f11b2383135a63bcf))

#### Features

*   Add variables5.rs exercise (#264) ([0c73609e](https://github.com/rust-lang/rustlings/commit/0c73609e6f2311295e95d6f96f8c747cfc4cba03))
*   Show a completion message when watching (#253) ([d25ee55a](https://github.com/rust-lang/rustlings/commit/d25ee55a3205882d35782e370af855051b39c58c))
*   Add type conversion and parsing exercises (#249) ([0c85dc11](https://github.com/rust-lang/rustlings/commit/0c85dc1193978b5165491b99cc4922caf8d14a65))
*   Created consistent money unit (#258) ([fd57f8f](https://github.com/rust-lang/rustlings/commit/fd57f8f2c1da2af8ddbebbccec214e6f40f4dbab))
*   Enable test for exercise test4 (#276) ([8b971ff](https://github.com/rust-lang/rustlings/commit/8b971ffab6079a706ac925f5917f987932b55c07))
*   Added traits exercises (#274 but specifically #216, which originally added
    this :heart:) ([b559cdd](https://github.com/rust-lang/rustlings/commit/b559cdd73f32c0d0cfc1feda39f82b3e3583df17))


<a name="2.1.0"></a>
## 2.1.0 (2019-11-27)

#### Bug Fixes

* add line numbers in several exercises and hints ([b565c4d3](https://github.com/rust-lang/rustlings/commit/b565c4d3e74e8e110bef201a082fa1302722a7c3))
* **arc1:**  Fix some words in the comment ([c42c3b21](https://github.com/rust-lang/rustlings/commit/c42c3b2101df9164c8cd7bb344def921e5ba3e61))
* **enums:**  Add link to chapter on pattern syntax (#242) ([615ce327](https://github.com/rust-lang/rustlings/commit/615ce3279800c56d89f19d218ccb7ef576624feb))
* **primitive_types4:**
  *  update outdated hint ([4c5189df](https://github.com/rust-lang/rustlings/commit/4c5189df2bdd9a231f6b2611919ba5aa14da0d3f))
  *  update outdated comment ([ded2c034](https://github.com/rust-lang/rustlings/commit/ded2c034ba93fa1e3c2c2ea16b83abc1a57265e8))
* **strings2:**  update line number in hint ([a09f684f](https://github.com/rust-lang/rustlings/commit/a09f684f05c58d239a6fc59ec5f81c2533e8b820))
* **variables1:**  Correct wrong word in comment ([fda5a470](https://github.com/rust-lang/rustlings/commit/fda5a47069e0954f16a04e8e50945e03becb71a5))

#### Features

* **watch:**  show hint while watching ([8143d57b](https://github.com/rust-lang/rustlings/commit/8143d57b4e88c51341dd4a18a14c536042cc009c))

<a name="2.0.0"></a>
## 2.0.0 (2019-11-12)

#### Bug Fixes

* **default:**  Clarify the installation procedure ([c371b853](https://github.com/rust-lang/rustlings/commit/c371b853afa08947ddeebec0edd074b171eeaae0))
* **info:**  Fix trailing newlines for hints ([795b6e34](https://github.com/rust-lang/rustlings/commit/795b6e348094a898e9227a14f6232f7bb94c8d31))
* **run:**  make `run` never prompt ([4b265465](https://github.com/rust-lang/rustlings/commit/4b26546589f7d2b50455429482cf1f386ceae8b3))

#### Breaking Changes

*   Refactor hint system ([9bdb0a12](https://github.com/rust-lang/rustlings/commit/9bdb0a12e45a8e9f9f6a4bd4a9c172c5376c7f60))
*   improve `watch` execution mode ([2cdd6129](https://github.com/rust-lang/rustlings/commit/2cdd61294f0d9a53775ee24ad76435bec8a21e60))
*   Index exercises by name ([627cdc07](https://github.com/rust-lang/rustlings/commit/627cdc07d07dfe6a740e885e0ddf6900e7ec336b))
* **run:**  makes `run` never prompt ([4b265465](https://github.com/rust-lang/rustlings/commit/4b26546589f7d2b50455429482cf1f386ceae8b3))

#### Features

* **cli:**  check for rustc before doing anything ([36a033b8](https://github.com/rust-lang/rustlings/commit/36a033b87a6549c1e5639c908bf7381c84f4f425))
* **hint:**  Add test for hint ([ce9fa6eb](https://github.com/rust-lang/rustlings/commit/ce9fa6ebbfdc3e7585d488d9409797285708316f))

<a name="1.5.1"></a>
### 1.5.1 (2019-11-11)

#### Bug Fixes

* **errors3:**  Update hint ([dcfb427b](https://github.com/rust-lang/rustlings/commit/dcfb427b09585f0193f0a294443fdf99f11c64cb), closes [#185](https://github.com/rust-lang/rustlings/issues/185))
* **if1:**  Remove `return` reference ([ad03d180](https://github.com/rust-lang/rustlings/commit/ad03d180c9311c0093e56a3531eec1a9a70cdb45))
* **strings:**  Move Strings before Structs ([6dcecb38](https://github.com/rust-lang/rustlings/commit/6dcecb38a4435593beb87c8e12d6314143631482), closes [#204](https://github.com/rust-lang/rustlings/issues/204))
* **structs1:**  Remove misleading comment ([f72e5a8f](https://github.com/rust-lang/rustlings/commit/f72e5a8f05568dde04eaeac10b9a69872f21cb37))
* **threads:**  Move Threads behind SLT ([fbe91a67](https://github.com/rust-lang/rustlings/commit/fbe91a67a482bfe64cbcdd58d06ba830a0f39da3), closes [#205](https://github.com/rust-lang/rustlings/issues/205))
* **watch:** clear screen before each `verify()`  ([3aff590](https://github.com/rust-lang/rustlings/commit/3aff59085586c24196a547c2693adbdcf4432648))

<a name="1.5.0"></a>
## 1.5.0 (2019-11-09)

#### Bug Fixes

* **test1:** Rewrite logic ([79a56942](https://github.com/rust-lang/rustlings/commit/79a569422c8309cfc9e4aed25bf4ab3b3859996b))
* **installation:**  Fix rustlings installation check ([7a252c47](https://github.com/rust-lang/rustlings/commit/7a252c475551486efb52f949b8af55803b700bc6))
* **iterators:**  Rename iterator3.rs ([433d2115](https://github.com/rust-lang/rustlings/commit/433d2115bc1c04b6d34a335a18c9a8f3e2672bc6))
* **iterators2:**  Remove syntax resulting in misleading error message ([4cde8664](https://github.com/rust-lang/rustlings/commit/4cde86643e12db162a66e62f23b78962986046ac))
* **option1:**
  *  Fix arguments passed to assert! macro (#222) ([4c2cf6da](https://github.com/rust-lang/rustlings/commit/4c2cf6da755efe02725e05ecc3a303304c10a6da))
  *  Fix arguments passed to assert! macro ([ead4f7af](https://github.com/rust-lang/rustlings/commit/ead4f7af9e10e53418efdde5c359159347282afd))
  *  Add test for prematurely passing exercise ([a750e4a1](https://github.com/rust-lang/rustlings/commit/a750e4a1a3006227292bb17d57d78ce84da6bfc6))
* **primitive_types4:**  Fail on a slice covering the wrong area ([5b1e673c](https://github.com/rust-lang/rustlings/commit/5b1e673cec1658afc4ebbbc800213847804facf5))
* **readme:**  http to https ([70946b85](https://github.com/rust-lang/rustlings/commit/70946b85e536e80e70ed9505cb650ca0a3a1fbb5))
* **test1:**
  *  Swap assertion parameter order ([4086d463](https://github.com/rust-lang/rustlings/commit/4086d463a981e81d97781851d17db2ced290f446))
  *  renamed function name to snake case closes #180 ([89d5186c](https://github.com/rust-lang/rustlings/commit/89d5186c0dae8135ecabf90ee8bb35949bc2d29b))

#### Features

*   Add enums exercises ([dc150321](https://github.com/rust-lang/rustlings/commit/dc15032112fc485226a573a18139e5ce928b1755))
*   Added exercise for struct update syntax ([1c4c8764](https://github.com/rust-lang/rustlings/commit/1c4c8764ed118740cd4cee73272ddc6cceb9d959))
* **iterators2:**  adds iterators2 exercise including config ([9288fccf](https://github.com/rust-lang/rustlings/commit/9288fccf07a2c5043b76d0fd6491e4cf72d76031))

<a name="1.4.1"></a>
### 1.4.1 (2019-08-13)


#### Bug Fixes

* **iterators2:**  Remove syntax resulting in misleading error message ([4cde8664](https://github.com/rust-lang/rustlings/commit/4cde86643e12db162a66e62f23b78962986046ac))
* **option1:**  Add test for prematurely passing exercise ([a750e4a1](https://github.com/rust-lang/rustlings/commit/a750e4a1a3006227292bb17d57d78ce84da6bfc6))
* **test1:**  Swap assertion parameter order ([4086d463](https://github.com/rust-lang/rustlings/commit/4086d463a981e81d97781851d17db2ced290f446))



<a name="1.4.0"></a>
## 1.4.0 (2019-07-13)

#### Bug Fixes

* **installation:**  Fix rustlings installation check ([7a252c47](https://github.com/rust-lang/rustlings/commit/7a252c475551486efb52f949b8af55803b700bc6))
* **iterators:**  Rename iterator3.rs ([433d2115](https://github.com/rust-lang/rustlings/commit/433d2115bc1c04b6d34a335a18c9a8f3e2672bc6))
* **readme:**  http to https ([70946b85](https://github.com/rust-lang/rustlings/commit/70946b85e536e80e70ed9505cb650ca0a3a1fbb5))
* **test1:**  renamed function name to snake case ([89d5186c](https://github.com/rust-lang/rustlings/commit/89d5186c0dae8135ecabf90ee8bb35949bc2d29b))
* **cli:** Check if changed exercise file exists before calling verify ([ba85ca3](https://github.com/rust-lang/rustlings/commit/ba85ca32c4cfc61de46851ab89f9c58a28f33c88))
* **structs1:** Fix the irrefutable let pattern warning ([cc6a141](https://github.com/rust-lang/rustlings/commit/cc6a14104d7c034eadc98297eaaa972d09c50b1f))

#### Features

* **changelog:**  Use clog for changelogs ([34e31232](https://github.com/rust-lang/rustlings/commit/34e31232dfddde284a341c9609b33cd27d9d5724))
* **iterators2:**  adds iterators2 exercise including config ([9288fccf](https://github.com/rust-lang/rustlings/commit/9288fccf07a2c5043b76d0fd6491e4cf72d76031))

<a name="1.3.0"></a>
### 1.3.0 (2019-06-05)

#### Features

- Adds a simple exercise for structures (#163, @briankung)

#### Bug Fixes

- Add Result type signature as it is difficult for new comers to understand Generics and Error all at once. (#157, @veggiemonk)
- Rustfmt and whitespace fixes (#161, @eddyp)
- errorsn.rs: Separate also the hints from each other to avoid accidental viewing (#162, @eddyp)
- fixed outdated links (#165, @gushroom)
- Fix broken link (#164, @HanKruiger)
- Remove highlighting and syntect (#167, @komaeda)

<a name="1.2.2"></a>
### 1.2.2 (2019-05-07)

#### Bug Fixes

- Reverted `--nocapture` flag since it was causing tests to pass unconditionally

<a name="1.2.1"></a>
### 1.2.1 (2019-04-22)

#### Bug Fixes

- Fix the `--nocapture` feature (@komaeda)
- Provide a nicer error message for when you're in the wrong directory

<a name="1.2.0"></a>
### 1.2.0 (2019-04-22)

#### Features

- Add errors to exercises that compile without user changes (@yvan-sraka)
- Use --nocapture when testing, enabling `println!` when running (@komaeda)

<a name="1.1.1"></a>
### 1.1.1 (2019-04-14)

#### Bug fixes

- Fix permissions on exercise files (@zacanger, #133)
- Make installation checks more thorough (@komaeda, 1b3469f236bc6979c27f6e1a04e4138a88e55de3)
- Fix order of true/false in tests for executables (@mgeier, #137)
- Stop run from panicking when compile fails (@cjpearce, #141)
- Fix intermittent test failure caused by race condition (@cjpearce, #140)
- Fix links by deleting book version (@diodfr, #142)
- Canonicalize paths to fix path matching (@cjpearce, #143)

<a name="1.1.0"></a>
### 1.1.0 (2019-03-20)

- errors2.rs: update link to Rust book (#124)
- Start verification at most recently modified file (#120)
- Watch for file creation events in watch mode (#117)
- Add standard library types to exercises suite (#119)
- Give a warning when Rustlings isn't run from the right directory (#123)
- Verify that rust version is recent enough to install Rustlings (#131)

<a name="1.0.1"></a>
### 1.0.1 (2019-03-06)

- Adds a way to install Rustlings in one command (`curl -L https://git.io/rustlings | bash`)
- Makes `rustlings watch` react to create file events (@shaunbennett, #117)
- Reworks the exercise management to use an external TOML file instead of just listing them in the code

<a name="1.0.0"></a>
### 1.0.0 (2019-03-06)

Initial release.



================================================
FILE: assets/rustlings-zh/CONTRIBUTING.md
================================================
## Contributing to Rustlings

First off, thanks for taking the time to contribute!! ❤️

### Quick Reference

I want to...

_add an exercise! ➡️ [read this](#addex) and then [open a Pull Request](#prs)_

_update an outdated exercise! ➡️ [open a Pull Request](#prs)_

_report a bug! ➡️ [open an Issue](#issues)_

_fix a bug! ➡️ [open a Pull Request](#prs)_

_implement a new feature! ➡️ [open an Issue to discuss it first, then a Pull Request](#issues)_

<a name="#src"></a>
### Working on the source code

`rustlings` is basically a glorified `rustc` wrapper. Therefore the source code
isn't really that complicated since the bulk of the work is done by `rustc`.
`src/main.rs` contains a simple `clap` CLI that loads from `src/verify.rs` and `src/run.rs`.

<a name="addex"></a>
### Adding an exercise

The first step is to add the exercise! Name the file `exercises/yourTopic/yourTopicN.rs`, make sure to
put in some helpful links, and link to sections of the book in `exercises/yourTopic/README.md`.

Next make sure it runs with `rustlings`. The exercise metadata is stored in `info.toml`, under the `exercises` array. The order of the `exercises` array determines the order the exercises are run by `rustlings verify`.

Add the metadata for your exercise in the correct order in the `exercises` array. If you are unsure of the correct ordering, add it at the bottom and ask in your pull request. The exercise metadata should contain the following:
```diff
  ...
+ [[exercises]]
+ name = "yourTopicN"
+ path = "exercises/yourTopic/yourTopicN.rs"
+ mode = "compile"
+ hint = """
+ Some kind of useful hint for your exercise."""
  ...
```

The `mode` attribute decides whether Rustlings will only compile your exercise, or compile and test it. If you have tests to verify in your exercise, choose `test`, otherwise `compile`.

That's all! Feel free to put up a pull request.

<a name="issues"></a>
### Issues

You can open an issue [here](https://github.com/rust-lang/rustlings/issues/new).
If you're reporting a bug, please include the output of the following commands:

- `rustc --version`
- `rustlings --version`
- `ls -la`
- Your OS name and version

<a name="prs"></a>
### Pull Requests

Opening a pull request is as easy as forking the repository and committing your
changes. There's a couple of things to watch out for:

#### Write correct commit messages

We follow the [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0-beta.4/)
specification, because it makes it easier to generate changelogs automatically.
This means that you have to format your commit messages in a specific way. Say
you're working on adding a new exercise called `foobar1.rs`. You could write
the following commit message:

```
feat: Add foobar1.rs exercise
```

If you're just fixing a bug, please use the `fix` type:

```
fix(verify): Make sure verify doesn't self-destruct
```

The scope within the brackets is optional, but should be any of these:

- `installation` (for the installation script)
- `cli` (for general CLI changes)
- `verify` (for the verification source file)
- `watch` (for the watch functionality source)
- `run` (for the run functionality source)
- `EXERCISENAME` (if you're changing a specific exercise, or set of exercises,
  substitute them here)

When the commit also happens to close an existing issue, link it in the message
body:

```
fix: Update foobar

closes #101029908
```

If you're doing simple changes, like updating a book link, use `chore`:

```
chore: Update exercise1.rs book link
```

If you're updating documentation, use `docs`:

```
docs: Add more information to Readme
```

If, and only if, you're absolutely sure you want to make a breaking change
(please discuss this beforehand!), add an exclamation mark to the type and
explain the breaking change in the message body:

```
fix!: Completely change verification

BREAKING CHANGE: This has to be done because lorem ipsum dolor
```

#### Pull Request Workflow

Once you open a Pull Request, it may be reviewed or labeled (or both) until
the maintainers accept your change. Then, [bors](https://github.com/bors) will
run the test suite with your changes and if it's successful, automatically
merge it in!



================================================
FILE: assets/rustlings-zh/default_out.txt
================================================
感谢安装 Rustlings!

你还没有任何使用经验？不用担心，Rustlings 正是为初学者量身定做！我们将教你大量
有关 Rust 的知识, 但在我们开始之前，以下有几个关于如何使用 Rustlings 的说明：

1. Rustlings 的核心在于你需要去解决一些练习。这些练习通常有些语法上的错误导致了
   他们无法通过编译或测试。有些又是逻辑上的问题。无论是什么错误，你的目标就是去找
   到它们然后解决！当练习编译通过，这意味着你成功解决了！并且 Rustlings 也已向你
   发起了下一题的挑战。
2. 如果你以 watch 模式运行 Rustlings （推荐），它将自动从第一个练习开始。不要
   为运行 Rustlings 时弹出的错误信息而感到困惑。因为你一运行 Rustlings 就会弹出
   错误信息！这是练习的一部分，所以快用编辑器打开练习文件，然后像侦探一样工作!
3. 如果你在一个练习中被卡住了，可以通过键入 'hint'（在观察模式下），或运行
   `rustex hint myexercise`来查看提示。
4. 如果你认为某个练习毫无意义，请随时在 Github 打开一个 issue
   (https://github.com/rustcollege/rust-exercise/issues/new)。我们积极地关注着项目的
   每个问题和每一件事。其他学习者也这样做的话，这样你们就可以互相帮助了

都明白了吗？牛🐂！可以运行 `rustex watch` 开始你的第一个练习。注意，确保打开你的编辑器!


================================================
FILE: assets/rustlings-zh/info.toml
================================================
# VARIABLES

[[exercises]]
name = "variables1"
path = "exercises/variables/variables1.rs"
mode = "compile"
hint = """
提示: 第 12 行的变量声明缺少了一个关键字，在 Rust 中，创建一个
新的变量绑定必须用到这个关键字。"""

[[exercises]]
name = "variables2"
path = "exercises/variables/variables2.rs"
mode = "compile"
hint = """
编译器在说，Rust 无法根据给定内容推断出变量 `x` 的类型.
如果你对第 7 行标注类型，会发生什么？
如果你对 x 赋予一个值呢？
如果你同时做到了以上两点呢？
 x 到底是什么类型？
如果 x 与 10 是同一类型，亦或者它是不同的类型呢？"""

[[exercises]]
name = "variables3"
path = "exercises/variables/variables3.rs"
mode = "compile"
hint = """
在 Rust，变量绑定默认是不可变的。但我们正试图重新分配
一个不同的值给 x ！我们可以使用一个关键字使变量可变。"""

[[exercises]]
name = "variables4"
path = "exercises/variables/variables4.rs"
mode = "compile"
hint = """
糟了！在这个练习中，我们在第 7 行创建了一个变量，然后试图在第 8 行
使用它，但是它并没被赋值！我们无法打印出不存在的内容，所以尝试赋予 x 一个值！
这个错误造成的 Bug 在任何编程语言中都非常容易发生——感谢 Rust 编译器提醒了我们"""

[[exercises]]
name = "variables5"
path = "exercises/variables/variables5.rs"
mode = "compile"
hint = """
在 variables3 中，我们已经学会了使用一个特殊的关键字使一个不可变的变量变得可变。
可惜的是，在这个练习中，这个方法并不管用，因为我们想给一个现有的变量分配一个不
同类型的值。有时，你会想重复使用现有的变量名称，因为你只是将数值转换为不同的类型，就像
本练习中一样。幸运的是，Rust 有一个强大的技术可以解决这个问题：变量遮蔽（Shadowing）！
有关变量遮蔽的更多内容可通过这本书的 'Variables and Mutability'* 章节了解:
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#shadowing
尝试使用此技术解决此练习。

译：Variables and Mutability：变量与可变性"""

[[exercises]]
name = "variables6"
path = "exercises/variables/variables6.rs"
mode = "compile"
hint = """
我们已经了解了变量与可变性，但还有另一种重要的变量类型；常量（Constant）。 
常量永远不可改变的，它用关键字 'const' 而非关键字 'let' 声明，并且其类型也必须被标注。

更多关于常量的信息 'Differences Between Variables and Constants'* 在这本书的章节 'Variables and Mutability':
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#differences-between-variables-and-constants

译：Differences Between Variables and Constants：变量与常量的区别
"""

# FUNCTIONS

[[exercises]]
name = "functions1"
path = "exercises/functions/functions1.rs"
mode = "compile"
hint = """
主函数中正试图调用一个名为 `call_me` 的函数，可这个函数并不存在。
它希望这个函数不接受任何参数，同时也不返回值。
听起来很像 `main` 函数，不是吗？"""

[[exercises]]
name = "functions2"
path = "exercises/functions/functions2.rs"
mode = "compile"
hint = """
 Rust 要求函数签名（signature）有类型标注，但是 `call_me` 函数缺少 `num` 的类型标注。"""

[[exercises]]
name = "functions3"
path = "exercises/functions/functions3.rs"
mode = "compile"
hint = """
此时, 函数 *声明（declaration）* 是没问题的，但函数调用出了问题"""

[[exercises]]
name = "functions4"
path = "exercises/functions/functions4.rs"
mode = "compile"
hint = """
错误信息指向第 15 行，说希望在`->`之后有一个类型。
那个地方标注了函数的返回类型——看看 `is_even` 函数的示例吧"""

[[exercises]]
name = "functions5"
path = "exercises/functions/functions5.rs"
mode = "compile"
hint = """
这是一个非常常见的错误，可以通过删除一个字符来解决。
发生的原因是 Rust 区分了表达式和语句：表达式根据其运算数（operand）返回一个值, 
而语句仅返回一个 `()` 类型，其行为好比 C/C++ 中的 `void` 。
我们希望 `square` 函数返回一个 `i32` 类型的值，但现在它返回的是 `()` 类型...
它们显然是不一样的。对此有两种解决方案。
1. 在 `num * num;` 前面加上 `return` 关键字
2. 移除 `;`，让它变成 `num * num`"""

# IF

[[exercises]]
name = "if1"
path = "exercises/if/if1.rs"
mode = "test"
hint = """
如果你愿意的话，也可以用一行来做这件事!
其他语言中的一些类似例子:
- 在 C(++) 中会是: `a > b ? a : b`
- 在 Python 中会是:  `a if a > b else b`
请记住在 Rust 中：
- `if` 的条件不需要用圆括号括起来
- `if`/`else` 的条件是表达式
- 每个条件后面都有一个 `{}` 块。"""

[[exercises]]
name = "if2"
path = "exercises/if/if2.rs"
mode = "test"
hint = """
对于第一个编译错误，在于 Rust 中的重要一点：
每个条件块（conditional block）都必须返回相同的类型。
为了通过测试，你需要几个条件用来判断不同的输入"""

# TEST 1

[[exercises]]
name = "quiz1"
path = "exercises/quiz1.rs"
mode = "test"
hint = "No hints this time ;)"

# MOVE SEMANTICS

[[exercises]]
name = "move_semantics1"
path = "exercises/move_semantics/move_semantics1.rs"
mode = "compile"
hint = """
在第 13 行有个 "cannot borrow immutable local variable `vec1` as mutable"* 错误，对吗？
修复错误的方法是添加一个关键词，并且添加的位置不在报错的第 13 行上。

译注：不能将不可变的局部变量 `vec1` 借用为可变变量"""

[[exercises]]
name = "move_semantics2"
path = "exercises/move_semantics/move_semantics2.rs"
mode = "compile"
hint = """
当我们在第 10 行调用 `fill_vec` 时，`vec0' 被 *移动（moved）* 到
函数 `fill_vec` 中，这意味着它会在 `fill_vec` 函数的末尾被丢弃，同时也
导致了我们不能在第 13 行再次使用 `vec0`（或在 `main` 中调用 `fill_vec` 后的任何地方）。
我们可以用几种方法来解决这个问题，都试一试吧！
1. 做一个 `vec0` 数据的拷贝，并将其传递给 `fill_vec` 。
2. 让 `fill_vec` 通过借用而不是获取所有权的方式获取参数，然后在函数中复制一份数据，以便返回
   一个具有所有权的 `Vec<i32>` 变量。
3. 让 `fill_vec` 借用可变参数（参数也需要可变），直接进行操作，然后不返回任何东西。接着你需要
   完全地去掉 `vec1`——但注意，这也将改变第一个 `println!` 打印出内容。"""

[[exercises]]
name = "move_semantics3"
path = "exercises/move_semantics/move_semantics3.rs"
mode = "compile"
hint = """
与之前不同：`fn fill_vec` 第一行的 `let mut vec = vec;` 现在已经不存在了。 
你可以在某个地方添加 `mut` 以使现有的不可变绑定变得可变，而非把不同的那一行加回去 :)"""

[[exercises]]
name = "move_semantics4"
path = "exercises/move_semantics/move_semantics4.rs"
mode = "compile"
hint = """
只要你觉得有确切的目标，就可以停止阅读 :) 或者试着做一个步骤，然后修复编译错误。
因此，目标有：
   - 去掉 main 中创建新 vector 的第一行
   - 所以 `vec0` 已不存在了，不能再把它传给 `fill_vec` 。
   - 现已不需要向 `fill_vec` 传递任何东西，所以它的（函数）签名应该反映出它不接受任何参数*。
   - 由于已不在 `main` 创建 vector ，所以需要在 `fill_vec` 中创建一个新的 vector，
     类似于 `main` 中的做法。
     
译注：练习中 fill_vec 的函数签名已经没有接受参数了，所以估计是在调用的地方"""

[[exercises]]
name = "move_semantics5"
path = "exercises/move_semantics/move_semantics5.rs"
mode = "compile"
hint = """
仔细推敲每个可变引用的使用范围。
在获取可变引用后是否能够立即更新引用（x）的值？ 
在本书的 'References and Borrowing' 部分了解更多关于 'Mutable References' 的信息。
https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#mutable-references.
"""

# PRIMITIVE TYPES

[[exercises]]
name = "primitive_types1"
path = "exercises/primitive_types/primitive_types1.rs"
mode = "compile"
hint = "这次没有提示 ;)"

[[exercises]]
name = "primitive_types2"
path = "exercises/primitive_types/primitive_types2.rs"
mode = "compile"
hint = "这次没有提示 ;)"

[[exercises]]
name = "primitive_types3"
path = "exercises/primitive_types/primitive_types3.rs"
mode = "compile"
hint = """
有一种简便的方法可以初始化具有一定大小的数组，而不需要你输入 100 个
元素（但如果你想的话，那当然可以！）。
例如，你可以这样做：
let array = ["Are we there yet?"; 10];

额外目标: 还有哪些东西可以在 `a.len()>=100` 时返回 true """

[[exercises]]
name = "primitive_types4"
path = "exercises/primitive_types/primitive_types4.rs"
mode = "test"
hint = """
看看这本书的：Understanding Ownership -> Slices -> Other Slices 章节吧：
https://doc.rust-lang.org/book/ch04-03-slices.html，
然后找出所需切片元素对应数组里的起始和截止下标。 

如果你好奇既然 `assert_eq!` 的第二个参数是引用，为什么第一个参数
没有使用 & 号用来表示引用，可以看看这本书的 Deref 强制转换部分：
https://doc.rust-lang.org/book/ch15-02-deref.html"""

[[exercises]]
name = "primitive_types5"
path = "exercises/primitive_types/primitive_types5.rs"
mode = "compile"
hint = """
看看这本书的 Data Types -> The Tuple Type 类型章节：
https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type
特别是关于解构的部分（这节中倒数第二个例子）。
你需要一个模式将 `name` 和 `age` 绑定到元组的适当部分。你能够做到的！！"""

[[exercises]]
name = "primitive_types6"
path = "exercises/primitive_types/primitive_types6.rs"
mode = "test"
hint = """
虽然你可以使用 `let` 对元组进行解构 ，但不妨试试对它进行索引，
正如这本书的 Data Types -> The Tuple Type 部分的最后一个例子表示的那样。
https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type
现在，你的工具箱里又多了一个工具！"""

# STRUCTS

[[exercises]]
name = "structs1"
path = "exercises/structs/structs1.rs"
mode = "test"
hint = """
Rust 不只有一种结构。实际上，所有的变体都是用来组合相关的数据。
首先是一般的（或经典的）结构，一块相关的数据被命名为一个字段集合。
元组结构基本上就是被命名的元组。
最后的单元结构没有任何字段，对泛型很有用。

在这个练习中，你需要完成并实现每一种结构。
更多关于结构的内容在这：https://doc.rust-lang.org/book/ch05-01-defining-structs.html"""

[[exercises]]
name = "structs2"
path = "exercises/structs/structs2.rs"
mode = "test"
hint = """
创建结构体的实例很简单，你只需要给它的字段分配一些值。
然而，在实例化结构时，还有些捷径。
看看这本书，来了解更多：https://doc.rust-lang.org/stable/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax"""

[[exercises]]
name = "structs3"
path = "exercises/structs/structs3.rs"
mode = "test"
hint = """
Package 实现的 new 方法在重量（weight_in_grams）不符合物理的情况下需要 panic :)，这在 Rust 需要怎么做？

对于 is_international：一个包裹具有国际性的条件有哪些？似乎与它所经过的地方有关吧？

对于 calculate_transport_fees：更大的通常更贵，我们的 Package 没有尺寸，但有些东西可能同样符合需要 :)

看看这本书，了解更多关于方法实现的信息：https://doc.rust-lang.org/book/ch05-03-method-syntax.html"""

# ENUMS

[[exercises]]
name = "enums1"
path = "exercises/enums/enums1.rs"
mode = "compile"
hint = """
提示：枚举类型还没有被定义。"""

[[exercises]]
name = "enums2"
path = "exercises/enums/enums2.rs"
mode = "compile"
hint = """
提示：你可以创建多种不同类型的枚举，如不包含值、匿名结构*、字符串、元组，等等。

译：匿名结构可能是不命名字段名的结构"""

[[exercises]]
name = "enums3"
path = "exercises/enums/enums3.rs"
mode = "test"
hint = "这次没有提示 ;)"

# MODULES

[[exercises]]
name = "modules1"
path = "exercises/modules/modules1.rs"
mode = "compile"
hint = """
Rust 中所有的东西默认都是私有的（private）——但是有个关键字可以标明某些东西为公开的（public）。
而编译器错误正指明某些东西需要能够被公开访问"""

[[exercises]]
name = "modules2"
path = "exercises/modules/modules2.rs"
mode = "compile"
hint = """
delicious_snacks 模块试图提供一个区别其内部结构的外部接口（对于 `fruits` 和 `veggies` 以及相关的常数）。
参照 main 中的使用情况完善 `use` 语句，并找到两个常量中缺少的某个关键字。"""

[[exercises]]
name = "modules3"
path = "exercises/modules/modules3.rs"
mode = "compile"
hint = """
UNIX_EPOCH 和 SystemTime 声明在 std::time 模块。通过 `use` 语句
将它们引入作用域。你可以使用嵌套路径（nested paths）
或全局操作符（glob operator）只需一行就能够引入它们。

译：嵌套是 {x,y,z} ，全局是 * """

# COLLECTIONS

[[exercises]]
name = "vec1"
path = "exercises/collections/vec1.rs"
mode = "test"
hint = """
Rust 有以下两种方式定义一个 vector 。
1. 一种方法是使用 `Vec::new()` 来创建一个新的 vector，然后
   使用 `push()` 方法往里面添加元素。
2. 第二种方法更简单，那就是使用 `vec![]` 宏，接着在宏的方括号内定义需要的元素。
阅读这本书的此章节：https://doc.rust-lang.org/stable/book/ch08-01-vectors.html
来了解更多。
"""

[[exercises]]
name = "vec2"
path = "exercises/collections/vec2.rs"
mode = "test"
hint = """
提示 1 ：`i` 是 Vec 中被迭代的每个元素，你可以乘以它吗？
提示 2 : 研究下编译错误给出的建议 ;)
"""

[[exercises]]
name = "hashmap1"
path = "exercises/collections/hashmap1.rs"
mode = "test"
hint = """
提示 1 ：看看函数的返回类型，推测出 `basket` 的类型。
提示 2 ：水果的数量应该不少于 5 个。并且需要确保篮子里至少有三种水果。
"""

[[exercises]]
name = "hashmap2"
path = "exercises/collections/hashmap2.rs"
mode = "test"
hint = """
使用 `HashMap` 中的 `entry()` 和 `or_insert()` 来完成目标。
了解更多：https://doc.rust-lang.org/stable/book/ch08-03-hash-maps.html#only-inserting-a-value-if-the-key-has-no-value 
"""

# STRINGS

[[exercises]]
name = "strings1"
path = "exercises/strings/strings1.rs"
mode = "compile"
hint = """
`current_favorite_color` 函数返回的是一个生命周期为 `'static` 的字符串切片。
我们知道这点是因为字符串直接存储在了代码中——它并不来自于文件、用户输入或
其他程序——所以只要程序还在运行，它就会一直存在。但它仍然是一个字符串切片。
有一种方法可以将字符串切片转换为 `String`，这在书的 Strings 章节有所介绍，还有一种
方法是使用 `From` 特征"""

[[exercises]]
name = "strings2"
path = "exercises/strings/strings2.rs"
mode = "compile"
hint = """
是的，只要把绑定在 `word` 上的值改为字符串切片而非 `String` 就可以很容易地解决这个问题，不是吗？？
有个方法是在第 9 行添一个字符，这将强制把 `String` 转为字符串切片。"""

# TEST 2

[[exercises]]
name = "quiz2"
path = "exercises/quiz2.rs"
mode = "compile"
hint = "No hints this time ;)"

# ERROR HANDLING

[[exercises]]
name = "errors1"
path = "exercises/error_handling/errors1.rs"
mode = "test"
hint = """
`Err` 是 `Result` 的成员之一，所以第二个测试的意思是 `generate_nametag_text` 
应该返回 `Result` 而不是 `Option` 。

要做到这些改变，你需要：
   - 修改函数签名的返回类型为 Result<String, String>，以便能返回 `Ok(String)` 和 `Err(String)`。
   - 更改函数返回值 `Some(stuff)` 为 `Ok(stuff)` 。
   - 更改函数返回值 `None` 为 `Err(error message)` 。
   - 将第一个测试预期的值从 `Some(stuff)` 改为 `Ok(stuff)`。"""

[[exercises]]
name = "errors2"
path = "exercises/error_handling/errors2.rs"
mode = "test"
hint = """
解决这个问题的一个方法是对 `item_quantity.parse::<i32>()` 使用 match 语句，
其中有两种情况需要被处理，分别是 `Ok(something)` 和 `Err(something)`。
不过这种方法在 Rust 中很常见，所以有一个 `?` 操作符，作用几乎符合你想让匹配语句做的事！
看一下 Error Handling 章节的这部分:
https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator
然后试一试！"""

[[exercises]]
name = "errors3"
path = "exercises/error_handling/errors3.rs"
mode = "compile"
hint = """
如果其它函数可以返回 `Result`，为什么 `main` 函数不能？"""

[[exercises]]
name = "errors4"
path = "exercises/error_handling/errors4.rs"
mode = "test"
hint = """
`PositiveNonzeroInteger::new` 将创建一个新的实例，并返回一个 `Ok` 。
它应该做一些检查，如果检查到失败，则返回 `Err` ，如果确定一切正常，则返回 `Ok` :)。"""

[[exercises]]
name = "errors5"
path = "exercises/error_handling/errors5.rs"
mode = "compile"
hint = """
提示：在 `main()` 中产生了两种 `Result` 类型，它们是通过 `?` 运算符返回的。
那么我们如何在 `main()` 中声明一个容纳这两者的返回类型？

额外提示：`?` 操作符的底层实现实际上是对错误值调用了 `From::from` ，将其转换为
了 `Box<dyn error::Error>` 类型。它是多态的——这意味着不同类型的错误可以从同一个函数返回，
因为它们都实现了`error::Error`特征，行为都是一致的。
请看这本书的这一部分：
https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator

这个练习使用了一些课程后期才会介绍到的概念，如 `Box` 指针和 `From` 特征。
现在详细了解它们并不重要，但如果你感兴趣，可以提前阅读。

阅读更多装箱错误（boxing errors）的内容：
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/boxing_errors.html

阅读更多关于使用 `?` 操作符和装箱错误的内容。
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html
"""

[[exercises]]
name = "errors6"
path = "exercises/error_handling/errors6.rs"
mode = "test"
hint = """
这个练习使用的是来自于 error 4 的 `PositiveNonzeroInteger` 完整版本。

在 TODO 要求你修改的那一行下面，有一个在 `Result` 上使用 `map_err()` 方法将
一种类型的错误转换为另一种类型的例子。尝试在 `parse()` 的 `Result` 上使用类似的东西。
你可能使用 `?` 操作符在函数中提前返回，或者使用 `match` 表达式，以及等等其它方法。

你可以在 `impl ParsePosNonzeroError` 内创建另一个方法来配合 `map_err()` 使用。

在 `std::result` 文档了解更多关于 `map_err()` 的信息：
https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"""

# Generics

[[exercises]]
name = "generics1"
path = "exercises/generics/generics1.rs"
mode = "compile"
hint = """
Rust 中的 Vector 通过泛型来创建任意类型的动态数组。
所以你要告诉编译器，我们要把什么类型的元素推入到这个数组里。"""

[[exercises]]
name = "generics2"
path = "exercises/generics/generics2.rs"
mode = "test"
hint = """
目前我们只包装了 'u32' 类型的值。
或许我们可以通过某种方式来修改对类型的显式引用？

如果你还没有头绪：https://doc.rust-lang.org/stable/book/ch10-01-syntax.html#in-method-definitions
"""

[[exercises]]
name = "generics3"
path = "exercises/generics/generics3.rs"
mode = "test"
hint = """
为了找到解决这个难题的最佳方法，你需要回想一下有关 trait 的知识，特别是 trait 的绑定语法——可能
还需要这个："use std::fmt::Display;"

这绝对比前两个练习更难！你需要使 ReportCard 结构通用，并拥有正确的属性，同时
你也需要稍微改变一下结构的实现……加油💪！
"""

# OPTIONS

[[exercises]]
name = "option1"
path = "exercises/option/option1.rs"
mode = "compile"
hint = """
提示 1：了解 Option 的一些方法：
is_some
is_none
unwrap

和：
模式匹配

提示 2：数组没有合适的默认值；在使用前需要添加这些值。
"""

[[exercises]]
name = "option2"
path = "exercises/option/option2.rs"
mode = "compile"
hint = """
查看：
https://doc.rust-lang.org/rust-by-example/flow_control/if_let.html
https://doc.rust-lang.org/rust-by-example/flow_control/while_let.html

记住，可以多次层叠地对 Options 使用 if let 或 while let 。
例如: Some(Some(variable)) = variable2
也可以参考下 Option::flatten
"""

[[exercises]]
name = "option3"
path = "exercises/option/option3.rs"
mode = "compile"
hint = """
编译器说 `match` 语句中发生了部分移动。
怎样避免这种情况？编译器也已给出了所需的修正。
按照编译器的建议进行修正后，请阅读：https://doc.rust-lang.org/std/keyword.ref.html"""

# TRAITS

[[exercises]]
name = "traits1"
path = "exercises/traits/traits1.rs"
mode = "test"
hint = """
下面的网站是关于 Rust 中 Traits 的讨论：
https://doc.rust-lang.org/book/ch10-02-traits.html
"""

[[exercises]]
name = "traits2"
path = "exercises/traits/traits2.rs"
mode = "test"
hint = """
注意 trait 是如何取得 'self' 的所有权，并返回一个 'Self' 的。
尝试修改传入的字符串 vector。 

Vector 已提供了在它尾部添加一个元素的方法。
参阅文档：https://doc.rust-lang.org/std/vec/struct.Vec.html"""

# TESTS

[[exercises]]
name = "tests1"
path = "exercises/tests/tests1.rs"
mode = "test"
hint = """
你甚至不需要写任何用于测试的代码——直接填入某个值然后运行，即使在现实中这样做没什么意义 :) 
`assert!` 是需要一个参数的宏。根据参数的值，`assert!` 可能什么也不会发生（这意味将通
过测试）或者 `assert!` 引发了 panic （测试失败）。所以试着去给 `assert!` 赋予不同的值，看
看哪些可以编译，哪些能够通过，哪些将造成失败 :)"""

[[exercises]]
name = "tests2"
path = "exercises/tests/tests2.rs"
mode = "test"
hint = """
和前面的练习一样，你无需编写任何代码就可以编译和运行这个测试。
`assert_eq!` 是一个接受两个参数并比较两者的宏。尝试给它两个相等、两个不同的
值和两个不同类型的值！也不妨试试调换下两个参数的位置"""

[[exercises]]
name = "tests3"
path = "exercises/tests/tests3.rs"
mode = "test"
hint = """
你可以在 `assert!` 接受参数的位置直接调用一个函数——所以你可以做一些类似于
`assert!(having_fun())` 的事情。如果你想检查得到的值是不是 false ，可以
用 `!` 来取反结果，例如 `assert!(!having_fun())`。"""

# TEST 3

[[exercises]]
name = "quiz3"
path = "exercises/quiz3.rs"
mode = "test"
hint = "No hints this time ;)"

# STANDARD LIBRARY TYPES

[[exercises]]
name = "box1"
path = "exercises/standard_library_types/box1.rs"
mode = "test"
hint = """
Step 1
The compiler's message should help: since we cannot store the value of the actual type
when working with recursive types, we need to store a reference (pointer) to its value.
We should, therefore, place our `List` inside a `Box`. More details in the book here:
https://doc.rust-lang.org/book/ch15-01-box.html#enabling-recursive-types-with-boxes

Step 2
Creating an empty list should be fairly straightforward (hint: peek at the assertions).
For a non-empty list keep in mind that we want to use our Cons "list builder".
Although the current list is one of integers (i32), feel free to change the definition
and try other types!
"""

[[exercises]]
name = "arc1"
path = "exercises/standard_library_types/arc1.rs"
mode = "compile"
hint = """
Make `shared_numbers` be an `Arc` from the numbers vector. Then, in order
to avoid creating a copy of `numbers`, you'll need to create `child_numbers`
inside the loop but still in the main thread.

`child_numbers` should be a clone of the Arc of the numbers instead of a
thread-local copy of the numbers.

This is a simple exercise if you understand the underlying concepts, but if this
is too much of a struggle, consider reading through all of Chapter 16 in the book:
https://doc.rust-lang.org/stable/book/ch16-00-concurrency.html
"""

[[exercises]]
name = "iterators1"
path = "exercises/standard_library_types/iterators1.rs"
mode = "compile"
hint = """
Step 1:
We need to apply something to the collection `my_fav_fruits` before we start to go through
it. What could that be? Take a look at the struct definition for a vector for inspiration:
https://doc.rust-lang.org/std/vec/struct.Vec.html.
Step 2 & step 2.1:
Very similar to the lines above and below. You've got this!
Step 3:
An iterator goes through all elements in a collection, but what if we've run out of
elements? What should we expect here? If you're stuck, take a look at
https://doc.rust-lang.org/std/iter/trait.Iterator.html for some ideas.
"""

[[exercises]]
name = "iterators2"
path = "exercises/standard_library_types/iterators2.rs"
mode = "test"
hint = """
Step 1
The variable `first` is a `char`. It needs to be capitalized and added to the
remaining characters in `c` in order to return the correct `String`.
The remaining characters in `c` can be viewed as a string slice using the
`as_str` method.
The documentation for `char` contains many useful methods.
https://doc.rust-lang.org/std/primitive.char.html

Step 2
Create an iterator from the slice. Transform the iterated values by applying
the `capitalize_first` function. Remember to collect the iterator.

Step 3.
This is surprising similar to the previous solution. Collect is very powerful
and very general. Rust just needs to know the desired type."""

[[exercises]]
name = "iterators3"
path = "exercises/standard_library_types/iterators3.rs"
mode = "test"
hint = """
The divide function needs to return the correct error when even division is not
possible.

The division_results variable needs to be collected into a collection type.

The result_with_list function needs to return a single Result where the success
case is a vector of integers and the failure case is a DivisionError.

The list_of_results function needs to return a vector of results.

See https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect for how 
the `FromIterator` trait is used in `collect()`."""

[[exercises]]
name = "iterators4"
path = "exercises/standard_library_types/iterators4.rs"
mode = "test"
hint = """
In an imperative language, you might write a for loop that updates
a mutable variable. Or, you might write code utilizing recursion
and a match clause. In Rust you can take another functional
approach, computing the factorial elegantly with ranges and iterators."""

[[exercises]]
name = "iterators5"
path = "exercises/standard_library_types/iterators5.rs"
mode = "test"
hint = """
The documentation for the std::iter::Iterator trait contains numerous methods
that would be helpful here.

Return 0 from count_collection_iterator to make the code compile in order to
test count_iterator.

The collection variable in count_collection_iterator is a slice of HashMaps. It
needs to be converted into an iterator in order to use the iterator methods.

The fold method can be useful in the count_collection_iterator function.

For a further challenge, consult the documentation for Iterator to find
a different method that could make your code more compact than using fold."""

# THREADS

[[exercises]]
name = "threads1"
path = "exercises/threads/threads1.rs"
mode = "compile"
hint = """
`Arc` is an Atomic Reference Counted pointer that allows safe, shared access
to **immutable** data. But we want to *change* the number of `jobs_completed`
so we'll need to also use another type that will only allow one thread to
mutate the data at a time. Take a look at this section of the book:
https://doc.rust-lang.org/book/ch16-03-shared-state.html#atomic-reference-counting-with-arct
and keep reading if you'd like more hints :)


Do you now have an `Arc` `Mutex` `JobStatus` at the beginning of main? Like:
`let status = Arc::new(Mutex::new(JobStatus { jobs_completed: 0 }));`
Similar to the code in the example in the book that happens after the text
that says "We can use Arc<T> to fix this.". If not, give that a try! If you
do and would like more hints, keep reading!!


Make sure neither of your threads are holding onto the lock of the mutex
while they are sleeping, since this will prevent the other thread from
being allowed to get the lock. Locks are automatically released when
they go out of scope.

Ok, so, real talk, this was actually tricky for *me* to do too. And
I could see a lot of different problems you might run into, so at this
point I'm not sure which one you've hit :)

Please open an issue if you're still running into a problem that
these hints are not helping you with, or if you've looked at the sample
answers and don't understand why they work and yours doesn't.

If you've learned from the sample solutions, I encourage you to come
back to this exercise and try it again in a few days to reinforce
what you've learned :)"""

# MACROS

[[exercises]]
name = "macros1"
path = "exercises/macros/macros1.rs"
mode = "compile"
hint = """
When you call a macro, you need to add something special compared to a
regular function call. If you're stuck, take a look at what's inside
`my_macro`."""

[[exercises]]
name = "macros2"
path = "exercises/macros/macros2.rs"
mode = "compile"
hint = """
Macros don't quite play by the same rules as the rest of Rust, in terms of
what's available where.

Unlike other things in Rust, the order of "where you define a macro" versus
"where you use it" actually matters."""

[[exercises]]
name = "macros3"
path = "exercises/macros/macros3.rs"
mode = "compile"
hint = """
In order to use a macro outside of its module, you need to do something
special to the module to lift the macro out into its parent.

The same trick also works on "extern crate" statements for crates that have
exported macros, if you've seen any of those around."""

[[exercises]]
name = "macros4"
path = "exercises/macros/macros4.rs"
mode = "compile"
hint = """
You only need to add a single character to make this compile.
The way macros are written, it wants to see something between each
"macro arm", so it can separate them."""

# TEST 4

[[exercises]]
name = "quiz4"
path = "exercises/quiz4.rs"
mode = "test"
hint = "No hints this time ;)"

#  CLIPPY

[[exercises]]
name = "clippy1"
path = "exercises/clippy/clippy1.rs"
mode = "clippy"
hint = """
Not every floating point value can be represented exactly in binary values in
memory. Take a look at the description of 
https://doc.rust-lang.org/stable/std/primitive.f32.html
When using the binary compare operators with floating points you won't compare
the floating point values but the binary representation in memory. This is 
usually not what you would like to do. 
See the suggestions of the clippy warning in compile output and use the
machine epsilon value...
https://doc.rust-lang.org/stable/std/primitive.f32.html#associatedconstant.EPSILON"""

[[exercises]]
name = "clippy2"
path = "exercises/clippy/clippy2.rs"
mode = "clippy"
hint = """
`for` loops over Option values are more clearly expressed as an `if let`"""

# TYPE CONVERSIONS

[[exercises]]
name = "using_as"
path = "exercises/conversions/using_as.rs"
mode = "test"
hint = """
Use the `as` operator to cast one of the operands in the last line of the
`average` function into the expected return type."""

[[exercises]]
name = "from_into"
path = "exercises/conversions/from_into.rs"
mode = "test"
hint = """
Follow the steps provided right before the `From` implementation"""

[[exercises]]
name = "from_str"
path = "exercises/conversions/from_str.rs"
mode = "test"
hint = """
The implementation of FromStr should return an Ok with a Person object,
or an Err with an error if the string is not valid.

This is almost like the `from_into` exercise, but returning errors instead
of falling back to a default value.

Hint: Look at the test cases to see which error variants to return.

Another hint: You can use the `map_err` method of `Result` with a function
or a closure to wrap the error from `parse::<usize>`.

Yet another hint: If you would like to propagate errors by using the `?`
operator in your solution, you might want to look at
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html
"""

[[exercises]]
name = "try_from_into"
path = "exercises/conversions/try_from_into.rs"
mode = "test"
hint = """
Follow the steps provided right before the `TryFrom` implementation.
You can also use the example at https://doc.rust-lang.org/std/convert/trait.TryFrom.html

Hint: Is there an implementation of `TryFrom` in the standard library that
can both do the required integer conversion and check the range of the input?

Another hint: Look at the test cases to see which error variants to return.

Yet another hint: You can use the `map_err` or `or` methods of `Result` to
convert errors.

Yet another hint: If you would like to propagate errors by using the `?`
operator in your solution, you might want to look at
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html

Challenge: Can you make the `TryFrom` implementations generic over many integer types?"""

[[exercises]]
name = "as_ref_mut"
path = "exercises/conversions/as_ref_mut.rs"
mode = "test"
hint = """
Add AsRef<str> as a trait bound to the functions."""

# ADVANCED ERRORS

[[exercises]]
name = "advanced_errs1"
path = "exercises/advanced_errors/advanced_errs1.rs"
mode = "test"
hint = """
This exercise uses an updated version of the code in errors6. The parsing
code is now in an implementation of the `FromStr` trait. Note that the
parsing code uses `?` directly, without any calls to `map_err()`. There is
one partial implementation of the `From` trait example that you should
complete.

Details: The `?` operator calls `From::from()` on the error type to convert
it to the error type of the return type of the surrounding function.

Hint: You will need to write another implementation of `From` that has a
different input type.
"""

[[exercises]]
name = "advanced_errs2"
path = "exercises/advanced_errors/advanced_errs2.rs"
mode = "test"
hint = """
This exercise demonstrates a few traits that are useful for custom error
types to implement. These traits make it easier for other code to consume
the custom error type.

Follow the steps in the comment near the top of the file. You will have to
supply a missing trait implementation, and complete a few incomplete ones.

You may find these pages to be helpful references:
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/define_error_type.html
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/boxing_errors.html
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/wrap_error.html

Hint: What trait must our error type have for `main()` to return the return
type that it returns?

Another hint: It's not necessary to implement any methods inside the missing
trait. (Some methods have default implementations that are supplied by the
trait.)

Another hint: Consult the tests to determine which error variants (and which
error message text) to produce for certain error conditions.

Challenge: There is one test that is marked `#[ignore]`. Can you supply the
missing code that will make it pass? You may want to consult the standard
library documentation for a certain trait for more hints.
"""



================================================
FILE: assets/rustlings-zh/install.ps1
================================================
#!/usr/bin/env pwsh

#Requires -Version 5
param($path = "$pwd/rustlings")

Write-Host "Let's get you set up with Rustlings!"

Write-Host "Checking requirements..."
if (Get-Command git -ErrorAction SilentlyContinue) {
    Write-Host "SUCCESS: Git is installed"
} else {
    Write-Host "WARNING: Git does not seem to be installed."
    Write-Host "Please download Git using your package manager or over https://git-scm.com/!"
    exit 1
}

if (Get-Command rustc -ErrorAction SilentlyContinue) {
    Write-Host "SUCCESS:  Rust is installed"
} else {
    Write-Host "WARNING: Rust does not seem to be installed."
    Write-Host "Please download Rust using https://rustup.rs!"
    exit 1
}

if (Get-Command cargo -ErrorAction SilentlyContinue) {
    Write-Host "SUCCESS: Cargo is installed"
} else {
    Write-Host "WARNING: Cargo does not seem to be installed."
    Write-Host "Please download Rust and Cargo using https://rustup.rs!"
    exit 1
}

# Function that compares two versions strings v1 and v2 given in arguments (e.g 1.31 and 1.33.0).
# Returns 1 if v1 > v2, 0 if v1 == v2, 2 if v1 < v2.
function vercomp($v1, $v2) {
    if ($v1 -eq $v2) {
       return 0
    }

    $v1 = $v1.Replace(".", "0")
    $v2 = $v2.Replace(".", "0")
    if ($v1.Length -gt $v2.Length) {
        $v2 = $v2.PadRight($v1.Length, "0")
    } else {
        $v1 = $v1.PadRight($v2.Length, "0")
    }

    if ($v1 -gt $v2) {
        return 1
    } else {
        return 2
    }
}

$rustVersion = $(rustc --version).Split(" ")[1]
$minRustVersion = "1.39"
if ((vercomp $rustVersion $minRustVersion) -eq 2) {
    Write-Host "WARNING: Rust version is too old: $rustVersion - needs at least $minRustVersion"
    Write-Host "Please update Rust with 'rustup update'"
    exit 1
} else {
    Write-Host "SUCCESS: Rust is up to date"
}

Write-Host "Cloning Rustlings at $path"
git clone -q https://github.com/rust-lang/rustlings $path
if (!($LASTEXITCODE -eq 0)) {
    exit 1
}

# UseBasicParsing is deprecated, pwsh 6 or above will automatically use it,
# but anyone running pwsh 5 will have to pass the argument.
$version = Invoke-WebRequest -UseBasicParsing https://api.github.com/repos/rust-lang/rustlings/releases/latest `
    | ConvertFrom-Json | Select-Object -ExpandProperty tag_name

Write-Host "Checking out version $version..."
Set-Location $path
git checkout -q tags/$version

Write-Host "Installing the 'rustlings' executable..."
cargo install --force --path .
if (!(Get-Command rustlings -ErrorAction SilentlyContinue)) {
    Write-Host "WARNING: Please check that you have '~/.cargo/bin' in your PATH environment variable!"
}

# Checking whether Clippy is installed.
# Due to a bug in Cargo, this must be done with Rustup: https://github.com/rust-lang/rustup/issues/1514
$clippy = (rustup component list | Select-String "clippy" | Select-String "installed") | Out-String
if (!$clippy) {
    Write-Host "Installing the 'cargo-clippy' executable..."
    rustup component add clippy
}

Write-Host "All done! Run 'rustlings' to get started."



================================================
FILE: assets/rustlings-zh/install.sh
================================================
#!/usr/bin/env bash

echo "Let's get you set up with Rustlings!"

echo "Checking requirements..."
if [ -x "$(command -v git)" ]
then
    echo "SUCCESS: Git is installed"
else
    echo "ERROR: Git does not seem to be installed."
    echo "Please download Git using your package manager or over https://git-scm.com/!"
    exit 1
fi

if [ -x "$(command -v rustc)" ]
then
    echo "SUCCESS: Rust is installed"
else
    echo "ERROR: Rust does not seem to be installed."
    echo "Please download Rust using https://rustup.rs!"
    exit 1
fi

if [ -x "$(command -v cargo)" ]
then
    echo "SUCCESS: Cargo is installed"
else
    echo "ERROR: Cargo does not seem to be installed."
    echo "Please download Rust and Cargo using https://rustup.rs!"
    exit 1
fi

# Look up python installations, starting with 3 with a fallback of 2
if [ -x "$(command -v python3)" ]
then
    PY="$(command -v python3)"
elif [ -x "$(command -v python)" ]
then
    PY="$(command -v python)"
elif [ -x "$(command -v python2)" ]
then
    PY="$(command -v python2)"
else
    echo "ERROR: No working python installation was found"
    echo "Please install python and add it to the PATH variable"
    exit 1
fi

# Function that compares two versions strings v1 and v2 given in arguments (e.g 1.31 and 1.33.0).
# Returns 1 if v1 > v2, 0 if v1 == v2, 2 if v1 < v2.
function vercomp() {
    if [[ $1 == $2 ]]
    then
        return 0
    fi
    v1=( ${1//./ } )
    v2=( ${2//./ } )
    len1=${#v1[@]}
    len2=${#v2[@]}
    max_len=$len1
    if [[ $max_len -lt $len2 ]]
    then
        max_len=$len2
    fi
    for i in `seq 0 $max_len`
    do
        # Fill empty fields with zeros in v1
        if [ -z "${v1[$i]}" ]
        then
            v1[$i]=0
        fi
        # And in v2
        if [ -z "${v2[$i]}" ]
        then
            v2[$i]=0
        fi
        if [ ${v1[$i]} -gt ${v2[$i]} ]
        then
            return 1
        fi
        if [ ${v1[$i]} -lt ${v2[$i]} ]
        then
            return 2
        fi
    done
    return 0
}

RustVersion=$(rustc --version | cut -d " " -f 2)
MinRustVersion=1.39
vercomp $RustVersion $MinRustVersion
if [ $? -eq 2 ]
then
    echo "ERROR: Rust version is too old: $RustVersion - needs at least $MinRustVersion"
    echo "Please update Rust with 'rustup update'"
    exit 1
else
    echo "SUCCESS: Rust is up to date"
fi

Path=${1:-rustlings/}
echo "Cloning Rustlings at $Path..."
git clone -q https://github.com/rust-lang/rustlings $Path

cd $Path

Version=$(curl -s https://api.github.com/repos/rust-lang/rustlings/releases/latest | ${PY} -c "import json,sys;obj=json.load(sys.stdin);print(obj['tag_name']);")
CargoBin="${CARGO_HOME:-$HOME/.cargo}/bin"

if [[ -z ${Version} ]]
then
    echo "The latest tag version could not be fetched remotely."
    echo "Using the local git repository..."
    Version=$(ls -tr .git/refs/tags/ | tail -1)
    if [[ -z ${Version}  ]]
    then
        echo "No valid tag version found"
        echo "Rustlings will be installed using the main branch"
        Version="main"
    else
        Version="tags/${Version}"
    fi
else
    Version="tags/${Version}"
fi

echo "Checking out version $Version..."
git checkout -q ${Version}

echo "Installing the 'rustlings' executable..."
cargo install --force --path .

if ! [ -x "$(command -v rustlings)" ]
then
    echo "WARNING: Please check that you have '$CargoBin' in your PATH environment variable!"
fi

# Checking whether Clippy is installed.
# Due to a bug in Cargo, this must be done with Rustup: https://github.com/rust-lang/rustup/issues/1514
Clippy=$(rustup component list | grep "clippy" | grep "installed")
if [ -z "$Clippy" ]
then
    echo "Installing the 'cargo-clippy' executable..."
    rustup component add clippy
fi

echo "All done! Run 'rustlings' to get started."



================================================
FILE: assets/rustlings-zh/LICENSE
================================================
The MIT License (MIT)

Copyright (c) 2016 Carol (Nichols || Goulding)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.




================================================
FILE: assets/rustlings-zh/.all-contributorsrc
================================================
{
  "files": [
    "README.md"
  ],
  "imageSize": 100,
  "commit": false,
  "contributors": [
    {
      "login": "carols10cents",
      "name": "Carol (Nichols || Goulding)",
      "avatar_url": "https://avatars2.githubusercontent.com/u/193874?v=4",
      "profile": "http://carol-nichols.com",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "QuietMisdreavus",
      "name": "QuietMisdreavus",
      "avatar_url": "https://avatars2.githubusercontent.com/u/5217170?v=4",
      "profile": "https://twitter.com/QuietMisdreavus",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "robertlugg",
      "name": "Robert M Lugg",
      "avatar_url": "https://avatars0.githubusercontent.com/u/6054540?v=4",
      "profile": "https://github.com/robertlugg",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "hynek",
      "name": "Hynek Schlawack",
      "avatar_url": "https://avatars3.githubusercontent.com/u/41240?v=4",
      "profile": "https://hynek.me/about/",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "spacekookie",
      "name": "Katharina Fey",
      "avatar_url": "https://avatars0.githubusercontent.com/u/7669898?v=4",
      "profile": "https://spacekookie.de",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "lukabavdaz",
      "name": "lukabavdaz",
      "avatar_url": "https://avatars0.githubusercontent.com/u/9624558?v=4",
      "profile": "https://github.com/lukabavdaz",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "evestera",
      "name": "Erik Vesteraas",
      "avatar_url": "https://avatars2.githubusercontent.com/u/4187449?v=4",
      "profile": "http://vestera.as",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "Delet0r",
      "name": "delet0r",
      "avatar_url": "https://avatars1.githubusercontent.com/u/23195618?v=4",
      "profile": "https://github.com/Delet0r",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "shaunbennett",
      "name": "Shaun Bennett",
      "avatar_url": "https://avatars1.githubusercontent.com/u/10522375?v=4",
      "profile": "http://phinary.ca",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "abagshaw",
      "name": "Andrew Bagshaw",
      "avatar_url": "https://avatars2.githubusercontent.com/u/8594541?v=4",
      "profile": "https://github.com/abagshaw",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "kisom",
      "name": "Kyle Isom",
      "avatar_url": "https://avatars2.githubusercontent.com/u/175578?v=4",
      "profile": "https://ai6ua.net/",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "ColinPitrat",
      "name": "Colin Pitrat",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1541863?v=4",
      "profile": "https://github.com/ColinPitrat",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "zacanger",
      "name": "Zac Anger",
      "avatar_url": "https://avatars3.githubusercontent.com/u/12520493?v=4",
      "profile": "https://zacanger.com",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "mgeier",
      "name": "Matthias Geier",
      "avatar_url": "https://avatars1.githubusercontent.com/u/705404?v=4",
      "profile": "https://github.com/mgeier",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "cjpearce",
      "name": "Chris Pearce",
      "avatar_url": "https://avatars1.githubusercontent.com/u/3453268?v=4",
      "profile": "https://github.com/cjpearce",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "yvan-sraka",
      "name": "Yvan Sraka",
      "avatar_url": "https://avatars2.githubusercontent.com/u/705213?v=4",
      "profile": "https://yvan-sraka.github.io",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "dendi239",
      "name": "Denys Smirnov",
      "avatar_url": "https://avatars3.githubusercontent.com/u/16478650?v=4",
      "profile": "https://github.com/dendi239",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "eddyp",
      "name": "eddyp",
      "avatar_url": "https://avatars2.githubusercontent.com/u/123772?v=4",
      "profile": "https://github.com/eddyp",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "briankung",
      "name": "Brian Kung",
      "avatar_url": "https://avatars1.githubusercontent.com/u/2836167?v=4",
      "profile": "http://about.me/BrianKung",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "miller-time",
      "name": "Russell",
      "avatar_url": "https://avatars3.githubusercontent.com/u/281039?v=4",
      "profile": "https://rcousineau.gitlab.io",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "danwilhelm",
      "name": "Dan Wilhelm",
      "avatar_url": "https://avatars3.githubusercontent.com/u/6137185?v=4",
      "profile": "http://danwilhelm.com",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "Jesse-Cameron",
      "name": "Jesse",
      "avatar_url": "https://avatars3.githubusercontent.com/u/3723654?v=4",
      "profile": "https://github.com/Jesse-Cameron",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "MrFroop",
      "name": "Fredrik Jambrén",
      "avatar_url": "https://avatars3.githubusercontent.com/u/196700?v=4",
      "profile": "https://github.com/MrFroop",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "petemcfarlane",
      "name": "Pete McFarlane",
      "avatar_url": "https://avatars3.githubusercontent.com/u/3472717?v=4",
      "profile": "https://github.com/petemcfarlane",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "nkanderson",
      "name": "nkanderson",
      "avatar_url": "https://avatars0.githubusercontent.com/u/4128825?v=4",
      "profile": "https://github.com/nkanderson",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "ajaxm",
      "name": "Ajax M",
      "avatar_url": "https://avatars0.githubusercontent.com/u/13360138?v=4",
      "profile": "https://github.com/ajaxm",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "Dylnuge",
      "name": "Dylan Nugent",
      "avatar_url": "https://avatars2.githubusercontent.com/u/118624?v=4",
      "profile": "https://dylnuge.com",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "vyaslav",
      "name": "vyaslav",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1385427?v=4",
      "profile": "https://github.com/vyaslav",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "gdoenlen",
      "name": "George",
      "avatar_url": "https://avatars1.githubusercontent.com/u/17297466?v=4",
      "profile": "https://join.sfxd.org",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "nyxtom",
      "name": "Thomas Holloway",
      "avatar_url": "https://avatars2.githubusercontent.com/u/222763?v=4",
      "profile": "https://github.com/nyxtom",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "workingjubilee",
      "name": "Jubilee",
      "avatar_url": "https://avatars1.githubusercontent.com/u/46493976?v=4",
      "profile": "https://github.com/workingjubilee",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "WofWca",
      "name": "WofWca",
      "avatar_url": "https://avatars1.githubusercontent.com/u/39462442?v=4",
      "profile": "https://github.com/WofWca",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "jrvidal",
      "name": "Roberto Vidal",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1636604?v=4",
      "profile": "https://github.com/jrvidal",
      "contributions": [
        "code",
        "doc",
        "ideas",
        "maintenance"
      ]
    },
    {
      "login": "jensim",
      "name": "Jens",
      "avatar_url": "https://avatars0.githubusercontent.com/u/3663856?v=4",
      "profile": "https://github.com/jensim",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "rahatarmanahmed",
      "name": "Rahat Ahmed",
      "avatar_url": "https://avatars3.githubusercontent.com/u/3174006?v=4",
      "profile": "http://rahatah.me/d",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "AbdouSeck",
      "name": "Abdou Seck",
      "avatar_url": "https://avatars2.githubusercontent.com/u/6490055?v=4",
      "profile": "https://github.com/AbdouSeck",
      "contributions": [
        "code",
        "content",
        "review"
      ]
    },
    {
      "login": "codehearts",
      "name": "Katie",
      "avatar_url": "https://avatars0.githubusercontent.com/u/2885412?v=4",
      "profile": "https://codehearts.com",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "Socratides",
      "name": "Socrates",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27732983?v=4",
      "profile": "https://github.com/Socratides",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "gnodarse",
      "name": "gnodarse",
      "avatar_url": "https://avatars3.githubusercontent.com/u/46761795?v=4",
      "profile": "https://github.com/gnodarse",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "harrisonmetz",
      "name": "Harrison Metzger",
      "avatar_url": "https://avatars1.githubusercontent.com/u/7883408?v=4",
      "profile": "https://github.com/harrisonmetz",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "TorbenJ",
      "name": "Torben Jonas",
      "avatar_url": "https://avatars2.githubusercontent.com/u/9077102?v=4",
      "profile": "https://github.com/TorbenJ",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "pbx",
      "name": "Paul Bissex",
      "avatar_url": "https://avatars0.githubusercontent.com/u/641?v=4",
      "profile": "http://paulbissex.com/",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "sjmann",
      "name": "Steven Mann",
      "avatar_url": "https://avatars0.githubusercontent.com/u/6589896?v=4",
      "profile": "https://github.com/sjmann",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "Tarnadas",
      "name": "Mario Reder",
      "avatar_url": "https://avatars2.githubusercontent.com/u/5855071?v=4",
      "profile": "https://smmdb.net/",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "sl4m",
      "name": "skim",
      "avatar_url": "https://avatars0.githubusercontent.com/u/47347?v=4",
      "profile": "https://keybase.io/skim",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "sanjaykdragon",
      "name": "Sanjay K",
      "avatar_url": "https://avatars1.githubusercontent.com/u/10261698?v=4",
      "profile": "https://github.com/sanjaykdragon",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "crodjer",
      "name": "Rohan Jain",
      "avatar_url": "https://avatars1.githubusercontent.com/u/343499?v=4",
      "profile": "http://www.rohanjain.in",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "saidaspen",
      "name": "Said Aspen",
      "avatar_url": "https://avatars1.githubusercontent.com/u/7727687?v=4",
      "profile": "https://www.saidaspen.se",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "uce",
      "name": "Ufuk Celebi",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1756620?v=4",
      "profile": "https://github.com/uce",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "lebedevsergey",
      "name": "lebedevsergey",
      "avatar_url": "https://avatars2.githubusercontent.com/u/7325764?v=4",
      "profile": "https://github.com/lebedevsergey",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "avrong",
      "name": "Aleksei Trifonov",
      "avatar_url": "https://avatars2.githubusercontent.com/u/6342851?v=4",
      "profile": "https://github.com/avrong",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "Darrenmeehan",
      "name": "Darren Meehan",
      "avatar_url": "https://avatars2.githubusercontent.com/u/411136?v=4",
      "profile": "https://drn.ie",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "jihchi",
      "name": "Jihchi Lee",
      "avatar_url": "https://avatars1.githubusercontent.com/u/87983?v=4",
      "profile": "https://github.com/jihchi",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "bertonha",
      "name": "Christofer Bertonha",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1225902?v=4",
      "profile": "https://github.com/bertonha",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "apatniv",
      "name": "Vivek Bharath Akupatni",
      "avatar_url": "https://avatars2.githubusercontent.com/u/22565917?v=4",
      "profile": "https://github.com/apatniv",
      "contributions": [
        "code",
        "test"
      ]
    },
    {
      "login": "DiD92",
      "name": "Dídac Sementé Fernández",
      "avatar_url": "https://avatars3.githubusercontent.com/u/6002416?v=4",
      "profile": "https://github.com/DiD92",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "wrobstory",
      "name": "Rob Story",
      "avatar_url": "https://avatars3.githubusercontent.com/u/2601457?v=4",
      "profile": "https://github.com/wrobstory",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "siobhanjacobson",
      "name": "Siobhan Jacobson",
      "avatar_url": "https://avatars2.githubusercontent.com/u/28983835?v=4",
      "profile": "https://github.com/siobhanjacobson",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "EvanCarroll",
      "name": "Evan Carroll",
      "avatar_url": "https://avatars2.githubusercontent.com/u/19922?v=4",
      "profile": "https://www.linkedin.com/in/evancarroll/",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "jmahmood",
      "name": "Jawaad Mahmood",
      "avatar_url": "https://avatars3.githubusercontent.com/u/95606?v=4",
      "profile": "http://www.jawaadmahmood.com",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "GaurangTandon",
      "name": "Gaurang Tandon",
      "avatar_url": "https://avatars1.githubusercontent.com/u/6308683?v=4",
      "profile": "https://github.com/GaurangTandon",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "dev-cyprium",
      "name": "Stefan Kupresak",
      "avatar_url": "https://avatars1.githubusercontent.com/u/6002628?v=4",
      "profile": "https://github.com/dev-cyprium",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "greg-el",
      "name": "Greg Leonard",
      "avatar_url": "https://avatars3.githubusercontent.com/u/45019882?v=4",
      "profile": "https://github.com/greg-el",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "ryanpcmcquen",
      "name": "Ryan McQuen",
      "avatar_url": "https://avatars3.githubusercontent.com/u/772937?v=4",
      "profile": "https://ryanpcmcquen.org",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "AnnikaCodes",
      "name": "Annika",
      "avatar_url": "https://avatars3.githubusercontent.com/u/56906084?v=4",
      "profile": "https://github.com/AnnikaCodes",
      "contributions": [
        "review"
      ]
    },
    {
      "login": "darnuria",
      "name": "Axel Viala",
      "avatar_url": "https://avatars1.githubusercontent.com/u/2827553?v=4",
      "profile": "https://darnuria.eu",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "sazid",
      "name": "Mohammed Sazid Al Rashid",
      "avatar_url": "https://avatars1.githubusercontent.com/u/2370167?v=4",
      "profile": "https://sazid.github.io",
      "contributions": [
        "content",
        "code"
      ]
    },
    {
      "login": "seeplusplus",
      "name": "Caleb Webber",
      "avatar_url": "https://avatars1.githubusercontent.com/u/17479099?v=4",
      "profile": "https://codingthemsoftly.com",
      "contributions": [
        "maintenance"
      ]
    },
    {
      "login": "pcn",
      "name": "Peter N",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1056756?v=4",
      "profile": "https://github.com/pcn",
      "contributions": [
        "maintenance"
      ]
    },
    {
      "login": "seancad",
      "name": "seancad",
      "avatar_url": "https://avatars1.githubusercontent.com/u/47405611?v=4",
      "profile": "https://github.com/seancad",
      "contributions": [
        "maintenance"
      ]
    },
    {
      "login": "wsh",
      "name": "Will Hayworth",
      "avatar_url": "https://avatars3.githubusercontent.com/u/181174?v=4",
      "profile": "http://willhayworth.com",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "chrizel",
      "name": "Christian Zeller",
      "avatar_url": "https://avatars3.githubusercontent.com/u/20802?v=4",
      "profile": "https://github.com/chrizel",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "jfchevrette",
      "name": "Jean-Francois Chevrette",
      "avatar_url": "https://avatars.githubusercontent.com/u/3001?v=4",
      "profile": "https://github.com/jfchevrette",
      "contributions": [
        "content",
        "code"
      ]
    },
    {
      "login": "jbaber",
      "name": "John Baber-Lucero",
      "avatar_url": "https://avatars.githubusercontent.com/u/1908117?v=4",
      "profile": "https://github.com/jbaber",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "tal-zvon",
      "name": "Tal",
      "avatar_url": "https://avatars.githubusercontent.com/u/3195851?v=4",
      "profile": "https://github.com/tal-zvon",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "apogeeoak",
      "name": "apogeeoak",
      "avatar_url": "https://avatars.githubusercontent.com/u/59737221?v=4",
      "profile": "https://github.com/apogeeoak",
      "contributions": [
        "content",
        "code"
      ]
    },
    {
      "login": "Crell",
      "name": "Larry Garfield",
      "avatar_url": "https://avatars.githubusercontent.com/u/254863?v=4",
      "profile": "http://www.garfieldtech.com/",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "circumspect",
      "name": "circumspect",
      "avatar_url": "https://avatars.githubusercontent.com/u/40770208?v=4",
      "profile": "https://github.com/circumspect",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "cjwyett",
      "name": "Cyrus Wyett",
      "avatar_url": "https://avatars.githubusercontent.com/u/34195737?v=4",
      "profile": "https://github.com/cjwyett",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "cadolphs",
      "name": "cadolphs",
      "avatar_url": "https://avatars.githubusercontent.com/u/13894820?v=4",
      "profile": "https://github.com/cadolphs",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "hpwxf",
      "name": "Pascal H.",
      "avatar_url": "https://avatars.githubusercontent.com/u/26146722?v=4",
      "profile": "https://www.haveneer.com",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "chapeupreto",
      "name": "Rod Elias",
      "avatar_url": "https://avatars.githubusercontent.com/u/834048?v=4",
      "profile": "https://twitter.com/chapeupreto",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "blerchy",
      "name": "Matt Lebl",
      "avatar_url": "https://avatars.githubusercontent.com/u/2555355?v=4",
      "profile": "https://github.com/blerchy",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "flakolefluk",
      "name": "Ignacio Le Fluk",
      "avatar_url": "https://avatars.githubusercontent.com/u/11986564?v=4",
      "profile": "http://flakolefluk.dev",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "tlyu",
      "name": "Taylor Yu",
      "avatar_url": "https://avatars.githubusercontent.com/u/431873?v=4",
      "profile": "https://github.com/tlyu",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "Zerotask",
      "name": "Patrick Hintermayer",
      "avatar_url": "https://avatars.githubusercontent.com/u/20150243?v=4",
      "profile": "https://zerotask.github.io",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "arthas168",
      "name": "Pete Pavlovski",
      "avatar_url": "https://avatars.githubusercontent.com/u/32264020?v=4",
      "profile": "https://petkopavlovski.com/",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "k12ish",
      "name": "k12ish",
      "avatar_url": "https://avatars.githubusercontent.com/u/45272873?v=4",
      "profile": "https://github.com/k12ish",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "hongshaoyang",
      "name": "Shao Yang Hong",
      "avatar_url": "https://avatars.githubusercontent.com/u/19281800?v=4",
      "profile": "https://github.com/hongshaoyang",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "bmacer",
      "name": "Brandon Macer",
      "avatar_url": "https://avatars.githubusercontent.com/u/13931806?v=4",
      "profile": "https://github.com/bmacer",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "stoiandan",
      "name": "Stoian Dan",
      "avatar_url": "https://avatars.githubusercontent.com/u/10388612?v=4",
      "profile": "https://github.com/stoiandan",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "PiDelport",
      "name": "Pi Delport",
      "avatar_url": "https://avatars.githubusercontent.com/u/630271?v=4",
      "profile": "https://about.me/pjdelport",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "sateeshkumarb",
      "name": "Sateesh ",
      "avatar_url": "https://avatars.githubusercontent.com/u/429263?v=4",
      "profile": "https://github.com/sateeshkumarb",
      "contributions": [
        "code",
        "content"
      ]
    },
    {
      "login": "kayuapi",
      "name": "ZC",
      "avatar_url": "https://avatars.githubusercontent.com/u/10304328?v=4",
      "profile": "https://github.com/kayuapi",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "hyperparabolic",
      "name": "hyperparabolic",
      "avatar_url": "https://avatars.githubusercontent.com/u/12348474?v=4",
      "profile": "https://github.com/hyperparabolic",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "kolbma",
      "name": "arlecchino",
      "avatar_url": "https://avatars.githubusercontent.com/u/5228369?v=4",
      "profile": "https://www.net4visions.at",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "jazzplato",
      "name": "Richthofen",
      "avatar_url": "https://avatars.githubusercontent.com/u/7576730?v=4",
      "profile": "https://richthofen.io/",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "cseltol",
      "name": "Ivan Nerazumov",
      "avatar_url": "https://avatars.githubusercontent.com/u/64264529?v=4",
      "profile": "https://github.com/cseltol",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "lauralindzey",
      "name": "lauralindzey",
      "avatar_url": "https://avatars.githubusercontent.com/u/65185744?v=4",
      "profile": "https://github.com/lauralindzey",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "sinharaksh1t",
      "name": "Rakshit Sinha",
      "avatar_url": "https://avatars.githubusercontent.com/u/28585848?v=4",
      "profile": "https://github.com/sinharaksh1t",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "dbednar230",
      "name": "Damian",
      "avatar_url": "https://avatars.githubusercontent.com/u/54457902?v=4",
      "profile": "https://github.com/dbednar230",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "benarmstead",
      "name": "Ben Armstead",
      "avatar_url": "https://avatars.githubusercontent.com/u/70973680?v=4",
      "profile": "https://benarmstead.co.uk",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "anuk909",
      "name": "anuk909",
      "avatar_url": "https://avatars.githubusercontent.com/u/34924662?v=4",
      "profile": "https://github.com/anuk909",
      "contributions": [
        "content",
        "code"
      ]
    },
    {
      "login": "granddaifuku",
      "name": "granddaifuku",
      "avatar_url": "https://avatars.githubusercontent.com/u/49578068?v=4",
      "profile": "https://granddaifuku.com/",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "Weilet",
      "name": "Weilet",
      "avatar_url": "https://avatars.githubusercontent.com/u/32561597?v=4",
      "profile": "https://weilet.me",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "Millione",
      "name": "LIU JIE",
      "avatar_url": "https://avatars.githubusercontent.com/u/38575932?v=4",
      "profile": "https://github.com/Millione",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "abusch",
      "name": "Antoine Büsch",
      "avatar_url": "https://avatars.githubusercontent.com/u/506344?v=4",
      "profile": "https://github.com/abusch",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "frogtd",
      "name": "frogtd",
      "avatar_url": "https://avatars.githubusercontent.com/u/31412003?v=4",
      "profile": "https://frogtd.com/",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "EmisonLu",
      "name": "Zhenghao Lu",
      "avatar_url": "https://avatars.githubusercontent.com/u/54395432?v=4",
      "profile": "https://github.com/EmisonLu",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "fredr",
      "name": "Fredrik Enestad",
      "avatar_url": "https://avatars.githubusercontent.com/u/762956?v=4",
      "profile": "https://soundtrackyourbrand.com",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "xuesongbj",
      "name": "xuesong",
      "avatar_url": "https://avatars.githubusercontent.com/u/18476085?v=4",
      "profile": "http://xuesong.pydevops.com",
      "contributions": [
        "content"
      ]
    },
    {
      "login": "MpdWalsh",
      "name": "Michael Walsh",
      "avatar_url": "https://avatars.githubusercontent.com/u/48160144?v=4",
      "profile": "https://github.com/MpdWalsh",
      "contributions": [
        "code"
      ]
    }
  ],
  "contributorsPerLine": 8,
  "projectName": "rustlings",
  "projectOwner": "rust-lang",
  "repoType": "github",
  "repoHost": "https://github.com",
  "skipCi": true
}



================================================
FILE: assets/rustlings-zh/.clog.toml
================================================
[clog]

repository = "https://github.com/rust-lang/rustlings"
changelog = "CHANGELOG.md"


================================================
FILE: assets/rustlings-zh/.editorconfig
================================================
root = true

[*.rs]
end_of_line = lf
insert_final_newfile = true
indent_style = space
indent_size = 4



================================================
FILE: assets/rustlings-zh/.gitpod.yml
================================================
tasks:
  - init: /workspace/rustlings/install.sh
    command: /workspace/.cargo/bin/rustlings watch

vscode:
  extensions:
    - rust-lang.rust@0.7.8:CvNqMTgDdt3UXt+6BCDTVg==



================================================
FILE: assets/rustlings-zh/.replit
================================================
language = "rust"
run = "[ -x ~/.cargo/bin/rustlings ] && ~/.cargo/bin/rustlings watch || ./install.sh"



================================================
FILE: assets/rustlings-zh/exercises/README.md
================================================
# Exercise to Book Chapter mapping

| Exercise               | Book Chapter |
|------------------------|--------------|
| variables              | §3.1          |
| functions              | §3.3          |
| if                     | §3.5          |
| move_semantics         | §4.1          |
| primitive_types        | §4.3          |
| structs                | §5.1          |
| enums                  | §6            |
| modules                | §7            |
| collections            | §8.1, §8.3    |
| strings                | §8.2          |
| error_handling         | §9            |
| generics               | §10           |
| option                 | §10.1         |
| traits                 | §10.2         |
| tests                  | §11.1         |
| standard_library_types | §13.2         |
| threads                | §16.1         |
| macros                 | §19.6         |
| clippy                 | n/a           |
| conversions            | n/a           |



================================================
FILE: assets/rustlings-zh/exercises/quiz1.rs
================================================
// quiz1.rs
// This is a quiz for the following sections:
// - Variables
// - Functions

// Mary is buying apples. One apple usually costs 2 Rustbucks, but if you buy
// more than 40 at once, each apple only costs 1! Write a function that calculates
// the price of an order of apples given the quantity bought. No hints this time!

// I AM NOT DONE

// Put your function here!
// fn calculate_apple_price {

// Don't modify this function!
#[test]
fn verify_test() {
    let price1 = calculate_apple_price(35);
    let price2 = calculate_apple_price(40);
    let price3 = calculate_apple_price(65);

    assert_eq!(70, price1);
    assert_eq!(80, price2);
    assert_eq!(65, price3);
}



================================================
FILE: assets/rustlings-zh/exercises/quiz2.rs
================================================
// quiz2.rs
// This is a quiz for the following sections:
// - Strings

// Ok, here are a bunch of values-- some are `String`s, some are `&str`s. Your
// task is to call one of these two functions on each value depending on what
// you think each value is. That is, add either `string_slice` or `string`
// before the parentheses on each line. If you're right, it will compile!

// I AM NOT DONE

fn string_slice(arg: &str) {
    println!("{}", arg);
}
fn string(arg: String) {
    println!("{}", arg);
}

fn main() {
    ???("blue");
    ???("red".to_string());
    ???(String::from("hi"));
    ???("rust is fun!".to_owned());
    ???("nice weather".into());
    ???(format!("Interpolation {}", "Station"));
    ???(&String::from("abc")[0..1]);
    ???("  hello there ".trim());
    ???("Happy Monday!".to_string().replace("Mon", "Tues"));
    ???("mY sHiFt KeY iS sTiCkY".to_lowercase());
}



================================================
FILE: assets/rustlings-zh/exercises/quiz3.rs
================================================
// quiz3.rs
// This is a quiz for the following sections:
// - Tests

// This quiz isn't testing our function -- make it do that in such a way that
// the test passes. Then write a second test that tests that we get the result
// we expect to get when we call `times_two` with a negative number.
// No hints, you can do this :)

// I AM NOT DONE

pub fn times_two(num: i32) -> i32 {
    num * 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn returns_twice_of_positive_numbers() {
        assert_eq!(times_two(4), ???);
    }

    #[test]
    fn returns_twice_of_negative_numbers() {
        // TODO replace unimplemented!() with an assert for `times_two(-4)`
        unimplemented!()
    }
}



================================================
FILE: assets/rustlings-zh/exercises/quiz4.rs
================================================
// quiz4.rs
// This quiz covers the sections:
// - Modules
// - Macros

// Write a macro that passes the quiz! No hints this time, you can do it!

// I AM NOT DONE

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_my_macro_world() {
        assert_eq!(my_macro!("world!"), "Hello world!");
    }

    #[test]
    fn test_my_macro_goodbye() {
        assert_eq!(my_macro!("goodbye!"), "Hello goodbye!");
    }
}



================================================
FILE: assets/rustlings-zh/exercises/advanced_errors/advanced_errs1.rs
================================================
// advanced_errs1.rs

// Remember back in errors6, we had multiple mapping functions so that we
// could translate lower-level errors into our custom error type using
// `map_err()`? What if we could use the `?` operator directly instead?

// Make this code compile! Execute `rustlings hint advanced_errs1` for
// hints :)

// I AM NOT DONE

use std::num::ParseIntError;
use std::str::FromStr;

// This is a custom error type that we will be using in the `FromStr`
// implementation.
#[derive(PartialEq, Debug)]
enum ParsePosNonzeroError {
    Creation(CreationError),
    ParseInt(ParseIntError),
}

impl From<CreationError> for ParsePosNonzeroError {
    fn from(e: CreationError) -> Self {
        // TODO: complete this implementation so that the `?` operator will
        // work for `CreationError`
    }
}

// TODO: implement another instance of the `From` trait here so that the
// `?` operator will work in the other place in the `FromStr`
// implementation below.

// Don't change anything below this line.

impl FromStr for PositiveNonzeroInteger {
    type Err = ParsePosNonzeroError;
    fn from_str(s: &str) -> Result<PositiveNonzeroInteger, Self::Err> {
        let x: i64 = s.parse()?;
        Ok(PositiveNonzeroInteger::new(x)?)
    }
}

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {
        match value {
            x if x < 0 => Err(CreationError::Negative),
            x if x == 0 => Err(CreationError::Zero),
            x => Ok(PositiveNonzeroInteger(x as u64)),
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_parse_error() {
        // We can't construct a ParseIntError, so we have to pattern match.
        assert!(matches!(
            PositiveNonzeroInteger::from_str("not a number"),
            Err(ParsePosNonzeroError::ParseInt(_))
        ));
    }

    #[test]
    fn test_negative() {
        assert_eq!(
            PositiveNonzeroInteger::from_str("-555"),
            Err(ParsePosNonzeroError::Creation(CreationError::Negative))
        );
    }

    #[test]
    fn test_zero() {
        assert_eq!(
            PositiveNonzeroInteger::from_str("0"),
            Err(ParsePosNonzeroError::Creation(CreationError::Zero))
        );
    }

    #[test]
    fn test_positive() {
        let x = PositiveNonzeroInteger::new(42);
        assert!(x.is_ok());
        assert_eq!(PositiveNonzeroInteger::from_str("42"), Ok(x.unwrap()));
    }
}



================================================
FILE: assets/rustlings-zh/exercises/advanced_errors/advanced_errs2.rs
================================================
// advanced_errs2.rs

// This exercise demonstrates a few traits that are useful for custom error
// types to implement, especially so that other code can consume the custom
// error type more usefully.

// Make this compile, and make the tests pass!
// Execute `rustlings hint advanced_errs2` for hints.

// Steps:
// 1. Implement a missing trait so that `main()` will compile.
// 2. Complete the partial implementation of `From` for
//    `ParseClimateError`.
// 3. Handle the missing error cases in the `FromStr` implementation for
//    `Climate`.
// 4. Complete the partial implementation of `Display` for
//    `ParseClimateError`.

// I AM NOT DONE

use std::error::Error;
use std::fmt::{self, Display, Formatter};
use std::num::{ParseFloatError, ParseIntError};
use std::str::FromStr;

// This is the custom error type that we will be using for the parser for
// `Climate`.
#[derive(Debug, PartialEq)]
enum ParseClimateError {
    Empty,
    BadLen,
    NoCity,
    ParseInt(ParseIntError),
    ParseFloat(ParseFloatError),
}

// This `From` implementation allows the `?` operator to work on
// `ParseIntError` values.
impl From<ParseIntError> for ParseClimateError {
    fn from(e: ParseIntError) -> Self {
        Self::ParseInt(e)
    }
}

// This `From` implementation allows the `?` operator to work on
// `ParseFloatError` values.
impl From<ParseFloatError> for ParseClimateError {
    fn from(e: ParseFloatError) -> Self {
        // TODO: Complete this function
    }
}

// TODO: Implement a missing trait so that `main()` below will compile. It
// is not necessary to implement any methods inside the missing trait.

// The `Display` trait allows for other code to obtain the error formatted
// as a user-visible string.
impl Display for ParseClimateError {
    // TODO: Complete this function so that it produces the correct strings
    // for each error variant.
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        // Imports the variants to make the following code more compact.
        use ParseClimateError::*;
        match self {
            NoCity => write!(f, "no city name"),
            ParseFloat(e) => write!(f, "error parsing temperature: {}", e),
        }
    }
}

#[derive(Debug, PartialEq)]
struct Climate {
    city: String,
    year: u32,
    temp: f32,
}

// Parser for `Climate`.
// 1. Split the input string into 3 fields: city, year, temp.
// 2. Return an error if the string is empty or has the wrong number of
//    fields.
// 3. Return an error if the city name is empty.
// 4. Parse the year as a `u32` and return an error if that fails.
// 5. Parse the temp as a `f32` and return an error if that fails.
// 6. Return an `Ok` value containing the completed `Climate` value.
impl FromStr for Climate {
    type Err = ParseClimateError;
    // TODO: Complete this function by making it handle the missing error
    // cases.
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let v: Vec<_> = s.split(',').collect();
        let (city, year, temp) = match &v[..] {
            [city, year, temp] => (city.to_string(), year, temp),
            _ => return Err(ParseClimateError::BadLen),
        };
        let year: u32 = year.parse()?;
        let temp: f32 = temp.parse()?;
        Ok(Climate { city, year, temp })
    }
}

// Don't change anything below this line (other than to enable ignored
// tests).

fn main() -> Result<(), Box<dyn Error>> {
    println!("{:?}", "Hong Kong,1999,25.7".parse::<Climate>()?);
    println!("{:?}", "".parse::<Climate>()?);
    Ok(())
}

#[cfg(test)]
mod test {
    use super::*;
    #[test]
    fn test_empty() {
        let res = "".parse::<Climate>();
        assert_eq!(res, Err(ParseClimateError::Empty));
        assert_eq!(res.unwrap_err().to_string(), "empty input");
    }
    #[test]
    fn test_short() {
        let res = "Boston,1991".parse::<Climate>();
        assert_eq!(res, Err(ParseClimateError::BadLen));
        assert_eq!(res.unwrap_err().to_string(), "incorrect number of fields");
    }
    #[test]
    fn test_long() {
        let res = "Paris,1920,17.2,extra".parse::<Climate>();
        assert_eq!(res, Err(ParseClimateError::BadLen));
        assert_eq!(res.unwrap_err().to_string(), "incorrect number of fields");
    }
    #[test]
    fn test_no_city() {
        let res = ",1997,20.5".parse::<Climate>();
        assert_eq!(res, Err(ParseClimateError::NoCity));
        assert_eq!(res.unwrap_err().to_string(), "no city name");
    }
    #[test]
    fn test_parse_int_neg() {
        let res = "Barcelona,-25,22.3".parse::<Climate>();
        assert!(matches!(res, Err(ParseClimateError::ParseInt(_))));
        let err = res.unwrap_err();
        if let ParseClimateError::ParseInt(ref inner) = err {
            assert_eq!(
                err.to_string(),
                format!("error parsing year: {}", inner.to_string())
            );
        } else {
            unreachable!();
        };
    }
    #[test]
    fn test_parse_int_bad() {
        let res = "Beijing,foo,15.0".parse::<Climate>();
        assert!(matches!(res, Err(ParseClimateError::ParseInt(_))));
        let err = res.unwrap_err();
        if let ParseClimateError::ParseInt(ref inner) = err {
            assert_eq!(
                err.to_string(),
                format!("error parsing year: {}", inner.to_string())
            );
        } else {
            unreachable!();
        };
    }
    #[test]
    fn test_parse_float() {
        let res = "Manila,2001,bar".parse::<Climate>();
        assert!(matches!(res, Err(ParseClimateError::ParseFloat(_))));
        let err = res.unwrap_err();
        if let ParseClimateError::ParseFloat(ref inner) = err {
            assert_eq!(
                err.to_string(),
                format!("error parsing temperature: {}", inner.to_string())
            );
        } else {
            unreachable!();
        };
    }
    #[test]
    fn test_parse_good() {
        let res = "Munich,2015,23.1".parse::<Climate>();
        assert_eq!(
            res,
            Ok(Climate {
                city: "Munich".to_string(),
                year: 2015,
                temp: 23.1,
            })
        );
    }
    #[test]
    #[ignore]
    fn test_downcast() {
        let res = "São Paulo,-21,28.5".parse::<Climate>();
        assert!(matches!(res, Err(ParseClimateError::ParseInt(_))));
        let err = res.unwrap_err();
        let inner: Option<&(dyn Error + 'static)> = err.source();
        assert!(inner.is_some());
        assert!(inner.unwrap().is::<ParseIntError>());
    }
}



================================================
FILE: assets/rustlings-zh/exercises/clippy/README.md
================================================
# Clippy

The Clippy tool is a collection of lints to analyze your code so you can catch common mistakes and improve your Rust code.

If you used the installation script for Rustlings, Clippy should be already installed.
If not you can install it manually via `rustup component add clippy`.

## Further information

- [GitHub Repository](https://github.com/rust-lang/rust-clippy).



================================================
FILE: assets/rustlings-zh/exercises/clippy/clippy1.rs
================================================
// clippy1.rs
// The Clippy tool is a collection of lints to analyze your code
// so you can catch common mistakes and improve your Rust code.
//
// For these exercises the code will fail to compile when there are clippy warnings
// check clippy's suggestions from the output to solve the exercise.
// Execute `rustlings hint clippy1` for hints :)

// I AM NOT DONE

fn main() {
    let x = 1.2331f64;
    let y = 1.2332f64;
    if y != x {
        println!("Success!");
    }
}



================================================
FILE: assets/rustlings-zh/exercises/clippy/clippy2.rs
================================================
// clippy2.rs
// Make me compile! Execute `rustlings hint clippy2` for hints :)

// I AM NOT DONE

fn main() {
    let mut res = 42;
    let option = Some(12);
    for x in option {
        res += x;
    }
    println!("{}", res);
}



================================================
FILE: assets/rustlings-zh/exercises/collections/README.md
================================================
# 集合（Collections）

Rust 的标准库包含了很多有用的数据结构，它们称作为集合。
大多其它的数据类型通常仅表示一个特定的值，但集合可以包含多个值。
内置的数组和元组类型指向的数据存储在堆上，这意味着存储的数据不必在编译时确定，
并可以根据程序的运行来增加或减少。

本次练习将带你熟悉 Rust 程序中两个特别常用的基本数据结构：

* *vector* 能够存储一段连续且数量不定的值。

* *散列表（hash map）* 能够将某个值与一个特定的键关联起来。
  你可能也知道它们：[C++ 中的 *unordered map*](https://en.cppreference.com/w/cpp/container/unordered_map)、[Python 的 *dictionary*](https://docs.python.org/3/tutorial/datastructures.html#dictionaries) 或其它语言中的 *associative array（译：关联数组、map、映射）*。

## 更多信息

- [Storing Lists of Values with Vectors](https://doc.rust-lang.org/stable/book/ch08-01-vectors.html)
- [Storing Keys with Associated Values in Hash Maps](https://doc.rust-lang.org/book/ch08-03-hash-maps.html)



================================================
FILE: assets/rustlings-zh/exercises/collections/hashmap1.rs
================================================
// hashmap1.rs

// 用散列表定义一个水果篮。以键表示水果的名称，值来代表篮子里对应水果的个数。
// 要求必须在篮子里放至少三种水果（如苹果、香蕉、芒果），每种水果的总数也应不少于五个。
//
// 让我通过编译和测试！
//
// 如果需要提示，可以执行命令 `rustlings hint hashmap1`。

// I AM NOT DONE

use std::collections::HashMap;

fn fruit_basket() -> HashMap<String, u32> {
    let mut basket = // TODO：在这声明个散列表

    // 给你两个香蕉
    basket.insert(String::from("banana"), 2);

    // TODO：在这往篮子里添加更多的水果

    basket
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn at_least_three_types_of_fruits() {
        let basket = fruit_basket();
        assert!(basket.len() >= 3);
    }

    #[test]
    fn at_least_five_fruits() {
        let basket = fruit_basket();
        assert!(basket.values().sum::<u32>() >= 5);
    }
}



================================================
FILE: assets/rustlings-zh/exercises/collections/hashmap2.rs
================================================
// hashmap2.rs
// 给你一个用散列表表示的水果篮，它的键表示水果的名称，值表示篮子里对应水果的个数。
// 现在需要往篮子添加至少 11 种水果。篮子里已有 - 苹果 (4),
// 芒果 (2) 和荔枝 (5) 三种水果，你不能再添加这些水果。
//
// 让我通过测试！
//
// 如果需要提示，可以执行命令 `rustlings hint hashmap2`。

// I AM NOT DONE

use std::collections::HashMap;

#[derive(Hash, PartialEq, Eq)]
enum Fruit {
    Apple,
    Banana,
    Mango,
    Lychee,
    Pineapple,
}

fn fruit_basket(basket: &mut HashMap<Fruit, u32>) {
    let fruit_kinds = vec![
        Fruit::Apple,
        Fruit::Banana,
        Fruit::Mango,
        Fruit::Lychee,
        Fruit::Pineapple,
    ];

    for fruit in fruit_kinds {
        // TODO：如果篮子里没有某种水果，就把它放入篮子。
        // 注意，你不能放入篮子中任何已有的水果。
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_fruit_basket() -> HashMap<Fruit, u32> {
        let mut basket = HashMap::<Fruit, u32>::new();
        basket.insert(Fruit::Apple, 4);
        basket.insert(Fruit::Mango, 2);
        basket.insert(Fruit::Lychee, 5);

        basket
    }

    #[test]
    fn test_given_fruits_are_not_modified() {
        let mut basket = get_fruit_basket();
        fruit_basket(&mut basket);
        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);
        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);
        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);
    }

    #[test]
    fn at_least_five_types_of_fruits() {
        let mut basket = get_fruit_basket();
        fruit_basket(&mut basket);
        let count_fruit_kinds = basket.len();
        assert!(count_fruit_kinds >= 5);
    }

    #[test]
    fn greater_than_eleven_fruits() {
        let mut basket = get_fruit_basket();
        fruit_basket(&mut basket);
        let count = basket.values().sum::<u32>();
        assert!(count > 11);
    }
}



================================================
FILE: assets/rustlings-zh/exercises/collections/vec1.rs
================================================
// vec1.rs
// 你的任务是创建一个与数组 `a` 中的元素完全相同的 `Vec`。
// 让我通过编译和测试！
// 如果需要提示，可以执行命令 `rustlings hint vec1`。

// I AM NOT DONE

fn array_and_vec() -> ([i32; 4], Vec<i32>) {
    let a = [10, 20, 30, 40]; // 一个普通的数组
    let v = // TODO：在这里用 vectors 的宏来声明你的 vector

    (a, v)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_array_and_vec_similarity() {
        let (a, v) = array_and_vec();
        assert_eq!(a, v[..]);
    }
}



================================================
FILE: assets/rustlings-zh/exercises/collections/vec2.rs
================================================
// vec2.rs
// 给定一个全是偶数的 Vec 。你的任务是完成一个循环，做到将 Vec 中的每个数字都乘以 2 。
//
// 让我通过编译和测试！
//
// 如果需要提示，可以执行命令 `rustlings hint vec2`。

// I AM NOT DONE

fn vec_loop(mut v: Vec<i32>) -> Vec<i32> {
    for i in v.iter_mut() {
        // TODO：将 Vec `v` 中的每个元素都乘以 2 。
    }

    // 此时 `v' 应该等于 [4, 8, 12, 16, 20] 。
    v
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vec_loop() {
        let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();
        let ans = vec_loop(v.clone());

        assert_eq!(ans, v.iter().map(|x| x * 2).collect::<Vec<i32>>());
    }
}



================================================
FILE: assets/rustlings-zh/exercises/conversions/README.md
================================================
# Type conversions

Rust offers a multitude of ways to convert a value of a given type into another type.

The simplest form of type conversion is a type cast expression. It is denoted with the binary operator `as`. For instance, `println!("{}", 1 + 1.0);` would not compile, since `1` is an integer while `1.0` is a float. However, `println!("{}", 1 as f32 + 1.0)` should compile. The exercise [`using_as`](using_as.rs) tries to cover this.

Rust also offers traits that facilitate type conversions upon implementation. These traits can be found under the [`convert`](https://doc.rust-lang.org/std/convert/index.html) module.
The traits are the following:
- `From` and `Into` covered in [`from_into`](from_into.rs)
- `TryFrom` and `TryInto` covered in [`try_from_into`](try_from_into.rs)
- `AsRef` and `AsMut` covered in [`as_ref_mut`](as_ref_mut.rs)

Furthermore, the `std::str` module offers a trait called [`FromStr`](https://doc.rust-lang.org/std/str/trait.FromStr.html) which helps with converting strings into target types via the `parse` method on strings. If properly implemented for a given type `Person`, then `let p: Person = "Mark,20".parse().unwrap()` should both compile and run without panicking.

These should be the main ways ***within the standard library*** to convert data into your desired types.

## Further information

These are not directly covered in the book, but the standard library has a great documentation for it.
- [conversions](https://doc.rust-lang.org/std/convert/index.html)
- [`FromStr` trait](https://doc.rust-lang.org/std/str/trait.FromStr.html)


================================================
FILE: assets/rustlings-zh/exercises/conversions/as_ref_mut.rs
================================================
// AsRef and AsMut allow for cheap reference-to-reference conversions.
// Read more about them at https://doc.rust-lang.org/std/convert/trait.AsRef.html
// and https://doc.rust-lang.org/std/convert/trait.AsMut.html, respectively.

// I AM NOT DONE

// Obtain the number of bytes (not characters) in the given argument
// Add the AsRef trait appropriately as a trait bound
fn byte_counter<T>(arg: T) -> usize {
    arg.as_ref().as_bytes().len()
}

// Obtain the number of characters (not bytes) in the given argument
// Add the AsRef trait appropriately as a trait bound
fn char_counter<T>(arg: T) -> usize {
    arg.as_ref().chars().count()
}

fn main() {
    let s = "Café au lait";
    println!("{}", char_counter(s));
    println!("{}", byte_counter(s));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn different_counts() {
        let s = "Café au lait";
        assert_ne!(char_counter(s), byte_counter(s));
    }

    #[test]
    fn same_counts() {
        let s = "Cafe au lait";
        assert_eq!(char_counter(s), byte_counter(s));
    }

    #[test]
    fn different_counts_using_string() {
        let s = String::from("Café au lait");
        assert_ne!(char_counter(s.clone()), byte_counter(s));
    }

    #[test]
    fn same_counts_using_string() {
        let s = String::from("Cafe au lait");
        assert_eq!(char_counter(s.clone()), byte_counter(s));
    }
}



================================================
FILE: assets/rustlings-zh/exercises/conversions/from_into.rs
================================================
// The From trait is used for value-to-value conversions.
// If From is implemented correctly for a type, the Into trait should work conversely.
// You can read more about it at https://doc.rust-lang.org/std/convert/trait.From.html
#[derive(Debug)]
struct Person {
    name: String,
    age: usize,
}

// We implement the Default trait to use it as a fallback
// when the provided string is not convertible into a Person object
impl Default for Person {
    fn default() -> Person {
        Person {
            name: String::from("John"),
            age: 30,
        }
    }
}

// Your task is to complete this implementation
// in order for the line `let p = Person::from("Mark,20")` to compile
// Please note that you'll need to parse the age component into a `usize`
// with something like `"4".parse::<usize>()`. The outcome of this needs to
// be handled appropriately.
//
// Steps:
// 1. If the length of the provided string is 0, then return the default of Person
// 2. Split the given string on the commas present in it
// 3. Extract the first element from the split operation and use it as the name
// 4. If the name is empty, then return the default of Person
// 5. Extract the other element from the split operation and parse it into a `usize` as the age
// If while parsing the age, something goes wrong, then return the default of Person
// Otherwise, then return an instantiated Person object with the results

// I AM NOT DONE

impl From<&str> for Person {
    fn from(s: &str) -> Person {
    }
}

fn main() {
    // Use the `from` function
    let p1 = Person::from("Mark,20");
    // Since From is implemented for Person, we should be able to use Into
    let p2: Person = "Gerald,70".into();
    println!("{:?}", p1);
    println!("{:?}", p2);
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_default() {
        // Test that the default person is 30 year old John
        let dp = Person::default();
        assert_eq!(dp.name, "John");
        assert_eq!(dp.age, 30);
    }
    #[test]
    fn test_bad_convert() {
        // Test that John is returned when bad string is provided
        let p = Person::from("");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }
    #[test]
    fn test_good_convert() {
        // Test that "Mark,20" works
        let p = Person::from("Mark,20");
        assert_eq!(p.name, "Mark");
        assert_eq!(p.age, 20);
    }
    #[test]
    fn test_bad_age() {
        // Test that "Mark,twenty" will return the default person due to an error in parsing age
        let p = Person::from("Mark,twenty");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_comma_and_age() {
        let p: Person = Person::from("Mark");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_age() {
        let p: Person = Person::from("Mark,");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name() {
        let p: Person = Person::from(",1");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name_and_age() {
        let p: Person = Person::from(",");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name_and_invalid_age() {
        let p: Person = Person::from(",one");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_trailing_comma() {
        let p: Person = Person::from("Mike,32,");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_trailing_comma_and_some_string() {
        let p: Person = Person::from("Mike,32,man");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }
}



================================================
FILE: assets/rustlings-zh/exercises/conversions/from_str.rs
================================================
// from_str.rs
// This is similar to from_into.rs, but this time we'll implement `FromStr`
// and return errors instead of falling back to a default value.
// Additionally, upon implementing FromStr, you can use the `parse` method
// on strings to generate an object of the implementor type.
// You can read more about it at https://doc.rust-lang.org/std/str/trait.FromStr.html
use std::num::ParseIntError;
use std::str::FromStr;

#[derive(Debug, PartialEq)]
struct Person {
    name: String,
    age: usize,
}

// We will use this error type for the `FromStr` implementation.
#[derive(Debug, PartialEq)]
enum ParsePersonError {
    // Empty input string
    Empty,
    // Incorrect number of fields
    BadLen,
    // Empty name field
    NoName,
    // Wrapped error from parse::<usize>()
    ParseInt(ParseIntError),
}

// I AM NOT DONE

// Steps:
// 1. If the length of the provided string is 0, an error should be returned
// 2. Split the given string on the commas present in it
// 3. Only 2 elements should be returned from the split, otherwise return an error
// 4. Extract the first element from the split operation and use it as the name
// 5. Extract the other element from the split operation and parse it into a `usize` as the age
//    with something like `"4".parse::<usize>()`
// 6. If while extracting the name and the age something goes wrong, an error should be returned
// If everything goes well, then return a Result of a Person object

impl FromStr for Person {
    type Err = ParsePersonError;
    fn from_str(s: &str) -> Result<Person, Self::Err> {
    }
}

fn main() {
    let p = "Mark,20".parse::<Person>().unwrap();
    println!("{:?}", p);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn empty_input() {
        assert_eq!("".parse::<Person>(), Err(ParsePersonError::Empty));
    }
    #[test]
    fn good_input() {
        let p = "John,32".parse::<Person>();
        assert!(p.is_ok());
        let p = p.unwrap();
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 32);
    }
    #[test]
    fn missing_age() {
        assert!(matches!(
            "John,".parse::<Person>(),
            Err(ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn invalid_age() {
        assert!(matches!(
            "John,twenty".parse::<Person>(),
            Err(ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn missing_comma_and_age() {
        assert_eq!("John".parse::<Person>(), Err(ParsePersonError::BadLen));
    }

    #[test]
    fn missing_name() {
        assert_eq!(",1".parse::<Person>(), Err(ParsePersonError::NoName));
    }

    #[test]
    fn missing_name_and_age() {
        assert!(matches!(
            ",".parse::<Person>(),
            Err(ParsePersonError::NoName | ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn missing_name_and_invalid_age() {
        assert!(matches!(
            ",one".parse::<Person>(),
            Err(ParsePersonError::NoName | ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn trailing_comma() {
        assert_eq!("John,32,".parse::<Person>(), Err(ParsePersonError::BadLen));
    }

    #[test]
    fn trailing_comma_and_some_string() {
        assert_eq!(
            "John,32,man".parse::<Person>(),
            Err(ParsePersonError::BadLen)
        );
    }
}



================================================
FILE: assets/rustlings-zh/exercises/conversions/try_from_into.rs
================================================
// try_from_into.rs
// TryFrom is a simple and safe type conversion that may fail in a controlled way under some circumstances.
// Basically, this is the same as From. The main difference is that this should return a Result type
// instead of the target type itself.
// You can read more about it at https://doc.rust-lang.org/std/convert/trait.TryFrom.html
use std::convert::{TryFrom, TryInto};

#[derive(Debug, PartialEq)]
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}

// We will use this error type for these `TryFrom` conversions.
#[derive(Debug, PartialEq)]
enum IntoColorError {
    // Incorrect length of slice
    BadLen,
    // Integer conversion error
    IntConversion,
}

// I AM NOT DONE

// Your task is to complete this implementation
// and return an Ok result of inner type Color.
// You need to create an implementation for a tuple of three integers,
// an array of three integers, and a slice of integers.
//
// Note that the implementation for tuple and array will be checked at compile time,
// but the slice implementation needs to check the slice length!
// Also note that correct RGB color values must be integers in the 0..=255 range.

// Tuple implementation
impl TryFrom<(i16, i16, i16)> for Color {
    type Error = IntoColorError;
    fn try_from(tuple: (i16, i16, i16)) -> Result<Self, Self::Error> {
    }
}

// Array implementation
impl TryFrom<[i16; 3]> for Color {
    type Error = IntoColorError;
    fn try_from(arr: [i16; 3]) -> Result<Self, Self::Error> {
    }
}

// Slice implementation
impl TryFrom<&[i16]> for Color {
    type Error = IntoColorError;
    fn try_from(slice: &[i16]) -> Result<Self, Self::Error> {
    }
}

fn main() {
    // Use the `from` function
    let c1 = Color::try_from((183, 65, 14));
    println!("{:?}", c1);

    // Since TryFrom is implemented for Color, we should be able to use TryInto
    let c2: Result<Color, _> = [183, 65, 14].try_into();
    println!("{:?}", c2);

    let v = vec![183, 65, 14];
    // With slice we should use `try_from` function
    let c3 = Color::try_from(&v[..]);
    println!("{:?}", c3);
    // or take slice within round brackets and use TryInto
    let c4: Result<Color, _> = (&v[..]).try_into();
    println!("{:?}", c4);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_tuple_out_of_range_positive() {
        assert_eq!(
            Color::try_from((256, 1000, 10000)),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_tuple_out_of_range_negative() {
        assert_eq!(
            Color::try_from((-1, -10, -256)),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_tuple_sum() {
        assert_eq!(
            Color::try_from((-1, 255, 255)),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_tuple_correct() {
        let c: Result<Color, _> = (183, 65, 14).try_into();
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }
    #[test]
    fn test_array_out_of_range_positive() {
        let c: Result<Color, _> = [1000, 10000, 256].try_into();
        assert_eq!(c, Err(IntoColorError::IntConversion));
    }
    #[test]
    fn test_array_out_of_range_negative() {
        let c: Result<Color, _> = [-10, -256, -1].try_into();
        assert_eq!(c, Err(IntoColorError::IntConversion));
    }
    #[test]
    fn test_array_sum() {
        let c: Result<Color, _> = [-1, 255, 255].try_into();
        assert_eq!(c, Err(IntoColorError::IntConversion));
    }
    #[test]
    fn test_array_correct() {
        let c: Result<Color, _> = [183, 65, 14].try_into();
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }
    #[test]
    fn test_slice_out_of_range_positive() {
        let arr = [10000, 256, 1000];
        assert_eq!(
            Color::try_from(&arr[..]),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_slice_out_of_range_negative() {
        let arr = [-256, -1, -10];
        assert_eq!(
            Color::try_from(&arr[..]),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_slice_sum() {
        let arr = [-1, 255, 255];
        assert_eq!(
            Color::try_from(&arr[..]),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_slice_correct() {
        let v = vec![183, 65, 14];
        let c: Result<Color, _> = Color::try_from(&v[..]);
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }
    #[test]
    fn test_slice_excess_length() {
        let v = vec![0, 0, 0, 0];
        assert_eq!(Color::try_from(&v[..]), Err(IntoColorError::BadLen));
    }
    #[test]
    fn test_slice_insufficient_length() {
        let v = vec![0, 0];
        assert_eq!(Color::try_from(&v[..]), Err(IntoColorError::BadLen));
    }
}



================================================
FILE: assets/rustlings-zh/exercises/conversions/using_as.rs
================================================
// Type casting in Rust is done via the usage of the `as` operator.
// Please note that the `as` operator is not only used when type casting.
// It also helps with renaming imports.
//
// The goal is to make sure that the division does not fail to compile
// and returns the proper type.

// I AM NOT DONE

fn average(values: &[f64]) -> f64 {
    let total = values.iter().fold(0.0, |a, b| a + b);
    total / values.len()
}

fn main() {
    let values = [3.5, 0.3, 13.0, 11.7];
    println!("{}", average(&values));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn returns_proper_type_and_value() {
        assert_eq!(average(&[3.5, 0.3, 13.0, 11.7]), 7.125);
    }
}



================================================
FILE: assets/rustlings-zh/exercises/enums/README.md
================================================
# 枚举（enums）

Rust 有一种叫做“枚举”的类型，这种类型列举出了某种集合中所有可能的值。
枚举是许多语言共有的一个功能，但它的作用在每种语言中都有所不同。
如 F#、OCaml 和 Haskell 之类的函数式语言中的代数数据类型（algebraic data types）和 Rust 的枚举很相似。
Rust 的“模式匹配”功能与枚举结合起非常强大，利用它我们很容易就能针对枚举的不同类型运行不同的代码。

## 更多信息

- [Enums](https://doc.rust-lang.org/book/ch06-00-enums.html)
- [Pattern syntax](https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html)



================================================
FILE: assets/rustlings-zh/exercises/enums/enums1.rs
================================================
// enums1.rs
// 让我能够编译！执行 `rustex hint enums1` 获取提示 :)

// I AM NOT DONE

#[derive(Debug)]
enum Message {
    // TODO：遵照下面的使用方式来定义几种 Message 的类型
}

fn main() {
    println!("{:?}", Message::Quit);
    println!("{:?}", Message::Echo);
    println!("{:?}", Message::Move);
    println!("{:?}", Message::ChangeColor);
}



================================================
FILE: assets/rustlings-zh/exercises/enums/enums2.rs
================================================
// enums2.rs
// 让我能够编译！执行 `rustex hint enums2` 获取提示！

// I AM NOT DONE

#[derive(Debug)]
enum Message {
    // TODO：定义下面使用到的多种 Message 类型
}

impl Message {
    fn call(&self) {
        println!("{:?}", &self);
    }
}

fn main() {
    let messages = [
        Message::Move { x: 10, y: 30 },
        Message::Echo(String::from("hello world")),
        Message::ChangeColor(200, 255, 255),
        Message::Quit,
    ];

    for message in &messages {
        message.call();
    }
}



================================================
FILE: assets/rustlings-zh/exercises/enums/enums3.rs
================================================
// enums3.rs
// 解决所有的 TODO ，通过测试！

// I AM NOT DONE

enum Message {
    // TODO：根据以下的使用方式，实现 Message 的不同类型
}

struct Point {
    x: u8,
    y: u8,
}

struct State {
    color: (u8, u8, u8),
    position: Point,
    quit: bool,
}

impl State {
    fn change_color(&mut self, color: (u8, u8, u8)) {
        self.color = color;
    }

    fn quit(&mut self) {
        self.quit = true;
    }

    fn echo(&self, s: String) {
        println!("{}", s);
    }

    fn move_position(&mut self, p: Point) {
        self.position = p;
    }

    fn process(&mut self, message: Message) {
        // TODO：使用 match 表达式来处理不同类型的消息
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_match_message_call() {
        let mut state = State {
            quit: false,
            position: Point { x: 0, y: 0 },
            color: (0, 0, 0),
        };
        state.process(Message::ChangeColor((255, 0, 255)));
        state.process(Message::Echo(String::from("hello world")));
        state.process(Message::Move(Point { x: 10, y: 15 }));
        state.process(Message::Quit);

        assert_eq!(state.color, (255, 0, 255));
        assert_eq!(state.position.x, 10);
        assert_eq!(state.position.y, 15);
        assert_eq!(state.quit, true);
    }
}



================================================
FILE: assets/rustlings-zh/exercises/error_handling/README.md
================================================
# 错误处理
大多数的错误并没有严重到需要让程序完全停止运行的程度。
有时一个函数执行失败时，你可以很容易地对造成失败的原因进行解释并采取对应措施的。
例如，你正试图打开一个文件，但由于该文件不存在导致了操作失败，这时你可能想创建
该文件而不是直接终止程序。

## 更多信息

- [Error Handling](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html)
- [Generics](https://doc.rust-lang.org/book/ch10-01-syntax.html)
- [Result](https://doc.rust-lang.org/rust-by-example/error/result.html)
- [Boxing errors](https://doc.rust-lang.org/rust-by-example/error/multiple_error_types/boxing_errors.html)



================================================
FILE: assets/rustlings-zh/exercises/error_handling/errors1.rs
================================================
// errors1.rs
// 假使你传给这个函数一个空字符串，那么它将拒绝生成一段个性签名（nametage）。
// 如果它能解释拒绝的原因是什么，而不是粗暴返回 `None` 那就更完美了。
// 第 2 个测试目前还没通过并未能编译，但它说明了我们希望这个函数具有的行为。
// 执行 `rustlings hint errors1` 获取提示！

// I AM NOT DONE

pub fn generate_nametag_text(name: String) -> Option<String> {// 译：生成个性签名
    if name.len() > 0 {
        Some(format!("Hi! My name is {}", name))// 译："嗨！我的名字是 {}"
    } else {
        // 不允许使用空的名字。
        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // 你可以注释掉第 2 个测试，那么这个测试就能初步通过。
    // 当你更改了测试的函数时，也需要修改下测试代码以使测试正确！
    #[test]
    fn generates_nametag_text_for_a_nonempty_name() {// 译：用一个非空名称生成一段个性签名
        assert_eq!(
            generate_nametag_text("Beyoncé".into()),
            Some("Hi! My name is Beyoncé".into())
        );
    }

    #[test]
    fn explains_why_generating_nametag_text_fails() {// 译：说明为什么个性签名生成失败了
        assert_eq!(
            generate_nametag_text("".into()),
            Err("`name` was empty; it must be nonempty.".into())
        );
    }
}



================================================
FILE: assets/rustlings-zh/exercises/error_handling/errors2.rs
================================================
// errors2.rs
// 假设我们正在编写一个游戏，你可以用代币购买物品。
// 所有物品的价格都是 5 个代币，每当你购买物品时，都需要 1 个代币的小费。
// 游戏玩家将输入他们想要购买的物品数量，`total_cost` 函数能够计算出所需的代币数量。
// 虽然玩家输入的是数量，但我们得到的却是一个字符串——他们可能输入了任何东西，而不仅仅是数字！

// 目前这个函数没有处理任何错误的情况（也没有处理成功的情况）。
// 我们要做的是：
// 如果我们在非数字的字符串上调用 `parse` 方法，该方法将返回 `ParseIntError`，
// 在这种情况下，我们要立刻从函数返回这个错误，而不是继续进行相关计算。

// 至少有两种方法可以做到这点，它们都是正确的——但其中一种简短得多! 
// 执行 `rustlings hint errors2` 以获得关于这两种方式的提示。

// I AM NOT DONE

use std::num::ParseIntError;

pub fn total_cost(item_quantity: &str) -> Result<i32, ParseIntError> {
    let processing_fee = 1;
    let cost_per_item = 5;
    let qty = item_quantity.parse::<i32>();

    Ok(qty * cost_per_item + processing_fee)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn item_quantity_is_a_valid_number() {
        assert_eq!(total_cost("34"), Ok(171));
    }

    #[test]
    fn item_quantity_is_an_invalid_number() {
        assert_eq!(
            total_cost("beep boop").unwrap_err().to_string(),
            "invalid digit found in string"
        );// 译：字符串中包含无效的数字
    }
}



================================================
FILE: assets/rustlings-zh/exercises/error_handling/errors3.rs
================================================
// errors3.rs
// 这是一个试图使用前面练习中 `total_cost` 函数完整版的程序。
// 但出了些问题！为什么不行？我们需要怎样做才能解决问题？
// 执行 `rustlings hint errors3` 获取提示！

// I AM NOT DONE

use std::num::ParseIntError;

fn main() {
    let mut tokens = 100;
    let pretend_user_input = "8";

    let cost = total_cost(pretend_user_input)?;

    if cost > tokens {
        println!("You can't afford that many!");// 译：你的代币不足以完成支付！
    } else {
        tokens -= cost;
        println!("You now have {} tokens.", tokens);// 译：现在你有 {} 个代币"
    }
}

pub fn total_cost(item_quantity: &str) -> Result<i32, ParseIntError> {
    let processing_fee = 1;
    let cost_per_item = 5;
    let qty = item_quantity.parse::<i32>()?;

    Ok(qty * cost_per_item + processing_fee)
}



================================================
FILE: assets/rustlings-zh/exercises/error_handling/errors4.rs
================================================
// errors4.rs
// 通过测试！执行 `rustlings hint errors4` 获取提示 :)

// I AM NOT DONE

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {
        Ok(PositiveNonzeroInteger(value as u64))
    }
}

#[test]
fn test_creation() {
    assert!(PositiveNonzeroInteger::new(10).is_ok());
    assert_eq!(
        Err(CreationError::Negative),
        PositiveNonzeroInteger::new(-10)
    );
    assert_eq!(Err(CreationError::Zero), PositiveNonzeroInteger::new(0));
}



================================================
FILE: assets/rustlings-zh/exercises/error_handling/errors5.rs
================================================
[Binary file]


================================================
FILE: assets/rustlings-zh/exercises/error_handling/errors6.rs
================================================
[Binary file]


================================================
FILE: assets/rustlings-zh/exercises/functions/README.md
================================================
# 函数（Functions）

在本练习，你将学习如何编写一个函数，以及 Rust 编译器怎样可以对事物进行追溯（trace things way back）。

译：依据练习的内容，追溯的意思可能是类型推导之类的事。

## 更多信息

- [How Functions Work](https://doc.rust-lang.org/book/ch03-03-how-functions-work.html)



================================================
FILE: assets/rustlings-zh/exercises/functions/functions1.rs
================================================
// functions1.rs
// 让我能够编译！执行 `rustex hint functions1` 获取提示 :)

// I AM NOT DONE

/// 翻译: [mg-chao](https://github.com/mg-chao)
fn main() {
    call_me();
}



================================================
FILE: assets/rustlings-zh/exercises/functions/functions2.rs
================================================
// functions2.rs
// 让我能够编译！执行 `rustex hint functions2` 获取提示 :)

// I AM NOT DONE

/// 翻译: [mg-chao](https://github.com/mg-chao)
fn main() {
    call_me(3);
}

fn call_me(num:) {
    for i in 0..num {
        println!("Ring! Call number {}", i + 1);// 译："叮！呼叫号码 {}"
    }
}



================================================
FILE: assets/rustlings-zh/exercises/functions/functions3.rs
================================================
// functions3.rs
// 让我能够编译！执行 `rustex hint functions3` 获取提示 :)

// I AM NOT DONE

/// 翻译: [mg-chao](https://github.com/mg-chao)
fn main() {
    call_me();
}

fn call_me(num: u32) {
    for i in 0..num {
        println!("Ring! Call number {}", i + 1);
    }
}



================================================
FILE: assets/rustlings-zh/exercises/functions/functions4.rs
================================================
// functions4.rs
// 让我能够编译！执行 `rustex hint functions4` 获取提示 :)

// 商店正在进行促销，如果价格是偶数，可以优惠 10 Rustbucks，如果是奇数，则优惠 3 Rustbucks。
// 译：Rustbucks 可能想表达 Rust元 的意思，好比 美元 。

// I AM NOT DONE

/// 翻译: [mg-chao](https://github.com/mg-chao)
fn main() {
    let original_price = 51;
    println!("Your sale price is {}", sale_price(original_price));// 译："你需支付 {}"
}

fn sale_price(price: i32) -> {
    if is_even(price) {
        price - 10
    } else {
        price - 3
    }
}

fn is_even(num: i32) -> bool {
    num % 2 == 0
}



================================================
FILE: assets/rustlings-zh/exercises/functions/functions5.rs
================================================
// functions5.rs
// 让我能够编译！执行 `rustex hint functions5` 获取提示 :)

// I AM NOT DONE

/// 翻译: [mg-chao](https://github.com/mg-chao)
fn main() {
    let answer = square(3);
    println!("The answer is {}", answer);// 译："答案是 {}"
}

fn square(num: i32) -> i32 {
    num * num;
}



================================================
FILE: assets/rustlings-zh/exercises/generics/README.md
================================================
# 泛型

泛型的主旨是把类型和函数泛化到多种情况。
这在很多方面有助于减少重复代码，但也可能需要为此使用相当多的语法。
也就是说，使用泛型的话则需要小心谨慎地标明泛型适用于哪些类型。

## 更多信息

- [Generic Data Types](https://doc.rust-lang.org/stable/book/ch10-01-syntax.html)
- [Bounds](https://doc.rust-lang.org/rust-by-example/generics/bounds.html)



================================================
FILE: assets/rustlings-zh/exercises/generics/generics1.rs
================================================
// 这个购物清单程序无法编译！
// 用你对泛型的了解来解决这个问题。

// 执行 `rustlings hint generics1` 获取提示！

// I AM NOT DONE

fn main() {
    let mut shopping_list: Vec<?> = Vec::new();
    shopping_list.push("milk");
}



================================================
FILE: assets/rustlings-zh/exercises/generics/generics2.rs
================================================
// 这个强大的 Wrapper 拥有存储一个正整数值的能力。
// 利用泛型重写它，使它支持包装（wrapping）任何类型的值。

// 执行 `rustlings hint generics2` 获取提示！

// I AM NOT DONE

struct Wrapper {
    value: u32,
}

impl Wrapper {
    pub fn new(value: u32) -> Self {
        Wrapper { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn store_u32_in_wrapper() {
        assert_eq!(Wrapper::new(42).value, 42);
    }

    #[test]
    fn store_str_in_wrapper() {
        assert_eq!(Wrapper::new("Foo").value, "Foo");
    }
}



================================================
FILE: assets/rustlings-zh/exercises/generics/generics3.rs
================================================
// 一所想象的魔法学院有一个采用 Rust 编写的新版成绩单生成系统！
// 目前该系统仅支持创建以数字表示的成绩单（如 1.0 -> 5.5）。
// 然而，学校也发布用字母表示的成绩（A+ -> F-），所以需要能够打印两种成绩单。

// 在 ReportCard 结构定义和 impl 块中进行必要的代码修改，以支持用字母表示的成绩单。
// 将第二个测试的 grade 改为 "A+"，用来表明代码已允许按字母表示成绩。

// 执行 'rustlings hint generics3' 获取提示！

// I AM NOT DONE

pub struct ReportCard {
    pub grade: f32,
    pub student_name: String,
    pub student_age: u8,
}

impl ReportCard {
    pub fn print(&self) -> String {
        format!("{} ({}) - achieved a grade of {}",// 译：{} ({}) - 成绩为 {}"
            &self.student_name, &self.student_age, &self.grade)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generate_numeric_report_card() {
        let report_card = ReportCard {
            grade: 2.1,
            student_name: "Tom Wriggle".to_string(),
            student_age: 12,
        };
        assert_eq!(
            report_card.print(),
            "Tom Wriggle (12) - achieved a grade of 2.1"
        );
    }

    #[test]
    fn generate_alphabetic_report_card() {
        // TODO：完成练习后，在这里更改 grade 的值。
        let report_card = ReportCard {
            grade: 2.1,
            student_name: "Gary Plotter".to_string(),
            student_age: 11,
        };
        assert_eq!(
            report_card.print(),
            "Gary Plotter (11) - achieved a grade of A+"
        );
    }
}



================================================
FILE: assets/rustlings-zh/exercises/if/README.md
================================================
# If

你将在这学习最基本的控制流（control flow）——`if`

## 更多信息

- [Control Flow - if expressions](https://doc.rust-lang.org/book/ch03-05-control-flow.html#if-expressions)



================================================
FILE: assets/rustlings-zh/exercises/if/if1.rs
================================================
// if1.rs

// I AM NOT DONE

pub fn bigger(a: i32, b: i32) -> i32 {
    // 完成这个返回更大数字的函数！
    // 但不允许以下方式：
    // - 调用其它函数
    // - 额外变量
    // 执行 `rustex hint if1` 获取提示
}

// 暂时不要在意它 :)
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ten_is_bigger_than_eight() {
        assert_eq!(10, bigger(10, 8));
    }

    #[test]
    fn fortytwo_is_bigger_than_thirtytwo() {
        assert_eq!(42, bigger(32, 42));
    }
}



================================================
FILE: assets/rustlings-zh/exercises/if/if2.rs
================================================
// if2.rs

// 第一步：让我能够编译！
// 第二步：bar_for_fuzz 和 default_to_baz 可以通过测试！
// 执行 `rustex hint if2` 获取提示 :)

// I AM NOT DONE

pub fn fizz_if_foo(fizzish: &str) -> &str {
    if fizzish == "fizz" {
        "foo"
    } else {
        1
    }
}

// 测试不需要更改。
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn foo_for_fizz() {
        assert_eq!(fizz_if_foo("fizz"), "foo")
    }

    #[test]
    fn bar_for_fuzz() {
        assert_eq!(fizz_if_foo("fuzz"), "bar")
    }

    #[test]
    fn default_to_baz() {
        assert_eq!(fizz_if_foo("literally anything"), "baz")
    }
}



================================================
FILE: assets/rustlings-zh/exercises/macros/README.md
================================================
# Macros

Rust's macro system is very powerful, but also kind of difficult to wrap your
head around. We're not going to teach you how to write your own fully-featured
macros. Instead, we'll show you how to use and create them.

## Further information

- [Macros](https://doc.rust-lang.org/book/ch19-06-macros.html)
- [The Little Book of Rust Macros](https://danielkeep.github.io/tlborm/book/index.html)



================================================
FILE: assets/rustlings-zh/exercises/macros/macros1.rs
================================================
// macros1.rs
// Make me compile! Execute `rustlings hint macros1` for hints :)

// I AM NOT DONE

macro_rules! my_macro {
    () => {
        println!("Check out my macro!");
    };
}

fn main() {
    my_macro();
}



================================================
FILE: assets/rustlings-zh/exercises/macros/macros2.rs
================================================
// macros2.rs
// Make me compile! Execute `rustlings hint macros2` for hints :)

// I AM NOT DONE

fn main() {
    my_macro!();
}

macro_rules! my_macro {
    () => {
        println!("Check out my macro!");
    };
}



================================================
FILE: assets/rustlings-zh/exercises/macros/macros3.rs
================================================
// macros3.rs
// Make me compile, without taking the macro out of the module!
// Execute `rustlings hint macros3` for hints :)

// I AM NOT DONE

mod macros {
    macro_rules! my_macro {
        () => {
            println!("Check out my macro!");
        };
    }
}

fn main() {
    my_macro!();
}



================================================
FILE: assets/rustlings-zh/exercises/macros/macros4.rs
================================================
// macros4.rs
// Make me compile! Execute `rustlings hint macros4` for hints :)

// I AM NOT DONE

macro_rules! my_macro {
    () => {
        println!("Check out my macro!");
    }
    ($val:expr) => {
        println!("Look at this other macro: {}", $val);
    }
}

fn main() {
    my_macro!();
    my_macro!(7777);
}



================================================
FILE: assets/rustlings-zh/exercises/modules/README.md
================================================
# 模块（Modules）

这部分我们将向你介绍 Rust 的模块系统。

## 更多信息

- [The Module System](https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html)



================================================
FILE: assets/rustlings-zh/exercises/modules/modules1.rs
================================================
// modules1.rs
// 让我能够编译！执行 `rustex hint modules1` 获取提示 :)

// I AM NOT DONE

mod sausage_factory {
    // 确保它仅在当前模块可见。
    fn get_secret_recipe() -> String {
        String::from("Ginger")
    }

    fn make_sausage() {
        get_secret_recipe();
        println!("sausage!");
    }
}

fn main() {
    sausage_factory::make_sausage();
}



================================================
FILE: assets/rustlings-zh/exercises/modules/modules2.rs
================================================
// modules2.rs
// 你可以把模块引入作用域，并使用 'use' 和 'as' 关键字给它们取个别称.
// 修复 'use' 语句的相关代码以通过编译。
// 让我能够编译！执行 `rustex hint modules2` 获取提示 :)

// I AM NOT DONE

mod delicious_snacks {

    // TODO: 修复这些 'use' 语句
    use self::fruits::PEAR as ???
    use self::veggies::CUCUMBER as ???

    mod fruits {
        pub const PEAR: &'static str = "Pear";
        pub const APPLE: &'static str = "Apple";
    }

    mod veggies {
        pub const CUCUMBER: &'static str = "Cucumber";
        pub const CARROT: &'static str = "Carrot";
    }
}

fn main() {
    println!(
        "favorite snacks: {} and {}",
        delicious_snacks::fruit,
        delicious_snacks::veggie
    );
}



================================================
FILE: assets/rustlings-zh/exercises/modules/modules3.rs
================================================
// modules3.rs
// 你可以使用 'use' 关键字将任何位置的模块（特别是 Rust 标准库中的模块）引入作用域。
// 从 std::time 模块引入 SystemTime 和 UNIX_EPOCH。如果你能用一行代码解决，就能获得额外得分。
// 让我能够编译！执行 `rustex hint modules3` 获取提示 :)

// I AM NOT DONE

// TODO: 完成这个 `use` 语句
use ???

fn main() {
    match SystemTime::now().duration_since(UNIX_EPOCH) {
        Ok(n) => println!("1970-01-01 00:00:00 UTC was {} seconds ago!", n.as_secs()),
        Err(_) => panic!("SystemTime before UNIX EPOCH!"),
    }
}



================================================
FILE: assets/rustlings-zh/exercises/move_semantics/README.md
================================================
# 移动语义（Move Semantics）

这些练习改编自 [pnkfelix](https://github.com/pnkfelix) 的 [Rust Tutorial](https://pnkfelix.github.io/rust-examples-icfp2014/) -- 谢谢 Felix !!!

## 更多信息

以下书籍中的内容对于当前的学习尤其重要。

- [Ownership](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html)
- [Reference and borrowing](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html)



================================================
FILE: assets/rustlings-zh/exercises/move_semantics/move_semantics1.rs
================================================
// move_semantics1.rs
// 让我能够编译！执行 `rustex hint move_semantics1` 获取提示 :)

// I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let vec1 = fill_vec(vec0);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);// 译："{} 长度为 {} 内容是 `{:?}`"

    vec1.push(88);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);
}

fn fill_vec(vec: Vec<i32>) -> Vec<i32> {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}



================================================
FILE: assets/rustlings-zh/exercises/move_semantics/move_semantics2.rs
================================================
// move_semantics2.rs
// 在不更改第 13 行的要求下通过编译！
// 执行 `rustex hint move_semantics2` 获取提示 :)

// I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    // 不要更改下面那行！
    println!("{} has length {} content `{:?}`", "vec0", vec0.len(), vec0);

    vec1.push(88);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);
}

fn fill_vec(vec: Vec<i32>) -> Vec<i32> {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}



================================================
FILE: assets/rustlings-zh/exercises/move_semantics/move_semantics3.rs
================================================
// move_semantics3.rs
// 在不添加新行仅改变已有行的要求下通过编译！
// （也不允许有多个分号的行！）
// 执行 `rustex hint move_semantics3` 获取提示 :)

// I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);

    vec1.push(88);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);
}

fn fill_vec(vec: Vec<i32>) -> Vec<i32> {
    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}



================================================
FILE: assets/rustlings-zh/exercises/move_semantics/move_semantics4.rs
================================================
// move_semantics4.rs
// 重构这段代码，做到删除 `vec0` ，并在 `fn fill_vec` 而非 `fn main` 中创建 vector ，
// 然后将新创建的 vector 从 `fill_vec` 转移到其调用者。
// 执行 `rustex hint move_semantics4` 获取提示 :)

// I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);

    vec1.push(88);

    println!("{} has length {} content `{:?}`", "vec1", vec1.len(), vec1);
}

// `fill_vec()` 不再获取 `vec: Vec<i32>` 参数
fn fill_vec() -> Vec<i32> {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}



================================================
FILE: assets/rustlings-zh/exercises/move_semantics/move_semantics5.rs
================================================
// move_semantics5.rs
// 只通过重新排列 `main()` 中的已有行来完成编译，并且不能增加、更改或删除任何行
// 执行 `rustex hint move_semantics5` 获取提示 :)

// I AM NOT DONE

fn main() {
    let mut x = 100;
    let y = &mut x;
    let z = &mut x;
    *y += 100;
    *z += 1000;
    assert_eq!(x, 1200);
}



================================================
FILE: assets/rustlings-zh/exercises/option/README.md
================================================
# Option

Option 类型代表可选的值：每个 Option 要么是 Some ，包含一个值；要么是 None ，表示空值。
Option 在 Rust 代码中十分常见，因为它有许多用途：
- 初始值
- 输入值不符合定义的情况下作为函数的返回值（部分函数）。
- 返回 None 作为简单错误的返回值
- 可选的结构字段
- 可以借用或 "取走" 的结构字段（的值）
- 可选的函数参数
- 空指针
- 在某些情况下交换值*

译注：“在某些情况下交换值”可以假设有个可变数组，现在要通过两个可变引用来交换其中两个元素的值。但 Rust 显然不允许有两个对数组的可变引用，这时候可以用 Option 包装下元素值，比如：

``` rust
fn main() {
    let mut array = vec![Some(1), Some(2)];
    let a = array.get_mut(0).unwrap().take().unwrap();
    let b = array.get_mut(1).unwrap().replace(a);
    *array.get_mut(0).unwrap() = b;
    println!("{:?}", array);// [Some(2), Some(1)]
}
```

嘿嘿，有点强行了。
[示例参考](https://zulip-archive.rust-lang.org/stream/122651-general/topic/.60Option.60.20.22swapping.20things.20out.20of.20difficult.20situations.22.3F.html)
[关于 Option 的描述来自于](https://doc.rust-lang.org/std/option/)

## 更多信息

- [Option Enum Format](https://doc.rust-lang.org/stable/book/ch10-01-syntax.html#in-enum-definitions)
- [Option Module Documentation](https://doc.rust-lang.org/std/option/)
- [Option Enum Documentation](https://doc.rust-lang.org/std/option/enum.Option.html)



================================================
FILE: assets/rustlings-zh/exercises/option/option1.rs
================================================
// option1.rs
// 让我通过编译！执行 `rustlings hint option1` 获取提示！

// I AM NOT DONE

// 你可以自由修改代码，但这个函数签名除外。
fn print_number(maybe_number: Option<u16>) {
    println!("printing: {}", maybe_number.unwrap());
}

fn main() {
    print_number(13);
    print_number(99);

    let mut numbers: [Option<u16>; 5];
    for iter in 0..5 {
        let number_to_add: u16 = {
            ((iter * 1235) + 2) / (4 * 16)
        };

        numbers[iter as usize] = number_to_add;
    }
}



================================================
FILE: assets/rustlings-zh/exercises/option/option2.rs
================================================
// option2.rs
// 让我通过编译！执行 `rustlings hint option2` 获取提示！

// I AM NOT DONE

fn main() {
    let optional_word = Some(String::from("rustlings"));
    // TODO：改成适用于值为 "Some" 类型的 if let 语句，
    word = optional_word {
        println!("The word is: {}", word);
    } else {
        println!("The optional word doesn't contain anything");
    }

    let mut optional_integers_vec: Vec<Option<i8>> = Vec::new();
    for x in 1..10 {
        optional_integers_vec.push(Some(x));
    }

    // TODO：改成 while let 语句——记住，vector.pop 的返回类型为 Option<T>。
    // 你可以多次层叠地对 `Option<T>` 使用 while let 或 if let
    integer = optional_integers_vec.pop() {
        println!("current value: {}", integer);
    }
}



================================================
FILE: assets/rustlings-zh/exercises/option/option3.rs
================================================
// option3.rs
// 让我通过编译！执行 `rustlings hint option3` 获取提示

// I AM NOT DONE

struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let y: Option<Point> = Some(Point { x: 100, y: 200 });

    match y {
        Some(p) => println!("Co-ordinates are {},{} ", p.x, p.y),
        _ => println!("no match"),
    }
    y; // 无需删除这行就可以解决。
}



================================================
FILE: assets/rustlings-zh/exercises/primitive_types/README.md
================================================
# 基本类型（Primitive Types）

Rust 有几个直接在编译器中实现基本类型。在本节中，我们来看看最重要的几个。

## 更多信息

- [Data Types](https://doc.rust-lang.org/stable/book/ch03-02-data-types.html)
- [The Slice Type](https://doc.rust-lang.org/stable/book/ch04-03-slices.html)



================================================
FILE: assets/rustlings-zh/exercises/primitive_types/primitive_types1.rs
================================================
// primitive_types1.rs
// 补充不完整代码行的缺失部分！
// 没有提示，也没有什么诀窍，只要习惯于键入这些内容就可以了 :)

// I AM NOT DONE

fn main() {
    // Booleans (`bool`)

    let is_morning = true;
    if is_morning {
        println!("Good morning!");// 译："早上好"
    }

    let // 参照上面的示例来补充这一行的缺失部分！或者让它值为 false ！
    if is_evening {
        println!("Good evening!");// 译："晚上好"
    }
}



================================================
FILE: assets/rustlings-zh/exercises/primitive_types/primitive_types2.rs
================================================
// primitive_types2.rs
// 补充不完整代码行的缺失部分！
// 没有提示，也没有什么诀窍，只要习惯于键入这些内容就可以了 :)

// I AM NOT DONE

fn main() {
    // Characters (`char`)

    let my_first_initial = 'C';
    if my_first_initial.is_alphabetic() {
        println!("Alphabetical!");// 译："字母！"
    } else if my_first_initial.is_numeric() {
        println!("Numerical!");// 译："数字！"
    } else {
        println!("Neither alphabetic nor numeric!");// 译："既不是字母也不是数字！"
    }

    let // 像上面的示例一样完成这行代码！你最喜欢的角色是什么？
    // 试试一个字母，或者一个数字，也可以一个特殊字符，又或者一个不属于
    // 你母语的字符，一个表情符号看起来也不错。
    if your_character.is_alphabetic() {
        println!("Alphabetical!");
    } else if your_character.is_numeric() {
        println!("Numerical!");
    } else {
        println!("Neither alphabetic nor numeric!");
    }
}



================================================
FILE: assets/rustlings-zh/exercises/primitive_types/primitive_types3.rs
================================================
// primitive_types3.rs
// 在 ??? 处创建一个不少于 100 个元素的数组。
// 执行 `rustex hint primitive_types3` 获取提示！

// I AM NOT DONE

fn main() {
    let a = ???

    if a.len() >= 100 {
        println!("Wow, that's a big array!");// 译："哇！那数组可真大！"
    } else {
        println!("Meh, I eat arrays like that for breakfast.");// 译："嗯，我把这样的数组当早餐吃。"
    }
}



================================================
FILE: assets/rustlings-zh/exercises/primitive_types/primitive_types4.rs
================================================
// primitive_types4.rs
// 在 ??? 处获取数组 a 的一个切片（slice），以通过测试。
// 执行 `rustex hint primitive_types4` 获取提示！!

// I AM NOT DONE

#[test]
fn slice_out_of_array() {
    let a = [1, 2, 3, 4, 5];

    let nice_slice = ???

    assert_eq!([2, 3, 4], nice_slice)
}



================================================
FILE: assets/rustlings-zh/exercises/primitive_types/primitive_types5.rs
================================================
// primitive_types5.rs
// 对 `cat` 元组进行解构（Destructure），使 println 能够运行。
// 执行 `rustex hint primitive_types5` 获取提示！

// I AM NOT DONE

fn main() {
    let cat = ("Furry McFurson", 3.5);
    let /* your pattern here */ = cat;// 译：模式写在这

    println!("{} is {} years old.", name, age);
}



================================================
FILE: assets/rustlings-zh/exercises/primitive_types/primitive_types6.rs
================================================
// primitive_types6.rs
// 使用元组索引（tuple index）来访问 `numbers` 的第二个元素。
// 你可以把第二个元素的表达式放在 ??? 处，这样测试就会通过。
// 执行 `rustex hint primitive_types6` 获取提示！

// I AM NOT DONE

#[test]
fn indexing_tuple() {
    let numbers = (1, 2, 3);
    // 用元组索引的语法替换下面的 ???
    let second = ???;

    assert_eq!(2, second,
        "This is not the 2nd number in the tuple!")// 译：这不是元组中的第二个数字!
}



================================================
FILE: assets/rustlings-zh/exercises/standard_library_types/README.md
================================================
# Standard library types

This section will teach you about Box, Shared-State Concurrency and Iterators.

## Further information

- [Using Box to Point to Data on the Heap](https://doc.rust-lang.org/book/ch15-01-box.html)
- [Shared-State Concurrency](https://doc.rust-lang.org/book/ch16-03-shared-state.html)
- [Iterator](https://doc.rust-lang.org/book/ch13-02-iterators.html)
- [Iterator documentation](https://doc.rust-lang.org/stable/std/iter/)



================================================
FILE: assets/rustlings-zh/exercises/standard_library_types/arc1.rs
================================================
// arc1.rs
// In this exercise, we are given a Vec of u32 called "numbers" with values ranging
// from 0 to 99 -- [ 0, 1, 2, ..., 98, 99 ]
// We would like to use this set of numbers within 8 different threads simultaneously.
// Each thread is going to get the sum of every eighth value, with an offset.
// The first thread (offset 0), will sum 0, 8, 16, ...
// The second thread (offset 1), will sum 1, 9, 17, ...
// The third thread (offset 2), will sum 2, 10, 18, ...
// ...
// The eighth thread (offset 7), will sum 7, 15, 23, ...

// Because we are using threads, our values need to be thread-safe.  Therefore,
// we are using Arc.  We need to make a change in each of the two TODOs.


// Make this code compile by filling in a value for `shared_numbers` where the
// first TODO comment is, and create an initial binding for `child_numbers`
// where the second TODO comment is. Try not to create any copies of the `numbers` Vec!
// Execute `rustlings hint arc1` for hints :)

// I AM NOT DONE

#![forbid(unused_imports)] // Do not change this, (or the next) line.
use std::sync::Arc;
use std::thread;

fn main() {
    let numbers: Vec<_> = (0..100u32).collect();
    let shared_numbers = // TODO
    let mut joinhandles = Vec::new();

    for offset in 0..8 {
        let child_numbers = // TODO
        joinhandles.push(thread::spawn(move || {
            let mut i = offset;
            let mut sum = 0;
            while i < child_numbers.len() {
                sum += child_numbers[i];
                i += 8;
            }
            println!("Sum of offset {} is {}", offset, sum);
        }));
    }
    for handle in joinhandles.into_iter() {
        handle.join().unwrap();
    }
}



================================================
FILE: assets/rustlings-zh/exercises/standard_library_types/box1.rs
================================================
// box1.rs
//
// At compile time, Rust needs to know how much space a type takes up. This becomes problematic
// for recursive types, where a value can have as part of itself another value of the same type.
// To get around the issue, we can use a `Box` - a smart pointer used to store data on the heap,
// which also allows us to wrap a recursive type.
//
// The recursive type we're implementing in this exercise is the `cons list` - a data structure
// frequently found in functional programming languages. Each item in a cons list contains two
// elements: the value of the current item and the next item. The last item is a value called `Nil`.
//
// Step 1: use a `Box` in the enum definition to make the code compile
// Step 2: create both empty and non-empty cons lists by replacing `unimplemented!()`
//
// Note: the tests should not be changed
//
// Execute `rustlings hint box1` for hints :)

// I AM NOT DONE

#[derive(PartialEq, Debug)]
pub enum List {
    Cons(i32, List),
    Nil,
}

fn main() {
    println!("This is an empty cons list: {:?}", create_empty_list());
    println!(
        "This is a non-empty cons list: {:?}",
        create_non_empty_list()
    );
}

pub fn create_empty_list() -> List {
    unimplemented!()
}

pub fn create_non_empty_list() -> List {
    unimplemented!()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_empty_list() {
        assert_eq!(List::Nil, create_empty_list())
    }

    #[test]
    fn test_create_non_empty_list() {
        assert_ne!(create_empty_list(), create_non_empty_list())
    }
}



================================================
FILE: assets/rustlings-zh/exercises/standard_library_types/iterators1.rs
================================================
// iterators1.rs
//
//  Make me compile by filling in the `???`s
//
// When performing operations on elements within a collection, iterators are essential.
// This module helps you get familiar with the structure of using an iterator and
// how to go through elements within an iterable collection.
//
// Execute `rustlings hint iterators1` for hints :D

// I AM NOT DONE

fn main () {
    let my_fav_fruits = vec!["banana", "custard apple", "avocado", "peach", "raspberry"];

    let mut my_iterable_fav_fruits = ???;   // TODO: Step 1

    assert_eq!(my_iterable_fav_fruits.next(), Some(&"banana"));
    assert_eq!(my_iterable_fav_fruits.next(), ???);     // TODO: Step 2
    assert_eq!(my_iterable_fav_fruits.next(), Some(&"avocado"));
    assert_eq!(my_iterable_fav_fruits.next(), ???);     // TODO: Step 2.1
    assert_eq!(my_iterable_fav_fruits.next(), Some(&"raspberry"));
    assert_eq!(my_iterable_fav_fruits.next(), ???);     // TODO: Step 3
}



================================================
FILE: assets/rustlings-zh/exercises/standard_library_types/iterators2.rs
================================================
// iterators2.rs
// In this exercise, you'll learn some of the unique advantages that iterators
// can offer. Follow the steps to complete the exercise.
// As always, there are hints if you execute `rustlings hint iterators2`!

// I AM NOT DONE

// Step 1.
// Complete the `capitalize_first` function.
// "hello" -> "Hello"
pub fn capitalize_first(input: &str) -> String {
    let mut c = input.chars();
    match c.next() {
        None => String::new(),
        Some(first) => ???,
    }
}

// Step 2.
// Apply the `capitalize_first` function to a slice of string slices.
// Return a vector of strings.
// ["hello", "world"] -> ["Hello", "World"]
pub fn capitalize_words_vector(words: &[&str]) -> Vec<String> {
    vec![]
}

// Step 3.
// Apply the `capitalize_first` function again to a slice of string slices.
// Return a single string.
// ["hello", " ", "world"] -> "Hello World"
pub fn capitalize_words_string(words: &[&str]) -> String {
    String::new()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_success() {
        assert_eq!(capitalize_first("hello"), "Hello");
    }

    #[test]
    fn test_empty() {
        assert_eq!(capitalize_first(""), "");
    }

    #[test]
    fn test_iterate_string_vec() {
        let words = vec!["hello", "world"];
        assert_eq!(capitalize_words_vector(&words), ["Hello", "World"]);
    }

    #[test]
    fn test_iterate_into_string() {
        let words = vec!["hello", " ", "world"];
        assert_eq!(capitalize_words_string(&words), "Hello World");
    }
}



================================================
FILE: assets/rustlings-zh/exercises/standard_library_types/iterators3.rs
================================================
// iterators3.rs
// This is a bigger exercise than most of the others! You can do it!
// Here is your mission, should you choose to accept it:
// 1. Complete the divide function to get the first four tests to pass.
// 2. Get the remaining tests to pass by completing the result_with_list and
//    list_of_results functions.
// Execute `rustlings hint iterators3` to get some hints!

// I AM NOT DONE

#[derive(Debug, PartialEq, Eq)]
pub enum DivisionError {
    NotDivisible(NotDivisibleError),
    DivideByZero,
}

#[derive(Debug, PartialEq, Eq)]
pub struct NotDivisibleError {
    dividend: i32,
    divisor: i32,
}

// Calculate `a` divided by `b` if `a` is evenly divisible by `b`.
// Otherwise, return a suitable error.
pub fn divide(a: i32, b: i32) -> Result<i32, DivisionError> {}

// Complete the function and return a value of the correct type so the test passes.
// Desired output: Ok([1, 11, 1426, 3])
fn result_with_list() -> () {
    let numbers = vec![27, 297, 38502, 81];
    let division_results = numbers.into_iter().map(|n| divide(n, 27));
}

// Complete the function and return a value of the correct type so the test passes.
// Desired output: [Ok(1), Ok(11), Ok(1426), Ok(3)]
fn list_of_results() -> () {
    let numbers = vec![27, 297, 38502, 81];
    let division_results = numbers.into_iter().map(|n| divide(n, 27));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_success() {
        assert_eq!(divide(81, 9), Ok(9));
    }

    #[test]
    fn test_not_divisible() {
        assert_eq!(
            divide(81, 6),
            Err(DivisionError::NotDivisible(NotDivisibleError {
                dividend: 81,
                divisor: 6
            }))
        );
    }

    #[test]
    fn test_divide_by_0() {
        assert_eq!(divide(81, 0), Err(DivisionError::DivideByZero));
    }

    #[test]
    fn test_divide_0_by_something() {
        assert_eq!(divide(0, 81), Ok(0));
    }

    #[test]
    fn test_result_with_list() {
        assert_eq!(format!("{:?}", result_with_list()), "Ok([1, 11, 1426, 3])");
    }

    #[test]
    fn test_list_of_results() {
        assert_eq!(
            format!("{:?}", list_of_results()),
            "[Ok(1), Ok(11), Ok(1426), Ok(3)]"
        );
    }
}



================================================
FILE: assets/rustlings-zh/exercises/standard_library_types/iterators4.rs
================================================
// iterators4.rs

// I AM NOT DONE

pub fn factorial(num: u64) -> u64 {
    // Complete this function to return the factorial of num
    // Do not use:
    // - return
    // Try not to use:
    // - imperative style loops (for, while)
    // - additional variables
    // For an extra challenge, don't use:
    // - recursion
    // Execute `rustlings hint iterators4` for hints.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn factorial_of_1() {
        assert_eq!(1, factorial(1));
    }
    #[test]
    fn factorial_of_2() {
        assert_eq!(2, factorial(2));
    }

    #[test]
    fn factorial_of_4() {
        assert_eq!(24, factorial(4));
    }
}



================================================
FILE: assets/rustlings-zh/exercises/standard_library_types/iterators5.rs
================================================
// iterators5.rs
// Let's define a simple model to track Rustlings exercise progress. Progress
// will be modelled using a hash map. The name of the exercise is the key and
// the progress is the value. Two counting functions were created to count the
// number of exercises with a given progress. These counting functions use
// imperative style for loops. Recreate this counting functionality using
// iterators. Only the two iterator methods (count_iterator and
// count_collection_iterator) need to be modified.
// Execute `rustlings hint iterators5` for hints.
//
// Make the code compile and the tests pass.

// I AM NOT DONE

use std::collections::HashMap;

#[derive(Clone, Copy, PartialEq, Eq)]
enum Progress {
    None,
    Some,
    Complete,
}

fn count_for(map: &HashMap<String, Progress>, value: Progress) -> usize {
    let mut count = 0;
    for val in map.values() {
        if val == &value {
            count += 1;
        }
    }
    count
}

fn count_iterator(map: &HashMap<String, Progress>, value: Progress) -> usize {
    // map is a hashmap with String keys and Progress values.
    // map = { "variables1": Complete, "from_str": None, ... }
}

fn count_collection_for(collection: &[HashMap<String, Progress>], value: Progress) -> usize {
    let mut count = 0;
    for map in collection {
        for val in map.values() {
            if val == &value {
                count += 1;
            }
        }
    }
    count
}

fn count_collection_iterator(collection: &[HashMap<String, Progress>], value: Progress) -> usize {
    // collection is a slice of hashmaps.
    // collection = [{ "variables1": Complete, "from_str": None, ... },
    //     { "variables2": Complete, ... }, ... ]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn count_complete() {
        let map = get_map();
        assert_eq!(3, count_iterator(&map, Progress::Complete));
    }

    #[test]
    fn count_equals_for() {
        let map = get_map();
        assert_eq!(
            count_for(&map, Progress::Complete),
            count_iterator(&map, Progress::Complete)
        );
    }

    #[test]
    fn count_collection_complete() {
        let collection = get_vec_map();
        assert_eq!(
            6,
            count_collection_iterator(&collection, Progress::Complete)
        );
    }

    #[test]
    fn count_collection_equals_for() {
        let collection = get_vec_map();
        assert_eq!(
            count_collection_for(&collection, Progress::Complete),
            count_collection_iterator(&collection, Progress::Complete)
        );
    }

    fn get_map() -> HashMap<String, Progress> {
        use Progress::*;

        let mut map = HashMap::new();
        map.insert(String::from("variables1"), Complete);
        map.insert(String::from("functions1"), Complete);
        map.insert(String::from("hashmap1"), Complete);
        map.insert(String::from("arc1"), Some);
        map.insert(String::from("as_ref_mut"), None);
        map.insert(String::from("from_str"), None);

        map
    }

    fn get_vec_map() -> Vec<HashMap<String, Progress>> {
        use Progress::*;

        let map = get_map();

        let mut other = HashMap::new();
        other.insert(String::from("variables2"), Complete);
        other.insert(String::from("functions2"), Complete);
        other.insert(String::from("if1"), Complete);
        other.insert(String::from("from_into"), None);
        other.insert(String::from("try_from_into"), None);

        vec![map, other]
    }
}



================================================
FILE: assets/rustlings-zh/exercises/strings/README.md
================================================
# 字符串

Rust 有两种字符串类型，一种是字符串切片（`&str`），另一种是拥有所有权的字符串（`String`）。我们不打算向你说明何时使用其中哪一种，但我们将为你讲解如何区分和创建它们，并灵活使用。

## 更多信息

- [Strings](https://doc.rust-lang.org/book/ch08-02-strings.html)



================================================
FILE: assets/rustlings-zh/exercises/strings/strings1.rs
================================================
// strings1.rs
// 在不改变函数签名的要求下通过编译！
// 执行 `rustlings hint strings1` 获取提示 ;)

// I AM NOT DONE

fn main() {
    let answer = current_favorite_color();
    println!("My current favorite color is {}", answer);// 译："当前我最喜爱的颜色是 {}"
}

// 译：当前最喜爱的颜色
fn current_favorite_color() -> String {
    "blue"
}



================================================
FILE: assets/rustlings-zh/exercises/strings/strings2.rs
================================================
// strings2.rs
// 在不改变函数签名的要求下通过编译！
// 执行 `rustlings hint strings2` 获取提示 ;)

// I AM NOT DONE

fn main() {
    let word = String::from("green"); // 尝试不更改这一行 :)
    if is_a_color_word(word) {
        println!("That is a color word I know!");// 译：我知道这个颜色词
    } else {
        println!("That is not a color word I know.");// 译：我不知道这个颜色词
    }
}

// 译：是否是颜色词
fn is_a_color_word(attempt: &str) -> bool {
    attempt == "green" || attempt == "blue" || attempt == "red"
}



================================================
FILE: assets/rustlings-zh/exercises/structs/README.md
================================================
# 结构（Structs）

Rust 有三种结构类型：经典的 C 结构、元组结构和单元结构。

## 更多信息

- [Structures](https://doc.rust-lang.org/book/ch05-01-defining-structs.html)
- [Method Syntax](https://doc.rust-lang.org/book/ch05-03-method-syntax.html)



================================================
FILE: assets/rustlings-zh/exercises/structs/structs1.rs
================================================
// structs1.rs
// 解决所有的 TODO ，通过测试！

// I AM NOT DONE

struct ColorClassicStruct {
    // TODO: 一些东西需要在这里
}

struct ColorTupleStruct(/* TODO: 一些东西需要在这里 */);

#[derive(Debug)]
struct UnitStruct;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn classic_c_structs() {
        // TODO: 实例化一个经典的 C 结构体！
        // let green =

        assert_eq!(green.name, "green");
        assert_eq!(green.hex, "#00FF00");
    }

    #[test]
    fn tuple_structs() {
        // TODO: 实例化一个元组结构！
        // let green =

        assert_eq!(green.0, "green");
        assert_eq!(green.1, "#00FF00");
    }

    #[test]
    fn unit_structs() {
        // TODO: 实例化一个单元结构！
        // let unit_struct =
        let message = format!("{:?}s are fun!", unit_struct);

        assert_eq!(message, "UnitStructs are fun!");
    }
}



================================================
FILE: assets/rustlings-zh/exercises/structs/structs2.rs
================================================
// structs2.rs
// 解决所有的 TODO ，通过测试！

// I AM NOT DONE

#[derive(Debug)]
struct Order {
    name: String,
    year: u32,
    made_by_phone: bool,
    made_by_mobile: bool,
    made_by_email: bool,
    item_number: u32,
    count: u32,
}

fn create_order_template() -> Order {
    Order {
        name: String::from("Bob"),
        year: 2019,
        made_by_phone: false,
        made_by_mobile: false,
        made_by_email: true,
        item_number: 123,
        count: 0,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn your_order() {
        let order_template = create_order_template();
        // TODO: 利用上面的模板（template 是模板的意思）然后改变其中的一些值来创建属于你的订单！
        // let your_order =
        assert_eq!(your_order.name, "Hacker in Rust");
        assert_eq!(your_order.year, order_template.year);
        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);
        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);
        assert_eq!(your_order.made_by_email, order_template.made_by_email);
        assert_eq!(your_order.item_number, order_template.item_number);
        assert_eq!(your_order.count, 1);
    }
}



================================================
FILE: assets/rustlings-zh/exercises/structs/structs3.rs
================================================
// structs3.rs
// 接口既可以包含数据也可以处理逻辑。
// 在这个练习中，我们已经定义了 Package 结构，但我们想测试一些根据它实现的逻辑。
// 让代码通过编译和测试！
// 如果你有问题，可以执行 `rustlings hint structs3` 查看提示

// I AM NOT DONE

#[derive(Debug)]
struct Package {// 译：包裹
    sender_country: String,// 译：寄件人国家
    recipient_country: String,// 译：收件人国家
    weight_in_grams: i32,// 译：重量（克）
}

impl Package {
    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -> Package {
        if weight_in_grams <= 0 {
            // 这里需要完成一些东西……
        } else {
            Package {
                sender_country,
                recipient_country,
                weight_in_grams,
            }
        }
    }

    fn is_international(&self) -> ??? {// 译：是否是国际上的
        // 这里需要完成一些东西……
    }

    fn get_fees(&self, cents_per_gram: i32) -> ??? {// 译：获取所需费用
        // 这里需要完成一些东西……
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn fail_creating_weightless_package() {// 译：失败地创建没有重量的包裹
        let sender_country = String::from("Spain");// 译：西班牙
        let recipient_country = String::from("Austria");// 译：奥地利

        Package::new(sender_country, recipient_country, -2210);
    }

    #[test]
    fn create_international_package() {// 译：创建国际上的包裹
        let sender_country = String::from("Spain");
        let recipient_country = String::from("Russia");

        let package = Package::new(sender_country, recipient_country, 1200);

        assert!(package.is_international());
    }

    #[test]
    fn create_local_package() {
        let sender_country = String::from("Canada");
        let recipient_country = sender_country.clone();

        let package = Package::new(sender_country, recipient_country, 1200);

        assert!(!package.is_international());
    }

    #[test]
    fn calculate_transport_fees() {// 译：计算运输费
        let sender_country = String::from("Spain");
        let recipient_country = String::from("Spain");

        let cents_per_gram = 3;// 译：分/克（一克需要多少分钱）

        let package = Package::new(sender_country, recipient_country, 1500);

        assert_eq!(package.get_fees(cents_per_gram), 4500);
    }
}



================================================
FILE: assets/rustlings-zh/exercises/tests/README.md
================================================
# 测试

这次不按书本上的顺序介绍测试——接下来的很多练习都会要求你通过测试！

## 更多信息

- [Writing Tests](https://doc.rust-lang.org/book/ch11-01-writing-tests.html)



================================================
FILE: assets/rustlings-zh/exercises/tests/tests1.rs
================================================
// tests1.rs
// 测试对于确保代码实现了预期功能非常重要。
// 可以用下面的命令对当前文件中的代码进行测试：
// rustlings run tests1

// 关于测试还有个问题——如何成功编译测试、通过测试或者使测试失败？
// 执行 `rustlings hint tests1` 获取提示 :)

// I AM NOT DONE

#[cfg(test)]
mod tests {
    #[test]
    fn you_can_assert() {
        assert!();
    }
}



================================================
FILE: assets/rustlings-zh/exercises/tests/tests2.rs
================================================
// tests2.rs
// 让测试能够编译然后通过测试和使测试失败！
// 执行 `rustlings hint tests2` 获取提示 :)

// I AM NOT DONE

#[cfg(test)]
mod tests {
    #[test]
    fn you_can_assert_eq() {
        assert_eq!();
    }
}



================================================
FILE: assets/rustlings-zh/exercises/tests/tests3.rs
================================================
// tests3.rs
// 这个测试不是在测试我们的函数——想些方法让它的返回值可以通过测试。
// 在第二个测试判断调用 `is_even(5)` 是否得到了预期的结果。
// 执行 `rustlings hint tests3` 获取提示 :)

// I AM NOT DONE

pub fn is_even(num: i32) -> bool {
    num % 2 == 0
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_true_when_even() {// 偶数将返回 true
        assert!();
    }

    #[test]
    fn is_false_when_odd() {// 奇数将返回 false
        assert!();
    }
}



================================================
FILE: assets/rustlings-zh/exercises/threads/README.md
================================================
# Threads

In most current operating systems, an executed program’s code is run in a process, and the operating system manages multiple processes at once.
Within your program, you can also have independent parts that run simultaneously. The features that run these independent parts are called threads.

## Further information

- [Dining Philosophers example](https://doc.rust-lang.org/1.4.0/book/dining-philosophers.html)
- [Using Threads to Run Code Simultaneously](https://doc.rust-lang.org/book/ch16-01-threads.html)



================================================
FILE: assets/rustlings-zh/exercises/threads/threads1.rs
================================================
// threads1.rs
// Make this compile! Execute `rustlings hint threads1` for hints :)
// The idea is the thread spawned on line 22 is completing jobs while the main thread is
// monitoring progress until 10 jobs are completed. Because of the difference between the
// spawned threads' sleep time, and the waiting threads sleep time, when you see 6 lines
// of "waiting..." and the program ends without timing out when running,
// you've got it :)

// I AM NOT DONE

use std::sync::Arc;
use std::thread;
use std::time::Duration;

struct JobStatus {
    jobs_completed: u32,
}

fn main() {
    let status = Arc::new(JobStatus { jobs_completed: 0 });
    let status_shared = status.clone();
    thread::spawn(move || {
        for _ in 0..10 {
            thread::sleep(Duration::from_millis(250));
            status_shared.jobs_completed += 1;
        }
    });
    while status.jobs_completed < 10 {
        println!("waiting... ");
        thread::sleep(Duration::from_millis(500));
    }
}



================================================
FILE: assets/rustlings-zh/exercises/traits/README.md
================================================
# Traits

Trait 是一系列方法的集合。

数据类型可以实现 trait。为此需要帮数据类型定义好构成 trait 的方法。 
例如，`String` 类型实现了 `From<&str>` trait。它赋予我们能力写出 `String::from("hello")`。

如此一来，trait 就有点类似于 Java 的接口和 C++ 的抽象类。

另外一些常见的 Rust trait 包括：
- `Clone` （`clone` 方法）
- `Display` (实现通过 `{}` 进行格式化显示)
- `Debug` (实现通过 `{:?}` 进行格式化显示 )

因为 trait 标明了数据类型之间的共有行为，所以它在编写泛型时非常有用。

## 更多信息

- [Traits](https://doc.rust-lang.org/book/ch10-02-traits.html)



================================================
FILE: assets/rustlings-zh/exercises/traits/traits1.rs
================================================
// traits1.rs
// 是时候来实现些 trait 了！
//
// 你的任务是为 `String` 实现 `AppendBar` trait。
//
// `AppendBar` 只有一个函数，它将 "Bar" 追加到任何实现该 trait 的对象上。
// 译：Append 有追加、附加的意思，所以“追加/附加 Bar”。

// I AM NOT DONE

trait AppendBar {
    fn append_bar(self) -> Self;
}

impl AppendBar for String {
    // 在这里编写代码
}

fn main() {
    let s = String::from("Foo");
    let s = s.append_bar();
    println!("s: {}", s);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_foo_bar() {
        assert_eq!(String::from("Foo").append_bar(), String::from("FooBar"));
    }

    #[test]
    fn is_bar_bar() {
        assert_eq!(
            String::from("").append_bar().append_bar(),
            String::from("BarBar")
        );
    }
}



================================================
FILE: assets/rustlings-zh/exercises/traits/traits2.rs
================================================
// traits2.rs
//
// 你的任务是为一个字符串 vector 实现 `AppendBar` trait。
//
// 为了实现该 trait，请思考下将 "Bar" 追加到字符串 vector 的意义是什么？ 
//
// 这次没有样板代码，相信自己！ 

// I AM NOT DONE

trait AppendBar {
    fn append_bar(self) -> Self;
}

//TODO：在这编写代码

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_vec_pop_eq_bar() {
        let mut foo = vec![String::from("Foo")].append_bar();
        assert_eq!(foo.pop().unwrap(), String::from("Bar"));
        assert_eq!(foo.pop().unwrap(), String::from("Foo"));
    }
}



================================================
FILE: assets/rustlings-zh/exercises/variables/README.md
================================================
# 变量（Variables）

在 Rust，变量默认是不可变的.
不可变意味着当一个值被绑定到某个名字上，你就不能再对这个值做出更改。
当然，你可以通过在变量名前添加 mut 来使它们变得可变。

## 更多信息

- [Variables and Mutability](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html)



================================================
FILE: assets/rustlings-zh/exercises/variables/variables1.rs
================================================
// variables1.rs
// 让我能够编译！执行 `rustex hint variables1` 获取提示 :)

// 关于 `I AM NOT DONE`：
// 即使你已经想到了解决方案，我们有时也会鼓励你在特定的练习
// 继续去尝试做到更好。如果你已经通过练习并做好了应对下一题
// 的准备, 请删除下面的 `I AM NOT DONE` 注释。

// I AM NOT DONE

/// 翻译: [mg-chao](https://github.com/mg-chao)
/// 加油 💪
fn main() {
    x = 5;
    println!("x has the value {}", x);// 译：x 的值是
}



================================================
FILE: assets/rustlings-zh/exercises/variables/variables2.rs
================================================
// variables2.rs
// 让我能够编译！执行 `rustex hint variables2` 获取提示 :)

// I AM NOT DONE

/// 翻译: [mg-chao](https://github.com/mg-chao)
fn main() {
    let x;
    if x == 10 {
        println!("Ten!");// 译：十！
    } else {
        println!("Not ten!");// 译：不是十！
    }
}



================================================
FILE: assets/rustlings-zh/exercises/variables/variables3.rs
================================================
// variables3.rs
// 让我能够编译！执行 `rustex hint variables3` 获取提示 :)

// I AM NOT DONE

/// 翻译: [mg-chao](https://github.com/mg-chao)
fn main() {
    let x = 3;
    println!("Number {}", x);// 译："数字 {}"
    x = 5; // don't change this line（译：不要更改这一行）
    println!("Number {}", x);
}



================================================
FILE: assets/rustlings-zh/exercises/variables/variables4.rs
================================================
// variables4.rs
// 让我能够编译！执行 `rustex hint variables4` 获取提示 :)

// I AM NOT DONE

/// 翻译: [mg-chao](https://github.com/mg-chao)
fn main() {
    let x: i32;
    println!("Number {}", x);
}



================================================
FILE: assets/rustlings-zh/exercises/variables/variables5.rs
================================================
// variables5.rs
// 让我能够编译！执行 `rustex hint variables5` 获取提示 :)

// I AM NOT DONE

/// 翻译: [mg-chao](https://github.com/mg-chao)
fn main() {
    let number = "T-H-R-E-E"; // don't change this line
    println!("Spell a Number : {}", number);// 译："拼接的数字：{}"
    number = 3;
    println!("Number plus two is : {}", number + 2);// 译："数字加上二是：{}"
}



================================================
FILE: assets/rustlings-zh/exercises/variables/variables6.rs
================================================
// variables6.rs
// 让我能够编译！执行 `rustex hint variables6` 获取提示 :)

// I AM NOT DONE

/// 翻译: [mg-chao](https://github.com/mg-chao)
const NUMBER = 3;
fn main() {
    println!("Number {}", NUMBER);
}



================================================
FILE: assets/rustlings-zh/src/exercise.rs
================================================
use regex::Regex;
use serde::Deserialize;
use std::env;
use std::fmt::{self, Display, Formatter};
use std::fs::{self, remove_file, File};
use std::io::Read;
use std::path::PathBuf;
use std::process::{self, Command};

const RUSTC_COLOR_ARGS: &[&str] = &["--color", "always"];
const I_AM_DONE_REGEX: &str = r"(?m)^\s*///?\s*I\s+AM\s+NOT\s+DONE";
const CONTEXT: usize = 2;
const CLIPPY_CARGO_TOML_PATH: &str = "./exercises/clippy/Cargo.toml";

// Get a temporary file name that is hopefully unique
#[inline]
fn temp_file() -> String {
    let thread_id: String = format!("{:?}", std::thread::current().id())
        .chars()
        .filter(|c| c.is_alphanumeric())
        .collect();

    format!("./temp_{}_{}", process::id(), thread_id)
}

// The mode of the exercise.
#[derive(Deserialize, Copy, Clone, Debug)]
#[serde(rename_all = "lowercase")]
pub enum Mode {
    // Indicates that the exercise should be compiled as a binary
    Compile,
    // Indicates that the exercise should be compiled as a test harness
    Test,
    // Indicates that the exercise should be linted with clippy
    Clippy,
}

#[derive(Deserialize)]
pub struct ExerciseList {
    pub exercises: Vec<Exercise>,
}

// A representation of a rustlings exercise.
// This is deserialized from the accompanying info.toml file
#[derive(Deserialize, Debug)]
pub struct Exercise {
    // Name of the exercise
    pub name: String,
    // The path to the file containing the exercise's source code
    pub path: PathBuf,
    // The mode of the exercise (Test, Compile, or Clippy)
    pub mode: Mode,
    // The hint text associated with the exercise
    pub hint: String,
}

// An enum to track of the state of an Exercise.
// An Exercise can be either Done or Pending
#[derive(PartialEq, Debug)]
pub enum State {
    // The state of the exercise once it's been completed
    Done,
    // The state of the exercise while it's not completed yet
    Pending(Vec<ContextLine>),
}

// The context information of a pending exercise
#[derive(PartialEq, Debug)]
pub struct ContextLine {
    // The source code that is still pending completion
    pub line: String,
    // The line number of the source code still pending completion
    pub number: usize,
    // Whether or not this is important
    pub important: bool,
}

// The result of compiling an exercise
pub struct CompiledExercise<'a> {
    exercise: &'a Exercise,
    _handle: FileHandle,
}

impl<'a> CompiledExercise<'a> {
    // Run the compiled exercise
    pub fn run(&self) -> Result<ExerciseOutput, ExerciseOutput> {
        self.exercise.run()
    }
}

// A representation of an already executed binary
#[derive(Debug)]
pub struct ExerciseOutput {
    // The textual contents of the standard output of the binary
    pub stdout: String,
    // The textual contents of the standard error of the binary
    pub stderr: String,
}

struct FileHandle;

impl Drop for FileHandle {
    fn drop(&mut self) {
        clean();
    }
}

impl Exercise {
    pub fn compile(&self) -> Result<CompiledExercise, ExerciseOutput> {
        let cmd = match self.mode {
            Mode::Compile => Command::new("rustc")
                .args(&[self.path.to_str().unwrap(), "-o", &temp_file()])
                .args(RUSTC_COLOR_ARGS)
                .output(),
            Mode::Test => Command::new("rustc")
                .args(&["--test", self.path.to_str().unwrap(), "-o", &temp_file()])
                .args(RUSTC_COLOR_ARGS)
                .output(),
            Mode::Clippy => {
                let cargo_toml = format!(
                    r#"[package]
name = "{}"
version = "0.0.1"
edition = "2018"
[[bin]]
name = "{}"
path = "{}.rs""#,
                    self.name, self.name, self.name
                );
                let cargo_toml_error_msg = if env::var("NO_EMOJI").is_ok() {
                    "Failed to write Clippy Cargo.toml file."
                } else {
                    "Failed to write 📎 Clippy 📎 Cargo.toml file."
                };
                fs::write(CLIPPY_CARGO_TOML_PATH, cargo_toml).expect(cargo_toml_error_msg);
                // To support the ability to run the clippy exercises, build
                // an executable, in addition to running clippy. With a
                // compilation failure, this would silently fail. But we expect
                // clippy to reflect the same failure while compiling later.
                Command::new("rustc")
                    .args(&[self.path.to_str().unwrap(), "-o", &temp_file()])
                    .args(RUSTC_COLOR_ARGS)
                    .output()
                    .expect("Failed to compile!");
                // Due to an issue with Clippy, a cargo clean is required to catch all lints.
                // See https://github.com/rust-lang/rust-clippy/issues/2604
                // This is already fixed on Clippy's master branch. See this issue to track merging into Cargo:
                // https://github.com/rust-lang/rust-clippy/issues/3837
                Command::new("cargo")
                    .args(&["clean", "--manifest-path", CLIPPY_CARGO_TOML_PATH])
                    .args(RUSTC_COLOR_ARGS)
                    .output()
                    .expect("Failed to run 'cargo clean'");
                Command::new("cargo")
                    .args(&["clippy", "--manifest-path", CLIPPY_CARGO_TOML_PATH])
                    .args(RUSTC_COLOR_ARGS)
                    .args(&["--", "-D", "warnings"])
                    .output()
            }
        }
        .expect("Failed to run 'compile' command.");

        if cmd.status.success() {
            Ok(CompiledExercise {
                exercise: self,
                _handle: FileHandle,
            })
        } else {
            clean();
            Err(ExerciseOutput {
                stdout: String::from_utf8_lossy(&cmd.stdout).to_string(),
                stderr: String::from_utf8_lossy(&cmd.stderr).to_string(),
            })
        }
    }

    fn run(&self) -> Result<ExerciseOutput, ExerciseOutput> {
        let arg = match self.mode {
            Mode::Test => "--show-output",
            _ => "",
        };
        let cmd = Command::new(&temp_file())
            .arg(arg)
            .output()
            .expect("Failed to run 'run' command");

        let output = ExerciseOutput {
            stdout: String::from_utf8_lossy(&cmd.stdout).to_string(),
            stderr: String::from_utf8_lossy(&cmd.stderr).to_string(),
        };

        if cmd.status.success() {
            Ok(output)
        } else {
            Err(output)
        }
    }

    pub fn state(&self) -> State {
        let mut source_file =
            File::open(&self.path).expect("We were unable to open the exercise file!");

        let source = {
            let mut s = String::new();
            source_file
                .read_to_string(&mut s)
                .expect("We were unable to read the exercise file!");
            s
        };

        let re = Regex::new(I_AM_DONE_REGEX).unwrap();

        if !re.is_match(&source) {
            return State::Done;
        }

        let matched_line_index = source
            .lines()
            .enumerate()
            .filter_map(|(i, line)| if re.is_match(line) { Some(i) } else { None })
            .next()
            .expect("This should not happen at all");

        let min_line = ((matched_line_index as i32) - (CONTEXT as i32)).max(0) as usize;
        let max_line = matched_line_index + CONTEXT;

        let context = source
            .lines()
            .enumerate()
            .filter(|&(i, _)| i >= min_line && i <= max_line)
            .map(|(i, line)| ContextLine {
                line: line.to_string(),
                number: i + 1,
                important: i == matched_line_index,
            })
            .collect();

        State::Pending(context)
    }

    // Check that the exercise looks to be solved using self.state()
    // This is not the best way to check since
    // the user can just remove the "I AM NOT DONE" string from the file
    // without actually having solved anything.
    // The only other way to truly check this would to compile and run
    // the exercise; which would be both costly and counterintuitive
    pub fn looks_done(&self) -> bool {
        self.state() == State::Done
    }
}

impl Display for Exercise {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        write!(f, "{}", self.path.to_str().unwrap())
    }
}

#[inline]
fn clean() {
    let _ignored = remove_file(&temp_file());
}

#[cfg(test)]
mod test {
    use super::*;
    use std::path::Path;

    #[test]
    fn test_clean() {
        File::create(&temp_file()).unwrap();
        let exercise = Exercise {
            name: String::from("example"),
            path: PathBuf::from("tests/fixture/state/pending_exercise.rs"),
            mode: Mode::Compile,
            hint: String::from(""),
        };
        let compiled = exercise.compile().unwrap();
        drop(compiled);
        assert!(!Path::new(&temp_file()).exists());
    }

    #[test]
    fn test_pending_state() {
        let exercise = Exercise {
            name: "pending_exercise".into(),
            path: PathBuf::from("tests/fixture/state/pending_exercise.rs"),
            mode: Mode::Compile,
            hint: String::new(),
        };

        let state = exercise.state();
        let expected = vec![
            ContextLine {
                line: "// fake_exercise".to_string(),
                number: 1,
                important: false,
            },
            ContextLine {
                line: "".to_string(),
                number: 2,
                important: false,
            },
            ContextLine {
                line: "// I AM NOT DONE".to_string(),
                number: 3,
                important: true,
            },
            ContextLine {
                line: "".to_string(),
                number: 4,
                important: false,
            },
            ContextLine {
                line: "fn main() {".to_string(),
                number: 5,
                important: false,
            },
        ];

        assert_eq!(state, State::Pending(expected));
    }

    #[test]
    fn test_finished_exercise() {
        let exercise = Exercise {
            name: "finished_exercise".into(),
            path: PathBuf::from("tests/fixture/state/finished_exercise.rs"),
            mode: Mode::Compile,
            hint: String::new(),
        };

        assert_eq!(exercise.state(), State::Done);
    }

    #[test]
    fn test_exercise_with_output() {
        let exercise = Exercise {
            name: "exercise_with_output".into(),
            path: PathBuf::from("tests/fixture/success/testSuccess.rs"),
            mode: Mode::Test,
            hint: String::new(),
        };
        let out = exercise.compile().unwrap().run().unwrap();
        assert!(out.stdout.contains("THIS TEST TOO SHALL PASS"));
    }
}



================================================
FILE: assets/rustlings-zh/src/main.rs
================================================
use crate::exercise::{Exercise, ExerciseList};
use crate::run::run;
use crate::verify::verify;
use argh::FromArgs;
use console::Emoji;
use notify::DebouncedEvent;
use notify::{RecommendedWatcher, RecursiveMode, Watcher};
use std::ffi::OsStr;
use std::fs;
use std::io::{self, prelude::*};
use std::path::Path;
use std::process::{Command, Stdio};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::mpsc::{channel, RecvTimeoutError};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

#[macro_use]
mod ui;

mod exercise;
mod run;
mod verify;

// In sync with crate version
const VERSION: &str = "4.6.0";

#[derive(FromArgs, PartialEq, Debug)]
/// Rustlings is a collection of small exercises to get you used to writing and reading Rust code
struct Args {
    /// show outputs from the test exercises
    #[argh(switch)]
    nocapture: bool,
    /// show the executable version
    #[argh(switch, short = 'v')]
    version: bool,
    #[argh(subcommand)]
    nested: Option<Subcommands>,
}

#[derive(FromArgs, PartialEq, Debug)]
#[argh(subcommand)]
enum Subcommands {
    Verify(VerifyArgs),
    Watch(WatchArgs),
    Run(RunArgs),
    Hint(HintArgs),
    List(ListArgs),
}

#[derive(FromArgs, PartialEq, Debug)]
#[argh(subcommand, name = "verify")]
/// Verifies all exercises according to the recommended order
struct VerifyArgs {}

#[derive(FromArgs, PartialEq, Debug)]
#[argh(subcommand, name = "watch")]
/// Reruns `verify` when files were edited
struct WatchArgs {}

#[derive(FromArgs, PartialEq, Debug)]
#[argh(subcommand, name = "run")]
/// Runs/Tests a single exercise
struct RunArgs {
    #[argh(positional)]
    /// the name of the exercise
    name: String,
}

#[derive(FromArgs, PartialEq, Debug)]
#[argh(subcommand, name = "hint")]
/// Returns a hint for the given exercise
struct HintArgs {
    #[argh(positional)]
    /// the name of the exercise
    name: String,
}

#[derive(FromArgs, PartialEq, Debug)]
#[argh(subcommand, name = "list")]
/// Lists the exercises available in Rustlings
struct ListArgs {
    #[argh(switch, short = 'p')]
    /// show only the paths of the exercises
    paths: bool,
    #[argh(switch, short = 'n')]
    /// show only the names of the exercises
    names: bool,
    #[argh(option, short = 'f')]
    /// provide a string to match exercise names
    /// comma separated patterns are acceptable
    filter: Option<String>,
    #[argh(switch, short = 'u')]
    /// display only exercises not yet solved
    unsolved: bool,
    #[argh(switch, short = 's')]
    /// display only exercises that have been solved
    solved: bool,
}

fn main() {
    let args: Args = argh::from_env();

    if args.version {
        println!("v{}", VERSION);
        std::process::exit(0);
    }

    if args.nested.is_none() {
        println!();
        println!(r#"       欢迎来到...                        "#);
        println!(r#"                 _   _ _                  "#);
        println!(r#"  _ __ _   _ ___| |_| (_)_ __   __ _ ___  "#);
        println!(r#" | '__| | | / __| __| | | '_ \ / _` / __| "#);
        println!(r#" | |  | |_| \__ \ |_| | | | | | (_| \__ \ "#);
        println!(r#" |_|   \__,_|___/\__|_|_|_| |_|\__, |___/ "#);
        println!(r#"                               |___/      "#);
        println!();
    }

    if !Path::new("info.toml").exists() {
        println!(
            "{} must be run from the rustlings directory",
            std::env::current_exe().unwrap().to_str().unwrap()
        );
        println!("Try `cd rustlings/`!");
        std::process::exit(1);
    }

    if !rustc_exists() {
        println!("We cannot find `rustc`.");
        println!("Try running `rustc --version` to diagnose your problem.");
        println!("For instructions on how to install Rust, check the README.");
        std::process::exit(1);
    }

    let toml_str = &fs::read_to_string("info.toml").unwrap();
    let exercises = toml::from_str::<ExerciseList>(toml_str).unwrap().exercises;
    let verbose = args.nocapture;

    let command = args.nested.unwrap_or_else(|| {
        let text = fs::read_to_string("default_out.txt").unwrap();
        println!("{}", text);
        std::process::exit(0);
    });
    match command {
        Subcommands::List(subargs) => {
            if !subargs.paths && !subargs.names {
                println!("{:<17}\t{:<46}\t{:<7}", "Name", "Path", "Status");
            }
            let mut exercises_done: u16 = 0;
            let filters = subargs.filter.clone().unwrap_or_default().to_lowercase();
            exercises.iter().for_each(|e| {
                let fname = format!("{}", e.path.display());
                let filter_cond = filters
                    .split(',')
                    .filter(|f| !f.trim().is_empty())
                    .any(|f| e.name.contains(&f) || fname.contains(&f));
                let status = if e.looks_done() {
                    exercises_done += 1;
                    "Done"
                } else {
                    "Pending"
                };
                let solve_cond = {
                    (e.looks_done() && subargs.solved)
                        || (!e.looks_done() && subargs.unsolved)
                        || (!subargs.solved && !subargs.unsolved)
                };
                if solve_cond && (filter_cond || subargs.filter.is_none()) {
                    let line = if subargs.paths {
                        format!("{}\n", fname)
                    } else if subargs.names {
                        format!("{}\n", e.name)
                    } else {
                        format!("{:<17}\t{:<46}\t{:<7}\n", e.name, fname, status)
                    };
                    // Somehow using println! leads to the binary panicking
                    // when its output is piped.
                    // So, we're handling a Broken Pipe error and exiting with 0 anyway
                    let stdout = std::io::stdout();
                    {
                        let mut handle = stdout.lock();
                        handle.write_all(line.as_bytes()).unwrap_or_else(|e| {
                            match e.kind() {
                                std::io::ErrorKind::BrokenPipe => std::process::exit(0),
                                _ => std::process::exit(1),
                            };
                        });
                    }
                }
            });
            let percentage_progress = exercises_done as f32 / exercises.len() as f32 * 100.0;
            println!(
                "Progress: You completed {} / {} exercises ({:.2} %).",
                exercises_done,
                exercises.len(),
                percentage_progress
            );
            std::process::exit(0);
        }

        Subcommands::Run(subargs) => {
            let exercise = find_exercise(&subargs.name, &exercises);

            run(exercise, verbose).unwrap_or_else(|_| std::process::exit(1));
        }

        Subcommands::Hint(subargs) => {
            let exercise = find_exercise(&subargs.name, &exercises);

            println!("{}", exercise.hint);
        }

        Subcommands::Verify(_subargs) => {
            verify(&exercises, verbose).unwrap_or_else(|_| std::process::exit(1));
        }

        Subcommands::Watch(_subargs) => match watch(&exercises, verbose) {
            Err(e) => {
                println!(
                    "Error: Could not watch your progress. Error message was {:?}.",
                    e
                );
                println!("Most likely you've run out of disk space or your 'inotify limit' has been reached.");
                std::process::exit(1);
            }
            Ok(WatchStatus::Finished) => {
                println!(
                    "{emoji} All exercises completed! {emoji}",
                    emoji = Emoji("🎉", "★")
                );
                println!();
                println!("+----------------------------------------------------+");
                println!("|          You made it to the Fe-nish line!          |");
                println!("+--------------------------  ------------------------+");
                println!("                          \\/                         ");
                println!("     ▒▒          ▒▒▒▒▒▒▒▒      ▒▒▒▒▒▒▒▒          ▒▒   ");
                println!("   ▒▒▒▒  ▒▒    ▒▒        ▒▒  ▒▒        ▒▒    ▒▒  ▒▒▒▒ ");
                println!("   ▒▒▒▒  ▒▒  ▒▒            ▒▒            ▒▒  ▒▒  ▒▒▒▒ ");
                println!(" ░░▒▒▒▒░░▒▒  ▒▒            ▒▒            ▒▒  ▒▒░░▒▒▒▒ ");
                println!("   ▓▓▓▓▓▓▓▓  ▓▓      ▓▓██  ▓▓  ▓▓██      ▓▓  ▓▓▓▓▓▓▓▓ ");
                println!("     ▒▒▒▒    ▒▒      ████  ▒▒  ████      ▒▒░░  ▒▒▒▒   ");
                println!("       ▒▒  ▒▒▒▒▒▒        ▒▒▒▒▒▒        ▒▒▒▒▒▒  ▒▒     ");
                println!("         ▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▓▒▒▒▒▒▒▒▒▓▓▒▒▓▓▒▒▒▒▒▒▒▒       ");
                println!("           ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒         ");
                println!("             ▒▒▒▒▒▒▒▒▒▒██▒▒▒▒▒▒██▒▒▒▒▒▒▒▒▒▒           ");
                println!("           ▒▒  ▒▒▒▒▒▒▒▒▒▒██████▒▒▒▒▒▒▒▒▒▒  ▒▒         ");
                println!("         ▒▒    ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒    ▒▒       ");
                println!("       ▒▒    ▒▒    ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒    ▒▒    ▒▒     ");
                println!("       ▒▒  ▒▒    ▒▒                  ▒▒    ▒▒  ▒▒     ");
                println!("           ▒▒  ▒▒                      ▒▒  ▒▒         ");
                println!();
                println!("We hope you enjoyed learning about the various aspects of Rust!");
                println!(
                    "If you noticed any issues, please don't hesitate to report them to our repo."
                );
                println!(
                    "You can also contribute your own exercises to help the greater community!"
                );
                println!();
                println!("Before reporting an issue or contributing, please read our guidelines:");
                println!("https://github.com/rust-lang/rustlings/blob/main/CONTRIBUTING.md");
            }
            Ok(WatchStatus::Unfinished) => {
                println!("We hope you're enjoying learning about Rust!");
                println!("If you want to continue working on the exercises at a later point, you can simply run `rustlings watch` again");
            }
        },
    }
}

fn spawn_watch_shell(
    failed_exercise_hint: &Arc<Mutex<Option<String>>>,
    should_quit: Arc<AtomicBool>,
) {
    let failed_exercise_hint = Arc::clone(failed_exercise_hint);
    println!("欢迎使用 watch 模式！你可以输入 'help' 以查看你在这能够使用的命令概览");
    thread::spawn(move || loop {
        let mut input = String::new();
        match io::stdin().read_line(&mut input) {
            Ok(_) => {
                let input = input.trim();
                if input == "hint" {
                    if let Some(hint) = &*failed_exercise_hint.lock().unwrap() {
                        println!("{}", hint);
                    }
                } else if input == "clear" {
                    println!("\x1B[2J\x1B[1;1H");
                } else if input.eq("quit") {
                    should_quit.store(true, Ordering::SeqCst);
                    println!("再见😊！");
                } else if input.eq("help") {
                    println!("在 watch 模式下可使用的命令:");
                    println!("  hint  - 显示当前练习的提示");
                    println!("  clear - 清理屏幕");
                    println!("  quit  - 退出 watch 模式");
                    println!("  help  - 显示这些帮助信息");
                    println!();
                    println!("当你编辑了练习文件的内容，watch 模式将自动重新评估当前练习");
                } else {
                    println!("未知的命令: {}", input);
                }
            }
            Err(error) => println!("命令读取错误: {}", error),
        }
    });
}

fn find_exercise<'a>(name: &str, exercises: &'a [Exercise]) -> &'a Exercise {
    if name.eq("next") {
        exercises
            .iter()
            .find(|e| !e.looks_done())
            .unwrap_or_else(|| {
                println!("🎉 Congratulations! You have done all the exercises!");
                println!("🔚 There are no more exercises to do next!");
                std::process::exit(1)
            })
    } else {
        exercises
            .iter()
            .find(|e| e.name == name)
            .unwrap_or_else(|| {
                println!("No exercise found for '{}'!", name);
                std::process::exit(1)
            })
    }
}

enum WatchStatus {
    Finished,
    Unfinished,
}

fn watch(exercises: &[Exercise], verbose: bool) -> notify::Result<WatchStatus> {
    /* Clears the terminal with an ANSI escape code.
    Works in UNIX and newer Windows terminals. */
    fn clear_screen() {
        println!("\x1Bc");
    }

    let (tx, rx) = channel();
    let should_quit = Arc::new(AtomicBool::new(false));

    let mut watcher: RecommendedWatcher = Watcher::new(tx, Duration::from_secs(2))?;
    watcher.watch(Path::new("./exercises"), RecursiveMode::Recursive)?;

    clear_screen();

    let to_owned_hint = |t: &Exercise| t.hint.to_owned();
    let failed_exercise_hint = match verify(exercises.iter(), verbose) {
        Ok(_) => return Ok(WatchStatus::Finished),
        Err(exercise) => Arc::new(Mutex::new(Some(to_owned_hint(exercise)))),
    };
    spawn_watch_shell(&failed_exercise_hint, Arc::clone(&should_quit));
    loop {
        match rx.recv_timeout(Duration::from_secs(1)) {
            Ok(event) => match event {
                DebouncedEvent::Create(b) | DebouncedEvent::Chmod(b) | DebouncedEvent::Write(b) => {
                    if b.extension() == Some(OsStr::new("rs")) && b.exists() {
                        let filepath = b.as_path().canonicalize().unwrap();
                        let pending_exercises = exercises
                            .iter()
                            .skip_while(|e| !filepath.ends_with(&e.path))
                            // .filter(|e| filepath.ends_with(&e.path))
                            .chain(
                                exercises
                                    .iter()
                                    .filter(|e| !e.looks_done() && !filepath.ends_with(&e.path)),
                            );
                        clear_screen();
                        match verify(pending_exercises, verbose) {
                            Ok(_) => return Ok(WatchStatus::Finished),
                            Err(exercise) => {
                                let mut failed_exercise_hint = failed_exercise_hint.lock().unwrap();
                                *failed_exercise_hint = Some(to_owned_hint(exercise));
                            }
                        }
                    }
                }
                _ => {}
            },
            Err(RecvTimeoutError::Timeout) => {
                // the timeout expired, just check the `should_quit` variable below then loop again
            }
            Err(e) => println!("watch error: {:?}", e),
        }
        // Check if we need to exit
        if should_quit.load(Ordering::SeqCst) {
            return Ok(WatchStatus::Unfinished);
        }
    }
}

fn rustc_exists() -> bool {
    Command::new("rustc")
        .args(&["--version"])
        .stdout(Stdio::null())
        .spawn()
        .and_then(|mut child| child.wait())
        .map(|status| status.success())
        .unwrap_or(false)
}



================================================
FILE: assets/rustlings-zh/src/run.rs
================================================
use crate::exercise::{Exercise, Mode};
use crate::verify::test;
use indicatif::ProgressBar;

// Invoke the rust compiler on the path of the given exercise,
// and run the ensuing binary.
// The verbose argument helps determine whether or not to show
// the output from the test harnesses (if the mode of the exercise is test)
pub fn run(exercise: &Exercise, verbose: bool) -> Result<(), ()> {
    match exercise.mode {
        Mode::Test => test(exercise, verbose)?,
        Mode::Compile => compile_and_run(exercise)?,
        Mode::Clippy => compile_and_run(exercise)?,
    }
    Ok(())
}

// Invoke the rust compiler on the path of the given exercise
// and run the ensuing binary.
// This is strictly for non-test binaries, so output is displayed
fn compile_and_run(exercise: &Exercise) -> Result<(), ()> {
    let progress_bar = ProgressBar::new_spinner();
    progress_bar.set_message(format!("Compiling {}...", exercise).as_str());
    progress_bar.enable_steady_tick(100);

    let compilation_result = exercise.compile();
    let compilation = match compilation_result {
        Ok(compilation) => compilation,
        Err(output) => {
            progress_bar.finish_and_clear();
            warn!(
                "Compilation of {} failed!, Compiler error message:\n",
                exercise
            );
            println!("{}", output.stderr);
            return Err(());
        }
    };

    progress_bar.set_message(format!("Running {}...", exercise).as_str());
    let result = compilation.run();
    progress_bar.finish_and_clear();

    match result {
        Ok(output) => {
            println!("{}", output.stdout);
            success!("Successfully ran {}", exercise);
            Ok(())
        }
        Err(output) => {
            println!("{}", output.stdout);
            println!("{}", output.stderr);

            warn!("Ran {} with errors", exercise);
            Err(())
        }
    }
}



================================================
FILE: assets/rustlings-zh/src/ui.rs
================================================
macro_rules! warn {
    ($fmt:literal, $ex:expr) => {{
        use console::{style, Emoji};
        use std::env;
        let formatstr = format!($fmt, $ex);
        if env::var("NO_EMOJI").is_ok() {
            println!("{} {}", style("!").red(), style(formatstr).red());
        } else {
            println!(
                "{} {}",
                style(Emoji("⚠️ ", "!")).red(),
                style(formatstr).red()
            );
        }
    }};
}

macro_rules! success {
    ($fmt:literal, $ex:expr) => {{
        use console::{style, Emoji};
        use std::env;
        let formatstr = format!($fmt, $ex);
        if env::var("NO_EMOJI").is_ok() {
            println!("{} {}", style("✓").green(), style(formatstr).green());
        } else {
            println!(
                "{} {}",
                style(Emoji("✅", "✓")).green(),
                style(formatstr).green()
            );
        }
    }};
}



================================================
FILE: assets/rustlings-zh/src/verify.rs
================================================
use crate::exercise::{CompiledExercise, Exercise, Mode, State};
use console::style;
use indicatif::ProgressBar;
use std::env;

// Verify that the provided container of Exercise objects
// can be compiled and run without any failures.
// Any such failures will be reported to the end user.
// If the Exercise being verified is a test, the verbose boolean
// determines whether or not the test harness outputs are displayed.
pub fn verify<'a>(
    start_at: impl IntoIterator<Item = &'a Exercise>,
    verbose: bool,
) -> Result<(), &'a Exercise> {
    for exercise in start_at {
        let compile_result = match exercise.mode {
            Mode::Test => compile_and_test(exercise, RunMode::Interactive, verbose),
            Mode::Compile => compile_and_run_interactively(exercise),
            Mode::Clippy => compile_only(exercise),
        };
        if !compile_result.unwrap_or(false) {
            return Err(exercise);
        }
    }
    Ok(())
}

enum RunMode {
    Interactive,
    NonInteractive,
}

// Compile and run the resulting test harness of the given Exercise
pub fn test(exercise: &Exercise, verbose: bool) -> Result<(), ()> {
    compile_and_test(exercise, RunMode::NonInteractive, verbose)?;
    Ok(())
}

// Invoke the rust compiler without running the resulting binary
fn compile_only(exercise: &Exercise) -> Result<bool, ()> {
    let progress_bar = ProgressBar::new_spinner();
    progress_bar.set_message(format!("Compiling {}...", exercise).as_str());
    progress_bar.enable_steady_tick(100);

    let _ = compile(exercise, &progress_bar)?;
    progress_bar.finish_and_clear();

    success!("Successfully compiled {}!", exercise);
    Ok(prompt_for_completion(exercise, None))
}

// Compile the given Exercise and run the resulting binary in an interactive mode
fn compile_and_run_interactively(exercise: &Exercise) -> Result<bool, ()> {
    let progress_bar = ProgressBar::new_spinner();
    progress_bar.set_message(format!("Compiling {}...", exercise).as_str());
    progress_bar.enable_steady_tick(100);

    let compilation = compile(exercise, &progress_bar)?;

    progress_bar.set_message(format!("Running {}...", exercise).as_str());
    let result = compilation.run();
    progress_bar.finish_and_clear();

    let output = match result {
        Ok(output) => output,
        Err(output) => {
            warn!("Ran {} with errors", exercise);
            println!("{}", output.stdout);
            println!("{}", output.stderr);
            return Err(());
        }
    };

    success!("Successfully ran {}!", exercise);

    Ok(prompt_for_completion(exercise, Some(output.stdout)))
}

// Compile the given Exercise as a test harness and display
// the output if verbose is set to true
fn compile_and_test(exercise: &Exercise, run_mode: RunMode, verbose: bool) -> Result<bool, ()> {
    let progress_bar = ProgressBar::new_spinner();
    progress_bar.set_message(format!("Testing {}...", exercise).as_str());
    progress_bar.enable_steady_tick(100);

    let compilation = compile(exercise, &progress_bar)?;
    let result = compilation.run();
    progress_bar.finish_and_clear();

    match result {
        Ok(output) => {
            if verbose {
                println!("{}", output.stdout);
            }
            success!("Successfully tested {}", &exercise);
            if let RunMode::Interactive = run_mode {
                Ok(prompt_for_completion(exercise, None))
            } else {
                Ok(true)
            }
        }
        Err(output) => {
            warn!(
                "Testing of {} failed! Please try again. Here's the output:",
                exercise
            );
            println!("{}", output.stdout);
            Err(())
        }
    }
}

// Compile the given Exercise and return an object with information
// about the state of the compilation
fn compile<'a, 'b>(
    exercise: &'a Exercise,
    progress_bar: &'b ProgressBar,
) -> Result<CompiledExercise<'a>, ()> {
    let compilation_result = exercise.compile();

    match compilation_result {
        Ok(compilation) => Ok(compilation),
        Err(output) => {
            progress_bar.finish_and_clear();
            warn!(
                "Compiling of {} failed! Please try again. Here's the output:",
                exercise
            );
            println!("{}", output.stderr);
            Err(())
        }
    }
}

fn prompt_for_completion(exercise: &Exercise, prompt_output: Option<String>) -> bool {
    let context = match exercise.state() {
        State::Done => return true,
        State::Pending(context) => context,
    };

    let no_emoji = env::var("NO_EMOJI").is_ok();

    let clippy_success_msg = if no_emoji {
        "The code is compiling, and Clippy is happy!"
    } else {
        "The code is compiling, and 📎 Clippy 📎 is happy!"
    };

    let success_msg = match exercise.mode {
        Mode::Compile => "The code is compiling!",
        Mode::Test => "The code is compiling, and the tests pass!",
        Mode::Clippy => clippy_success_msg,
    };

    println!();
    if no_emoji {
        println!("~*~ {} ~*~", success_msg)
    } else {
        println!("🎉 🎉  {} 🎉 🎉", success_msg)
    }
    println!();

    if let Some(output) = prompt_output {
        println!("Output:");
        println!("{}", separator());
        println!("{}", output);
        println!("{}", separator());
        println!();
    }

    println!("You can keep working on this exercise,");
    println!(
        "or jump into the next one by removing the {} comment:",
        style("`I AM NOT DONE`").bold()
    );
    println!();
    for context_line in context {
        let formatted_line = if context_line.important {
            format!("{}", style(context_line.line).bold())
        } else {
            context_line.line.to_string()
        };

        println!(
            "{:>2} {}  {}",
            style(context_line.number).blue().bold(),
            style("|").blue(),
            formatted_line
        );
    }

    false
}

fn separator() -> console::StyledObject<&'static str> {
    style("====================").bold()
}



================================================
FILE: assets/rustlings-zh/tests/integration_tests.rs
================================================
use assert_cmd::prelude::*;
use glob::glob;
use predicates::boolean::PredicateBooleanExt;
use std::fs::File;
use std::io::Read;
use std::process::Command;

#[test]
fn runs_without_arguments() {
    let mut cmd = Command::cargo_bin("rustlings").unwrap();
    cmd.assert().success();
}

#[test]
fn fails_when_in_wrong_dir() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .current_dir("tests/")
        .assert()
        .code(1);
}

#[test]
fn verify_all_success() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .arg("verify")
        .current_dir("tests/fixture/success")
        .assert()
        .success();
}

#[test]
fn verify_fails_if_some_fails() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .arg("verify")
        .current_dir("tests/fixture/failure")
        .assert()
        .code(1);
}

#[test]
fn run_single_compile_success() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["run", "compSuccess"])
        .current_dir("tests/fixture/success/")
        .assert()
        .success();
}

#[test]
fn run_single_compile_failure() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["run", "compFailure"])
        .current_dir("tests/fixture/failure/")
        .assert()
        .code(1);
}

#[test]
fn run_single_test_success() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["run", "testSuccess"])
        .current_dir("tests/fixture/success/")
        .assert()
        .success();
}

#[test]
fn run_single_test_failure() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["run", "testFailure"])
        .current_dir("tests/fixture/failure/")
        .assert()
        .code(1);
}

#[test]
fn run_single_test_not_passed() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["run", "testNotPassed.rs"])
        .current_dir("tests/fixture/failure/")
        .assert()
        .code(1);
}

#[test]
fn run_single_test_no_filename() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .arg("run")
        .current_dir("tests/fixture/")
        .assert()
        .code(1);
}

#[test]
fn run_single_test_no_exercise() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["run", "compNoExercise.rs"])
        .current_dir("tests/fixture/failure")
        .assert()
        .code(1);
}

#[test]
fn get_hint_for_single_test() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["hint", "testFailure"])
        .current_dir("tests/fixture/failure")
        .assert()
        .code(0)
        .stdout("Hello!\n");
}

#[test]
fn all_exercises_require_confirmation() {
    for exercise in glob("exercises/**/*.rs").unwrap() {
        let path = exercise.unwrap();
        let source = {
            let mut file = File::open(&path).unwrap();
            let mut s = String::new();
            file.read_to_string(&mut s).unwrap();
            s
        };
        source
            .matches("// I AM NOT DONE")
            .next()
            .unwrap_or_else(|| {
                panic!(
                    "There should be an `I AM NOT DONE` annotation in {:?}",
                    path
                )
            });
    }
}

#[test]
fn run_compile_exercise_does_not_prompt() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["run", "pending_exercise"])
        .current_dir("tests/fixture/state")
        .assert()
        .code(0)
        .stdout(predicates::str::contains("I AM NOT DONE").not());
}

#[test]
fn run_test_exercise_does_not_prompt() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["run", "pending_test_exercise"])
        .current_dir("tests/fixture/state")
        .assert()
        .code(0)
        .stdout(predicates::str::contains("I AM NOT DONE").not());
}

#[test]
fn run_single_test_success_with_output() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["--nocapture", "run", "testSuccess"])
        .current_dir("tests/fixture/success/")
        .assert()
        .code(0)
        .stdout(predicates::str::contains("THIS TEST TOO SHALL PAS"));
}

#[test]
fn run_single_test_success_without_output() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["run", "testSuccess"])
        .current_dir("tests/fixture/success/")
        .assert()
        .code(0)
        .stdout(predicates::str::contains("THIS TEST TOO SHALL PAS").not());
}

#[test]
fn run_rustlings_list() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["list"])
        .current_dir("tests/fixture/success")
        .assert()
        .success();
}

#[test]
fn run_rustlings_list_no_pending() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["list"])
        .current_dir("tests/fixture/success")
        .assert()
        .success()
        .stdout(predicates::str::contains("Pending").not());
}

#[test]
fn run_rustlings_list_both_done_and_pending() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["list"])
        .current_dir("tests/fixture/state")
        .assert()
        .success()
        .stdout(predicates::str::contains("Done").and(predicates::str::contains("Pending")));
}

#[test]
fn run_rustlings_list_without_pending() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["list", "--solved"])
        .current_dir("tests/fixture/state")
        .assert()
        .success()
        .stdout(predicates::str::contains("Pending").not());
}

#[test]
fn run_rustlings_list_without_done() {
    Command::cargo_bin("rustlings")
        .unwrap()
        .args(&["list", "--unsolved"])
        .current_dir("tests/fixture/state")
        .assert()
        .success()
        .stdout(predicates::str::contains("Done").not());
}



================================================
FILE: assets/rustlings-zh/tests/fixture/failure/compFailure.rs
================================================
fn main() {
    let
}


================================================
FILE: assets/rustlings-zh/tests/fixture/failure/compNoExercise.rs
================================================
fn main() {
}



================================================
FILE: assets/rustlings-zh/tests/fixture/failure/info.toml
================================================
[[exercises]]
name = "compFailure"
path = "compFailure.rs"
mode = "compile"
hint = ""

[[exercises]]
name = "testFailure"
path = "testFailure.rs"
mode = "test"
hint = "Hello!"



================================================
FILE: assets/rustlings-zh/tests/fixture/failure/testFailure.rs
================================================
#[test]
fn passing() {
    asset!(true);
}



================================================
FILE: assets/rustlings-zh/tests/fixture/failure/testNotPassed.rs
================================================
#[test]
fn not_passing() {
    assert!(false);
}



================================================
FILE: assets/rustlings-zh/tests/fixture/state/finished_exercise.rs
================================================
// fake_exercise

fn main() {

}



================================================
FILE: assets/rustlings-zh/tests/fixture/state/info.toml
================================================
[[exercises]]
name = "pending_exercise"
path = "pending_exercise.rs"
mode = "compile"
hint = """"""

[[exercises]]
name = "pending_test_exercise"
path = "pending_test_exercise.rs"
mode = "test"
hint = """"""

[[exercises]]
name = "finished_exercise"
path = "finished_exercise.rs"
mode = "compile"
hint = """"""




================================================
FILE: assets/rustlings-zh/tests/fixture/state/pending_exercise.rs
================================================
// fake_exercise

// I AM NOT DONE

fn main() {

}



================================================
FILE: assets/rustlings-zh/tests/fixture/state/pending_test_exercise.rs
================================================
// I AM NOT DONE

#[test]
fn it_works() {}



================================================
FILE: assets/rustlings-zh/tests/fixture/success/compSuccess.rs
================================================
fn main() {
}



================================================
FILE: assets/rustlings-zh/tests/fixture/success/info.toml
================================================
[[exercises]]
name = "compSuccess"
path = "compSuccess.rs"
mode = "compile"
hint = """"""

[[exercises]]
name = "testSuccess"
path = "testSuccess.rs"
mode = "test"
hint = """"""



================================================
FILE: assets/rustlings-zh/tests/fixture/success/testSuccess.rs
================================================
#[test]
fn passing() {
    println!("THIS TEST TOO SHALL PASS");
    assert!(true);
}



================================================
FILE: assets/writing-material/books.md
================================================
## 本书参考的书籍

1. [Rust语言](https://doc.rust-lang.org/book)

3. [Cargo教学](https://doc.rust-lang.org/cargo/index.html)

4. [Rust性能之书](https://nnethercote.github.io/perf-book/title-page.html)

5. [Rust异步编程](https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html)

6. [Rust API Guidlines](https://rust-lang.github.io/api-guidelines/naming.html)

7. [Rust in action](https://livebook.manning.com/book/rust-in-action/chapter-5/)
    - [示例](https://github.com/barabadzhi/rust-in-action)

8. [Rust nomicon](https://doc.rust-lang.org/nomicon/dot-operator.html)
    
9. [Rust Forge](https://forge.rust-lang.org/infra/other-installation-methods.html#other-rust-installation-methods)

10. [rustc开发者之书](https://rustc-dev-guide.rust-lang.org/method-lookup.html)

11. [Rust Style](https://doc.rust-lang.org/1.6.0/style/README.html)

12. [Learning Rust](https://learning-rust.github.io/docs/a1.why_rust.html)

13. [Rust doc](https://doc.rust-lang.org/rustdoc/the-doc-attribute.html)

14. [Unstable Rust](https://doc.rust-lang.org/stable/unstable-book/)

15. [Rust Fuzz Book](https://rust-fuzz.github.io/book/)


## 可参考的教程
1. https://github.com/ferrous-systems/teaching-material#core-topics


================================================
FILE: assets/writing-material/courses.md
================================================
## 可借鉴的课程形式
https://www.reddit.com/r/rust/comments/rwp8mo/teaching_rust_at_the_university_of_warsaw/

## 练习题




================================================
FILE: assets/writing-material/demos_for_learning.md
================================================
整理几个可以作为学习demo的项目，需要将注释和相关文档翻译成中文

1. [mini-redis](https://github.com/tokio-rs/mini-redis)


================================================
FILE: assets/writing-material/good-sourcecode.md
================================================
# 值得学习的源代码

https://www.reddit.com/r/rust/comments/rxfx85/good_rust_source_code/

https://www.reddit.com/r/rust/comments/rx8rom/rust_projects_where_you_learnt_a_ton_of_stuff/


================================================
FILE: assets/writing-material/读者疑惑的点记录.md
================================================
# 读者疑惑的点
这里记录一些读者反馈的在阅读过程中，可能会导致疑惑或者困惑的点，后续针对这些地方，可以进行相应的内容优化。

1. 引用和切片的区别



================================================
FILE: assets/writing-material/posts/atomic.md
================================================
https://www.reddit.com/r/rust/comments/rtqrx4/introducing_atomicstory/


================================================
FILE: assets/writing-material/posts/attributes.md
================================================
## #[derive(Default)]
```rust
#[derive(Default)]
struct NotSend(Rc<()>);

fn require_send(_: impl Send) {}

async fn bar() {}
async fn foo() {
    //Returns the "default value" for a type.
    NotSend::default();
}
```


================================================
FILE: assets/writing-material/posts/file.md
================================================
## 读取全部内容

```rust
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

fn main() {
    // Create a path to the desired file
    let path = Path::new("hello.txt");
    let display = path.display();

    // Open the path in read-only mode, returns `io::Result<File>`
    let mut file = match File::open(&path) {
        Err(why) => panic!("couldn't open {}: {}", display, why),
        Ok(file) => file,
    };

    // Read the file contents into a string, returns `io::Result<usize>`
    let mut s = String::new();
    match file.read_to_string(&mut s) {
        Err(why) => panic!("couldn't read {}: {}", display, why),
        Ok(_) => print!("{} contains:\n{}", display, s),
    }

    // `file` goes out of scope, and the "hello.txt" file gets closed
}
```

## 读取全部行
This process is more efficient than creating a String in memory especially working with larger files.

```rust
use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;

fn main() {
    // File hosts must exist in current path before this produces output
    if let Ok(lines) = read_lines("./hosts") {
        // Consumes the iterator, returns an (Optional) String
        for line in lines {
            if let Ok(ip) = line {
                println!("{}", ip);
            }
        }
    }
}

// The output is wrapped in a Result to allow matching on errors
// Returns an Iterator to the Reader of the lines of the file.
fn read_lines<P>(filename: P) -> io::Result<io::Lines<io::BufReader<File>>>
where P: AsRef<Path>, {
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}
```

## 一些常用的文件操作
```rust
use std::fs;
use std::fs::{File, OpenOptions};
use std::io;
use std::io::prelude::*;
use std::os::unix;
use std::path::Path;

fn cat(path: &Path) -> io::Result<String> {
    let mut f = File::open(path)?;
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}

// A simple implementation of `% echo s > path`
fn echo(s: &str, path: &Path) -> io::Result<()> {
    let mut f = File::create(path)?;

    f.write_all(s.as_bytes())
}

// A simple implementation of `% touch path` (ignores existing files)
fn touch(path: &Path) -> io::Result<()> {
    match OpenOptions::new().create(true).write(true).open(path) {
        Ok(_) => Ok(()),
        Err(e) => Err(e),
    }
}

fn main() {
    println!("`mkdir a`");
    // Create a directory, returns `io::Result<()>`
    match fs::create_dir("a") {
        Err(why) => println!("! {:?}", why.kind()),
        Ok(_) => {},
    }

    println!("`echo hello > a/b.txt`");
    // The previous match can be simplified using the `unwrap_or_else` method
    echo("hello", &Path::new("a/b.txt")).unwrap_or_else(|why| {
        println!("! {:?}", why.kind());
    });

    println!("`mkdir -p a/c/d`");
    // Recursively create a directory, returns `io::Result<()>`
    fs::create_dir_all("a/c/d").unwrap_or_else(|why| {
        println!("! {:?}", why.kind());
    });

    println!("`touch a/c/e.txt`");
    touch(&Path::new("a/c/e.txt")).unwrap_or_else(|why| {
        println!("! {:?}", why.kind());
    });

    println!("`ln -s ../b.txt a/c/b.txt`");
    // Create a symbolic link, returns `io::Result<()>`
    if cfg!(target_family = "unix") {
        unix::fs::symlink("../b.txt", "a/c/b.txt").unwrap_or_else(|why| {
        println!("! {:?}", why.kind());
        });
    }

    println!("`cat a/c/b.txt`");
    match cat(&Path::new("a/c/b.txt")) {
        Err(why) => println!("! {:?}", why.kind()),
        Ok(s) => println!("> {}", s),
    }

    println!("`ls a`");
    // Read the contents of a directory, returns `io::Result<Vec<Path>>`
    match fs::read_dir("a") {
        Err(why) => println!("! {:?}", why.kind()),
        Ok(paths) => for path in paths {
            println!("> {:?}", path.unwrap().path());
        },
    }

    println!("`rm a/c/e.txt`");
    // Remove a file, returns `io::Result<()>`
    fs::remove_file("a/c/e.txt").unwrap_or_else(|why| {
        println!("! {:?}", why.kind());
    });

    println!("`rmdir a/c/d`");
    // Remove an empty directory, returns `io::Result<()>`
    fs::remove_dir("a/c/d").unwrap_or_else(|why| {
        println!("! {:?}", why.kind());
    }
}
```



================================================
FILE: assets/writing-material/posts/function_signature.md
================================================
## 函数的入参是一个async function
因为我们使用了trait bound，所以不能用`Fn() -> impl Future<Output=Result<Return, sql::Error>>`的方式.

```rust
use core::future::Future;

pub async fn on_tran<F, Fut>(f: F) -> usize 
    where F: Fn() -> Fut, Fut: Future<Output=usize> {
    f().await
}


#[tokio::main]
async fn main() {
    let foo = || {
        async {
            8 as usize
        }
    };
    
    println!("{}", on_tran(foo).await);
}
```



================================================
FILE: assets/writing-material/posts/generics.md
================================================
https://stackoverflow.com/questions/37606035/pass-generic-function-as-argument


================================================
FILE: assets/writing-material/posts/hashmap.md
================================================
## Key of hashmap
Any type that implements the Eq and Hash traits can be a key in HashMap.

Note that f32 and f64 do not implement Hash, likely because floating-point precision errors would make using them as hashmap keys horribly error-prone.

All collection classes implement Eq and Hash if their contained type also respectively implements Eq and Hash. For example, `Vec<T>` will implement Hash if T implements Hash.



================================================
FILE: assets/writing-material/posts/identifier.md
================================================
## Raw identifiers
Rust因为版本更迭原因，可能会新增一些`关键字`,这些新增关键字可能会导致旧的函数名调用不再通过编译，例如在Rust Edition 2015中，引入了新的关键字`try`.

运行以下代码:
```rust
extern crate foo;

fn main() {
    foo::try();
}
```

将获得下面的错误
```rust
error: expected identifier, found keyword `try`
 --> src/main.rs:4:4
  |
4 | foo::try();
  |      ^^^ expected identifier, found keyword
```

可以用Raw identifier来解决:
```rust
extern crate foo;

fn main() {
    foo::r#try();
}
```


================================================
FILE: assets/writing-material/posts/images.md
================================================
## 容器类型说明图
https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p


================================================
FILE: assets/writing-material/posts/interview.md
================================================
https://www.reddit.com/r/rust/comments/si0j6v/im_preparing_for_a_rust_interview/


================================================
FILE: assets/writing-material/posts/io.md
================================================

## Reading input as Raw Bytes
The built-in String type uses UTF-8 internally, which adds a small, but nonzero overhead caused by UTF-8 validation when you read input into it. If you just want to process input bytes without worrying about UTF-8 (for example if you handle ASCII text), you can use `BufRead::read_until`.




================================================
FILE: assets/writing-material/posts/Iterator.md
================================================
包含了一些Iterator的常用处理方法
## 遍历同时获取元素的索引
```rust
    let mut xs = vec![1i32, 2, 3];
    for (i, x) in xs.iter().enumerate() {
        println!("In position {} we have value {}", i, x);
    }
```

## 几种从Vec生成Iterator的方式
1. iter返回的是值的不可变引用，即&T
2. iter_mut返回的是可变引用，即&mut T
3. into_iter返回的是T类型的值

```rust
  let mut v = [String::from("a"), String::from("a"), String::from("a")];
    // - move occurs because `v` has type `Vec<String>`, which does not implement the `Copy
    //`v` moved due to this method call
    for x in v.into_iter() {
        println!("{:?}", x)
    }

    // Error: borrow of moved value: `v`
    println!("{:?}", v)
```
## 忽略Vec中失败的Result
`filter_map` calls a function and filters out the results that are `None`

```rust
fn main() {
    let strings = vec!["tofu", "93", "18"];
    let numbers: Vec<_> = strings
        .into_iter()
        .filter_map(|s| s.parse::<i32>().ok())
        .collect();
    println!("Results: {:?}", numbers);
}
```

## 遍历Vec时，失败直接返回
`Result` implements `FromIter` so that a vector of results (`Vec<Result<T, E>>`) can be turned into a result with a vector (`Result<Vec<T>, E>`). Once an `Result::Err` is found, the iteration will terminate

```rust
fn main() {
    let strings = vec!["tofu", "93", "18"];
    let numbers: Result<Vec<_>, _> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!("Results: {:?}", numbers);
}
```

This same technique can be used with `Option`.

## 遍历Vec时，收集所有的正确值和错误值

```rust
fn main() {
    let strings = vec!["tofu", "93", "18"];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    let numbers: Vec<_> = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec<_> = errors.into_iter().map(Result::unwrap_err).collect();
    println!("Numbers: {:?}", numbers);
    println!("Errors: {:?}", errors);
}
```


================================================
FILE: assets/writing-material/posts/lifetime.md
================================================
## for<'a>

https://www.reddit.com/r/rust/comments/rq43c6/generic_fn_impl_for_iterating_over_mut_items_twice/

https://www.reddit.com/r/rust/comments/6uobit/fora_lifetime_syntax/



================================================
FILE: assets/writing-material/posts/lifetime_elision_rules.md
================================================
一些lifetime消除规则


### 1
Let's talk about a feature that's available in both editions: we've added some additional elision rules for `impl` blocks and function definitions. Code like this:

```rust
impl<'a> Reader for BufReader<'a> {
    // methods go here
}
```

can now be written like this:
```rust
impl Reader for BufReader<'_> {
    // methods go here
}
```

The `'_` lifetime still shows that `BufReader` takes a parameter, but we don't need to create a name for it anymore.

### 2
Lifetimes are still required to be defined in structs. However, we no longer require as much boilerplate as before:

```rust
// Rust 2015
struct Ref<'a, T: 'a> {
    field: &'a T
}

// Rust 2018
struct Ref<'a, T> {
    field: &'a T
}
```

The `: 'a` is inferred. You can still be explicit if you prefer. We're considering some more options for elision here in the future, but have no concrete plans yet.




================================================
FILE: assets/writing-material/posts/non-lexical-lifetime.md
================================================
https://stackoverflow.com/questions/50251487/what-are-non-lexical-lifetimes




================================================
FILE: assets/writing-material/posts/operators.md
================================================
## Operators and Symbols

This appendix contains a glossary of Rust’s syntax, including operators and
other symbols that appear by themselves or in the context of paths, generics,
trait bounds, macros, attributes, comments, tuples, and brackets.

### Operators

Table B-1 contains the operators in Rust, an example of how the operator would
appear in context, a short explanation, and whether that operator is
overloadable. If an operator is overloadable, the relevant trait to use to
overload that operator is listed.

<span class="caption">Table B-1: Operators</span>

| Operator | Example | Explanation | Overloadable? |
|----------|---------|-------------|---------------|
| `!` | `ident!(...)`, `ident!{...}`, `ident![...]` | Macro expansion | |
| `!` | `!expr` | Bitwise or logical complement | `Not` |
| `!=` | `var != expr` | Nonequality comparison | `PartialEq` |
| `%` | `expr % expr` | Arithmetic remainder | `Rem` |
| `%=` | `var %= expr` | Arithmetic remainder and assignment | `RemAssign` |
| `&` | `&expr`, `&mut expr` | Borrow | |
| `&` | `&type`, `&mut type`, `&'a type`, `&'a mut type` | Borrowed pointer type | |
| `&` | `expr & expr` | Bitwise AND | `BitAnd` |
| `&=` | `var &= expr` | Bitwise AND and assignment | `BitAndAssign` |
| `&&` | `expr && expr` | Short-circuiting logical AND | |
| `*` | `expr * expr` | Arithmetic multiplication | `Mul` |
| `*=` | `var *= expr` | Arithmetic multiplication and assignment | `MulAssign` |
| `*` | `*expr` | Dereference | `Deref` |
| `*` | `*const type`, `*mut type` | Raw pointer | |
| `+` | `trait + trait`, `'a + trait` | Compound type constraint | |
| `+` | `expr + expr` | Arithmetic addition | `Add` |
| `+=` | `var += expr` | Arithmetic addition and assignment | `AddAssign` |
| `,` | `expr, expr` | Argument and element separator | |
| `-` | `- expr` | Arithmetic negation | `Neg` |
| `-` | `expr - expr` | Arithmetic subtraction | `Sub` |
| `-=` | `var -= expr` | Arithmetic subtraction and assignment | `SubAssign` |
| `->` | `fn(...) -> type`, <code>&vert;...&vert; -> type</code> | Function and closure return type | |
| `.` | `expr.ident` | Member access | |
| `..` | `..`, `expr..`, `..expr`, `expr..expr` | Right-exclusive range literal | `PartialOrd` |
| `..=` | `..=expr`, `expr..=expr` | Right-inclusive range literal | `PartialOrd` |
| `..` | `..expr` | Struct literal update syntax | |
| `..` | `variant(x, ..)`, `struct_type { x, .. }` | “And the rest” pattern binding | |
| `...` | `expr...expr` | (Deprecated, use `..=` instead) In a pattern: inclusive range pattern | |
| `/` | `expr / expr` | Arithmetic division | `Div` |
| `/=` | `var /= expr` | Arithmetic division and assignment | `DivAssign` |
| `:` | `pat: type`, `ident: type` | Constraints | |
| `:` | `ident: expr` | Struct field initializer | |
| `:` | `'a: loop {...}` | Loop label | |
| `;` | `expr;` | Statement and item terminator | |
| `;` | `[...; len]` | Part of fixed-size array syntax | |
| `<<` | `expr << expr` | Left-shift | `Shl` |
| `<<=` | `var <<= expr` | Left-shift and assignment | `ShlAssign` |
| `<` | `expr < expr` | Less than comparison | `PartialOrd` |
| `<=` | `expr <= expr` | Less than or equal to comparison | `PartialOrd` |
| `=` | `var = expr`, `ident = type` | Assignment/equivalence | |
| `==` | `expr == expr` | Equality comparison | `PartialEq` |
| `=>` | `pat => expr` | Part of match arm syntax | |
| `>` | `expr > expr` | Greater than comparison | `PartialOrd` |
| `>=` | `expr >= expr` | Greater than or equal to comparison | `PartialOrd` |
| `>>` | `expr >> expr` | Right-shift | `Shr` |
| `>>=` | `var >>= expr` | Right-shift and assignment | `ShrAssign` |
| `@` | `ident @ pat` | Pattern binding | |
| `^` | `expr ^ expr` | Bitwise exclusive OR | `BitXor` |
| `^=` | `var ^= expr` | Bitwise exclusive OR and assignment | `BitXorAssign` |
| <code>&vert;</code> | <code>pat &vert; pat</code> | Pattern alternatives | |
| <code>&vert;</code> | <code>expr &vert; expr</code> | Bitwise OR | `BitOr` |
| <code>&vert;=</code> | <code>var &vert;= expr</code> | Bitwise OR and assignment | `BitOrAssign` |
| <code>&vert;&vert;</code> | <code>expr &vert;&vert; expr</code> | Short-circuiting logical OR | |
| `?` | `expr?` | Error propagation | |

### Non-operator Symbols

The following list contains all non-letters that don’t function as operators;
that is, they don’t behave like a function or method call.

Table B-2 shows symbols that appear on their own and are valid in a variety of
locations.

<span class="caption">Table B-2: Stand-Alone Syntax</span>

| Symbol | Explanation |
|--------|-------------|
| `'ident` | Named lifetime or loop label |
| `...u8`, `...i32`, `...f64`, `...usize`, etc. | Numeric literal of specific type |
| `"..."` | String literal |
| `r"..."`, `r#"..."#`, `r##"..."##`, etc. | Raw string literal, escape characters not processed |
| `b"..."` | Byte string literal; constructs a `[u8]` instead of a string |
| `br"..."`, `br#"..."#`, `br##"..."##`, etc. | Raw byte string literal, combination of raw and byte string literal |
| `'...'` | Character literal |
| `b'...'` | ASCII byte literal |
| <code>&vert;...&vert; expr</code> | Closure |
| `!` | Always empty bottom type for diverging functions |
| `_` | “Ignored” pattern binding; also used to make integer literals readable |

Table B-3 shows symbols that appear in the context of a path through the module
hierarchy to an item.

<span class="caption">Table B-3: Path-Related Syntax</span>

| Symbol | Explanation |
|--------|-------------|
| `ident::ident` | Namespace path |
| `::path` | Path relative to the crate root (i.e., an explicitly absolute path) |
| `self::path` | Path relative to the current module (i.e., an explicitly relative path).
| `super::path` | Path relative to the parent of the current module |
| `type::ident`, `<type as trait>::ident` | Associated constants, functions, and types |
| `<type>::...` | Associated item for a type that cannot be directly named (e.g., `<&T>::...`, `<[T]>::...`, etc.) |
| `trait::method(...)` | Disambiguating a method call by naming the trait that defines it |
| `type::method(...)` | Disambiguating a method call by naming the type for which it’s defined |
| `<type as trait>::method(...)` | Disambiguating a method call by naming the trait and type |

Table B-4 shows symbols that appear in the context of using generic type
parameters.

<span class="caption">Table B-4: Generics</span>

| Symbol | Explanation |
|--------|-------------|
| `path<...>` | Specifies parameters to generic type in a type (e.g., `Vec<u8>`) |
| `path::<...>`, `method::<...>` | Specifies parameters to generic type, function, or method in an expression; often referred to as turbofish (e.g., `"42".parse::<i32>()`) |
| `fn ident<...> ...` | Define generic function |
| `struct ident<...> ...` | Define generic structure |
| `enum ident<...> ...` | Define generic enumeration |
| `impl<...> ...` | Define generic implementation |
| `for<...> type` | Higher-ranked lifetime bounds |
| `type<ident=type>` | A generic type where one or more associated types have specific assignments (e.g., `Iterator<Item=T>`) |

Table B-5 shows symbols that appear in the context of constraining generic type
parameters with trait bounds.

<span class="caption">Table B-5: Trait Bound Constraints</span>

| Symbol | Explanation |
|--------|-------------|
| `T: U` | Generic parameter `T` constrained to types that implement `U` |
| `T: 'a` | Generic type `T` must outlive lifetime `'a` (meaning the type cannot transitively contain any references with lifetimes shorter than `'a`) |
| `T: 'static` | Generic type `T` contains no borrowed references other than `'static` ones |
| `'b: 'a` | Generic lifetime `'b` must outlive lifetime `'a` |
| `T: ?Sized` | Allow generic type parameter to be a dynamically sized type |
| `'a + trait`, `trait + trait` | Compound type constraint |

Table B-6 shows symbols that appear in the context of calling or defining
macros and specifying attributes on an item.

<span class="caption">Table B-6: Macros and Attributes</span>

| Symbol | Explanation |
|--------|-------------|
| `#[meta]` | Outer attribute |
| `#![meta]` | Inner attribute |
| `$ident` | Macro substitution |
| `$ident:kind` | Macro capture |
| `$(…)…` | Macro repetition |
| `ident!(...)`, `ident!{...}`, `ident![...]` | Macro invocation |

Table B-7 shows symbols that create comments.

<span class="caption">Table B-7: Comments</span>

| Symbol | Explanation |
|--------|-------------|
| `//` | Line comment |
| `//!` | Inner line doc comment |
| `///` | Outer line doc comment |
| `/*...*/` | Block comment |
| `/*!...*/` | Inner block doc comment |
| `/**...*/` | Outer block doc comment |

Table B-8 shows symbols that appear in the context of using tuples.

<span class="caption">Table B-8: Tuples</span>

| Symbol | Explanation |
|--------|-------------|
| `()` | Empty tuple (aka unit), both literal and type |
| `(expr)` | Parenthesized expression |
| `(expr,)` | Single-element tuple expression |
| `(type,)` | Single-element tuple type |
| `(expr, ...)` | Tuple expression |
| `(type, ...)` | Tuple type |
| `expr(expr, ...)` | Function call expression; also used to initialize tuple `struct`s and tuple `enum` variants |
| `expr.0`, `expr.1`, etc. | Tuple indexing |

Table B-9 shows the contexts in which curly braces are used.

<span class="caption">Table B-9: Curly Brackets</span>

| Context | Explanation |
|---------|-------------|
| `{...}` | Block expression |
| `Type {...}` | `struct` literal |

Table B-10 shows the contexts in which square brackets are used.

<span class="caption">Table B-10: Square Brackets</span>

| Context | Explanation |
|---------|-------------|
| `[...]` | Array literal |
| `[expr; len]` | Array literal containing `len` copies of `expr` |
| `[type; len]` | Array type containing `len` instances of `type` |
| `expr[expr]` | Collection indexing. Overloadable (`Index`, `IndexMut`) |
| `expr[..]`, `expr[a..]`, `expr[..b]`, `expr[a..b]` | Collection indexing pretending to be collection slicing, using `Range`, `RangeFrom`, `RangeTo`, or `RangeFull` as the “index” |



================================================
FILE: assets/writing-material/posts/package.md
================================================
## layout
```go
.
├── Cargo.lock
├── Cargo.toml
├── src/
│   ├── lib.rs
│   ├── main.rs
│   └── bin/
│       ├── named-executable.rs
│       ├── another-executable.rs
│       └── multi-file-executable/
│           ├── main.rs
│           └── some_module.rs
├── benches/
│   ├── large-input.rs
│   └── multi-file-bench/
│       ├── main.rs
│       └── bench_module.rs
├── examples/
│   ├── simple.rs
│   └── multi-file-example/
│       ├── main.rs
│       └── ex_module.rs
└── tests/
    ├── some-integration-tests.rs
    └── multi-file-test/
        ├── main.rs
        └── test_module.rs
```




================================================
FILE: assets/writing-material/posts/performance.md
================================================
## books
1. [Rust性能之书](https://nnethercote.github.io/perf-book/title-page.html)
2. [How to write fast rust code](https://likebike.com/posts/How_To_Write_Fast_Rust_Code.html#emit-asm)


## crates
1. [高性能Mutex库](https://github.com/Amanieu/parking_lot)

## 不要通过环境变量来控制在不同环境下的tracing行为

这种控制消耗很大，随着rust 1.57.0版本发布，可以使用自定义cargo profile的方式来实现

cargo profile可以做：
Enable costlier tracing/logging/debug on staging builds, or force LTO only for production builds.


为何不要用环境变量来控制tracing库的行为:
If your app is in any way performance sensitive you are carrying a significant cost for that.


================================================
FILE: assets/writing-material/posts/plugins.md
================================================

https://www.reddit.com/r/rust/comments/sboyb2/designing_a_rust_rust_plugin_system/


================================================
FILE: assets/writing-material/posts/reference.md
================================================
## struct中的一个字段是另外一个字段的指针
```rust
#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
}

impl Test {
    fn new(txt: &str) -> Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
        }
    }

    fn init(&mut self) {
        let self_ref: *const String = &self.a;
        self.b = self_ref;
    }

    fn a(&self) -> &str {
        &self.a
    }

    fn b(&self) -> &String {
        assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
        unsafe { &*(self.b) }
    }
}
```

Test provides methods to get a reference to the value of the fields a and b. Since b is a reference to a we store it as a pointer since the borrowing rules of Rust doesn't allow us to define this lifetime. We now have what we call a self-referential struct.




================================================
FILE: assets/writing-material/posts/rust-analyser.md
================================================
## 可以为rust-analyzer指定一个check文件夹，避免构建的cache被lock住

You can already setup rust-analyzer to use different folder. I set `Check On Save` to `check` and in `Check On Save: Extra Args` to `--target-dir target/rust-analyzer-target`.


================================================
FILE: assets/writing-material/posts/self-referential.md
================================================
## code snippets
1. https://stackoverflow.com/questions/67823680/open-a-single-file-from-a-zip-archive-and-pass-on-as-read-instance/67828823#67828823


## crates
1. https://github.com/Kimundi/owning-ref-rs
2. https://github.com/joshua-maros/ouroboros

https://www.reddit.com/r/learnrust/comments/rf4qdz/is_it_possible_to_hold_an_arena_and_references/


================================================
FILE: assets/writing-material/posts/SIMD.md
================================================

https://www.reddit.com/r/rust/comments/rqgwaz/why_is_my_simd_code_slower_than_the_naive_one/


================================================
FILE: assets/writing-material/posts/string.md
================================================
## 字符串常量

```rust
fn main() {
    // You can use escapes to write bytes by their hexadecimal values...
    let byte_escape = "I'm writing \x52\x75\x73\x74!";
    println!("What are you doing\x3F (\\x3F means ?) {}", byte_escape);

    // ...or Unicode code points.
    let unicode_codepoint = "\u{211D}";
    let character_name = "\"DOUBLE-STRUCK CAPITAL R\"";

    println!("Unicode character {} (U+211D) is called {}",
                unicode_codepoint, character_name );


    let long_string = "String literals
                        can span multiple lines.
                        The linebreak and indentation here ->\
                        <- can be escaped too!";
    println!("{}", long_string);
}
```

```rust
fn main() {
    let raw_str = r"Escapes don't work here: \x3F \u{211D}";
    println!("{}", raw_str);

    // If you need quotes in a raw string, add a pair of #s
    let quotes = r#"And then I said: "There is no escape!""#;
    println!("{}", quotes);

    // If you need "# in your string, just use more #s in the delimiter.
    // There is no limit for the number of #s you can use.
    let longer_delimiter = r###"A string with "# in it. And even "##!"###;
    println!("{}", longer_delimiter);
}
```

## Bytes string
Want a string that's not UTF-8? (Remember, `str` and `String` must be valid UTF-8). Or maybe you want an array of bytes that's mostly text? Byte strings to the rescue!

```rust
use std::str;

fn main() {
    // Note that this is not actually a `&str`
    let bytestring: &[u8; 21] = b"this is a byte string";

    // Byte arrays don't have the `Display` trait, so printing them is a bit limited
    println!("A byte string: {:?}", bytestring);

    // Byte strings can have byte escapes...
    let escaped = b"\x52\x75\x73\x74 as bytes";
    // ...but no unicode escapes
    // let escaped = b"\u{211D} is not allowed";
    println!("Some escaped bytes: {:?}", escaped);


    // Raw byte strings work just like raw strings
    let raw_bytestring = br"\u{211D} is not escaped here";
    println!("{:?}", raw_bytestring);

    // Converting a byte array to `str` can fail
    if let Ok(my_str) = str::from_utf8(raw_bytestring) {
        println!("And the same as text: '{}'", my_str);
    }

    let _quotes = br#"You can also use "fancier" formatting, \
                    like with normal raw strings"#;

    // Byte strings don't have to be UTF-8
    let shift_jis = b"\x82\xe6\x82\xa8\x82\xb1\x82\xbb"; // "ようこそ" in SHIFT-JIS

    // But then they can't always be converted to `str`
    match str::from_utf8(shift_jis) {
        Ok(my_str) => println!("Conversion successful: '{}'", my_str),
        Err(e) => println!("Conversion failed: {:?}", e),
    };
}
```


================================================
FILE: assets/writing-material/posts/system_command.md
================================================
关于调用os的命令

```rust
use std::process::Command;

fn main() {
    let output = Command::new("rustc")
        .arg("--versn")
        .output().unwrap_or_else(|e| {
            panic!("failed to execute process: {}", e)
    });

    if output.status.success() {
        let s = String::from_utf8_lossy(&output.stdout);

        print!("rustc succeeded and stdout was:\n{}", s);
    } else {
        let s = String::from_utf8_lossy(&output.stderr);

        print!("rustc failed and stderr was:\n{}", s);
    }
}
```

## Pipes
The std::Child struct represents a running child process, and exposes the stdin, stdout and stderr handles for interaction with the underlying process via pipes.

```rust
use std::io::prelude::*;
use std::process::{Command, Stdio};

static PANGRAM: &'static str =
"the quick brown fox jumped over the lazy dog\n";

fn main() {
    // Spawn the `wc` command
    let process = match Command::new("wc")
                                .stdin(Stdio::piped())
                                .stdout(Stdio::piped())
                                .spawn() {
        Err(why) => panic!("couldn't spawn wc: {}", why),
        Ok(process) => process,
    };

    // Write a string to the `stdin` of `wc`.
    //
    // `stdin` has type `Option<ChildStdin>`, but since we know this instance
    // must have one, we can directly `unwrap` it.
    match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) {
        Err(why) => panic!("couldn't write to wc stdin: {}", why),
        Ok(_) => println!("sent pangram to wc"),
    }

    // Because `stdin` does not live after the above calls, it is `drop`ed,
    // and the pipe is closed.
    //
    // This is very important, otherwise `wc` wouldn't start processing the
    // input we just sent.

    // The `stdout` field also has type `Option<ChildStdout>` so must be unwrapped.
    let mut s = String::new();
    match process.stdout.unwrap().read_to_string(&mut s) {
        Err(why) => panic!("couldn't read wc stdout: {}", why),
        Ok(_) => print!("wc responded with:\n{}", s),
    }
}

```


## 调用命令，使用用户的输入作为参数

```rust
let cmd = Command::new("rev")
    .stdin(Stdio::inherit())
    .stdout(Stdio::inherit())
    .output()?;
```

https://www.reddit.com/r/learnrust/comments/r5wwkz/what_the_relationship_between_processstdio_and/



================================================
FILE: assets/writing-material/posts/threads.md
================================================
## Arc和Mutex结合实现多线程数据修改和汇总
```rust
use std::sync::{Arc,Mutex};
use std::thread;
use std::time::Duration;

struct JobStatus {
    jobs_completed: u32,
}

fn main() {
    let status = Arc::new(Mutex::new(JobStatus { jobs_completed: 0 }));
    let status_shared = Arc::clone(&status);
    thread::spawn(move || {
        for _ in 0..10 {
            thread::sleep(Duration::from_millis(250));
            let mut s = status_shared.lock().unwrap();
            s.jobs_completed += 1;
        }
    });

    while status.lock().unwrap().jobs_completed < 10 {
        println!("waiting... ");
        thread::sleep(Duration::from_millis(500));
    }
}
```

## 多个线程同时无锁的对一个数组进行修改
https://www.reddit.com/r/rust/comments/rtutr0/lockless_threads_for_mutable_operations/


================================================
FILE: assets/writing-material/posts/to_resolved.md
================================================
## unknown `into` behavior

```rust
 let s: Box<dyn Error + Send + Sync> = "connection reset by peer".into();
 ```

this works because:
```rust
impl From<&'_ str> for Box<dyn Error>
```


================================================
FILE: assets/writing-material/posts/tokio.md
================================================
## 性能

https://www.reddit.com/r/rust/comments/lg0a7b/benchmarking_tokio_tasks_and_goroutines/


================================================
FILE: assets/writing-material/posts/trivia.md
================================================
## Rust冷知识

https://www.reddit.com/r/rust/comments/rwufz4/borrow_checker_allows_borrow_of_mutably_borrowed/


================================================
FILE: assets/writing-material/posts/wasm.md
================================================
https://www.reddit.com/r/rust/comments/s9yugv/compile_rust_to_wasm_and_import_as_typescript/


================================================
FILE: assets/writing-material/posts/fight-with-compiler-check/borrow.md
================================================
## 可以通过move struct中的字段，来解决borrow和mut borrow无法共存的问题

```rust
struct Foo {
    bar: Bar
}

let bar: &Bar = &foo.bar;
let foo_mut: &mut Foo = &mut foo; // Can’t do it.
println!("{}{}", foo_mut, bar);
```

If you no longer need Bar as a field of Foo, you can move it out instead of borrowing. This way you will be able to obtain Bar and still be able to mutate Foo.

```rust
struct Foo {
    bar: Option<Bar>
}

let bar: Bar = foo.bar.take(); // sets option to None
let foo_mut: &mut Foo = &mut foo;

println!("{}{}", foo_mut, bar);
```




================================================
FILE: assets/writing-material/posts/fight-with-compiler-check/generic.md
================================================
## the type parameter `T` is not constrained by the impl trait

```rust
use std::default::Default;

trait Maker {
    type Item;

    fn make(&mut self) -> Self::Item;
}

struct Foo<T> {
    a: T,
}

struct Bar;

impl<T> Maker for Bar
    where T: Default  {
    type Item = Foo<T>;

    fn make(&mut self) -> Foo<T> {
        Foo {
            a: <T as Default>::default(),
        }
    }
}
```

上面的代码会导致以下编译错误:
```bash
tests/lang.rs:1000:10: 1000:11 error: the type parameter `T` is not constrained by the impl trait, self type, or predicates [E0207]
tests/lang.rs:1000     impl<T> Maker for Bar
```

可以使用[幽灵数据]()来初步解决

```rust
use std::marker::PhantomData;
struct Bar<T> {
    _m: PhantomData<T>
}

impl<T> Maker for Bar<T>
    where T: Default  {
    type Item = Foo<T>;

    fn make(&mut self) -> Foo<T> {
        Foo {
            a: <T as Default>::default(),
        }
    }
}
```

关于这个问题，主要是因为在`impl`代码块中，关联类型是由`Self`和所有输入类型参数一同决定的，也就是说`关联类型`中出现的泛型参数，必须在`impl`中有所定义，要么为`Maker`增加泛型变量，要么为`Bar`增加。

如果你想要让Self拥有多种可能的类型，就得使用外部输入的类型参数，而不是关联类型：
```rust
use std::default::Default;

trait Maker<Item> {
    fn make(&mut self) -> Item;
}

struct Foo<T> {
    a: T,
}

struct Bar;

impl<T> Maker<Foo<T>> for Bar
    where T: Default  
{

    fn make(&mut self) -> Foo<T> {
        Foo {
            a: <T as Default>::default(),
        }
    }
}
```

类似的例子还有这个：https://www.reddit.com/r/rust/comments/r61l29/generic_impl_doesnt_work_while_generic_function/




================================================
FILE: assets/writing-material/posts/tests/doc_test.md
================================================
## Documentation testing
The primary way of documenting a Rust project is through annotating the source code. Documentation comments are written in markdown and support code blocks in them. Rust takes care about correctness, so these code blocks are compiled and used as tests.

```rust
/// First line is a short summary describing function.
///
/// The next lines present detailed documentation. Code blocks start with
/// triple backquotes and have implicit `fn main()` inside
/// and `extern crate <cratename>`. Assume we're testing `doccomments` crate:
///
/// ```
/// let result = doccomments::add(2, 3);
/// assert_eq!(result, 5);
/// ```
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

/// Usually doc comments may include sections "Examples", "Panics" and "Failures".
///
/// The next function divides two numbers.
///
/// # Examples
///
/// ```
/// let result = doccomments::div(10, 2);
/// assert_eq!(result, 5);
/// ```
///
/// # Panics
///
/// The function panics if the second argument is zero.
///
/// ```rust,should_panic
/// // panics on division by zero
/// doccomments::div(10, 0);
/// ```
pub fn div(a: i32, b: i32) -> i32 {
    if b == 0 {
        panic!("Divide-by-zero error");
    }

    a / b
}

/// Using hidden `try_main` in doc tests.
///
/// ```
/// # // hidden lines start with `#` symbol, but they're still compileable!
/// # fn try_main() -> Result<(), String> { // line that wraps the body shown in doc
/// let res = try::try_div(10, 2)?;
/// # Ok(()) // returning from try_main
/// # }
/// # fn main() { // starting main that'll unwrap()
/// #    try_main().unwrap(); // calling try_main and unwrapping
/// #                         // so that test will panic in case of error
/// # }
/// ```
pub fn try_div(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err(String::from("Divide-by-zero"))
    } else {
        Ok(a / b)
    }
}
```

```bash
$ cargo test
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests doccomments

running 3 tests
test src/lib.rs - add (line 7) ... ok
test src/lib.rs - div (line 21) ... ok
test src/lib.rs - div (line 31) ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

## 最新进展
根据twitter上的消息，rust即将支持从测试文件中，自动获取文档注释的功能，这样就能保持测试文件和文档的一致性，无需在多个地方维护多套测试代码


================================================
FILE: assets/writing-material/posts/tests/integration_test.md
================================================
Cargo looks for integration tests in `tests` directory next to `src`.

File `src/lib.rs`:

```rust
// Define this in a crate called `adder`.
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

File with `test: tests/integration_test.rs`:

```rust
#[test]
fn test_add() {
    assert_eq!(adder::add(3, 2), 5);
}
```


================================================
FILE: assets/writing-material/posts/tests/misc.md
================================================
## Development dependencies
Sometimes there is a need to have dependencies for tests (or examples, or benchmarks) only. Such dependencies are added to Cargo.toml in the [dev-dependencies] section. These dependencies are not propagated to other packages which depend on this package.

One such example is using a crate that extends standard assert! macros.
File Cargo.toml:

```toml
# standard crate data is left out
[dev-dependencies]
pretty_assertions = "0.4.0"
```

File `src/lib.rs`:

```toml
// externing crate for test-only use
#[cfg(test)]
#[macro_use]
extern crate pretty_assertions;

pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }
}
```


================================================
FILE: assets/writing-material/posts/tests/unit_test.md
================================================
## Tests and ?
in Rust 2018, your unit tests can return Result<()>, which lets you use ? in them! This can make them much more concise.

```rust
fn sqrt(number: f64) -> Result<f64, String> {
    if number >= 0.0 {
        Ok(number.powf(0.5))
    } else {
        Err("negative floats don't have square roots".to_owned())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sqrt() -> Result<(), String> {
        let x = 4.0;
        assert_eq!(sqrt(x)?.powf(2.0), x);
        Ok(())
    }
}
```

## Testing panics
To check functions that should panic under certain circumstances, use attribute #[should_panic]. This attribute accepts optional parameter expected = with the text of the panic message. If your function can panic in multiple ways, it helps make sure your test is testing the correct panic.

```rust
pub fn divide_non_zero_result(a: u32, b: u32) -> u32 {
    if b == 0 {
        panic!("Divide-by-zero error");
    } else if a < b {
        panic!("Divide result is zero");
    }
    a / b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_divide() {
        assert_eq!(divide_non_zero_result(10, 2), 5);
    }

    #[test]
    #[should_panic]
    fn test_any_panic() {
        divide_non_zero_result(1, 0);
    }

    #[test]
    #[should_panic(expected = "Divide result is zero")]
    fn test_specific_panic() {
        divide_non_zero_result(1, 10);
    }
}

```

## Ignoring tests
Tests can be marked with the #[ignore] attribute to exclude some tests. Or to run them with command cargo test -- --ignored

```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 2), 4);
    }

    #[test]
    fn test_add_hundred() {
        assert_eq!(add(100, 2), 102);
        assert_eq!(add(2, 100), 102);
    }

    #[test]
    #[ignore]
    fn ignored_test() {
        assert_eq!(add(0, 0), 0);
    }
}
```


================================================
FILE: assets/writing-material/style_guide/coding.md
================================================
# 代码风格

## 使用[tap](https://github.com/myrrlyn/tap)库来实现`point-free`编程风格
```rust
use tap::{Tap, TapFallible};

type SomeValue = String;
type SomeOtherValue = String;
type SomeError = String;

fn foo() -> Result<SomeValue, SomeError> {
    Ok("foo".into())
}

fn bar(input: &str) -> Result<SomeOtherValue, SomeError> {
    if input == "bar" {
        Ok("Success".into())
    } else {
        Err("This is a failure message".into())
    }
}

fn my_fun() -> Result<SomeOtherValue, SomeError> {
    foo()
        .tap_err(|err| println!("foo() failed with error: {}", err))
        .and_then(|foo_val| bar(&foo_val))
        .tap(|res| println!("bar() returned result: {:?}", res))
}

fn main() {
    let result = my_fun();
    println!("{:?}", result);
}
```


================================================
FILE: assets/writing-material/style_guide/naming.md
================================================
# 命名规范

基本的Rust命名规范在[RFC 430]中有描述.

通常，对于"type-level"的构造Rust倾向于使用驼峰命名,而对于'value-level'的构造使用蛇形命名。详情如下:

| 条目 | 惯例 |
| ---- | ---------- |
| 包Crates | [unclear](https://github.com/rust-lang/api-guidelines/issues/29) |
| 模块Modules | `snake_case` |
| 类型Types | `UpperCamelCase` |
| 特征Traits | `UpperCamelCase` |
| 枚举项 | `UpperCamelCase` |
| 函数Functions | `snake_case` |
| 方法Methods | `snake_case` |
| 通用构造器General constructors | `new` or `with_more_details` |
| 转换构造器Conversion constructors | `from_some_other_type` |
| 宏Macros | `snake_case!` |
| 局部变量Local variables | `snake_case` |
| 静态类型Statics | `SCREAMING_SNAKE_CASE` |
| 常量Constants | `SCREAMING_SNAKE_CASE` |
| 类型参数Type parameters | `UpperCamelCase`, 通常使用一个大写字母: `T` |
| 生命周期Lifetimes | 通常使用小写字母: `'a`, `'de`, `'src` |
| Features | [unclear](https://github.com/rust-lang/api-guidelines/issues/101) but see [C-FEATURE] |

对于驼峰命名法, 复合词的缩略形式我们认为是一个单独的词语，所以只对首字母进行大写: 使用`Uuid`而不是`UUID`, `Usize`而不是`USize`, `Stdin`而不是`StdIn`.对于蛇形命名法，缩略词用全小写: `is_xid_start`.

对于蛇形命名(包括全大写的`SCREAMING_SNAKE_CASE`), 除了最后一部分，其它部分的词语都不能由单个字母组成：
`btree_map`而不是`b_tree_map`, `PI_2`而不是`PI2`.

包名不应该使用`-rs`或者`-rust`作为后缀，因为每一个包都是Rust写的，因此这种多余的注释其实没有任何意义。

[RFC 430]: https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md
[C-FEATURE]: #c-feature


##  类型转换要遵守`as_`, `to_`, `into_`命名惯例(C-CONV)
类型转换应该通过方法调用的方式实现，其中的前缀规则如下：

| 方法前缀 | 性能开销 | 所有权改变 |
| ------ | ---- | --------- |
| `as_` | Free | borrowed -\> borrowed |
| `to_` | Expensive | borrowed -\> borrowed<br>borrowed -\> owned (non-Copy types)<br>owned -\> owned (Copy types) |
| `into_` | Variable | owned -\> owned (non-Copy types) |

For example:

- [`str::as_bytes()`] 把`str`变成UTF-8字节数组, 性能开销是0. 其中输入是一个借用的`&str`，输出也是一个借用的`&str`.
- [`Path::to_str`] 会执行一次昂贵的UTF-8字节数组检查，输入和输出都是借用的。对于这种情况，如果把方法命名为`as_str`是不正确的，因为这个方法的开销还挺大.
- [`str::to_lowercase()`]在调用过程中会遍历字符串的字符，且可能会分配新的内存对象.输入是一个借用的`str`，输出是一个有独立所有权的`String`
- [`String::into_bytes()`]返回`String`底层的`Vec<u8>`数组，转换本身是零消耗的。该方法获取`String`的所有权，然后返回一个新的有独立所有权的`Vec<u8>`


[`str::as_bytes()`]: https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes
[`Path::to_str`]: https://doc.rust-lang.org/std/path/struct.Path.html#method.to_str
[`str::to_lowercase()`]: https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase
[`f64::to_radians()`]: https://doc.rust-lang.org/std/primitive.f64.html#method.to_radians
[`String::into_bytes()`]: https://doc.rust-lang.org/std/string/struct.String.html#method.into_bytes
[`BufReader::into_inner()`]: https://doc.rust-lang.org/std/io/struct.BufReader.html#method.into_inner
[`BufWriter::into_inner()`]: https://doc.rust-lang.org/std/io/struct.BufWriter.html#method.into_inner


当一个单独的值被某个类型所包装时，访问该类型的内部值应通过`into_inner()`方法来访问。例如将一个缓冲区值包装为[`BufReader`]类型，还有[`GzDecoder`]、[`AtomicBool`]等，都是这种类型。


[`BufReader`]: https://doc.rust-lang.org/std/io/struct.BufReader.html#method.into_inner
[`GzDecoder`]: https://docs.rs/flate2/0.2.19/flate2/read/struct.GzDecoder.html#method.into_inner
[`AtomicBool`]: https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.into_inner

如果`mut`限定符在返回类型中出现，那么在命名上也应该体现出来。例如，[`Vec::as_mut_slice`] 就说明它返回了一个mut切片，在这种情况下`as_mut_slice`比`as_slice_mut`更适合。

[`Vec::as_mut_slice`]: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.as_mut_slice

```rust
// 返回类型是一个mut切片.
fn as_mut_slice(&mut self) -> &mut [T];
```

##### 标准库中的一些例子

- [`Result::as_ref`](https://doc.rust-lang.org/std/result/enum.Result.html#method.as_ref)
- [`RefCell::as_ptr`](https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.as_ptr)
- [`slice::to_vec`](https://doc.rust-lang.org/std/primitive.slice.html#method.to_vec)
- [`Option::into_iter`](https://doc.rust-lang.org/std/option/enum.Option.html#method.into_iter)


##  读访问器(Getter)的名称遵循Rust的命名规范(C-GETTER)

除了少数例外，在Rust代码中`get`前缀不用于getter。

```rust
pub struct S {
    first: First,
    second: Second,
}

impl S {
    // 而不是get_first
    pub fn first(&self) -> &First {
        &self.first
    }

    // 而不是get_first_mut, get_mut_first, or mut_first.
    pub fn first_mut(&mut self) -> &mut First {
        &mut self.first
    }
}
```
至于上文提到的少数例外，如下：当有且仅有一个值能被getter所获取时，才使用`get`前缀。例如，
[`Cell::get`]能直接访问到`Cell`中的内容。

[`Cell::get`]: https://doc.rust-lang.org/std/cell/struct.Cell.html#method.get

有些getter会在过程中执行运行时检查，那么我们就可以考虑添加`_unchecked`getter函数，这个函数虽然不安全，但是往往具有更高的性能，
典型的例子如下：

```rust
fn get(&self, index: K) -> Option<&V>;
fn get_mut(&mut self, index: K) -> Option<&mut V>;
unsafe fn get_unchecked(&self, index: K) -> &V;
unsafe fn get_unchecked_mut(&mut self, index: K) -> &mut V;
```

[`TempDir::path`]: https://docs.rs/tempdir/0.3.5/tempdir/struct.TempDir.html#method.path
[`TempDir::into_path`]: https://docs.rs/tempdir/0.3.5/tempdir/struct.TempDir.html#method.into_path

### 标准库示例

- [`std::io::Cursor::get_mut`](https://doc.rust-lang.org/std/io/struct.Cursor.html#method.get_mut)
- [`std::ptr::Unique::get_mut`](https://doc.rust-lang.org/std/ptr/struct.Unique.html#method.get_mut)
- [`std::sync::PoisonError::get_mut`](https://doc.rust-lang.org/std/sync/struct.PoisonError.html#method.get_mut)
- [`std::sync::atomic::AtomicBool::get_mut`](https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.get_mut)
- [`std::collections::hash_map::OccupiedEntry::get_mut`](https://doc.rust-lang.org/std/collections/hash_map/struct.OccupiedEntry.html#method.get_mut)
- [`<[T]>::get_unchecked`](https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked)

## 一个集合上的方法，如果返回迭代器，需遵循命名规则：`iter`, `iter_mut`, `into_iter` (C-ITER)

```rust
fn iter(&self) -> Iter             // Iter implements Iterator<Item = &U>
fn iter_mut(&mut self) -> IterMut  // IterMut implements Iterator<Item = &mut U>
fn into_iter(self) -> IntoIter     // IntoIter implements Iterator<Item = U>
```
上面的规则适用于同构性的数据集合。与之相反，`str`类型是一个utf8字节数组切片，与同构性集合有一点微妙的差别，它可以认为是字节集合，也可以认为是字符集合，因此它提供了[`str::bytes`]去遍历字节，还有[`str::chars`]去遍历字符，而并没有直接定义`iter`等方法。

[`str::bytes`]: https://doc.rust-lang.org/std/primitive.str.html#method.bytes
[`str::chars`]: https://doc.rust-lang.org/std/primitive.str.html#method.chars

上述规则只适用于方法，并不适用于函数。例如`url`包的[`percent_encode`]函数返回一个迭代器用于遍历百分比编码([Percent encoding](https://en.wikipedia.org/wiki/Percent-encoding))的字符串片段. 在这种情况下，使用`iter`/`iter_mut`/`into_iter`诸如此类的函数命名无法表达任何具体的含义。

[`percent_encode`]: https://docs.rs/url/1.4.0/url/percent_encoding/fn.percent_encode.html
[RFC 199]: https://github.com/rust-lang/rfcs/blob/master/text/0199-ownership-variants.md

### 标准库示例

- [`Vec::iter`](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter)
- [`Vec::iter_mut`](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut)
- [`Vec::into_iter`](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter)
- [`BTreeMap::iter`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter)
- [`BTreeMap::iter_mut`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter_mut)

## 迭代器的类型应该与产生它的方法名相匹配(C-ITER-TY)
例如形如`into_iter()`的方法应该返回一个`IntoIter`类型，与之相似，其它任何返回迭代器的方法也应该遵循这种命名惯例。

上述规则主要应用于方法，但是经常对于函数也适用。例如上文提到的url包中的[`percent_encode`]函数，返回了一个[`PercentEncode`]类型.

[PercentEncode-type]: https://docs.rs/url/1.4.0/url/percent_encoding/struct.PercentEncode.html

特别是，当这些类型跟包名前缀一起使用时，将具备非常清晰的含义，例如[`vec::IntoIter`].

[`vec::IntoIter`]: https://doc.rust-lang.org/std/vec/struct.IntoIter.html

### 标准库示例

* [`Vec::iter`] returns [`Iter`][slice::Iter]
* [`Vec::iter_mut`] returns [`IterMut`][slice::IterMut]
* [`Vec::into_iter`] returns [`IntoIter`][vec::IntoIter]
* [`BTreeMap::keys`] returns [`Keys`][btree_map::Keys]
* [`BTreeMap::values`] returns [`Values`][btree_map::Values]

[`Vec::iter`]: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter
[slice::Iter]: https://doc.rust-lang.org/std/slice/struct.Iter.html
[`Vec::iter_mut`]: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut
[slice::IterMut]: https://doc.rust-lang.org/std/slice/struct.IterMut.html
[`Vec::into_iter`]: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter
[vec::IntoIter]: https://doc.rust-lang.org/std/vec/struct.IntoIter.html
[`BTreeMap::keys`]: https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.keys
[btree_map::Keys]: https://doc.rust-lang.org/std/collections/btree_map/struct.Keys.html
[`BTreeMap::values`]: https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.values
[btree_map::Values]: https://doc.rust-lang.org/std/collections/btree_map/struct.Values.html


<a id="c-feature"></a>
## Cargo Feature的名称不应该包含占位词(C-FEATURE)

不要在[Cargo feature]中包含无法传达任何意义的词，例如`use-abc`或`with-abc`，直接命名为`abc`即可。

[Cargo feature]: http://doc.crates.io/manifest.html#the-features-section

一个典型的例子就是：一个包对标准库有可选性的依赖。标准的写法如下：

```toml
# 在Cargo.toml中

[features]
default = ["std"]
std = []
```

```rust
// 在我们自定义的lib.rs中

#![cfg_attr(not(feature = "std"), no_std)]
```
除了`std`之外，不要使用任何`ust-std`或者`with-std`等自以为很有创造性的名称。

## 命名要使用一致性的词序(C-WORD-ORDER)

这是一些标准库中的错误类型:

- [`JoinPathsError`](https://doc.rust-lang.org/std/env/struct.JoinPathsError.html)
- [`ParseBoolError`](https://doc.rust-lang.org/std/str/struct.ParseBoolError.html)
- [`ParseCharError`](https://doc.rust-lang.org/std/char/struct.ParseCharError.html)
- [`ParseFloatError`](https://doc.rust-lang.org/std/num/struct.ParseFloatError.html)
- [`ParseIntError`](https://doc.rust-lang.org/std/num/struct.ParseIntError.html)
- [`RecvTimeoutError`](https://doc.rust-lang.org/std/sync/mpsc/enum.RecvTimeoutError.html)
- [`StripPrefixError`](https://doc.rust-lang.org/std/path/struct.StripPrefixError.html)

它们都使用了`谓语-宾语-错误`的词序，如果我们想要表达一个网络地址无法分析的错误，由于词序一致性的原则，命名应该如下`ParseAddrError`,而不是`AddrParseError`。

词序和个人习惯有很大关系，想要注意的是，你可以选择合适的词序，但是要在包的范畴内保持一致性，就如标准库中的包一样。



================================================
FILE: ci/copy-assets.sh
================================================
#!/usr/bin/env bash

cp ./assets/CNAME ./book/
cp ./assets/*.html ./book/
cp ./assets/sitemap.xml ./book/


================================================
FILE: src/about-book.md
================================================
<img src="https://github.com/sunface/rust-course/blob/main/assets/banner.jpg?raw=true" />

Rust 语言真的好：连续八年成为全世界最受欢迎的语言、没有 GC 也无需手动内存管理、性能比肩 C++/C 还能直接调用它们的代码、安全性极高 - 总有公司说使用 Rust 后以前的大部分 bug 都将自动消失、全世界最好的包管理工具 Cargo 等等。但...

**有人说: "Rust 太难了，学了也没用"**

对于后面一句话我们持保留意见，如果以找工作为标准，那国内环境确实还不好，但如果你想成为更优秀的程序员或者是玩转开源，那 Rust 还真是不错的选择，具体原因见[下一章](https://course.rs/into-rust.html)。

至于 Rust 难学，那正是本书要解决的问题，如果看完后，你觉得没有学会 Rust，可以找我们退款，哦抱歉，这是开源书，那就退 🌟 吧 :)

如果看到这里，大家觉得这本书的介绍并没有吸引到你，不要立即放弃，强烈建议读一下[进入 Rust 编程世界](https://course.rs/into-rust.html)，那里会有不一样的精彩。

## 配套练习题

对于学习编程而言，读一篇文章不如做几道练习题，此话虽然夸张，但是也不无道理。既然如此，既读书又做练习题，效果会不会更好？再加上练习题是书本的配套呢？ :P

- [Rust 语言实战](https://github.com/sunface/rust-by-practice), Rust 语言圣经配套习题，支持中英双语，可以在右上角切换

## 创作感悟

截至目前，Rust 语言圣经已写了 170 余章，110 余万字，历经 1000 多个小时，每一个章节都是手动写就，没有任何机翻和质量上的妥协( 相信深入阅读过的读者都能体会到这一点 )。

曾经有读者问过 "这么好的书为何要开源，而不是出版?"，原因很简单：**只有完全开源才能完美地呈现出我想要的教学效果**。

总之，Rust 要在国内真正发展起来，必须得有一些追逐梦想的人在做着不计付出的事情，而我希望自己能贡献一份微薄之力。

但是要说完全无欲无求，那也是不可能的，看到项目多了一颗 🌟，那感觉...棒极了，因为它代表了读者的认可和称赞。

你们用指尖绘制的星空，那里繁星点点，每一颗都在鼓励着怀揣着开源梦想的程序员披荆斩棘、不断前行，不夸张的说，没有你们，开源世界就没有星光，自然也就不会有今天的开源盛世。

因此，**我恳请大家，如果觉得书还可以，就在你的指尖星空绘制一颗新的 🌟，指引我们继续砥砺前行**。这个人世间，因善意而美好。

最后，能通过开源在茫茫人海中与大家相识，这感觉真好 :D

## 🏆 贡献者

非常感谢本教程的[所有贡献者](https://github.com/sunface/rust-course/graphs/contributors)，正是有了你们，才有了现在的高质量 Rust 教程!

<br />

🏆

<table>
    <tbody>
    <tr>
        <td align="center">
            <a href="https://github.com/EluvK">
                <img src="https://avatars.githubusercontent.com/u/36977935?v=4" width="160px" alt=""/>
                <br />
                <sub><b>EluvK</b></sub>
            </a>
        </td>
        <td align="center">
            <a href="https://github.com/AllanDowney">
                <img src="https://avatars.githubusercontent.com/u/82752697?v=4?s=100"  width="160px" alt=""/>
                <br />
                <sub><b>AllanDowney</b></sub>
            </a>
        </td>
    </tr>
    </tbody>
</table>

<br />

🏅

<table>
    <tbody>
    <tr>
        <td align="center">
            <a href="https://github.com/JesseAtSZ">
                <img src="https://avatars.githubusercontent.com/u/35264598?v=4?s=100" width="100px" alt=""/>
                <br />
                <sub><b>JesseAtSZ</b></sub>
            </a>
        </td>
        <td align="center">
            <a href="https://github.com/Rustln">
                <img src="https://avatars.githubusercontent.com/u/100085326?v=4?s=100" width="100px" alt=""/>
                <br />
                <sub><b>Rustln</b></sub>
            </a>
        </td>
        <td align="center">
            <a href="https://github.com/1132719438">
                <img src="https://avatars.githubusercontent.com/u/10138791?v=4?s=100" width="100px" alt=""/>
                <br />
                <sub><b>1132719438</b></sub>
            </a>
        </td>
        <td align="center">
            <a href="https://github.com/zongzi531">
                <img src="https://avatars.githubusercontent.com/u/22429236?v=4?s=100" width="100px" alt=""/>
                <br />
                <sub><b>zongzi531</b></sub>
            </a>
        </td>
    </tr>
    </tbody>
</table>



================================================
FILE: src/beat-ai.md
================================================
## Beat AI
专属于软件开发工程师的 AI 入门圣经。从神经网络到大模型，从高层设计到微观原理，从工程实现到算法，学完后，你会发现 AI 也并不是想象中那么高不可攀、无法战胜，Just beat it !

- 官方地址: [https://github.com/sunface/beat-ai](https://github.com/sunface/beat-ai)
  
## 目前进度
准备开始动笔，预计在 2024.08 之前会完成基本的章节。

## 关于作者
作者并不是写书的小白，已经有一本 <<Rust语言圣经>> ，在 Rust 领域是目前最火的书籍，备受好评。

## Q & A
Q: 为什么又双叒叕写一本 AI 入门书籍？

A: 一般来说，懂 AI 的往往并不深入懂工程，而精通工程的又不太懂 AI，我们的目的就是填补这个 gap，以工程师的角度来呈现 AI 的相关知识体系。

Q: 不懂数学可以学吗

A: 一本优秀的书籍它应该是**层次丰富、结构清晰、深入浅出、通俗易懂**的，能满足不同读者群体的需求。本书也是，就算读者大大不懂数学，无非就是无法深入到算法层面，但是并不妨碍深入学习理解 AI，我们也会对算法进行一些深入浅出的趣味讲解。

Q: 没有软件开发的背景，不太懂工程，也不懂数学，能学吗?

A: 答案基本同上，千人千面，各有所获。


================================================
FILE: src/community.md
================================================
[Binary file]


================================================
FILE: src/github.md
================================================
# GitHub



================================================
FILE: src/index-list.md
================================================
# 快速查询入口

<<Rust 语言圣经>> 既然自诩为 Rust 日常开发工具书，那就得有工具书的样子，如果没有了快速索引查询的功能，也就没有了灵魂。

因此我们决定在这里提供一个对全书内容进行快速索引的途径。理论上来说，**你想查的任何东西在这里都可以快速的被找到并能进入相应的章节查看详细的介绍**。

可能大家会有疑问，不是有站内搜索功能嘛？是的，但是尴尬的是：首先它不支持中文，其次就算支持了中文，也一样不好用，我们需要的是快速精准地找到内容而不是模糊的查询内容。

# 索引列表 doing

<a id="head"></a>

|    NN     |   NN    |   NN    |   NN    |   NN    |   NN    |   NN    |   NN    |   NN    |
| :-------: | :-----: | :-----: | :-----: | :-----: | :-----: | :-----: | :-----: | :-----: |
| [#](#sym) | [A](#a) | [B](#b) | [C](#c) | [D](#d) | [E](#e) | [F](#f) | [G](#g) | [H](#h) |
|  [I](#i)  | [J](#j) | [K](#k) | [L](#l) | [M](#m) | [N](#n) | [O](#o) | [P](#p) | [Q](#q) |
|  [R](#r)  | [S](#s) | [T](#t) | [U](#u) | [V](#v) | [W](#w) | [X](#x) | [Y](#y) | [Z](#z) |

</br>

|       NN        |    NN    |     NN     |
| :-------------: | :------: | :--------: |
| [Cargo](#cargo) | [Naming] | [Keywords] |

[naming]: https://course.rs/practice/naming.html
[keywords]: https://course.rs/appendix/keywords.html

[bottom](#bottom)

## Sym

| 名称                              | 关键字         | 简介                                                                                 |
| --------------------------------- | -------------- | ------------------------------------------------------------------------------------ |
| `[?]`                             | 错误传播       | 用于简化错误传播                                                                     |
| `[()]`                            | 单元类型       | 单元类型，无返回值                                                                   |
| `!` : 1. [函数] 2. [类型]         | 永不返回       | 永不返回                                                                             |
| `[&]`                             | 引用           | 常规引用是一个指针类型，指向了对象存储的内存地址                                     |
| `[\*]`                            | 解引用         | 解出引用所指向的值                                                                   |
| `[@]`                             | 变量绑定       | 为一个字段绑定另外一个变量                                                           |
| `_` : 1. [忽略变量] 2. [模式匹配] | 忽略           | 1. 忽略该值或者类型，否则编译器会给你一个 `变量未使用的` 的警告<br>2. 模式匹配通配符 |
| `['a: 'b]`                        | 生命周期约束   | 用来说明两个生命周期的长短                                                           |
| `[{:?}] {:#?}`                    | 打印结构体信息 | 使用 `#[derive(Debug)]` 派生实现 `Debug` 特征，另见 [格式化输出]                     |
| `[::]`                            | 关联函数       | 定义在 `impl` 中且没有 `self` 的函数                                                 |
|                                   |                |

`[?]`: https://course.rs/basic/result-error/result.html#传播界的大明星-
`[()]`: https://course.rs/basic/base-type/function.html#无返回值
`[函数]`: https://course.rs/basic/base-type/function.html#永不返回的发散函数-
`[类型]`: https://course.rs/advance/into-types/custom-type.html#永不返回类型
`[&]`: https://course.rs/basic/ownership/borrowing.html#引用与解引用
`[\*]`: https://course.rs/basic/ownership/borrowing.html#引用与解引用
`[@]`: https://course.rs/basic/match-pattern/all-patterns.html#绑定
`['a: 'b]`: https://course.rs/advance/lifetime/advance.html#生命周期约束-hrtb
`[{:?}]`: https://course.rs/basic/compound-type/struct.html#使用-derivedebug-来打印结构体的信息
`[忽略变量]`: https://course.rs/basic/variable.html#使用下划线开头忽略未使用的变量
`[模式匹配]`: https://course.rs/basic/match-pattern/match-if-let.html#_-通配符
`[::]`: https://course.rs/basic/method.html#关联函数
`[格式化输出]`: https://course.rs/basic/formatted-output.html#-与-

[back](#head)

## A

| 名称          | 关键字   | 简介                                                                                                                   |
| ------------- | -------- | ---------------------------------------------------------------------------------------------------------------------- |
| [array 数组]  | 数组     | 长度固定<br>元素必须有相同的类型<br>依次线性排列<br>可以通过索引访问其中的元素<br>`let a: [i32; 5] = [1, 2, 3, 4, 5];` |
| [array slice] | 数组切片 | `let slice: &[i32] = &a[1..3];`                                                                                        |
| [as 转换]     | 类型转换 | `(x as T)`                                                                                                             |
|               | KWA      |                                                                                                                        |

[array 数组]: https://course.rs/basic/compound-type/array.html
[array slice]: https://course.rs/basic/compound-type/array.html#数组切片
[as 转换]: https://course.rs/advance/into-types/converse.html#as转换

[back](#head)

## B

| 名称               | 关键字       | 简介                                                                                                                            |
| ------------------ | ------------ | ------------------------------------------------------------------------------------------------------------------------------- |
| [变量遮蔽]         | shadowing    | 允许声明相同的变量名，后者会遮蔽掉前者                                                                                          |
| [变量覆盖]         | 模式匹配     | 无论是是 `match` 还是 `if let`，他们都可以在模式匹配时覆盖掉老的值，绑定新的值                                                  |
| [变量作用域]       | 所有权       | 作用域是一个变量在程序中有效的范围                                                                                              |
| [表达式] 与 [语句] |              | 表达式：进行求值，结尾无 `;`，有返回值，如 `x + 9` 另见 [附录 C]</br>语句：完成一个操作，结尾有 `;` ，无返回值，如 `let x = 9;` |
| [bool 布尔]        | 布尔类型     | `true` `false`，占用 1 字节                                                                                                     |
| [Box\<T\>]         | 智能指针     | 允许你将一个值分配到堆上，然后在栈上保留一个智能指针指向堆上的数据                                                              |
| [break]            | 循环控制     | 直接跳出当前整个循环                                                                                                            |
| [backtrace 栈展开] | 不可恢复错误 | `RUST_BACKTRACE=1 cargo run`                                                                                                    |
|                    | KWB          |                                                                                                                                 |

[变量遮蔽]: https://course.rs/basic/variable.html#变量遮蔽shadowing
[变量覆盖]: https://course.rs/basic/match-pattern/match-if-let.html#变量覆盖
[变量作用域]: https://course.rs/basic/ownership/ownership.html#变量作用域
[bool 布尔]: https://course.rs/basic/base-type/char-bool.html#布尔bool
[表达式]: https://course.rs/basic/base-type/statement-expression.html#表达式
[语句]: https://course.rs/basic/base-type/statement-expression.html#语句
[附录 c]: https://course.rs/appendix/expressions.html
[break]: https://course.rs/basic/flow-control.html#break
[backtrace 栈展开]: https://course.rs/basic/result-error/panic.html#backtrace-栈展开
[box\<t\>]: https://course.rs/advance/smart-pointer/box.html#使用-boxt-将数据存储在堆上

[back](#head)

## C

| 名称               | 关键字   | 简介                                                                                                             |
| ------------------ | -------- | ---------------------------------------------------------------------------------------------------------------- |
| [char 字符]        | 字符类型 | 使用 `''` 表示，所有的 Unicode 值                                                                                |
| [const 常量]       | constant | `const MAX_POINTS: u32 = 100_000;`                                                                               |
| [const 泛型]       | 泛型     | `const N: usize` 针对值的泛型，适合处理数组长度的问题                                                            |
| [const 泛型表达式] | 泛型     |                                                                                                                  |
| [Copy 拷贝]        | 浅拷贝   | 任何基本类型的组合可以 `Copy`，不需要分配内存或某种形式资源的类型是可以 `Copy` 的。                              |
| [continue]         | 循环控制 | 跳过当前当次的循环，开始下次的循环                                                                               |
| [Clone 克隆]       | 深拷贝   | 需要复制堆上的数据时，可以使用 `.clone()` 方法                                                                   |
| [Closure]          | 闭包     | 闭包是一种匿名函数，它可以赋值给变量也可以作为参数传递给其它函数，不同于函数的是，它允许[捕获调用者作用域中的值] |
|                    | KWC      |                                                                                                                  |

[char 字符]: https://course.rs/basic/base-type/char-bool.html#字符类型char
[const 常量]: https://course.rs/basic/variable.html#变量和常量之间的差异
[copy 拷贝]: https://course.rs/basic/ownership/ownership.html#拷贝浅拷贝
[clone 克隆]: https://course.rs/basic/ownership/ownership.html#克隆深拷贝
[continue]: https://course.rs/basic/flow-control.html#continue
[const 泛型]: https://course.rs/basic/trait/generic.html#const-泛型rust-151-版本引入的重要特性
[const 泛型表达式]: https://course.rs/basic/trait/generic.html#const-泛型表达式
[closure]: https://course.rs/advance/functional-programing/closure.html
[捕获调用者作用域中的值]: https://course.rs/advance/functional-programing/closure.html#捕获作用域中的值

[back](#head)

## D

| 名称              | 关键字   | 简介                                                                                                               |
| ----------------- | -------- | ------------------------------------------------------------------------------------------------------------------ |
| [derive]          | 派生特征 | `#[derive(Trait)]`，被标记的对象自动实现对应的默认特征<br>详见：[附录-派生特征]                                    |
| [点操作符]        | 类型转换 | 方法调用的点操作符，在调用时，会发生很多魔法般的类型转换<br>例如：自动引用、自动解引用，强制类型转换直到类型能匹配 |
| [Deref 解引用]    | 智能指针 |                                                                                                                    |
| [三种 Deref 转换] | 智能指针 |                                                                                                                    |
| [Drop 释放资源]   | 智能指针 |                                                                                                                    |
|                   | KWD      |                                                                                                                    |

[derive]: https://course.rs/basic/trait/trait.html#通过-derive-派生特征
[附录-派生特征]: https://course.rs/appendix/derive.html
[点操作符]: https://course.rs/basic/converse.html#点操作符
[deref 解引用]: https://course.rs/advance/smart-pointer/deref.html#deref-解引用
[三种 deref 转换]: https://course.rs/advance/smart-pointer/deref.html#三种-deref-转换
[drop 释放资源]: https://course.rs/advance/smart-pointer/drop.html#drop-释放资源

[back](#head)

## E

| 名称              | 关键字   | 简介                                     |
| ----------------- | -------- | ---------------------------------------- |
| [enum 枚举]       | 枚举类型 | 允许通过列举可能的成员来定义一个枚举类型 |
| [enum 同一化类型] | 枚举方法 | 枚举实现方法                             |
|                   | KWE      |                                          |

[enum 枚举]: https://course.rs/basic/compound-type/enum.html#枚举
[enum 同一化类型]: https://course.rs/basic/compound-type/enum.html#同一化类型

[back](#head)

## F

| 名称             | 关键字   | 简介                                                                                                                                                                                                                                                         |
| ---------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [浮点数]         | 数值类型 | `f32`<br>`f64`(默认类型)                                                                                                                                                                                                                                     |
| [for 循环]       | 循环控制 | `for item in &collection {}`                                                                                                                                                                                                                                 |
| ['fn' 函数]      |          | 函数名和变量名使用 `蛇形命名法(snake case)`<br>函数的位置可以随便放<br>每个函数参数都需要标注类型                                                                                                                                                            |
| [调用同名的方法] |          | 1. 默认调用类型上的方法<br>`Struct.function(receiver_if_method, next_arg, ...);`<br>2. 显式调用特征上的方法<br>`Trait::function(receiver_if_method, next_arg, ...);`<br>3. [完全限定语法]<br>`<Type as Trait>::function(receiver_if_method, next_arg, ...);` |
| [三种 Fn 特征]   | 闭包     | 闭包[捕获变量]有三种途径，恰好对应函数参数的三种传入方式：转移所有权、可变借用、不可变借用                                                                                                                                                                   |
| [三种 Fn 的关系] | 闭包     |                                                                                                                                                                                                                                                              |
|                  | KWF      |                                                                                                                                                                                                                                                              |

[浮点数]: https://course.rs/basic/base-type/numbers.html#浮点类型
[for 循环]: https://course.rs/basic/flow-control.html#for-循环
['fn' 函数]: https://course.rs/basic/base-type/function.html
[调用同名的方法]: https://course.rs/basic/trait/advance-trait.html#调用同名的方法
[完全限定语法]: https://course.rs/basic/trait/advance-trait.html#完全限定语法
[三种 fn 特征]: https://course.rs/advance/functional-programing/closure.html#三种-fn-特征
[捕获变量]: https://course.rs/advance/functional-programing/closure.html#捕获作用域中的值
[三种 fn 的关系]: https://course.rs/advance/functional-programing/closure.html#三种-fn-的关系

[back](#head)

## G

| 名称            | 关键字 | 简介                               |
| --------------- | ------ | ---------------------------------- |
| [Generics 泛型] | 泛型   | 用同一功能的函数处理不同类型的数据 |
|                 | KWG    |                                    |

[generics 泛型]: https://course.rs/basic/trait/generic.html

[back](#head)

## H

| 名称                  | 关键字   | 简介                                                                                                |
| --------------------- | -------- | --------------------------------------------------------------------------------------------------- |
| [HashMap]             | 哈希类型 | `HashMap<K, V>`，存储的是一一映射的 `KV` 键值对，并提供了平均复杂度为 `O(1)` 的查询方法             |
| [HashMap::new()]      |          | 创建 HashMap，需要手动通过 `use std::collections::HashMap;` 引入到我们当前的作用域中来              |
| `hash.insert(K, V)`   |          | 插入键值对，必须声明为 `mut`                                                                        |
| [元组创建 HashMap]    |          | 使用迭代器和 collect 方法创建<br>`let teams_map: HashMap<_, _> = teams_list.into_iter().collect();` |
| [查询 HashMap]        |          | 通过 `get` 方法可以获取元素，返回一个 `Option<&T>` 类型                                             |
| [更新 HashMap 中的值] |          |                                                                                                     |
|                       | KWH      |                                                                                                     |

[hashmap::new()]: https://course.rs/basic/collections/hashmap.html#使用-new-方法创建
[元组创建 hashmap]: https://course.rs/basic/collections/hashmap.html#使用迭代器和-collect-方法创建
[查询 hashmap]: https://course.rs/basic/collections/hashmap.html#查询-hashmap
[更新 hashmap 中的值]: https://course.rs/basic/collections/hashmap.html#更新-hashmap-中的值

[back](#head)

## I

| 名称                                         | 关键字   | 简介                                                                  |
| -------------------------------------------- | -------- | --------------------------------------------------------------------- |
| [if else]                                    | 流程控制 | 根据条件执行不同的代码分支                                            |
| [else if]                                    | 流程控制 | 处理多重条件                                                          |
| [if let 匹配]                                | 模式匹配 | 当你只要匹配一个条件，且忽略其他条件时就用 `if let`，否则都用 `match` |
| `impl Trait` 1. [函数参数] 2. [函数返回类型] |          |                                                                       |
|                                              | KWI      |                                                                       |

[if else]: https://course.rs/basic/flow-control.html#使用-if-来做分支控制
[else if]: https://course.rs/basic/flow-control.html#使用-else-if-来处理多重条件
[if let 匹配]: https://course.rs/basic/match-pattern/match-if-let.html#if-let-匹配
[函数参数]: https://course.rs/basic/trait/trait.html#使用特征作为函数参数
[函数返回类型]: https://course.rs/basic/trait/trait.html#函数返回中的-impl-trait

[back](#head)

## J

| 名称 | 关键字 | 简介 |
| ---- | ------ | ---- |
|      | KWJ    |      |

[back](#head)

## K

| 名称 | 关键字 | 简介 |
| ---- | ------ | ---- |
|      | KWK    |      |

[back](#head)

## L

| 名称        | 关键字   | 简介                           |
| ----------- | -------- | ------------------------------ |
| [let]       | 变量绑定 | `let x : u32 = 5;`             |
| [let mut]   | 可变变量 | `let mut x : u32 = 5; x = 9;`  |
| [loop 循环] | 循环控制 | 无限循环，注意要配合 [`break`] |
|             | KWL      |                                |

[let]: https://course.rs/basic/variable.html#变量绑定
[let mut]: https://course.rs/basic/variable.html#变量可变性
[`break`]: https://course.rs/basic/flow-control.html#break
[loop 循环]: https://course.rs/basic/flow-control.html#loop-循环

[back](#head)

## M

| 名称            | 关键字     | 简介                                                                                                                                                                     |
| --------------- | ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [模式绑定]      | 模式匹配   | 从模式中取出绑定的值                                                                                                                                                     |
| [全模式列表]    | 模式匹配   | 列出了所有的模式匹配                                                                                                                                                     |
| [Method 方法]   | `impl`     | Rust 的方法往往跟结构体、枚举、特征一起使用                                                                                                                              |
| [Method getter] | `getter`   | 方法名跟结构体的字段名相同                                                                                                                                               |
| [match 匹配]    | 模式匹配   | 1. `match` 的匹配必须要穷举出所有可能，因此这里用 `_ ` 来代表未列出的所有可能性<br>2. `match` 的每一个分支都必须是一个表达式，且所有分支的表达式最终返回值的类型必须相同 |
| [matches! 宏]   | 模式匹配   | 将一个表达式跟模式进行匹配，然后返回匹配的结果 `true` 或 `false`                                                                                                         |
| [match guard]   | 匹配守卫   | 位于 `match` 分支模式之后的额外 `if` 条件，它能为分支模式提供更进一步的匹配条件                                                                                          |
| [move 移动]     | 转移所有权 | `let s2 = s1;`<br>`s1` 所有权转移给了 `s2`，`s1` 失效                                                                                                                    |
|                 | KWM        |                                                                                                                                                                          |

[模式绑定]: https://course.rs/basic/match-pattern/match-if-let.html#模式绑定
[match 匹配]: https://course.rs/basic/match-pattern/match-if-let.html#match-匹配
[matches! 宏]: https://course.rs/basic/match-pattern/match-if-let.html#matches宏
[move 移动]: https://course.rs/basic/ownership/ownership.html#转移所有权
[全模式列表]: https://course.rs/basic/match-pattern/all-patterns.html
[match guard]: https://course.rs/basic/match-pattern/all-patterns.html#匹配守卫提供的额外条件
[method 方法]: https://course.rs/basic/method.html#定义方法
[method getter]: https://course.rs/basic/method.html#方法名跟结构体字段名相同

[back](#head)

## N

| 名称                | 关键字  | 简介                                                                                       |
| ------------------- | ------- | ------------------------------------------------------------------------------------------ |
| [newtype for Trait] | newtype | 为一个[元组结构体]创建新类型。该元组结构体封装有一个字段，该字段就是希望实现特征的具体类型 |
| [newtype ]          | newtype | 深入 Rust 类型                                                                             |
|                     | KWN     |                                                                                            |

[newtype for trait]: https://course.rs/basic/trait/advance-trait.html#在外部类型上实现外部特征newtype
[元组结构体]: https://course.rs/basic/compound-type/struct.html#元组结构体tuple-struct
[newtype ]: http://localhost:8080/advance/into-types/custom-type.html#newtype

[back](#head)

## O

| 名称          | 关键字      | 简介                                                            |
| ------------- | ----------- | --------------------------------------------------------------- |
| [Option]      | Option 枚举 | 用于处理空值，**一个变量要么有值：`Some(T)`, 要么为空：`None`** |
| [Option 解构] | 模式匹配    | 可以通过 `match` 来实现                                         |
|               | KWO         |                                                                 |

[option]: https://course.rs/basic/compound-type/enum.html#option-枚举用于处理空值
[option 解构]: https://course.rs/basic/match-pattern/option.html#匹配-optiont

[back](#head)

## P

| 名称                  | 关键字       | 简介                                                                 |
| --------------------- | ------------ | -------------------------------------------------------------------- |
| [panic! 不可恢复错误] | 不可恢复错误 | 程序会打印出一个错误信息，展开报错点往前的函数调用堆栈，最后退出程序 |
| [panic 原理剖析]      | 不可恢复错误 |                                                                      |
| [println!]            | 格式化参数   | 对输出内容格式有更多要求                                             |
|                       | KWP          |                                                                      |

[panic! 不可恢复错误]: https://course.rs/basic/result-error/panic.html#panic-与不可恢复错误
[panic 原理剖析]: https://course.rs/basic/result-error/panic.html#panic-原理剖析
[println!]: https://course.rs/basic/formatted-output.html#格式化参数

[back](#head)

## Q

| 名称 | 关键字 | 简介 |
| ---- | ------ | ---- |
|      | KWQ    |      |

[back](#head)

## R

| 名称                   | 关键字     | 简介                                                                               |
| ---------------------- | ---------- | ---------------------------------------------------------------------------------- |
| [Range 序列]           |            | 生成连续的数值<br> 只允许用于数字或字符类型<br> `..` 右半开区间 <br>`..=` 闭合区间 |
| [Result 可恢复的错误]  | 可恢复错误 | `enum Result<T, E> { Ok(T), Err(E), }`                                             |
| [对返回的错误进行处理] | 可恢复错误 | 对返回的错误进行处理                                                               |
|                        | KWR        |                                                                                    |

[range 序列]: https://course.rs/basic/base-type/numbers.html#序列range
[result 可恢复的错误]: https://course.rs/basic/result-error/result.html#可恢复的错误-result
[对返回的错误进行处理]: https://course.rs/basic/result-error/result.html#对返回的错误进行处理

[back](#head)

## S

| 名称                   | 关键字        | 简介                                                                                                                     |
| ---------------------- | ------------- | ------------------------------------------------------------------------------------------------------------------------ |
| [所有权与堆栈]         |               | Rust 所有权提供的强大保障                                                                                                |
| [所有权原则]           |               | Rust 中每一个值都 `有且只有` 一个所有者(变量)<br> 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)                   |
| [slice 切片]           | `&str`        | 允许你引用 `String` 中部分连续的元素序列，而不是引用整个 `String` <br>语法：`[开始索引..终止索引]`<br>字符串字面量是切片 |
| [String 字符串]        | `String` 类型 | Rust 中的字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4)                                            |
| [String 操作]          | `String` 方法 | 由于 `String` 是可变字符串，因此我们可以对它进行创建、增删操作                                                           |
| [String 转义]          | `String` 方法 | 通过转义的方式 `\` 输出 ASCII 和 Unicode 字符                                                                            |
| [struct 结构体]        | 结构体        | 通过关键字 `struct` 定义<br>一个清晰明确的结构体 `名称`<br>几个有名字的结构体 `字段`<br>通过 `.` 访问字段                |
| [self &self &mut self] | Method 方法   | `self` 指代类型的实例                                                                                                    |
| [Self 与 self]         |               | `self` 指代当前的实例对象，`Self` 指代特征或者方法类型的别名                                                             |
| [生命周期标注语法]     | 生命周期      | `&'a i32`                                                                                                                |
| [生命周期消除]         | 生命周期      |                                                                                                                          |
| [生命周期消除规则补充] | 生命周期      |                                                                                                                          |
| [函数中的生命周期]     | 生命周期      |                                                                                                                          |
| [结构体中的生命周期]   | 生命周期      |                                                                                                                          |
| [方法中的生命周期]     | 生命周期      |                                                                                                                          |
| [静态生命周期]         | 生命周期      | `&'static` 拥有该生命周期的引用可以和整个程序活得一样久，另见 [&'static 和 T: 'static]                                   |
|                        | KWS           |                                                                                                                          |

[所有权与堆栈]: https://course.rs/basic/ownership/ownership.html#所有权与堆栈
[所有权原则]: https://course.rs/basic/ownership/ownership.html#所有权原则
[slice 切片]: https://course.rs/basic/compound-type/string-slice.html#切片slice
[string 字符串]: https://course.rs/basic/compound-type/string-slice.html#什么是字符串
[string 操作]: https://course.rs/basic/compound-type/string-slice.html#操作字符串
[string 转义]: https://course.rs/basic/compound-type/string-slice.html#字符串转义
[struct 结构体]: https://course.rs/basic/compound-type/struct.html
[self &self &mut self]: https://course.rs/basic/method.html#selfself-和-mut-self
[self 与 self]: https://course.rs/basic/trait/trait-object#self-与-self
[生命周期标注语法]: https://course.rs/basic/lifetime.html#生命周期标注语法
[生命周期消除]: https://course.rs/basic/lifetime.html#生命周期消除
[生命周期消除规则补充]: https://course.rs/advance/lifetime/advance.html#生命周期消除规则补充
[函数中的生命周期]: https://course.rs/basic/lifetime.html#函数中的生命周期
[结构体中的生命周期]: https://course.rs/basic/lifetime.html#结构体中的生命周期
[方法中的生命周期]: https://course.rs/basic/lifetime.html#方法中的生命周期
[静态生命周期]: https://course.rs/basic/lifetime.html#静态生命周期
[&'static 和 t: 'static]: https://course.rs/advance/lifetime/static.html

[back](#head)

## T

| 名称                                                     | 关键字     | 简介                                                                                                                                                                                        |
| -------------------------------------------------------- | ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [Tuple 元组]                                             |            | 由多种类型组合一起，元组的长度是固定的，元组中元素的顺序也是固定的<br>用模式匹配解构元组：`let (x, y, z) = (20, 19.2, 1)`<br>用 `.` 来访问元组：`tuple.0` 索引从 0 开始                     |
| [Tuple Struct]                                           | 元组结构体 | 结构体必须要有名称，但字段可以没有名称<br>`struct Color(i32, i32, i32);`                                                                                                                    |
| [Trait 特征]                                             | 特征       | 一个可以被共享的行为，只要实现了特征，你就能使用该行为                                                                                                                                      |
| [T: Trait]                                               | 特征约束   | 还可以有多重约束，`T: Trait1 + Trait2`<br>另见：[where 约束]                                                                                                                                |
| [Trait Object]                                           | 特征对象   | 特征对象指向实现了 `Trait` 特征的类型的实例，可以在运行时通过特征对象找到具体调用的类型方法                                                                                                 |
| `type` 1. [关联类型] 2. [默认泛型类型参数] 3. [类型别名] |            | 1. `type Item;`<br>`Self` 用来指代当前调用者的具体类型，那么 `Self::em` 就用来指代该类型实现中定义的 `Item` 类型<br>2. `type Output = Struct;`<br>指定一个默认值，返回一个关联类型 `Output` |
| [特征定义中的特征约束]                                   | 特征       | 用来说明一个特征需要实现另一个特征                                                                                                                                                          |
| [TryInto 转换]                                           | 类型转换   | 尝试进行一次转换，并返回一个 `Result`，可以对其进行相应的错误处理                                                                                                                           |
|                                                          | KWT        |                                                                                                                                                                                             |

[tuple 元组]: https://course.rs/basic/compound-type/tuple.html#元组
[tuple struct]: https://course.rs/basic/compound-type/struct.html#元组结构体tuple-struct
[trait 特征]: https://course.rs/basic/trait/trait.html#定义特征
[t: trait]: https://course.rs/basic/trait/trait.html#特征约束trait-bound
[trait object]: https://course.rs/basic/trait/trait-object.html#特征对象定义
[关联类型]: https://course.rs/basic/trait/advance-trait.html#关联类型
[默认泛型类型参数]: https://course.rs/basic/trait/advance-trait.html#默认泛型类型参数
[特征定义中的特征约束]: https://course.rs/basic/trait/advance-trait.html#特征定义中的特征约束
[tryinto 转换]: https://course.rs/advance/into-types/converse.html#tryinto-转换
[类型别名]: https://course.rs/advance/into-types/custom-type.html#类型别名type-alias

[back](#head)

## U

| 名称               | 关键字     | 简介                                                              |
| ------------------ | ---------- | ----------------------------------------------------------------- |
| [Unit-like Struct] | 单元结构体 | 没有任何字段和属性<br>`struct AlwaysEqual;`                       |
| [unwrap & expect]  | 可恢复错误 | 如果返回成功，就将 `Ok(T)` 中的值取出来，如果失败，就直接 `panic` |
|                    | KWU        |                                                                   |

[unit-like struct]: https://course.rs/basic/compound-type/struct.html#单元结构体unit-like-struct
[unwrap & expect]: https://course.rs/basic/result-error/result.html#失败就-panic-unwrap-和-expect

[back](#head)

## V

| 名称                       | 关键字   | 简介                                                                                           |
| -------------------------- | -------- | ---------------------------------------------------------------------------------------------- |
| [Vector 动态数组]          | 动态数组 | `Vec<T>`，动态数组允许你存储多个值，这些值在内存中一个紧挨着另一个排列。只能存储相同类型的元素 |
| [Vec::new]                 |          | 创建动态数组                                                                                   |
| [vec!\[\]]                 |          | 创建动态数组，能在创建时给予初始化值                                                           |
| [vec.push]                 |          | 向数组尾部添加元素，必须声明为 `mut`                                                           |
| [vec.get]                  |          | 从 Vector 中读取元素，返回 `Option<&T>`                                                        |
| `&vec[index]`              |          | 从 Vector 中读取元素，使用下标索引访问，从 0 开始                                              |
| [迭代遍历 Vector 中的元素] |          | 如果想要依次访问数组中的元素，可以使用迭代的方式去遍历数组                                     |
| [存储不同类型的元素]       |          | 通过使用枚举类型和特征对象来实现不同类型元素的存储                                             |
|                            | KWV      |                                                                                                |

[vector 动态数组]: https://course.rs/basic/collections/vector.html
[vec::new]: https://course.rs/basic/collections/vector.html#vecnew
[vec!\[\]]: https://course.rs/basic/collections/vector.html#vec
[vec.push]: https://course.rs/basic/collections/vector.html#更新-vector
[vec.get]: https://course.rs/basic/collections/vector.html#从-vector-中读取元素
[迭代遍历 vector 中的元素]: https://course.rs/basic/collections/vector.html#迭代遍历-vector-中的元素
[存储不同类型的元素]: https://course.rs/basic/collections/vector.html#存储不同类型的元素

[back](#head)

## W

| 名称         | 关键字   | 简介                                                              |
| ------------ | -------- | ----------------------------------------------------------------- |
| [while 循环] | 循环控制 | 当条件为 `true` 时，继续循环，条件为 `false`，跳出循环            |
| [where 约束] | 特征约束 | 当特征约束变多时，函数签名会很复杂，可以用 `where` 做形式上的改进 |
|              | KWW      |                                                                   |

[while 循环]: https://course.rs/basic/flow-control.html#while-循环
[where 约束]: https://course.rs/basic/trait/trait.html#where-约束

[back](#head)

## X

| 名称 | 关键字 | 简介 |
| ---- | ------ | ---- |
|      | KWX    |      |

[back](#head)

## Y

| 名称 | 关键字 | 简介 |
| ---- | ------ | ---- |
|      | KWY    |      |

[back](#head)

## Z

| 名称         | 关键字   | 简介                                                                                                             |
| ------------ | -------- | ---------------------------------------------------------------------------------------------------------------- |
| [整数]       | 数值类型 | 有符号整数，`i8`，`i16`，`i32`，`i64`，`i128`，`isize`<br>无符号整数，`u8`，`u16`，`u32`，`u64`，`u128`，`usize` |
| [整形字面量] | 进制书写 | 十进制 `98_222`<br>十六进制 `0xff`<br>八进制 `0o77`<br>二进制 `0b1111_0000`<br>字节(仅限于`u8`) `b'A'`           |
|              | KWZ      |                                                                                                                  |

[整数]: https://course.rs/basic/base-type/numbers.html#整数类型
[整形字面量]: https://course.rs/basic/base-type/numbers.html#整数类型

[back](#head)

## Cargo

| 名称  | 关键字 | 简介 |
| ----- | ------ | ---- |
| Cargo | KWCG   |      |

[back](#head)

<a id="bottom"></a>



================================================
FILE: src/into-rust.md
================================================
[Binary file]


================================================
FILE: src/practice.md
================================================
## 课后习题

[https://practice.rs](https://practice.rs)


================================================
FILE: src/rust-weekly.md
================================================
# 「Rust 语言周刊」 第 17 期 · 2022-07-15
Rust语言周刊精选全世界过去一周(或者几周)的优秀文章、新闻、开源项目和语言动态。

本周刊由 RustCn 倾情打造，其中， `[Zh]` 标识的中文资料由 Rust 翻译计划提供，并且原始的 Markdown 文档已[全部开源](https://github.com/rustlang-cn/rustt)，欢迎大家阅读和订阅。

> RustCn：https://hirust.cn, 公众号: Rust语言中文网

<img src="https://pica.zhimg.com/80/v2-2826dfca738cdc1795e77d12eb269906_1440w.png">
<h5 align="center">题图: Tauri 发布 1.0 版本</h5>


## 官方新闻

1、[Zh] [Rust 发布 1.62 版本](https://course.rs/appendix/rust-versions/1.62.html)

如果大家期待 Rust 像其它语言一样，每一个新版本都带来大量新特性，那你们可要失望了，1.62 的更新内容相当少，甚至不如某些语言一个 minor 版本的更新力度，但**错不在 Rust**，建议大家了解下 Rust 的[版本发布流程](https://course.rs/appendix/rust-version.html)，就明白其中的弯弯绕绕了。

## 开源项目

1、[基于 Rust 的操作系统训练营](https://github.com/LearningOS/rust-based-os-comp2022)

该训练营有一个配套教程，将带大家从零开始使用 Rust 编写 RISC-V 架构的 类 Unix 内核 。

我自己也做开源，深知这件事会占用多少的时间和精力，甚至还会遭人非议，而我仅仅是写写书，跟作者这种大佬一比，差距就太大了... Respect!

2、[Tauri 发布 1.0 版本](https://tauri.app/blog/tauri_1_0/)

虽然 Tauri 很有名，但是为防有同学不知道背景，还是简单介绍下：它是一款跨平台的桌面应用开发框架，虽然内核是使用 Rust 开发，但是开发者可以使用自己喜欢的前端框架( `react`, `vue`, `vite` )来构建自己的用户界面，最终编译生成一个可执行的二进制文件，方便在各个不同的操作系统间分发运行。总之，你可以将 Tauri 当作是理念更先进的 Electron.js 。

言归正传，在历经 1 年多的时间后，Tauri 终于发布了 1.0 版本，这也标志着它已经可以在生产环境正式使用，并且目前来看，官方文档还算可以，甚至还提供了[中文文档](https://tauri.app/zh/v1/guides/getting-started/prerequisites)，除此之外，我还发现了一个[宝藏教学系列](https://zhuanlan.zhihu.com/p/539708101)，值得一读。

3、[lettre 发布 0.1.0 版本](https://lettre.rs/post/lettre-0-10/)

`lettre` 是一个现代化的邮件发送库，它简单易用、安全可靠，但是需要注意，它的目标**不是支持所有的邮件 RFC 标准**，因此在你有特殊需求时，可能会需要自己动手，丰衣足食。

该库目前已被多个项目使用，包括大名鼎鼎的 `crates.io`。 

4、[workers-rs: 使用 Rust + WebAssembly 实现 Cloudflare 的 Workers](https://github.com/cloudflare/workers-rs)

Cloudflare 已经成为全世界最大的 DNS 服务商，而且它的业务不仅仅是 DNS，目前云计算方面也进行的如火如荼。CF 最大的优势不仅仅在于 DNS 的快速和稳定，还在于它提供了多种方式来扩展你的 DNS 使用，例如你可以使用 Rust 来变成它的 worker。

为了便于有需要的同学进一步学习该如何使用，这里还有一篇[实战文章](https://logankeenan.com/posts/running-a-rust-server-in-a-cloudflare-worker/)，值得一看。


## 精选文章

1、[过程宏揭秘 II](https://blog.jetbrains.com/rust/2022/07/07/procedural-macros-under-the-hood-part-ii/)

想要了解过程宏是如何编译、怎么跟 IDE 互动的吗？来看看这个系列的文章，作者来自 Intellij Rust 插件开发组，之前还给 RustCon 分享过，干货满满。

本文是系列文章中的第二篇，第一篇见[这里](https://blog.jetbrains.com/rust/2022/03/18/procedural-macros-under-the-hood-part-i/)。


2、[youtube][有字幕] [AWS 在构建 Rust SDK 方面的实践](https://www.youtube.com/watch?v=N0XMjokwTIM)

如果没有亚马逊这几年对 Rust 的大力(肆)支(鼓)持(吹)，Rust 也不会走到今天这个地步。出于敬意，放上这个视频，事实上，里面更多的是对自己产品的宣传 = ， = 特别是第一部分，大家可以跳着看，一些关于底层的讲解还是值得一看的。

3、[Zh] [在 GCC 13 中，大家可能将看到 Rust 的身影](https://www.oschina.net/news/202630/gcc-rust-approved-by-gcc-steering-committee)

目前来说，Rust 的编译器实现是基于 LLVM 的，而我们可能很快将看到基于 GCC 的实现，与 LLVM 不同，新的编译器将能获得 GCC 内部优化通道的所有访问权，同时带来更多的目标平台的支持，以及享受 GCC 众多的插件生态。

该项目已经历时多年(从 Rust 0.9 版本开始)，我一度怀疑可能永远都无法看到它的身影，没想到现在突然官宣了，但是项目依然还处于早期阶段，当前的目标是在 GCC 13 中提供测试级别的支持。

再加上 Rust 即将在 Linux 5.20 中出现，可以预料， Rust 的未来将更加美好，大家一起期待吧！

4、[C++ 大战 Rust 系列：可变性和所有权](https://www.tangramvision.com/blog/c-rust-interior-mutability-moving-and-ownership)

虽然 Rust 将所有权发扬光大，但是咱不能说 Rust 发明了所有权，毕竟众所周知：Rust 语言是借鉴大师 :P  

在这篇文章中，作者将介绍 C++ 和 Rust 在实现所有权、可变性方面的不同设计哲学，以及标准库、编译器层面的支持。

5、[Rust 错误介绍，比你想要的更多](https://www.shuttle.rs/blog/2022/06/30/error-handling)

文章不错，标题也不错！ 虽然你想要的错误处理几乎都可以在 `https://course.rs` 上找到，但是这篇文章依然值得一看。

6、[Youtube][有字幕] [为何你的 Rust 编译这么慢？](https://www.youtube.com/watch?v=pMiqRM5ooNw)

视频质量自然非常高，从各个方面介绍了该如何提升 Rust 的编译速度，干货满满，强烈推荐。

但...我的天，我真的佩服作者，就以 Rust 周刊举例吧，每次周刊基本都要花费我几个小时，那一个将近 3 个小时的干货视频，要准备多久？简直是卷王在世 :)

甚至有人评论到：这个是一个 AMSR 视频...


7、[Rust中的再借用](https://haibane-tenshi.github.io/rust-reborrowing/)

大家都知道 Rust 中的生命周期很难，那你们谈谈对借用的印象，难吗？我猜，大多数人会说不难。其实不然，Rust 中的借用并不仅仅是书上介绍的那些，例如**再借用(reborrowing)**，你听说过吗？

8、[我很强，但 Rust 更强](https://blog.polybdenum.com/2022/06/25/an-unfortunate-experience-with-rust.html)

作者说他对于 Rust 极其有经验，但是就算这样的高手，依然避免不了被 Rust 所教育，你问怎么个教育法？当然是跟编译器搏斗咯。

其实，从我个人而言，非常推荐大家看看这类文章，那些关于 Rust 如何成功的营销文，爽则爽矣，对于技术却无多大帮助。而这种错误实践类的文章，却能帮助我们少走很多弯路！



================================================
FILE: src/rustt.md
================================================
# Rustt 翻译计划

🥇Rustt 翻译计划，这里有国内最优质、最实时的 Rust 技术文章、学习资料和新闻资讯，欢迎大家[前往阅读和订阅](https://github.com/studyrs/Rustt)。

## 最近优秀作品展

| 中文名 |   翻译时间 | 作者 |
| ------- | -------- | ----- |
| [series][Rust 六边形架构](https://github.com/studyrs/Rustt/tree/main/Articles/%5B2022-04-03%5D%20Rust%20六边形架构) | 2022-04-04 | [trdthg](https://github.com/trdthg) |
| [用 Rust 写 Devops 工具](https://github.com/studyrs/Rustt/blob/main/Articles/%5B2022-04-02%5D%20用%20Rust%20写%20DevOps%20工具.md) | 2022-04-03 | [Xiaobin.Liu](https://github.com/lxbwolf) |
| [Rust 大佬给初学者的学习建议](https://github.com/studyrs/Rustt/blob/main/Articles/%5B2022-04-02%5D%20Rust%20大佬给初学者的学习建议.md) | 2022-04-02 | [Asura](https://github.com/asur4s) |
| [Rust 背后并不是公司](https://github.com/studyrs/Rustt/blob/main/Articles/%5B2022-04-01%5D%20Rust%20背后并不是公司.md) | 2022-04-01 | [子殊](https://github.com/allenli178) |
| [在 Rust 中使用 epoll 实现非阻塞 IO](https://github.com/studyrs/Rustt/blob/main/Articles/%5B2022-03-29%5D%20在%20Rust%20中使用%20epoll%20实现基本的非阻塞%20IO.md) | 2022-03-29 | [BK0717](https://github.com/hyuuko) | 



================================================
FILE: src/rusty-book.md
================================================
<h1 align="center">Rusty Book( 锈书 )</h1>

<div align="center">
    <img width="100%" src="https://github.com/studyrs/rusty-book/blob/main/assets/banner.gif?raw=true" />
</div>
   
<div align="center">

</div>

在 Rust 元宇宙，最优秀的项目可以称之为 `rusty`，用咱中国话来说，就是够锈( 秀 )。

如果你有以下需求，可以来看看锈书，它绝对不会让你失望：

- 想要知道现在优秀的、关注度高的 Rust 项目有哪些

- 发现一些好玩、有趣、酷炫的开源库

- 需要寻找某个类型的库，例如，一个 HTTP 客户端或 ProtoBuffer 编码库，要求是好用、更新活跃、高质量

- 想要寻找常用操作的代码片段，用于熟悉 Rust 或者直接复制粘贴到自己的项目中，例如文件操作、数据库操作、HTTP 请求、排序算法、正则等

在线阅读锈书:[Github地址](https://github.com/rustlang-cn/rusty-book)



================================================
FILE: src/some-thoughts.md
================================================
[Binary file]


================================================
FILE: src/SUMMARY.md
================================================
[Binary file]


================================================
FILE: src/advance/errors.md
================================================
[Binary file]


================================================
FILE: src/advance/global-variable.md
================================================
# 全局变量

在一些场景，我们可能需要全局变量来简化状态共享的代码，包括全局 ID，全局数据存储等等，下面一起来看看有哪些创建全局变量的方法。

首先，有一点可以肯定，全局变量的生命周期肯定是`'static`，但是不代表它需要用`static`来声明，例如常量、字符串字面值等无需使用`static`进行声明，原因是它们已经被打包到二进制可执行文件中。

下面我们从编译期初始化及运行期初始化两个类别来介绍下全局变量有哪些类型及该如何使用。

## 编译期初始化

我们大多数使用的全局变量都只需要在编译期初始化即可，例如静态配置、计数器、状态值等等。

#### 静态常量

全局常量可以在程序任何一部分使用，当然，如果它是定义在某个模块中，你需要引入对应的模块才能使用。常量，顾名思义它是不可变的，很适合用作静态配置：

```rust
const MAX_ID: usize =  usize::MAX / 2;
fn main() {
   println!("用户ID允许的最大值是{}",MAX_ID);
}
```

**常量与普通变量的区别**

- 关键字是`const`而不是`let`
- 定义常量必须指明类型（如 i32）不能省略
- 定义常量时变量的命名规则一般是全部大写
- 常量可以在任意作用域进行定义，其生命周期贯穿整个程序的生命周期。编译时编译器会尽可能将其内联到代码中，所以在不同地方对同一常量的引用并不能保证引用到相同的内存地址
- 常量的赋值只能是常量表达式/数学表达式，也就是说必须是在编译期就能计算出的值，如果需要在运行时才能得出结果的值比如函数，则不能赋值给常量表达式
- 对于变量出现重复的定义(绑定)会发生变量遮盖，后面定义的变量会遮住前面定义的变量，常量则不允许出现重复的定义

#### 静态变量

静态变量允许声明一个全局的变量，常用于全局数据统计，例如我们希望用一个变量来统计程序当前的总请求数：

```rust
static mut REQUEST_RECV: usize = 0;
fn main() {
   unsafe {
        REQUEST_RECV += 1;
        assert_eq!(REQUEST_RECV, 1);
   }
}
```

Rust 要求必须使用`unsafe`语句块才能访问和修改`static`变量，因为这种使用方式往往并不安全，其实编译器是对的，当在多线程中同时去修改时，会不可避免的遇到脏数据。

只有在同一线程内或者不在乎数据的准确性时，才应该使用全局静态变量。

和常量相同，定义静态变量的时候必须赋值为在编译期就可以计算出的值(常量表达式/数学表达式)，不能是运行时才能计算出的值(如函数)

**静态变量和常量的区别**

- 静态变量不会被内联，在整个程序中，静态变量只有一个实例，所有的引用都会指向同一个地址
- 存储在静态变量中的值必须要实现 Sync trait

#### 原子类型

想要全局计数器、状态控制等功能，又想要线程安全的实现，原子类型是非常好的办法。

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
static REQUEST_RECV: AtomicUsize  = AtomicUsize::new(0);
fn main() {
    for _ in 0..100 {
        REQUEST_RECV.fetch_add(1, Ordering::Relaxed);
    }

    println!("当前用户请求数{:?}",REQUEST_RECV);
}
```

关于原子类型的讲解看[这篇文章](https://course.rs/advance/concurrency-with-threads/sync2.html)

#### 示例：全局 ID 生成器

来看看如何使用上面的内容实现一个全局 ID 生成器:

```rust
use std::sync::atomic::{Ordering, AtomicUsize};

struct Factory{
    factory_id: usize,
}

static GLOBAL_ID_COUNTER: AtomicUsize = AtomicUsize::new(0);
const MAX_ID: usize = usize::MAX / 2;

fn generate_id()->usize{
    // 检查两次溢出，否则直接加一可能导致溢出
    let current_val = GLOBAL_ID_COUNTER.load(Ordering::Relaxed);
    if current_val > MAX_ID{
        panic!("Factory ids overflowed");
    }
    GLOBAL_ID_COUNTER.fetch_add(1, Ordering::Relaxed);
    let next_id = GLOBAL_ID_COUNTER.load(Ordering::Relaxed);
    if next_id > MAX_ID{
        panic!("Factory ids overflowed");
    }
    next_id
}

impl Factory{
    fn new()->Self{
        Self{
            factory_id: generate_id()
        }
    }
}
```

## 运行期初始化

以上的静态初始化有一个致命的问题：无法用函数进行静态初始化，例如你如果想声明一个全局的`Mutex`锁：

```rust
use std::sync::Mutex;
static NAMES: Mutex<String> = Mutex::new(String::from("Sunface, Jack, Allen"));

fn main() {
    let v = NAMES.lock().unwrap();
    println!("{}",v);
}
```

运行后报错如下：

```console
error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants
 --> src/main.rs:3:42
  |
3 | static NAMES: Mutex<String> = Mutex::new(String::from("sunface"));
```

但你又必须在声明时就对`NAMES`进行初始化，此时就陷入了两难的境地。好在天无绝人之路，我们可以使用`lazy_static`包来解决这个问题。

#### lazy_static

[`lazy_static`](https://github.com/rust-lang-nursery/lazy-static.rs)是社区提供的非常强大的宏，用于懒初始化静态变量，之前的静态变量都是在编译期初始化的，因此无法使用函数调用进行赋值，而`lazy_static`允许我们在运行期初始化静态变量！

```rust
use std::sync::Mutex;
use lazy_static::lazy_static;
lazy_static! {
    static ref NAMES: Mutex<String> = Mutex::new(String::from("Sunface, Jack, Allen"));
}

fn main() {
    let mut v = NAMES.lock().unwrap();
    v.push_str(", Myth");
    println!("{}",v);
}
```

当然，使用`lazy_static`在每次访问静态变量时，会有轻微的性能损失，因为其内部实现用了一个底层的并发原语`std::sync::Once`，在每次访问该变量时，程序都会执行一次原子指令用于确认静态变量的初始化是否完成。

`lazy_static`宏，匹配的是`static ref`，所以定义的静态变量都是不可变引用

可能有读者会问，为何需要在运行期初始化一个静态变量，除了上面的全局锁，你会遇到最常见的场景就是：**一个全局的动态配置，它在程序开始后，才加载数据进行初始化，最终可以让各个线程直接访问使用**

再来看一个使用`lazy_static`实现全局缓存的例子:

```rust
use lazy_static::lazy_static;
use std::collections::HashMap;

lazy_static! {
    static ref HASHMAP: HashMap<u32, &'static str> = {
        let mut m = HashMap::new();
        m.insert(0, "foo");
        m.insert(1, "bar");
        m.insert(2, "baz");
        m
    };
}

fn main() {
    // 首次访问`HASHMAP`的同时对其进行初始化
    println!("The entry for `0` is \"{}\".", HASHMAP.get(&0).unwrap());

    // 后续的访问仅仅获取值，再不会进行任何初始化操作
    println!("The entry for `1` is \"{}\".", HASHMAP.get(&1).unwrap());
}
```

需要注意的是，`lazy_static`直到运行到`main`中的第一行代码时，才进行初始化，非常`lazy static`。

#### Box::leak

在`Box`智能指针章节中，我们提到了`Box::leak`可以用于全局变量，例如用作运行期初始化的全局动态配置，先来看看如果不使用`lazy_static`也不使用`Box::leak`，会发生什么：

```rust
#[derive(Debug)]
struct Config {
    a: String,
    b: String,
}
static mut CONFIG: Option<&mut Config> = None;

fn main() {
    unsafe {
        CONFIG = Some(&mut Config {
            a: "A".to_string(),
            b: "B".to_string(),
        });

        println!("{:?}", CONFIG)
    }
}
```

以上代码我们声明了一个全局动态配置`CONFIG`，并且其值初始化为`None`，然后在程序开始运行后，给它赋予相应的值，运行后报错:

```console
error[E0716]: temporary value dropped while borrowed
  --> src/main.rs:10:28
   |
10 |            CONFIG = Some(&mut Config {
   |   _________-__________________^
   |  |_________|
   | ||
11 | ||             a: "A".to_string(),
12 | ||             b: "B".to_string(),
13 | ||         });
   | ||         ^-- temporary value is freed at the end of this statement
   | ||_________||
   |  |_________|assignment requires that borrow lasts for `'static`
   |            creates a temporary which is freed while still in use
```

可以看到，Rust 的借用和生命周期规则限制了我们做到这一点，因为试图将一个局部生命周期的变量赋值给全局生命周期的`CONFIG`，这明显是不安全的。

好在`Rust`为我们提供了`Box::leak`方法，它可以将一个变量从内存中泄漏(听上去怪怪的，竟然做主动内存泄漏)，然后将其变为`'static`生命周期，最终该变量将和程序活得一样久，因此可以赋值给全局静态变量`CONFIG`。

```rust
#[derive(Debug)]
struct Config {
    a: String,
    b: String
}
static mut CONFIG: Option<&mut Config> = None;

fn main() {
    let c = Box::new(Config {
        a: "A".to_string(),
        b: "B".to_string(),
    });

    unsafe {
        // 将`c`从内存中泄漏，变成`'static`生命周期
        CONFIG = Some(Box::leak(c));
        println!("{:?}", CONFIG);
    }
}
```

#### 从函数中返回全局变量

问题又来了，如果我们需要在运行期，从一个函数返回一个全局变量该如何做？例如：

```rust
#[derive(Debug)]
struct Config {
    a: String,
    b: String,
}
static mut CONFIG: Option<&mut Config> = None;

fn init() -> Option<&'static mut Config> {
    Some(&mut Config {
        a: "A".to_string(),
        b: "B".to_string(),
    })
}


fn main() {
    unsafe {
        CONFIG = init();

        println!("{:?}", CONFIG)
    }
}
```

报错这里就不展示了，跟之前大同小异，还是生命周期引起的，那么该如何解决呢？依然可以用`Box::leak`:

```rust
#[derive(Debug)]
struct Config {
    a: String,
    b: String,
}
static mut CONFIG: Option<&mut Config> = None;

fn init() -> Option<&'static mut Config> {
    let c = Box::new(Config {
        a: "A".to_string(),
        b: "B".to_string(),
    });

    Some(Box::leak(c))
}


fn main() {
    unsafe {
        CONFIG = init();

        println!("{:?}", CONFIG)
    }
}
```

## 标准库中的 Once 和 Lazy

在 Rust 1.70.0 版本之前，标准库通过实验性 API 提供 `lazy::OnceCell` 和 `lazy::SyncOnceCell` 来实现单次初始化容器，这时，懒初始化主要依靠 `lazy_static` 。
随着 `cell::OnceCell` 和 `sync::OnceLock` 在 1.70.0 中稳定和 `LazyCell` 和 `LazyLock` 在 1.80.0 中稳定，只使用标准库实现懒加载成为可能。

这4个容器可以这样区分：

|      | 单线程   | 多线程   |
|------|----------|----------|
| Once | OnceCell | OnceLock |
| Lazy | LazyCell | LazyLock |

其中，`Lazy` 会自动按需加载内容，让代码更简洁，更人性化，而 `Once` 则可以手动指定初始化的时机或使用不同的方法初始化，更强大。
`Cell` 的实现更简单，效率也更高，但是他并不保证线程安全，而 `Lock` 通过内部同步机制实现了线程安全。

#### Once 使用方法

下面，我们先看一下 `Once` 的使用方法：

```rust
use std::{sync::OnceLock, thread};

fn main() {
    // 子线程中调用
    let handle = thread::spawn(|| {
        let logger = Logger::global();
        logger.log("thread message".to_string());
    });

    // 主线程调用
    let logger = Logger::global();
    logger.log("some message".to_string());

    let logger2 = Logger::global();
    logger2.log("other message".to_string());

    handle.join().unwrap();
}

#[derive(Debug)]
struct Logger;

static LOGGER: OnceLock<Logger> = OnceLock::new();

impl Logger {
    fn global() -> &'static Logger {
        // 获取或初始化 Logger
        LOGGER.get_or_init(|| {
            println!("Logger is being created..."); // 初始化打印
            Logger
        })
    }

    fn log(&self, message: String) {
        println!("{}", message)
    }
}
```

以上代码我们声明了一个 `global()` 关联函数，并在其内部调用 `get_or_init` 进行初始化 `Logger`，之后在不同线程上多次调用 `Logger::global()` 获取其实例。
由于需要在多个线程中使用，所以我们使用了 `OnceLock`。以下是输出：

```console
Logger is being created...
some message
other message
thread message
```

可以看到，`Logger is being created...` 在多个线程中使用也只被打印了一次。

#### Lazy 使用方法

上述例子如果使用 `LazyLock` 来实现，则可以变得更加简洁：

```rust
use std::{sync::LazyLock, thread};

fn main() {
    // 子线程中调用
    let handle = thread::spawn(|| {
        let logger = &LOGGER;
        logger.log("thread message".to_string());
    });

    // 主线程调用
    let logger = &LOGGER;
    logger.log("some message".to_string());

    let logger2 = &LOGGER;
    logger2.log("other message".to_string());

    handle.join().unwrap();
}

#[derive(Debug)]
struct Logger;

static LOGGER: LazyLock<Logger> = LazyLock::new(Logger::new);

impl Logger {
    fn new() -> Logger {
        println!("Logger is being created...");
        Logger
    }

    fn log(&self, message: String) {
        println!("{}", message)
    }
}
```

以上代码中，我们使用 `LazyLock::new` 方法直接对全局变量 `LOGGER` 进行赋值，并传入一个初始化函数。
使用的时候，可以直接使用对全局变量的引用。在获取引用的时候， `LazyLock` 会自动检查初始化的状态并进行初始化。

## 总结

在 Rust 中有很多方式可以创建一个全局变量，本章也只是介绍了其中一部分，更多的还等待大家自己去挖掘学习(当然，未来可能本章节会不断完善，最后变成一个巨无霸- , -)。

简单来说，全局变量可以分为两种：

- 编译期初始化的全局变量，`const`创建常量，`static`创建静态变量，`Atomic`创建原子类型
- 运行期初始化的全局变量，`lazy_static`用于懒初始化，`Box::leak`利用内存泄漏将一个变量的生命周期变为`'static`



================================================
FILE: src/advance/hrtb.md
================================================
# 高阶特征约束(HRTB) todo


https://www.reddit.com/r/rust/comments/s6g16d/help_with_hrtb_lifetimes/

## for<'a>

https://www.reddit.com/r/rust/comments/rq43c6/generic_fn_impl_for_iterating_over_mut_items_twice/

https://www.reddit.com/r/rust/comments/6uobit/fora_lifetime_syntax/







================================================
FILE: src/advance/intro.md
================================================
# Rust 高级进阶

恭喜你，学会 Rust 基础后，金丹大道已在向你招手，大部分 Rust 代码对你来说都是家常便饭，简单得很。可是，对于一门难度传言在外的语言，怎么可能如此简单的就被征服，最难的生命周期，咱还没见过长啥样呢。

从本章开始，我们将进入 Rust 的进阶学习环节，与基础环节不同的是，由于你已经对 Rust 有了一定的认识，因此我们**不会再对很多细节进行翻来覆去的详细讲解，甚至会一带而过**。

总之，欢迎来到高级 Rust 的世界，全新的 Boss，全新的装备，你准备好了吗？



================================================
FILE: src/advance/macro.md
================================================
# Macro 宏编程

在编程世界可以说是谈“宏”色变，原因在于 C 语言中的宏是非常危险的东东，但并不是所有语言都像 C 这样，例如对于古老的语言 Lisp 来说，宏就是就是一个非常强大的好帮手。

那话说回来，在 Rust 中宏到底是好是坏呢？本章将带你揭开它的神秘面纱。

事实上，我们虽然没有见过宏，但是已经多次用过它，例如在全书的第一个例子中就用到了：`println!("你好，世界")`，这里 `println!` 就是一个最常用的宏，可以看到它和函数最大的区别是：它在调用时多了一个 `!`，除此之外还有 `vec!` 、`assert_eq!` 都是相当常用的，可以说**宏在 Rust 中无处不在**。

细心的读者可能会注意到 `println!` 后面跟着的是 `()`，而 `vec!` 后面跟着的是 `[]`，这是因为宏的参数可以使用 `()`、`[]` 以及 `{}`:

```rust
fn main() {
    println!("aaaa");
    println!["aaaa"];
    println!{"aaaa"}
}
```

虽然三种使用形式皆可，但是 Rust 内置的宏都有自己约定俗成的使用方式，例如 `vec![...]`、`assert_eq!(...)` 等。

在 Rust 中宏分为两大类：**声明式宏( _declarative macros_ )** `macro_rules!` 和三种**过程宏( _procedural macros_ )**:

- `#[derive]`，在之前多次见到的派生宏，可以为目标结构体或枚举派生指定的代码，例如 `Debug` 特征
- 类属性宏(Attribute-like macro)，用于为目标添加自定义的属性
- 类函数宏(Function-like macro)，看上去就像是函数调用

如果感觉难以理解，也不必担心，接下来我们将逐个看看它们的庐山真面目，在此之前，先来看下为何需要宏，特别是 Rust 的函数明明已经很强大了。

## 宏和函数的区别

宏和函数的区别并不少，而且对于宏擅长的领域，函数其实是有些无能为力的。

#### 元编程

从根本上来说，宏是通过一种代码来生成另一种代码，如果大家熟悉元编程，就会发现两者的共同点。

在[附录 D](https://course.rs/appendix/derive.html)中讲到的 `derive` 属性，就会自动为结构体派生出相应特征所需的代码，例如 `#[derive(Debug)]`，还有熟悉的 `println!` 和 `vec!`，所有的这些宏都会展开成相应的代码，且很可能是长得多的代码。

总之，元编程可以帮我们减少所需编写的代码，也可以一定程度上减少维护的成本，虽然函数复用也有类似的作用，但是宏依然拥有自己独特的优势。

#### 可变参数

Rust 的函数签名是固定的：定义了两个参数，就必须传入两个参数，多一个少一个都不行，对于从 JS/TS 过来的同学，这一点其实是有些恼人的。

而宏就可以拥有可变数量的参数，例如可以调用一个参数的 `println!("hello")`，也可以调用两个参数的 `println!("hello {}", name)`。

#### 宏展开

由于宏会被展开成其它代码，且这个展开过程是发生在编译器对代码进行解释之前。因此，宏可以为指定的类型实现某个特征：先将宏展开成实现特征的代码后，再被编译。

而函数就做不到这一点，因为它直到运行时才能被调用，而特征需要在编译期被实现。

#### 宏的缺点

相对函数来说，由于宏是基于代码再展开成代码，因此实现相比函数来说会更加复杂，再加上宏的语法更为复杂，最终导致定义宏的代码相当地难读，也难以理解和维护。

## 声明式宏 `macro_rules!`

在 Rust 中使用最广的就是声明式宏，它们也有一些其它的称呼，例如示例宏( macros by example )、`macro_rules!` 或干脆直接称呼为**宏**。

声明式宏允许我们写出类似 `match` 的代码。`match` 表达式是一个控制结构，其接收一个表达式，然后将表达式的结果与多个模式进行匹配，一旦匹配了某个模式，则该模式相关联的代码将被执行:

```rust
match target {
    模式1 => 表达式1,
    模式2 => {
        语句1;
        语句2;
        表达式2
    },
    _ => 表达式3
}
```

而**宏也是将一个值跟对应的模式进行匹配，且该模式会与特定的代码相关联**。但是与 `match` 不同的是，**宏里的值是一段 Rust 源代码**(字面量)，模式用于跟这段源代码的结构相比较，一旦匹配，传入宏的那段源代码将被模式关联的代码所替换，最终实现宏展开。值得注意的是，**所有的这些都是在编译期发生，并没有运行期的性能损耗**。

#### 简化版的 vec!

在[动态数组 Vector 章节](https://course.rs/basic/collections/vector.html#vec)中，我们学习了使用 `vec!` 来便捷的初始化一个动态数组:

```rust
let v: Vec<u32> = vec![1, 2, 3];
```

最重要的是，通过 `vec!` 创建的动态数组支持任何元素类型，也并没有限制数组的长度，如果使用函数，我们是无法做到这一点的。

好在我们有 `macro_rules!`，来看看该如何使用它来实现 `vec!`，以下是一个简化实现：

```rust
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```

简化实现版本？这也太难了吧！！只能说，欢迎来到宏的世界，在这里你能见到优雅 Rust 的另一面:) 标准库中的 `vec!` 还包含了预分配内存空间的代码，如果引入进来，那大家将更难以接受。

`#[macro_export]` 注释将宏进行了导出，这样其它的包就可以将该宏引入到当前作用域中，然后才能使用。可能有同学会提问：我们在使用标准库 `vec!` 时也没有引入宏啊，那是因为 Rust 已经通过 [`std::prelude`](https://course.rs/appendix/prelude.html) 的方式为我们自动引入了。

紧接着，就使用 `macro_rules!` 进行了宏定义，需要注意的是宏的名称是 `vec`，而不是 `vec!`，后者的感叹号只在调用时才需要。

`vec` 的定义结构跟 `match` 表达式很像，但这里我们只有一个分支，其中包含一个模式 `( $( $x:expr ),* )`，跟模式相关联的代码就在 `=>` 之后。一旦模式成功匹配，那这段相关联的代码就会替换传入的源代码。

由于 `vec` 宏只有一个模式，因此它只能匹配一种源代码，其它类型的都将导致报错，而更复杂的宏往往会拥有更多的分支。

虽然宏和 `match` 都称之为模式，但是前者跟[后者](https://course.rs/basic/match-pattern/all-patterns.html)的模式规则是不同的。如果大家想要更深入的了解宏的模式，可以查看[这里](https://doc.rust-lang.org/reference/macros-by-example.html)。

#### 模式解析

而现在，我们先来简单讲解下 `( $( $x:expr ),* )` 的含义。

首先，我们使用圆括号 `()` 将整个宏模式包裹其中。紧随其后的是 `$()`，跟括号中模式相匹配的值(传入的 Rust 源代码)会被捕获，然后用于代码替换。在这里，模式 `$x:expr` 会匹配任何 Rust 表达式并给予该模式一个名称：`$x`。

`$()` 之后的逗号说明 `$()` 所匹配的代码使用逗号分隔符分割，紧随逗号之后的 `*` 说明 `*` 之前的模式(`$()`内的部分)会被匹配零次或任意多次(类似正则表达式)(且以逗号分割)。

当我们使用 `vec![1, 2, 3]` 来调用该宏时，`$x` 模式将被匹配三次，分别是 `1`、`2`、`3`。为了帮助大家巩固，我们再来一起过一下：

1. `$()` 中包含的是模式 `$x:expr`，该模式中的 `expr` 表示会匹配任何 Rust 表达式，并给予该模式一个名称 `$x`
2. 因此 `$x` 模式可以跟整数 `1` 进行匹配，也可以跟字符串 "hello" 进行匹配: `vec!["hello", "world"]`
3. `$()` 之后的逗号，意味着 `1` 、 `2` 和 `3` 之间使用逗号进行分割
4. `*` 说明之前的模式可以出现零次也可以任意次，这里出现了三次

__需要注意的是，此处简化的 `vec!` 实现中， `3` 后面是不能继续接逗号的( `vec![1, 2, 3]` 合法，但 `vec![1, 2, 3,]` 不合法)，要匹配最后一个可有可无的逗号，可参考Rust官方的 `vec!` 宏定义，关键代码如下：__

```rust
($($x:expr),+ $(,)?) => (
    <[_]>::into_vec(
        // This rustc_box is not required, but it produces a dramatic improvement in compile
        // time when constructing arrays with many elements.
        #[rustc_box]
        $crate::boxed::Box::new([$($x),+])
    )
);
```

接下来，我们再来看看与模式相关联、在 `=>` 之后的代码：

```rust
{
    {
        let mut temp_vec = Vec::new();
        $(
            temp_vec.push($x);
        )*
        temp_vec
    }
};
```

这里就比较好理解了，`$()` 中的 `temp_vec.push()` 将根据模式匹配的次数生成对应的代码，当调用 `vec![1, 2, 3]` 时，下面这段生成的代码将替代传入的源代码，也就是替代 `vec![1, 2, 3]` :

```rust
{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
```

如果是 `let v = vec![1, 2, 3]`，那生成的代码最后返回的值 `temp_vec` 将被赋予给变量 `v`，等同于 :

```rust
let v = {
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
```

至此，我们定义了一个宏，它可以接受任意类型和数量的参数，并且理解了其语法的含义。

#### 未来将被替代的 `macro_rules`

对于 `macro_rules` 来说，它是存在一些问题的，因此，Rust 计划在未来使用新的声明式宏来替换它：工作方式类似，但是解决了目前存在的一些问题，在那之后，`macro_rules` 将变为 `deprecated` 状态。

由于绝大多数 Rust 开发者都是宏的用户而不是编写者，因此在这里我们不会对 `macro_rules` 进行更深入的学习，如果大家感兴趣，可以看看这本书 [ “The Little Book of Rust Macros”](https://veykril.github.io/tlborm/)。

## 用过程宏为属性标记生成代码

第二种常用的宏就是[_过程宏_](https://doc.rust-lang.org/reference/procedural-macros.html) ( _procedural macros_ )，从形式上来看，过程宏跟函数较为相像，但过程宏是使用源代码作为输入参数，基于代码进行一系列操作后，再输出一段全新的代码。**注意，过程宏中的 derive 宏输出的代码并不会替换之前的代码，这一点与声明宏有很大的不同！**

至于前文提到的过程宏的三种类型(自定义 `derive`、属性宏、函数宏)，它们的工作方式都是类似的。

当**创建过程宏**时，它的定义必须要放入一个独立的包中，且包的类型也是特殊的，这么做的原因相当复杂，大家只要知道这种限制在未来可能会有所改变即可。

> 事实上，根据[这个说法](https://www.reddit.com/r/rust/comments/t1oa1e/what_are_the_complex_technical_reasons_why/)，过程宏放入独立包的原因在于它必须先被编译后才能使用，如果过程宏和使用它的代码在一个包，就必须先单独对过程宏的代码进行编译，然后再对我们的代码进行编译，但悲剧的是 Rust 的编译单元是包，因此你无法做到这一点。

假设我们要创建一个 `derive` 类型的过程宏：

```rust
use proc_macro;

#[proc_macro_derive(HelloMacro)]
pub fn some_name(input: TokenStream) -> TokenStream {
}
```

用于定义过程宏的函数 `some_name` 使用 `TokenStream` 作为输入参数，并且返回的也是同一个类型。`TokenStream` 是在 `proc_macro` 包中定义的，顾名思义，它代表了一个 `Token` 序列。

在理解了过程宏的基本定义后，我们再来看看该如何创建三种类型的过程宏，首先，从大家最熟悉的 `derive` 开始。

## 自定义 `derive` 过程宏

假设我们有一个特征 `HelloMacro`，现在有两种方式让用户使用它：

- 为每个类型手动实现该特征，就像之前[特征章节](https://course.rs/basic/trait/trait.html#为类型实现特征)所做的
- 使用过程宏来统一实现该特征，这样用户只需要对类型进行标记即可：`#[derive(HelloMacro)]`

以上两种方式并没有孰优孰劣，主要在于不同的类型是否可以使用同样的默认特征实现，如果可以，那过程宏的方式可以帮我们减少很多代码实现:

```rust
use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Sunfei;

#[derive(HelloMacro)]
struct Sunface;

fn main() {
    Sunfei::hello_macro();
    Sunface::hello_macro();
}
```

简单吗？简单！不过为了实现这段代码展示的功能，我们还需要创建相应的过程宏才行。 首先，创建一个新的工程用于演示：

```shell
$ cargo new hello_macro
$ cd hello_macro/
$ touch src/lib.rs
```

此时，`src` 目录下包含两个文件 `lib.rs` 和 `main.rs`，前者是 `lib` 包根，后者是二进制包根，如果大家对包根不熟悉，可以看看[这里](https://course.rs/basic/crate-module/crate.html)。

接下来，先在 `src/lib.rs` 中定义过程宏所需的 `HelloMacro` 特征和其关联函数:

```rust
pub trait HelloMacro {
    fn hello_macro();
}
```

然后在 `src/main.rs` 中编写主体代码，首先映入大家脑海的可能会是如下实现:

```rust
use hello_macro::HelloMacro;

struct Sunfei;

impl HelloMacro for Sunfei {
    fn hello_macro() {
        println!("Hello, Macro! My name is Sunfei!");
    }
}

struct Sunface;

impl HelloMacro for Sunface {
    fn hello_macro() {
        println!("Hello, Macro! My name is Sunface!");
    }
}

fn main() {
    Sunfei::hello_macro();
}
```

但是这种方式有个问题，如果想要实现不同的招呼内容，就需要为每一个类型都实现一次相应的特征，Rust 不支持反射，因此我们无法在运行时获得类型名。

使用宏，就不存在这个问题：

```rust
use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Sunfei;

#[derive(HelloMacro)]
struct Sunface;

fn main() {
    Sunfei::hello_macro();
    Sunface::hello_macro();
}
```

简单明了的代码总是令人愉快，为了让代码运行起来，还需要定义下过程宏。就如前文提到的，目前只能在单独的包中定义过程宏，尽管未来这种限制会被取消，但是现在我们还得遵循这个规则。

宏所在的包名自然也有要求，必须以 `derive` 为后缀，对于 `hello_macro` 宏而言，包名就应该是 `hello_macro_derive`。在之前创建的 `hello_macro` 项目根目录下，运行如下命令，创建一个单独的 `lib` 包:

```rust
cargo new hello_macro_derive --lib
```

至此， `hello_macro` 项目的目录结构如下：

```shell
hello_macro
├── Cargo.toml
├── src
│   ├── main.rs
│   └── lib.rs
└── hello_macro_derive
    ├── Cargo.toml
    ├── src
        └── lib.rs
```

由于过程宏所在的包跟我们的项目紧密相连，因此将它放在项目之中。现在，问题又来了，该如何在项目的 `src/main.rs` 中引用 `hello_macro_derive` 包的内容？

方法有两种，第一种是将 `hello_macro_derive` 发布到 `crates.io` 或 `GitHub` 中，就像我们引用的其它依赖一样；另一种就是使用相对路径引入的本地化方式，修改 `hello_macro/Cargo.toml` 文件添加以下内容:

```toml
[dependencies]
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }
# 也可以使用下面的相对路径
# hello_macro_derive = { path = "./hello_macro_derive" }
```

此时，`hello_macro` 项目就可以成功的引用到 `hello_macro_derive` 本地包了，对于项目依赖引入的详细介绍，可以参见 [Cargo 章节](https://course.rs/cargo/dependency.html)。

另外，学习过程更好的办法是通过展开宏来阅读和调试自己写的宏，这里需要用到一个 cargo-expand 的工具，可以通过下面的命令安装
```bash
cargo install cargo-expand
```

接下来，就到了重头戏环节，一起来看看该如何定义过程宏。

#### 定义过程宏

首先，在 `hello_macro_derive/Cargo.toml` 文件中添加以下内容：

```toml
[lib]
proc-macro = true

[dependencies]
syn = "1.0"
quote = "1.0"
```

其中 `syn` 和 `quote` 依赖包都是定义过程宏所必需的，同时，还需要在 `[lib]` 中将过程宏的开关开启 : `proc-macro = true`。

其次，在 `hello_macro_derive/src/lib.rs` 中添加如下代码：

```rust
extern crate proc_macro;

use proc_macro::TokenStream;
use quote::quote;
use syn;
use syn::DeriveInput;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // 基于 input 构建 AST 语法树
    let ast:DeriveInput = syn::parse(input).unwrap();

    // 构建特征实现代码
    impl_hello_macro(&ast)
}
```

这个函数的签名我们在之前已经介绍过，总之，这种形式的过程宏定义是相当通用的，下面来分析下这段代码。

首先有一点，对于绝大多数过程宏而言，这段代码往往只在 `impl_hello_macro(&ast)` 中的实现有所区别，对于其它部分基本都是一致的，如包的引入、宏函数的签名、语法树构建等。

`proc_macro` 包是 Rust 自带的，因此无需在 `Cargo.toml` 中引入依赖，它包含了相关的编译器 `API`，可以用于读取和操作 Rust 源代码。

由于我们为 `hello_macro_derive` 函数标记了 `#[proc_macro_derive(HelloMacro)]`，当用户使用 `#[derive(HelloMacro)]` 标记了他的类型后，`hello_macro_derive` 函数就将被调用。这里的秘诀就是特征名 `HelloMacro`，它就像一座桥梁，将用户的类型和过程宏联系在一起。

`syn` 将字符串形式的 Rust 代码解析为一个 AST 树的数据结构，该数据结构可以在随后的 `impl_hello_macro` 函数中进行操作。最后，操作的结果又会被 `quote` 包转换回 Rust 代码。这些包非常关键，可以帮我们节省大量的精力，否则你需要自己去编写支持代码解析和还原的解析器，这可不是一件简单的任务！

derive过程宏只能用在struct/enum/union上，多数用在结构体上，我们先来看一下一个结构体由哪些部分组成:
```rust
// vis，可视范围             ident，标识符     generic，范型    fields: 结构体的字段
pub              struct    User            <'a, T>          {

// vis   ident   type
   pub   name:   &'a T,

}
```

其中type还可以细分，具体请阅读syn文档或源码

`syn::parse` 调用会返回一个 `DeriveInput` 结构体来代表解析后的 Rust 代码:

```rust
DeriveInput {
    // --snip--
    vis: Visibility,
    ident: Ident {
        ident: "Sunfei",
        span: #0 bytes(95..103)
    },
    generics: Generics,
    // Data是一个枚举，分别是DataStruct，DataEnum，DataUnion，这里以 DataStruct 为例
    data: Data(
        DataStruct {
            struct_token: Struct,
            fields: Fields,
            semi_token: Some(
                Semi
            )
        }
    )
}
```

以上就是源代码 `struct Sunfei;` 解析后的结果，里面有几点值得注意:

- `fields: Fields` 是一个枚举类型，`Fields::Named`, `Fields::Unnamed`, `Fields::Unit` 分别表示结构体中的显式命名字段（如例子所示），元组或元组变体中的匿名字段(例如`Some(T)`)，单元类型或单元变体字段（例如`None` ）。
- `ident: "Sunfei"` 说明类型名称为 `Sunfei`， `ident` 是标识符 `identifier` 的简写

如果想要了解更多的信息，可以查看 [`syn` 文档](https://docs.rs/syn/1.0/syn/struct.DeriveInput.html)。

大家可能会注意到在 `hello_macro_derive` 函数中有 `unwrap` 的调用，也许会以为这是为了演示目的，没有做错误处理，实际上并不是的。由于该函数只能返回 `TokenStream` 而不是 `Result`，那么在报错时直接 `panic` 来抛出错误就成了相当好的选择。当然，这里实际上还是做了简化，在生产项目中，你应该通过 `panic!` 或 `expect` 抛出更具体的报错信息。

至此，这个函数大家应该已经基本理解了，下面来看看如何构建特征实现的代码，也是过程宏的核心目标:

```rust
fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}
```

首先，将结构体的名称赋予给 `name`，也就是 `name` 中会包含一个字段，它的值是字符串 "Sunfei"。

其次，使用 `quote!` 可以定义我们想要返回的 Rust 代码。由于编译器需要的内容和 `quote!` 直接返回的不一样，因此还需要使用 `.into` 方法其转换为 `TokenStream`。

大家注意到 `#name` 的使用了吗？这也是 `quote!` 提供的功能之一，如果想要深入了解 `quote`，可以看看[官方文档](https://docs.rs/quote)。

特征的 `hell_macro()` 函数只有一个功能，就是使用 `println!` 打印一行欢迎语句。

其中 `stringify!` 是 Rust 提供的内置宏，可以将一个表达式(例如 `1 + 2`)在编译期转换成一个字符串字面值(`"1 + 2"`)，该字面量会直接打包进编译出的二进制文件中，具有 `'static` 生命周期。而 `format!` 宏会对表达式进行求值，最终结果是一个 `String` 类型。在这里使用 `stringify!` 有两个好处:

- `#name` 可能是一个表达式，我们需要它的字面值形式
- 可以减少一次 `String` 带来的内存分配

在运行之前，可以先用 expand 展开宏，观察是否有错误或符合预期:
```shell
$ cargo expand --bin hello_macro
```
```rust
struct Sunfei;
impl HelloMacro for Sunfei {
    fn hello_macro() {
        {
            ::std::io::_print(
                ::core::fmt::Arguments::new_v1(
                    &["Hello, Macro! My name is ", "!\n"],
                    &[::core::fmt::ArgumentV1::new_display(&"Sunfei")],
                ),
            );
        };
    }
}
struct Sunface;
impl HelloMacro for Sunface {
    fn hello_macro() {
        {
            ::std::io::_print(
                ::core::fmt::Arguments::new_v1(
                    &["Hello, Macro! My name is ", "!\n"],
                    &[::core::fmt::ArgumentV1::new_display(&"Sunface")],
                ),
            );
        };
    }
}
fn main() {
    Sunfei::hello_macro();
    Sunface::hello_macro();
}
```

从展开的代码也能看出derive宏的特性，`struct Sunfei;` 和 `struct Sunface;` 都被保留了，也就是说最后 `impl_hello_macro()` 返回的token被加到结构体后面，这和类属性宏可以修改输入
的token是不一样的，input的token并不能被修改。

至此，过程宏的定义、特征定义、主体代码都已经完成，运行下试试:

```shell
$ cargo run

     Running `target/debug/hello_macro`
Hello, Macro! My name is Sunfei!
Hello, Macro! My name is Sunface!
```

Bingo，虽然过程有些复杂，但是结果还是很喜人，我们终于完成了自己的第一个过程宏！

下面来实现一个更实用的例子，实现官方的#[derive(Default)]宏，废话不说直接开干:

```rust
extern crate proc_macro;
use proc_macro::TokenStream;
use quote::quote;
use syn::{self, Data};
use syn::DeriveInput;

#[proc_macro_derive(MyDefault)]
pub fn my_default(input: TokenStream) -> TokenStream {
    let ast: DeriveInput = syn::parse(input).unwrap();
    let id = ast.ident;

    let Data::Struct(s) = ast.data else{
        panic!("MyDefault derive macro must use in struct");
    };

    // 声明一个新的ast，用于动态构建字段赋值的token
    let mut field_ast = quote!();

    // 这里就是要动态添加token的地方了，需要动态完成Self的字段赋值
    for (idx,f) in s.fields.iter().enumerate() {
        let (field_id, field_ty) = (&f.ident, &f.ty);


        if field_id.is_none(){
             //没有ident表示是匿名字段，对于匿名字段，都需要添加 `#field_idx: #field_type::default(),` 这样的代码
            let field_idx  = syn::Index::from(idx);
            field_ast.extend(quote! {
                # field_idx: # field_ty::default(),
            });
        }else{
            //对于命名字段，都需要添加 `#field_name: #field_type::default(),` 这样的代码
            field_ast.extend(quote! {
                # field_id: # field_ty::default(),
            });
        }
    }

    quote! {
        impl Default for # id {
            fn default() -> Self {
                Self {
                    # field_ast
                }
            }
        }
    }.into()
}
```

然后来写使用代码:

```rust
#[derive(MyDefault)]
struct SomeData (u32,String);

#[derive(MyDefault)]
struct User {
    name: String,
    data: SomeData,
}

fn main() {

}
```

然后我们先展开代码看一看

```rust
struct SomeData(u32, String);
impl Default for SomeData {
    fn default() -> Self {
        Self {
            0: u32::default(),
            1: String::default(),
        }
    }
}
struct User {
    name: String,
    data: SomeData,
}
impl Default for User {
    fn default() -> Self {
        Self {
            name: String::default(),
            data: SomeData::default(),
        }
    }
}
fn main() {}
```

展开的代码符合预期，然后我们修改一下使用代码并测试结果

```rust
#[derive(MyDefault, Debug)]
struct SomeData (u32,String);

#[derive(MyDefault, Debug)]
struct User {
    name: String,
    data: SomeData,
}

fn main() {
    println!("{:?}", User::default());
}
```

执行

```shell
$ cargo run

    Running `target/debug/aaa`
User { name: "", data: SomeData(0, "") }
```



接下来，再来看看过程宏的另外两种类型跟 `derive` 类型有何区别。

## 类属性宏(Attribute-like macros)

类属性过程宏跟 `derive` 宏类似，但是前者允许我们定义自己的属性。除此之外，`derive` 只能用于结构体和枚举，而类属性宏可以用于其它类型项，例如函数。

假设我们在开发一个 `web` 框架，当用户通过 `HTTP GET` 请求访问 `/` 根路径时，使用 `index` 函数为其提供服务:

```rust
#[route(GET, "/")]
fn index() {
```

如上所示，代码功能非常清晰、简洁，这里的 `#[route]` 属性就是一个过程宏，它的定义函数大概如下：

```rust
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
```

与 `derive` 宏不同，类属性宏的定义函数有两个参数：

- 第一个参数时用于说明属性包含的内容：`Get, "/"` 部分
- 第二个是属性所标注的类型项，在这里是 `fn index() {...}`，注意，函数体也被包含其中

除此之外，类属性宏跟 `derive` 宏的工作方式并无区别：创建一个包，类型是 `proc-macro`，接着实现一个函数用于生成想要的代码。

## 类函数宏(Function-like macros)

类函数宏可以让我们定义像函数那样调用的宏，从这个角度来看，它跟声明宏 `macro_rules` 较为类似。

区别在于，`macro_rules` 的定义形式与 `match` 匹配非常相像，而类函数宏的定义形式则类似于之前讲过的两种过程宏:

```rust
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
```

而使用形式则类似于函数调用:

```rust
let sql = sql!(SELECT * FROM posts WHERE id=1);
```

大家可能会好奇，为何我们不使用声明宏 `macro_rules` 来定义呢？原因是这里需要对 `SQL` 语句进行解析并检查其正确性，这个复杂的过程是 `macro_rules` 难以对付的，**而过程宏相比起来就会灵活的多**。

## 补充学习资料

1. [dtolnay/proc-macro-workshop](https://github.com/dtolnay/proc-macro-workshop)，学习如何编写过程宏
2. [The Little Book of Rust Macros](https://veykril.github.io/tlborm/)，学习如何编写声明宏 `macro_rules!`
3. [syn](https://crates.io/crates/syn) 和 [quote](https://crates.io/crates/quote) ，用于编写过程宏的包，它们的文档有很多值得学习的东西
4. [Structuring, testing and debugging procedural macro crates](https://www.reddit.com/r/rust/comments/rjumsg/any_good_resources_for_learning_rust_macros/)，从测试、debug、结构化的角度来编写过程宏
5. [blog.turbo.fish](https://blog.turbo.fish)，里面的过程宏系列文章值得一读
6. [Rust 宏小册中文版](https://zjp-cn.github.io/tlborm/)，非常详细的解释了宏各种知识

## 总结

Rust 中的宏主要分为两大类：声明宏和过程宏。

声明宏目前使用 `macro_rules` 进行创建，它的形式类似于 `match` 匹配，对于用户而言，可读性和维护性都较差。由于其存在的问题和限制，在未来， `macro_rules` 会被 `deprecated`，Rust 会使用一个新的声明宏来替代它。

而过程宏的定义更像是我们平时写函数的方式，因此它更加灵活，它分为三种类型：`derive` 宏、类属性宏、类函数宏，具体在文中都有介绍。

虽然 Rust 中的宏很强大，但是它并不应该成为我们的常规武器，原因是它会影响 Rust 代码的可读性和可维护性，我相信没有几个人愿意去维护别人写的宏 ：）

因此，大家应该熟悉宏的使用场景，但是不要滥用，当你真的需要时，再回来查看本章了解实现细节，这才是最完美的使用方式。



================================================
FILE: src/advance/simd.md
================================================
# SIMD

由于 Rust 最新也是万众瞩目的 `Portable SIMD` 还没有完全成熟，只能在 `nightly` 版本中使用，因此功能上可能还存在变数，鉴于此，本文不会深入介绍在 Rust 中如何编写 SIMD 代码，而是将目光聚集在两个点上：何为 `SIMD` 以及关于 `Portable SIMD` 的简单介绍。



================================================
FILE: src/advance/async/async-await.md
================================================
[Binary file]


================================================
FILE: src/advance/async/future-excuting.md
================================================
# 底层探秘: Future 执行器与任务调度

异步编程背后到底藏有什么秘密？究竟是哪只幕后之手在操纵这一切？如果你对这些感兴趣，就继续看下去，否则可以直接跳过，因为本章节的内容对于一个 API 工程师并没有太多帮助。

但是如果你希望能深入理解 `Rust` 的 `async/.await` 代码是如何工作、理解运行时和性能，甚至未来想要构建自己的 `async` 运行时或相关工具，那么本章节终究不会辜负于你。

## Future 特征

`Future` 特征是 Rust 异步编程的核心，毕竟异步函数是异步编程的核心，而 `Future` 恰恰是异步函数的返回值和被执行的关键。

首先，来给出 `Future` 的定义：它是一个能产出值的异步计算(虽然该值可能为空，例如 `()` )。光看这个定义，可能会觉得很空洞，我们来看看一个简化版的 `Future` 特征:

```rust
trait SimpleFuture {
    type Output;
    fn poll(&mut self, wake: fn()) -> Poll<Self::Output>;
}

enum Poll<T> {
    Ready(T),
    Pending,
}
```

在上一章中，我们提到过 `Future` 需要被执行器`poll`(轮询)后才能运行，诺，这里 `poll` 就来了，通过调用该方法，可以推进 `Future` 的进一步执行，直到被切走为止( 这里不好理解，但是你只需要知道 `Future` 并不能保证在一次 `poll` 中就被执行完，后面会详解介绍)。

若在当前 `poll` 中， `Future` 可以被完成，则会返回 `Poll::Ready(result)` ，反之则返回 `Poll::Pending`， 并且安排一个 `wake` 函数：当未来 `Future` 准备好进一步执行时， 该函数会被调用，然后管理该 `Future` 的执行器(例如上一章节中的`block_on`函数)会再次调用 `poll` 方法，此时 `Future` 就可以继续执行了。

如果没有 `wake` 方法，那执行器无法知道某个 `Future` 是否可以继续被执行，除非执行器定期的轮询每一个 `Future`，确认它是否能被执行，但这种作法效率较低。而有了 `wake`，`Future` 就可以主动通知执行器，然后执行器就可以精确的执行该 `Future`。 这种“事件通知 -> 执行”的方式要远比定期对所有 `Future` 进行一次全遍历来的高效。

也许大家还是迷迷糊糊的，没事，我们用一个例子来说明下。考虑一个需要从 `socket` 读取数据的场景：如果有数据，可以直接读取数据并返回 `Poll::Ready(data)`， 但如果没有数据，`Future` 会被阻塞且不会再继续执行，此时它会注册一个 `wake` 函数，当 `socket` 数据准备好时，该函数将被调用以通知执行器：我们的 `Future` 已经准备好了，可以继续执行。

下面的 `SocketRead` 结构体就是一个 `Future`:

```rust
pub struct SocketRead<'a> {
    socket: &'a Socket,
}

impl SimpleFuture for SocketRead<'_> {
    type Output = Vec<u8>;

    fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
        if self.socket.has_data_to_read() {
            // socket有数据，写入buffer中并返回
            Poll::Ready(self.socket.read_buf())
        } else {
            // socket中还没数据
            //
            // 注册一个`wake`函数，当数据可用时，该函数会被调用，
            // 然后当前Future的执行器会再次调用`poll`方法，此时就可以读取到数据
            self.socket.set_readable_callback(wake);
            Poll::Pending
        }
    }
}
```

这种 `Future` 模型允许将多个异步操作组合在一起，同时还无需任何内存分配。不仅仅如此，如果你需要同时运行多个 `Future`或链式调用多个 `Future` ，也可以通过无内存分配的状态机实现，例如：

```rust
trait SimpleFuture {
    type Output;
    fn poll(&mut self, wake: fn()) -> Poll<Self::Output>;
}

enum Poll<T> {
    Ready(T),
    Pending,
}

/// 一个SimpleFuture，它会并发地运行两个Future直到它们完成
///
/// 之所以可以并发，是因为两个Future的轮询可以交替进行，一个阻塞，另一个就可以立刻执行，反之亦然
pub struct Join<FutureA, FutureB> {
    // 结构体的每个字段都包含一个Future，可以运行直到完成.
    // 等到Future完成后，字段会被设置为 `None`. 这样Future完成后，就不会再被轮询
    a: Option<FutureA>,
    b: Option<FutureB>,
}

impl<FutureA, FutureB> SimpleFuture for Join<FutureA, FutureB>
where
    FutureA: SimpleFuture<Output = ()>,
    FutureB: SimpleFuture<Output = ()>,
{
    type Output = ();
    fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
        // 尝试去完成一个 Future `a`
        if let Some(a) = &mut self.a {
            if let Poll::Ready(()) = a.poll(wake) {
                self.a.take();
            }
        }

        // 尝试去完成一个 Future `b`
        if let Some(b) = &mut self.b {
            if let Poll::Ready(()) = b.poll(wake) {
                self.b.take();
            }
        }

        if self.a.is_none() && self.b.is_none() {
            // 两个 Future都已完成 - 我们可以成功地返回了
            Poll::Ready(())
        } else {
            // 至少还有一个 Future 没有完成任务，因此返回 `Poll::Pending`.
            // 当该 Future 再次准备好时，通过调用`wake()`函数来继续执行
            Poll::Pending
        }
    }
}
```

上面代码展示了如何同时运行多个 `Future`， 且在此过程中没有任何内存分配，让并发编程更加高效。 类似的，多个`Future`也可以一个接一个的连续运行：

```rust
/// 一个SimpleFuture, 它使用顺序的方式，一个接一个地运行两个Future
//
// 注意: 由于本例子用于演示，因此功能简单，`AndThenFut` 会假设两个 Future 在创建时就可用了.
// 而真实的`Andthen`允许根据第一个`Future`的输出来创建第二个`Future`，因此复杂的多。
pub struct AndThenFut<FutureA, FutureB> {
    first: Option<FutureA>,
    second: FutureB,
}

impl<FutureA, FutureB> SimpleFuture for AndThenFut<FutureA, FutureB>
where
    FutureA: SimpleFuture<Output = ()>,
    FutureB: SimpleFuture<Output = ()>,
{
    type Output = ();
    fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
        if let Some(first) = &mut self.first {
            match first.poll(wake) {
                // 我们已经完成了第一个 Future， 可以将它移除， 然后准备开始运行第二个
                Poll::Ready(()) => self.first.take(),
                // 第一个 Future 还不能完成
                Poll::Pending => return Poll::Pending,
            };
        }

        // 运行到这里，说明第一个Future已经完成，尝试去完成第二个
        self.second.poll(wake)
    }
}
```

这些例子展示了在不需要内存对象分配以及深层嵌套回调的情况下，该如何使用 `Future` 特征去表达异步控制流。 在了解了基础的控制流后，我们再来看看真实的 `Future` 特征有何不同之处。

```rust
trait Future {
    type Output;
    fn poll(
        // 首先值得注意的地方是，`self`的类型从`&mut self`变成了`Pin<&mut Self>`:
        self: Pin<&mut Self>,
        // 其次将`wake: fn()` 修改为 `cx: &mut Context<'_>`:
        cx: &mut Context<'_>,
    ) -> Poll<Self::Output>;
}
```

首先这里多了一个 `Pin` ，关于它我们会在后面章节详细介绍，现在你只需要知道使用它可以创建一个无法被移动的 `Future` ，因为无法被移动，所以它将具有固定的内存地址，意味着我们可以存储它的指针(如果内存地址可能会变动，那存储指针地址将毫无意义！)，也意味着可以实现一个自引用数据结构: `struct MyFut { a: i32, ptr_to_a: *const i32 }`。 而对于 `async/await` 来说，`Pin` 是不可或缺的关键特性。

其次，从 `wake: fn()` 变成了 `&mut Context<'_>` 。意味着 `wake` 函数可以携带数据了，为何要携带数据？考虑一个真实世界的场景，一个复杂应用例如 web 服务器可能有数千连接同时在线，那么同时就有数千 `Future` 在被同时管理着，如果不能携带数据，当一个 `Future` 调用 `wake` 后，执行器该如何知道是哪个 `Future` 调用了 `wake` ,然后进一步去 `poll` 对应的 `Future` ？没有办法！那之前的例子为啥就可以使用没有携带数据的 `wake` ？ 因为足够简单，不存在歧义性。

总之，在正式场景要进行 `wake` ，就必须携带上数据。 而 `Context` 类型通过提供一个 `Waker` 类型的值，就可以用来唤醒特定的的任务。

## 使用 Waker 来唤醒任务

对于 `Future` 来说，第一次被 `poll` 时无法完成任务是很正常的。但它需要确保在未来一旦准备好时，可以通知执行器再次对其进行 `poll` 进而继续往下执行，该通知就是通过 `Waker` 类型完成的。

`Waker` 提供了一个 `wake()` 方法可以用于告诉执行器：相关的任务可以被唤醒了，此时执行器就可以对相应的 `Future` 再次进行 `poll` 操作。

#### 构建一个定时器

下面一起来实现一个简单的定时器 `Future` 。为了让例子尽量简单，当计时器创建时，我们会启动一个线程接着让该线程进入睡眠，等睡眠结束后再通知给 `Future` 。

注意本例子还会在后面继续使用，因此我们重新创建一个工程来演示：使用 `cargo new --lib timer_future` 来创建一个新工程，在 `lib` 包的根路径 `src/lib.rs` 中添加以下内容：

```rust
use std::{
    future::Future,
    pin::Pin,
    sync::{Arc, Mutex},
    task::{Context, Poll, Waker},
    thread,
    time::Duration,
};
```

继续来实现 `Future` 定时器，之前提到: 新建线程在睡眠结束后会需要将状态同步给定时器 `Future` ，由于是多线程环境，我们需要使用 `Arc<Mutex<T>>` 来作为一个共享状态，用于在新线程和 `Future` 定时器间共享。

```rust
pub struct TimerFuture {
    shared_state: Arc<Mutex<SharedState>>,
}

/// 在Future和等待的线程间共享状态
struct SharedState {
    /// 定时(睡眠)是否结束
    completed: bool,

    /// 当睡眠结束后，线程可以用`waker`通知`TimerFuture`来唤醒任务
    waker: Option<Waker>,
}
```

下面给出 `Future` 的具体实现:

```rust
impl Future for TimerFuture {
    type Output = ();
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        // 通过检查共享状态，来确定定时器是否已经完成
        let mut shared_state = self.shared_state.lock().unwrap();
        if shared_state.completed {
            Poll::Ready(())
        } else {
            // 设置`waker`，这样新线程在睡眠(计时)结束后可以唤醒当前的任务，接着再次对`Future`进行`poll`操作,
            //
            // 下面的`clone`每次被`poll`时都会发生一次，实际上，应该是只`clone`一次更加合理。
            // 选择每次都`clone`的原因是： `TimerFuture`可以在执行器的不同任务间移动，如果只克隆一次，
            // 那么获取到的`waker`可能已经被篡改并指向了其它任务，最终导致执行器运行了错误的任务
            shared_state.waker = Some(cx.waker().clone());
            Poll::Pending
        }
    }
}
```

代码很简单，只要新线程设置了 `shared_state.completed = true` ，那任务就能顺利结束。如果没有设置，会为当前的任务克隆一份 `Waker` ，这样新线程就可以使用它来唤醒当前的任务。

最后，再来创建一个 API 用于构建定时器和启动计时线程:

```rust
impl TimerFuture {
    /// 创建一个新的`TimerFuture`，在指定的时间结束后，该`Future`可以完成
    pub fn new(duration: Duration) -> Self {
        let shared_state = Arc::new(Mutex::new(SharedState {
            completed: false,
            waker: None,
        }));

        // 创建新线程
        let thread_shared_state = shared_state.clone();
        thread::spawn(move || {
            // 睡眠指定时间实现计时功能
            thread::sleep(duration);
            let mut shared_state = thread_shared_state.lock().unwrap();
            // 通知执行器定时器已经完成，可以继续`poll`对应的`Future`了
            shared_state.completed = true;
            if let Some(waker) = shared_state.waker.take() {
                waker.wake()
            }
        });

        TimerFuture { shared_state }
    }
}
```

至此，一个简单的定时器 `Future` 就已创建成功，那么该如何使用它呢？相信部分爱动脑筋的读者已经猜到了：我们需要创建一个执行器，才能让程序动起来。

## 执行器 Executor

Rust 的 `Future` 是惰性的：只有屁股上拍一拍，它才会努力动一动。其中一个推动它的方式就是在 `async` 函数中使用 `.await` 来调用另一个 `async` 函数，但是这个只能解决 `async` 内部的问题，那么这些最外层的 `async` 函数，谁来推动它们运行呢？答案就是我们之前多次提到的执行器 `executor` 。

执行器会管理一批 `Future` (最外层的 `async` 函数)，然后通过不停地 `poll` 推动它们直到完成。 最开始，执行器会先 `poll` 一次 `Future` ，后面就不会主动去 `poll` 了，而是等待 `Future` 通过调用 `wake` 函数来通知它可以继续，它才会继续去 `poll` 。这种 **wake 通知然后 poll** 的方式会不断重复，直到 `Future` 完成。

#### 构建执行器

下面我们将实现一个简单的执行器，它可以同时并发运行多个 `Future` 。例子中，需要用到 `futures` 包的 `ArcWake` 特征，它可以提供一个方便的途径去构建一个 `Waker` 。编辑 `Cargo.toml` ，添加下面依赖:

```rust
[dependencies]
futures = "0.3"
```

在之前的内容中，我们在 `src/lib.rs` 中创建了定时器 `Future` ，现在在 `src/main.rs` 中来创建程序的主体内容，开始之前，先引入所需的包：

```rust
use {
    futures::{
        future::{BoxFuture, FutureExt},
        task::{waker_ref, ArcWake},
    },
    std::{
        future::Future,
        sync::mpsc::{sync_channel, Receiver, SyncSender},
        sync::{Arc, Mutex},
        task::{Context, Poll},
        time::Duration,
    },
    // 引入之前实现的定时器模块
    timer_future::TimerFuture,
};
```

执行器需要从一个消息通道( `channel` )中拉取事件，然后运行它们。当一个任务准备好后（可以继续执行），它会将自己放入消息通道中，然后等待执行器 `poll` 。

```rust
/// 任务执行器，负责从通道中接收任务然后执行
struct Executor {
    ready_queue: Receiver<Arc<Task>>,
}

/// `Spawner`负责创建新的`Future`然后将它发送到任务通道中
#[derive(Clone)]
struct Spawner {
    task_sender: SyncSender<Arc<Task>>,
}

/// 一个Future，它可以调度自己(将自己放入任务通道中)，然后等待执行器去`poll`
struct Task {
    /// 进行中的Future，在未来的某个时间点会被完成
    ///
    /// 按理来说`Mutex`在这里是多余的，因为我们只有一个线程来执行任务。但是由于
    /// Rust并不聪明，它无法知道`Future`只会在一个线程内被修改，并不会被跨线程修改。因此
    /// 我们需要使用`Mutex`来满足这个笨笨的编译器对线程安全的执着。
    ///
    /// 如果是生产级的执行器实现，不会使用`Mutex`，因为会带来性能上的开销，取而代之的是使用`UnsafeCell`
    future: Mutex<Option<BoxFuture<'static, ()>>>,

    /// 可以将该任务自身放回到任务通道中，等待执行器的poll
    task_sender: SyncSender<Arc<Task>>,
}

fn new_executor_and_spawner() -> (Executor, Spawner) {
    // 任务通道允许的最大缓冲数(任务队列的最大长度)
    // 当前的实现仅仅是为了简单，在实际的执行中，并不会这么使用
    const MAX_QUEUED_TASKS: usize = 10_000;
    let (task_sender, ready_queue) = sync_channel(MAX_QUEUED_TASKS);
    (Executor { ready_queue }, Spawner { task_sender })
}
```

下面再来添加一个方法用于生成 `Future` , 然后将它放入任务通道中:

```rust
impl Spawner {
    fn spawn(&self, future: impl Future<Output = ()> + 'static + Send) {
        let future = future.boxed();
        let task = Arc::new(Task {
            future: Mutex::new(Some(future)),
            task_sender: self.task_sender.clone(),
        });
        self.task_sender.send(task).expect("任务队列已满");
    }
}
```

在执行器 `poll` 一个 `Future` 之前，首先需要调用 `wake` 方法进行唤醒，然后再由 `Waker` 负责调度该任务并将其放入任务通道中。创建 `Waker` 的最简单的方式就是实现 `ArcWake` 特征，先来为我们的任务实现 `ArcWake` 特征，这样它们就能被转变成 `Waker` 然后被唤醒:

```rust
impl ArcWake for Task {
    fn wake_by_ref(arc_self: &Arc<Self>) {
        // 通过发送任务到任务管道的方式来实现`wake`，这样`wake`后，任务就能被执行器`poll`
        let cloned = arc_self.clone();
        arc_self
            .task_sender
            .send(cloned)
            .expect("任务队列已满");
    }
}
```

当任务实现了 `ArcWake` 特征后，它就变成了 `Waker` ，在调用 `wake()` 对其唤醒后会将任务复制一份所有权( `Arc` )，然后将其发送到任务通道中。最后我们的执行器将从通道中获取任务，然后进行 `poll` 执行：

```rust
impl Executor {
    fn run(&self) {
        while let Ok(task) = self.ready_queue.recv() {
            // 获取一个future，若它还没有完成(仍然是Some，不是None)，则对它进行一次poll并尝试完成它
            let mut future_slot = task.future.lock().unwrap();
            if let Some(mut future) = future_slot.take() {
                // 基于任务自身创建一个 `LocalWaker`
                let waker = waker_ref(&task);
                let context = &mut Context::from_waker(&*waker);
                // `BoxFuture<T>`是`Pin<Box<dyn Future<Output = T> + Send + 'static>>`的类型别名
                // 通过调用`as_mut`方法，可以将上面的类型转换成`Pin<&mut dyn Future + Send + 'static>`
                if future.as_mut().poll(context).is_pending() {
                    // Future还没执行完，因此将它放回任务中，等待下次被poll
                    *future_slot = Some(future);
                }
            }
        }
    }
}
```

恭喜！我们终于拥有了自己的执行器，下面再来写一段代码使用该执行器去运行之前的定时器 `Future` ：

```rust
fn main() {
    let (executor, spawner) = new_executor_and_spawner();

    // 生成一个任务
    spawner.spawn(async {
        println!("howdy!");
        // 创建定时器Future，并等待它完成
        TimerFuture::new(Duration::new(2, 0)).await;
        println!("done!");
    });

    // drop掉任务，这样执行器就知道任务已经完成，不会再有新的任务进来
    drop(spawner);

    // 运行执行器直到任务队列为空
    // 任务运行后，会先打印`howdy!`, 暂停2秒，接着打印 `done!`
    executor.run();
}
```

## 执行器和系统 IO

前面我们一起看过一个使用 `Future` 从 `Socket` 中异步读取数据的例子:

```rust
pub struct SocketRead<'a> {
    socket: &'a Socket,
}

impl SimpleFuture for SocketRead<'_> {
    type Output = Vec<u8>;

    fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
        if self.socket.has_data_to_read() {
            // socket有数据，写入buffer中并返回
            Poll::Ready(self.socket.read_buf())
        } else {
            // socket中还没数据
            //
            // 注册一个`wake`函数，当数据可用时，该函数会被调用，
            // 然后当前Future的执行器会再次调用`poll`方法，此时就可以读取到数据
            self.socket.set_readable_callback(wake);
            Poll::Pending
        }
    }
}
```

该例子中，`Future` 将从 `Socket` 读取数据，若当前还没有数据，则会让出当前线程的所有权，允许执行器去执行其它的 `Future` 。当数据准备好后，会调用 `wake()` 函数将该 `Future` 的任务放入任务通道中，等待执行器的 `poll` 。

关于该流程已经反复讲了很多次，相信大家应该非常清楚了。然而该例子中还有一个疑问没有解决：

- `set_readable_callback` 方法到底是怎么工作的？怎么才能知道 `socket` 中的数据已经可以被读取了？

关于第二点，其中一个简单粗暴的方法就是使用一个新线程不停的检查 `socket` 中是否有了数据，当有了后，就调用 `wake()` 函数。该方法确实可以满足需求，但是性能着实太低了，需要为每个阻塞的 `Future` 都创建一个单独的线程！

在现实世界中，该问题往往是通过操作系统提供的 `IO` 多路复用机制来完成，例如 `Linux` 中的 **`epoll`**，`FreeBSD` 和 `macOS` 中的 **`kqueue`** ，`Windows` 中的 **`IOCP`**, `Fuchisa`中的 **`ports`** 等(可以通过 Rust 的跨平台包 `mio` 来使用它们)。借助 IO 多路复用机制，可以实现一个线程同时阻塞地去等待多个异步 IO 事件，一旦某个事件完成就立即退出阻塞并返回数据。相关实现类似于以下代码：

```rust
struct IoBlocker {
    /* ... */
}

struct Event {
    // Event的唯一ID，该事件发生后，就会被监听起来
    id: usize,

    // 一组需要等待或者已发生的信号
    signals: Signals,
}

impl IoBlocker {
    /// 创建需要阻塞等待的异步IO事件的集合
    fn new() -> Self { /* ... */ }

    /// 对指定的IO事件表示兴趣
    fn add_io_event_interest(
        &self,

        /// 事件所绑定的socket
        io_object: &IoObject,

        event: Event,
    ) { /* ... */ }

    /// 进入阻塞，直到某个事件出现
    fn block(&self) -> Event { /* ... */ }
}

let mut io_blocker = IoBlocker::new();
io_blocker.add_io_event_interest(
    &socket_1,
    Event { id: 1, signals: READABLE },
);
io_blocker.add_io_event_interest(
    &socket_2,
    Event { id: 2, signals: READABLE | WRITABLE },
);
let event = io_blocker.block();

// 当socket的数据可以读取时，打印 "Socket 1 is now READABLE"
println!("Socket {:?} is now {:?}", event.id, event.signals);
```

这样，我们只需要一个执行器线程，它会接收 IO 事件并将其分发到对应的 `Waker` 中，接着后者会唤醒相关的任务，最终通过执行器 `poll` 后，任务可以顺利地继续执行, 这种 IO 读取流程可以不停的循环，直到 `socket` 关闭。



================================================
FILE: src/advance/async/getting-started.md
================================================
[Binary file]


================================================
FILE: src/advance/async/intro.md
================================================
# 异步编程

在艰难的学完 Rust 入门和进阶所有的 70 个章节后，我们终于来到了这里。假如之前攀登的是珠穆朗玛峰，那么现在攀登的就是乔戈里峰( 比珠峰还难攀爬... )。

如果你想开发 Web 服务器、数据库驱动、消息服务等需要高并发的服务，那么本章的内容将值得认真对待和学习。

接下来，我们将深入了解 async/await 的使用方式及背后的原理。

> 本章在内容上大量借鉴和翻译了原版英文书籍[Asynchronous Programming In Rust](https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html), 特此感谢



================================================
FILE: src/advance/async/multi-futures-simultaneous.md
================================================
[Binary file]


================================================
FILE: src/advance/async/pain-points-and-workarounds.md
================================================
[Binary file]


================================================
FILE: src/advance/async/pin-unpin.md
================================================
[Binary file]


================================================
FILE: src/advance/async/web-server.md
================================================
[Binary file]


================================================
FILE: src/advance/circle-self-ref/circle-reference.md
================================================
# Weak 与循环引用

Rust 的安全性是众所周知的，但是不代表它不会内存泄漏。一个典型的例子就是同时使用 `Rc<T>` 和 `RefCell<T>` 创建循环引用，最终这些引用的计数都无法被归零，因此 `Rc<T>` 拥有的值也不会被释放清理。

## 何为循环引用

关于内存泄漏，如果你没有充足的 Rust 经验，可能都无法造出一份代码来再现它：

```rust
use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell<Rc<List>>),
    Nil,
}

impl List {
    fn tail(&self) -> Option<&RefCell<Rc<List>>> {
        match self {
            Cons(_, item) => Some(item),
            Nil => None,
        }
    }
}

fn main() {}
```

这里我们创建一个有些复杂的枚举类型 `List`，这个类型很有意思，它的每个值都指向了另一个 `List`，此外，得益于 `Rc` 的使用还允许多个值指向一个 `List`：

<img alt="" src="https://pica.zhimg.com/80/v2-0db007dfb4167ebc22f50cf5b5a85f53_1440w.png" class="center"  />

如上图所示，每个矩形框节点都是一个 `List` 类型，它们或者是拥有值且指向另一个 `List` 的`Cons`，或者是一个没有值的终结点 `Nil`。同时，由于 `RefCell` 的使用，每个 `List` 所指向的 `List` 还能够被修改。

下面来使用一下这个复杂的 `List` 枚举：

```rust
fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a的初始化rc计数 = {}", Rc::strong_count(&a));
    println!("a指向的节点 = {:?}", a.tail());

    // 创建`b`到`a`的引用
    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));

    println!("在b创建后，a的rc计数 = {}", Rc::strong_count(&a));
    println!("b的初始化rc计数 = {}", Rc::strong_count(&b));
    println!("b指向的节点 = {:?}", b.tail());

    // 利用RefCell的可变性，创建了`a`到`b`的引用
    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&b);
    }

    println!("在更改a后，b的rc计数 = {}", Rc::strong_count(&b));
    println!("在更改a后，a的rc计数 = {}", Rc::strong_count(&a));

    // 下面一行println!将导致循环引用
    // 我们可怜的8MB大小的main线程栈空间将被它冲垮，最终造成栈溢出
    // println!("a next item = {:?}", a.tail());
}
```

这个类型定义看着复杂，使用起来更复杂！不过排除这些因素，我们可以清晰看出：

1. 在创建了 `a` 后，紧接着就使用 `a` 创建了 `b`，因此 `b` 引用了 `a`
2. 然后我们又利用 `Rc` 克隆了 `b`，然后通过 `RefCell` 的可变性，让 `a` 引用了 `b`

至此我们成功创建了循环引用`a`-> `b` -> `a` -> `b` ····

先来观察下引用计数：

```console
a的初始化rc计数 = 1
a指向的节点 = Some(RefCell { value: Nil })
在b创建后，a的rc计数 = 2
b的初始化rc计数 = 1
b指向的节点 = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
在更改a后，b的rc计数 = 2
在更改a后，a的rc计数 = 2
```

在 `main` 函数结束前，`a` 和 `b` 的引用计数均是 `2`，随后 `b` 触发 `Drop`，此时引用计数会变为 `1`，并不会归 `0`，因此 `b` 所指向内存不会被释放，同理可得 `a` 指向的内存也不会被释放，最终发生了内存泄漏。

下面一张图很好的展示了这种引用循环关系：
<img alt="" src="https://pic1.zhimg.com/80/v2-2dbfc981f05019bf70bf81c93f956c35_1440w.png" class="center"  />

现在我们还需要轻轻的推一下，让塔米诺骨牌轰然倒塌。反注释最后一行代码，试着运行下：

```console
RefCell { value: Cons(5, RefCell { value: Cons(10, RefCell { value: Cons(5, RefCell { value: Cons(10, RefCell { value: Cons(5, RefCell { value: Cons(10, RefCell {
...无穷无尽
thread 'main' has overflowed its stack
fatal runtime error: stack overflow
```

通过 `a.tail` 的调用，Rust 试图打印出 `a -> b -> a ···` 的所有内容，但是在不懈的努力后，`main` 线程终于不堪重负，发生了[栈溢出](https://course.rs/pitfalls/stack-overflow.html)。

以上的代码可能并不会造成什么大的问题，但是在一个更加复杂的程序中，类似的问题可能会造成你的程序不断地分配内存、泄漏内存，最终程序会不幸**OOM**，当然这其中的 CPU 损耗也不可小觑。

总之，创建循环引用并不简单，但是也并不是完全遇不到，当你使用 `RefCell<Rc<T>>` 或者类似的类型嵌套组合（具备内部可变性和引用计数）时，就要打起万分精神，前面可能是深渊！

那么问题来了？ 如果我们确实需要实现上面的功能，该怎么办？答案是使用 `Weak`。

## Weak

`Weak` 非常类似于 `Rc`，但是与 `Rc` 持有所有权不同，`Weak` 不持有所有权，它仅仅保存一份指向数据的弱引用：如果你想要访问数据，需要通过 `Weak` 指针的 `upgrade` 方法实现，该方法返回一个类型为 `Option<Rc<T>>` 的值。

看到这个返回，相信大家就懂了：何为弱引用？就是**不保证引用关系依然存在**，如果不存在，就返回一个 `None`！

因为 `Weak` 引用不计入所有权，因此它**无法阻止所引用的内存值被释放掉**，而且 `Weak` 本身不对值的存在性做任何担保，引用的值还存在就返回 `Some`，不存在就返回 `None`。

#### Weak 与 Rc 对比

我们来将 `Weak` 与 `Rc` 进行以下简单对比：

| `Weak`                                          | `Rc`                                      |
| ----------------------------------------------- | ----------------------------------------- |
| 不计数                                          | 引用计数                                  |
| 不拥有所有权                                    | 拥有值的所有权                            |
| 不阻止值被释放(drop)                            | 所有权计数归零，才能 drop                 |
| 引用的值存在返回 `Some`，不存在返回 `None `     | 引用的值必定存在                          |
| 通过 `upgrade` 取到 `Option<Rc<T>>`，然后再取值 | 通过 `Deref` 自动解引用，取值无需任何操作 |

通过这个对比，可以非常清晰的看出 `Weak` 为何这么弱，而这种弱恰恰非常适合我们实现以下的场景：

- 持有一个 `Rc` 对象的临时引用，并且不在乎引用的值是否依然存在
- 阻止 `Rc` 导致的循环引用，因为 `Rc` 的所有权机制，会导致多个 `Rc` 都无法计数归零

使用方式简单总结下：**对于父子引用关系，可以让父节点通过 `Rc` 来引用子节点，然后让子节点通过 `Weak` 来引用父节点**。

#### Weak 总结

因为 `Weak` 本身并不是很好理解，因此我们再来帮大家梳理总结下，然后再通过一个例子，来彻底掌握。

`Weak` 通过 `use std::rc::Weak` 来引入，它具有以下特点:

- 可访问，但没有所有权，不增加引用计数，因此不会影响被引用值的释放回收
- 可由 `Rc<T>` 调用 `downgrade` 方法转换成 `Weak<T>`
- `Weak<T>` 可使用 `upgrade` 方法转换成 `Option<Rc<T>>`，如果资源已经被释放，则 `Option` 的值是 `None`
- 常用于解决循环引用的问题

一个简单的例子：

```rust
use std::rc::Rc;
fn main() {
    // 创建Rc，持有一个值5
    let five = Rc::new(5);

    // 通过Rc，创建一个Weak指针
    let weak_five = Rc::downgrade(&five);

    // Weak引用的资源依然存在，取到值5
    let strong_five: Option<Rc<_>> = weak_five.upgrade();
    assert_eq!(*strong_five.unwrap(), 5);

    // 手动释放资源`five`
    drop(five);

    // Weak引用的资源已不存在，因此返回None
    let strong_five: Option<Rc<_>> = weak_five.upgrade();
    assert_eq!(strong_five, None);
}
```

需要承认的是，使用 `Weak` 让 Rust 本来就堪忧的代码可读性又下降了不少，但是。。。真香，因为可以解决循环引用了。

## 使用 Weak 解决循环引用

理论知识已经足够，现在用两个例子来模拟下真实场景下可能会遇到的循环引用。

#### 工具间的故事

工具间里，每个工具都有其主人，且多个工具可以拥有一个主人；同时一个主人也可以拥有多个工具，在这种场景下，就很容易形成循环引用，好在我们有 `Weak`：

```rust
use std::rc::Rc;
use std::rc::Weak;
use std::cell::RefCell;

// 主人
struct Owner {
    name: String,
    gadgets: RefCell<Vec<Weak<Gadget>>>,
}

// 工具
struct Gadget {
    id: i32,
    owner: Rc<Owner>,
}

fn main() {
    // 创建一个 Owner
    // 需要注意，该 Owner 也拥有多个 `gadgets`
    let gadget_owner : Rc<Owner> = Rc::new(
        Owner {
            name: "Gadget Man".to_string(),
            gadgets: RefCell::new(Vec::new()),
        }
    );

    // 创建工具，同时与主人进行关联：创建两个 gadget，他们分别持有 gadget_owner 的一个引用。
    let gadget1 = Rc::new(Gadget{id: 1, owner: gadget_owner.clone()});
    let gadget2 = Rc::new(Gadget{id: 2, owner: gadget_owner.clone()});

    // 为主人更新它所拥有的工具
    // 因为之前使用了 `Rc`，现在必须要使用 `Weak`，否则就会循环引用
    gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&gadget1));
    gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&gadget2));

    // 遍历 gadget_owner 的 gadgets 字段
    for gadget_opt in gadget_owner.gadgets.borrow().iter() {

        // gadget_opt 是一个 Weak<Gadget> 。 因为 weak 指针不能保证他所引用的对象
        // 仍然存在。所以我们需要显式的调用 upgrade() 来通过其返回值(Option<_>)来判
        // 断其所指向的对象是否存在。
        // 当然，Option 为 None 的时候这个引用原对象就不存在了。
        let gadget = gadget_opt.upgrade().unwrap();
        println!("Gadget {} owned by {}", gadget.id, gadget.owner.name);
    }

    // 在 main 函数的最后，gadget_owner，gadget1 和 gadget2 都被销毁。
    // 具体是，因为这几个结构体之间没有了强引用（`Rc<T>`），所以，当他们销毁的时候。
    // 首先 gadget2 和 gadget1 被销毁。
    // 然后因为 gadget_owner 的引用数量为 0，所以这个对象可以被销毁了。
    // 循环引用问题也就避免了
}
```

#### tree 数据结构

```rust
use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&branch),
            Rc::weak_count(&branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&leaf),
            Rc::weak_count(&leaf),
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );
}

```

这个例子就留给读者自己解读和分析，我们就不画蛇添足了:）

## unsafe 解决循环引用

除了使用 Rust 标准库提供的这些类型，你还可以使用 `unsafe` 里的裸指针来解决这些棘手的问题，但是由于我们还没有讲解 `unsafe`，因此这里就不进行展开，只附上[源码链接](https://github.com/sunface/rust-algos/blob/fbcdccf3e8178a9039329562c0de0fd01a3372fb/src/unsafe/self-ref.md)，挺长的，需要耐心 o_o

虽然 `unsafe` 不安全，但是在各种库的代码中依然很常见用它来实现自引用结构，主要优点如下:

- 性能高，毕竟直接用裸指针操作
- 代码更简单更符合直觉: 对比下 `Option<Rc<RefCell<Node>>>`

## 总结

本文深入讲解了何为循环引用以及如何使用 `Weak` 来解决，同时还结合 `Rc`、`RefCell`、`Weak` 等实现了两个有实战价值的例子，让大家对智能指针的使用更加融会贯通。

至此，智能指针一章即将结束（严格来说还有一个 `Mutex` 放在多线程一章讲解），而 Rust 语言本身的学习之旅也即将结束，后面我们将深入多线程、项目工程、应用实践、性能分析等特色专题，来一睹 Rust 在这些领域的风采。



================================================
FILE: src/advance/circle-self-ref/intro.md
================================================
# 循环引用与自引用

实现一个链表是学习各大编程语言的常用技巧，但是在 Rust 中实现链表意味着····Hell，是的，你没看错，Welcome to hell。

链表在 Rust 中之所以这么难，完全是因为循环引用和自引用的问题引起的，这两个问题可以说综合了 Rust 的很多难点，难出了新高度，因此本书专门开辟一章，分为上下两篇，试图彻底解决这两个老大难。

本章难度较高，但是非常值得深入阅读，它会让你对 Rust 的理解上升到一个新的境界。



================================================
FILE: src/advance/circle-self-ref/self-referential.md
================================================
[Binary file]


================================================
FILE: src/advance/concurrency-with-threads/concurrency-parallelism.md
================================================
[Binary file]


================================================
FILE: src/advance/concurrency-with-threads/intro.md
================================================
# 多线程并发编程

安全和高效的处理并发是 Rust 语言的主要目标之一。随着现代处理器的核心数不断增加，并发和并行已经成为日常编程不可或缺的一部分，甚至于 Go 语言已经将并发简化到一个 `go` 关键字就可以。

可惜的是，在 Rust 中由于语言设计理念、安全、性能的多方面考虑，并没有采用 Go 语言大道至简的方式，而是选择了多线程与 `async/await` 相结合，优点是可控性更强、性能更高，缺点是复杂度并不低，当然这也是系统级语言的应有选择：**使用复杂度换取可控性和性能**。

不过，大家也不用担心，本书的目标就是降低 Rust 使用门槛，这个门槛自然也包括如何在 Rust 中进行异步并发编程，我们将从多线程以及 `async/await` 两个方面去深入浅出地讲解，首先，从本章的多线程开始。

在本章，我们将深入讲解并发和并行的区别以及如何使用多线程进行 Rust 并发编程，那么先来看看何为并行与并发。



================================================
FILE: src/advance/concurrency-with-threads/message-passing.md
================================================
[Binary file]


================================================
FILE: src/advance/concurrency-with-threads/races.md
================================================
# 数据竞争



================================================
FILE: src/advance/concurrency-with-threads/ref-counter-lock.md
================================================
# Rc、Arc、Mutex、Rwlock(todo)

https://oribenshir.github.io/afternoon_rusting//blog/deref-smart-pointer


================================================
FILE: src/advance/concurrency-with-threads/send-sync.md
================================================
# 基于 Send 和 Sync 的线程安全

为何 Rc、RefCell 和裸指针不可以在多线程间使用？如何让裸指针可以在多线程使用？我们一起来探寻下这些问题的答案。

## 无法用于多线程的`Rc`

先来看一段多线程使用`Rc`的代码:

```rust
use std::thread;
use std::rc::Rc;
fn main() {
    let v = Rc::new(5);
    let t = thread::spawn(move || {
        println!("{}",v);
    });

    t.join().unwrap();
}
```

以上代码将`v`的所有权通过`move`转移到子线程中，看似正确实则会报错：

```console
error[E0277]: `Rc<i32>` cannot be sent between threads safely
------ 省略部分报错 --------
    = help: within `[closure@src/main.rs:5:27: 7:6]`, the trait `Send` is not implemented for `Rc<i32>`
```

表面原因是`Rc`无法在线程间安全的转移，实际是编译器给予我们的那句帮助: ```the trait `Send` is not implemented for `Rc<i32>` ```(`Rc<i32>`未实现`Send`特征), 那么此处的`Send`特征又是何方神圣？

## Rc 和 Arc 源码对比

在介绍`Send`特征之前，再来看看`Arc`为何可以在多线程使用，玄机在于两者的源码实现上：

```rust
// Rc源码片段
impl<T: ?Sized> !marker::Send for Rc<T> {}
impl<T: ?Sized> !marker::Sync for Rc<T> {}

// Arc源码片段
unsafe impl<T: ?Sized + Sync + Send> Send for Arc<T> {}
unsafe impl<T: ?Sized + Sync + Send> Sync for Arc<T> {}
```

`!`代表移除特征的相应实现，上面代码中`Rc<T>`的`Send`和`Sync`特征被特地移除了实现，而`Arc<T>`则相反，实现了`Sync + Send`，再结合之前的编译器报错，大概可以明白了：`Send`和`Sync`是在线程间安全使用一个值的关键。

## Send 和 Sync

`Send`和`Sync`是 Rust 安全并发的重中之重，但是实际上它们只是标记特征(marker trait，该特征未定义任何行为，因此非常适合用于标记), 来看看它们的作用：

- 实现`Send`的类型可以在线程间安全的传递其所有权
- 实现`Sync`的类型可以在线程间安全的共享(通过引用)

这里还有一个潜在的依赖：一个类型要在线程间安全的共享的前提是，指向它的引用必须能在线程间传递。因为如果引用都不能被传递，我们就无法在多个线程间使用引用去访问同一个数据了。

由上可知，**若类型 T 的引用`&T`是`Send`，则`T`是`Sync`**。

没有例子的概念讲解都是耍流氓，来看看`RwLock`的实现:

```rust
unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}
```

首先`RwLock`可以在线程间安全的共享，那它肯定是实现了`Sync`，但是我们的关注点不在这里。众所周知，`RwLock`可以并发的读，说明其中的值`T`必定也可以在线程间共享，那`T`必定要实现`Sync`。

果不其然，上述代码中，`T`的特征约束中就有一个`Sync`特征，那问题又来了，`Mutex`是不是相反？再来看看:

```rust
unsafe impl<T: ?Sized + Send> Sync for Mutex<T> {}
```

不出所料，`Mutex<T>`中的`T`并没有`Sync`特征约束。

武学秘籍再好，不见生死也是花拳绣腿。同样的，我们需要通过实战来彻底掌握`Send`和`Sync`，但在实战之前，先来简单看看有哪些类型实现了它们。

## 实现`Send`和`Sync`的类型

在 Rust 中，几乎所有类型都默认实现了`Send`和`Sync`，而且由于这两个特征都是可自动派生的特征(通过`derive`派生)，意味着一个复合类型(例如结构体), 只要它内部的所有成员都实现了`Send`或者`Sync`，那么它就自动实现了`Send`或`Sync`。

正是因为以上规则，Rust 中绝大多数类型都实现了`Send`和`Sync`，除了以下几个(事实上不止这几个，只不过它们比较常见):

- 裸指针两者都没实现，因为它本身就没有任何安全保证
- `UnsafeCell`不是`Sync`，因此`Cell`和`RefCell`也不是
- `Rc`两者都没实现(因为内部的引用计数器不是线程安全的)

当然，如果是自定义的复合类型，那没实现那哥俩的就较为常见了：**只要复合类型中有一个成员不是`Send`或`Sync`，那么该复合类型也就不是`Send`或`Sync`**。

**手动实现 `Send` 和 `Sync` 是不安全的**，通常并不需要手动实现 Send 和 Sync trait，实现者需要使用`unsafe`小心维护并发安全保证。

至此，相关的概念大家已经掌握，但是我敢肯定，对于这两个滑不溜秋的家伙，大家依然会非常模糊，不知道它们该如何使用。那么我们来一起看看如何让裸指针可以在线程间安全的使用。

## 为裸指针实现`Send`

上面我们提到裸指针既没实现`Send`，意味着下面代码会报错:

```rust
use std::thread;
fn main() {
    let p = 5 as *mut u8;
    let t = thread::spawn(move || {
        println!("{:?}",p);
    });

    t.join().unwrap();
}
```

报错跟之前无二： ``` `*mut u8` cannot be sent between threads safely```, 但是有一个问题，我们无法为其直接实现`Send`特征，好在可以用[`newtype`类型](https://course.rs/advance/into-types/custom-type.html#newtype) :`struct MyBox(*mut u8);`。

还记得之前的规则吗：复合类型中有一个成员没实现`Send`，该复合类型就不是`Send`，因此我们需要手动为它实现:

```rust
use std::thread;

#[derive(Debug)]
struct MyBox(*mut u8);
unsafe impl Send for MyBox {}
fn main() {
    let p = MyBox(5 as *mut u8);
    let t = thread::spawn(move || {
        println!("{:?}",p);
    });

    t.join().unwrap();
}
```

此时，我们的指针已经可以欢快的在多线程间撒欢，以上代码很简单，但有一点需要注意：`Send`和`Sync`是`unsafe`特征，实现时需要用`unsafe`代码块包裹。

## 为裸指针实现`Sync`

由于`Sync`是多线程间共享一个值，大家可能会想这么实现：

```rust
use std::thread;
fn main() {
    let v = 5;
    let t = thread::spawn(|| {
        println!("{:?}",&v);
    });

    t.join().unwrap();
}
```

关于这种用法，在多线程章节也提到过，线程如果直接去借用其它线程的变量，会报错:`closure may outlive the current function,`, 原因在于编译器无法确定主线程`main`和子线程`t`谁的生命周期更长，特别是当两个线程都是子线程时，没有任何人知道哪个子线程会先结束，包括编译器！

因此我们得配合`Arc`去使用:

```rust
use std::thread;
use std::sync::Arc;
use std::sync::Mutex;

#[derive(Debug)]
struct MyBox(*const u8);
unsafe impl Send for MyBox {}

fn main() {
    let b = &MyBox(5 as *const u8);
    let v = Arc::new(Mutex::new(b));
    let t = thread::spawn(move || {
        let _v1 =  v.lock().unwrap();
    });

    t.join().unwrap();
}
```

上面代码将智能指针`v`的所有权转移给新线程，同时`v`包含了一个引用类型`b`，当在新的线程中试图获取内部的引用时，会报错：

```console
error[E0277]: `*const u8` cannot be shared between threads safely
--> src/main.rs:25:13
|
25  |     let t = thread::spawn(move || {
|             ^^^^^^^^^^^^^ `*const u8` cannot be shared between threads safely
|
= help: within `MyBox`, the trait `Sync` is not implemented for `*const u8`
```

因为我们访问的引用实际上还是对主线程中的数据的借用，转移进来的仅仅是外层的智能指针引用。要解决很简单，为`MyBox`实现`Sync`:

```rust
unsafe impl Sync for MyBox {}
```

## 总结

通过上面的两个裸指针的例子，我们了解了如何实现`Send`和`Sync`，以及如何只实现`Send`而不实现`Sync`，简单总结下：

1. 实现`Send`的类型可以在线程间安全的传递其所有权, 实现`Sync`的类型可以在线程间安全的共享(通过引用)
2. 绝大部分类型都实现了`Send`和`Sync`，常见的未实现的有：裸指针、`Cell`、`RefCell`、`Rc` 等
3. 可以为自定义类型实现`Send`和`Sync`，但是需要`unsafe`代码块
4. 可以为部分 Rust 中的类型实现`Send`、`Sync`，但是需要使用`newtype`，例如文中的裸指针例子



================================================
FILE: src/advance/concurrency-with-threads/sync1.md
================================================
# 线程同步：锁、Condvar 和信号量

在多线程编程中，同步性极其的重要，当你需要同时访问一个资源、控制不同线程的执行次序时，都需要使用到同步性。

在 Rust 中有多种方式可以实现同步性。在上一节中讲到的消息传递就是同步性的一种实现方式，例如我们可以通过消息传递来控制不同线程间的执行次序。还可以使用共享内存来实现同步性，例如通过锁和原子操作等并发原语来实现多个线程同时且安全地去访问一个资源。

## 该如何选择

共享内存可以说是同步的灵魂，因为消息传递的底层实际上也是通过共享内存来实现，两者的区别如下：

- 共享内存相对消息传递能节省多次内存拷贝的成本
- 共享内存的实现简洁的多
- 共享内存的锁竞争更多

消息传递适用的场景很多，我们下面列出了几个主要的使用场景:

- 需要可靠和简单的(简单不等于简洁)实现时
- 需要模拟现实世界，例如用消息去通知某个目标执行相应的操作时
- 需要一个任务处理流水线(管道)时，等等

而使用共享内存(并发原语)的场景往往就比较简单粗暴：需要简洁的实现以及更高的性能时。

总之，消息传递类似一个单所有权的系统：一个值同时只能有一个所有者，如果另一个线程需要该值的所有权，需要将所有权通过消息传递进行转移。而共享内存类似于一个多所有权的系统：多个线程可以同时访问同一个值。

## 互斥锁 Mutex

既然是共享内存，那并发原语自然是重中之重，先来一起看看皇冠上的明珠: 互斥锁`Mutex`(mutual exclusion 的缩写)。

`Mutex`让多个线程并发的访问同一个值变成了排队访问：同一时间，只允许一个线程`A`访问该值，其它线程需要等待`A`访问完成后才能继续。

#### 单线程中使用 Mutex

先来看看单线程中`Mutex`该如何使用:

```rust
use std::sync::Mutex;

fn main() {
    // 使用`Mutex`结构体的关联函数创建新的互斥锁实例
    let m = Mutex::new(5);

    {
        // 获取锁，然后deref为`m`的引用
        // lock返回的是Result
        let mut num = m.lock().unwrap();
        *num = 6;
        // 锁自动被drop
    }

    println!("m = {:?}", m);
}
```

在注释中，已经大致描述了代码的功能，不过有一点需要注意：和`Box`类似，数据被`Mutex`所拥有，要访问内部的数据，需要使用方法`m.lock()`向`m`申请一个锁, 该方法会**阻塞当前线程，直到获取到锁**，因此当多个线程同时访问该数据时，只有一个线程能获取到锁，其它线程只能阻塞着等待，这样就保证了数据能被安全的修改！

**`m.lock()`方法也有可能报错**，例如当前正在持有锁的线程`panic`了。在这种情况下，其它线程不可能再获得锁，因此`lock`方法会返回一个错误。

这里你可能奇怪，`m.lock`明明返回一个锁，怎么就变成我们的`num`数值了？聪明的读者可能会想到智能指针，没错，因为`Mutex<T>`是一个智能指针，准确的说是`m.lock()`返回一个智能指针`MutexGuard<T>`:

- 它实现了`Deref`特征，会被自动解引用后获得一个引用类型，该引用指向`Mutex`内部的数据
- 它还实现了`Drop`特征，在超出作用域后，自动释放锁，以便其它线程能继续获取锁

正因为智能指针的使用，使得我们无需任何操作就能获取其中的数据。 如果释放锁，你需要做的仅仅是做好锁的作用域管理，例如上述代码的内部花括号使用，建议读者尝试下去掉内部的花括号，然后再次尝试获取第二个锁`num1`，看看会发生什么，友情提示：不会报错，但是主线程会永远阻塞，因为不幸发生了死锁。

```rust
use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    let mut num = m.lock().unwrap();
    *num = 6;
    // 锁还没有被 drop 就尝试申请下一个锁，导致主线程阻塞
    // drop(num); // 手动 drop num ，可以让 num1 申请到下个锁
    let mut num1 = m.lock().unwrap();
    *num1 = 7;
    // drop(num1); // 手动 drop num1 ，观察打印结果的不同

    println!("m = {:?}", m);
}
```

#### 多线程中使用 Mutex

单线程中使用锁，说实话纯粹是为了演示功能，毕竟多线程才是锁的舞台。 现在，我们再来看看，如何在多线程下使用`Mutex`来访问同一个资源.

##### 无法运行的`Rc<T>`

```rust
use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    // 通过`Rc`实现`Mutex`的多所有权
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&counter);
        // 创建子线程，并将`Mutex`的所有权拷贝传入到子线程中
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    // 等待所有子线程完成
    for handle in handles {
        handle.join().unwrap();
    }

    // 输出最终的计数结果
    println!("Result: {}", *counter.lock().unwrap());
}
```

由于子线程需要通过`move`拿走锁的所有权，因此我们需要使用多所有权来保证每个线程都拿到数据的独立所有权，恰好智能指针[`Rc<T>`](https://course.rs/advance/smart-pointer/rc-arc.html)可以做到(**上面代码会报错**！具体往下看，别跳过-, -)。

以上代码实现了在多线程中计数的功能，由于多个线程都需要去修改该计数器，因此我们需要使用锁来保证同一时间只有一个线程可以修改计数器，否则会导致脏数据：想象一下 A 线程和 B 线程同时拿到计数器，获取了当前值`1`, 并且同时对其进行了修改，最后值变成`2`，你会不会在风中凌乱？毕竟正确的值是`3`，因为两个线程各自加 1。

可能有人会说，有那么巧的事情吗？事实上，对于人类来说，因为干啥啥慢，并没有那么多巧合，所以人总会存在巧合心理。但是对于计算机而言，每秒可以轻松运行上亿次，在这种频次下，一切巧合几乎都将必然发生，因此千万不要有任何侥幸心理。

> 如果事情有变坏的可能，不管这种可能性有多小，它都会发生！ - 在计算机领域歪打正着的墨菲定律

事实上，上面的代码会报错:

```console
error[E0277]: `Rc<Mutex<i32>>` cannot be sent between threads safely
                // `Rc`无法在线程中安全的传输
   --> src/main.rs:11:22
    |
13  |           let handle = thread::spawn(move || {
    |  ______________________^^^^^^^^^^^^^_-
    | |                      |
    | |                      `Rc<Mutex<i32>>` cannot be sent between threads safely
14  | |             let mut num = counter.lock().unwrap();
15  | |
16  | |             *num += 1;
17  | |         });
    | |_________- within this `[closure@src/main.rs:11:36: 15:10]`
    |
    = help: within `[closure@src/main.rs:11:36: 15:10]`, the trait `Send` is not implemented for `Rc<Mutex<i32>>`
     // `Rc`没有实现`Send`特征
    = note: required because it appears within the type `[closure@src/main.rs:11:36: 15:10]`
```

错误中提到了一个关键点：`Rc<T>`无法在线程中传输，因为它没有实现`Send`特征(在下一节将详细介绍)，而该特征可以确保数据在线程中安全的传输。

##### 多线程安全的 `Arc<T>`

好在，我们有`Arc<T>`，得益于它的[内部计数器](https://course.rs/advance/smart-pointer/rc-arc.html#多线程无力的rc)是多线程安全的，因此可以在多线程环境中使用:

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

以上代码可以顺利运行:

```console
Result: 10
```

#### 内部可变性

在之前章节，我们提到过[内部可变性](https://course.rs/advance/smart-pointer/cell-refcell.html#内部可变性)，其中`Rc<T>`和`RefCell<T>`的结合，可以实现单线程的内部可变性。

现在我们又有了新的武器，由于`Mutex<T>`可以支持修改内部数据，当结合`Arc<T>`一起使用时，可以实现多线程的内部可变性。

简单总结下：`Rc<T>/RefCell<T>`用于单线程内部可变性， `Arc<T>/Mutex<T>`用于多线程内部可变性。

#### 需要小心使用的 Mutex

如果有其它语言的编程经验，就知道互斥锁这家伙不好对付，想要正确使用，你得牢记在心：

- 在使用数据前必须先获取锁
- 在数据使用完成后，必须**及时**的释放锁，比如文章开头的例子，使用内部语句块的目的就是为了及时的释放锁

这两点看起来不起眼，但要正确的使用，其实是相当不简单的，对于其它语言，忘记释放锁是经常发生的，虽然 Rust 通过智能指针的`drop`机制帮助我们避免了这一点，但是由于不及时释放锁导致的性能问题也是常见的。

正因为这种困难性，导致很多用户都热衷于使用消息传递的方式来实现同步，例如 Go 语言直接把`channel`内置在语言特性中，甚至还有无锁的语言，例如`erlang`，完全使用`Actor`模型，依赖消息传递来完成共享和同步。幸好 Rust 的类型系统、所有权机制、智能指针等可以很好的帮助我们减轻使用锁时的负担。

另一个值的注意的是在使用`Mutex<T>`时，Rust 无法帮我们避免所有的逻辑错误，例如在之前章节，我们提到过使用`Rc<T>`可能会导致[循环引用的问题](https://course.rs/advance/circle-self-ref/circle-reference.html)。类似的，`Mutex<T>`也存在使用上的风险，例如创建死锁(deadlock)：当一个操作试图锁住两个资源，然后两个线程各自获取其中一个锁，并试图获取另一个锁时，就会造成死锁。

## 死锁

在 Rust 中有多种方式可以创建死锁，了解这些方式有助于你提前规避可能的风险，一起来看看。

#### 单线程死锁

这种死锁比较容易规避，但是当代码复杂后还是有可能遇到：

```rust
use std::sync::Mutex;

fn main() {
    let data = Mutex::new(0);
    let d1 = data.lock();
    let d2 = data.lock();
} // d1锁在此处释放
```

非常简单，只要你在另一个锁还未被释放时去申请新的锁，就会触发，当代码复杂后，这种情况可能就没有那么显眼。

#### 多线程死锁

当我们拥有两个锁，且两个线程各自使用了其中一个锁，然后试图去访问另一个锁时，就可能发生死锁：

```rust
use std::{sync::{Mutex, MutexGuard}, thread};
use std::thread::sleep;
use std::time::Duration;

use lazy_static::lazy_static;
lazy_static! {
    static ref MUTEX1: Mutex<i64> = Mutex::new(0);
    static ref MUTEX2: Mutex<i64> = Mutex::new(0);
}

fn main() {
    // 存放子线程的句柄
    let mut children = vec![];
    for i_thread in 0..2 {
        children.push(thread::spawn(move || {
            for _ in 0..1 {
                // 线程1
                if i_thread % 2 == 0 {
                    // 锁住MUTEX1
                    let guard: MutexGuard<i64> = MUTEX1.lock().unwrap();

                    println!("线程 {} 锁住了MUTEX1，接着准备去锁MUTEX2 !", i_thread);

                    // 当前线程睡眠一小会儿，等待线程2锁住MUTEX2
                    sleep(Duration::from_millis(10));

                    // 去锁MUTEX2
                    let guard = MUTEX2.lock().unwrap();
                // 线程2
                } else {
                    // 锁住MUTEX2
                    let _guard = MUTEX2.lock().unwrap();

                    println!("线程 {} 锁住了MUTEX2, 准备去锁MUTEX1", i_thread);

                    let _guard = MUTEX1.lock().unwrap();
                }
            }
        }));
    }

    // 等子线程完成
    for child in children {
        let _ = child.join();
    }

    println!("死锁没有发生");
}
```

在上面的描述中，我们用了"可能"二字，原因在于死锁在这段代码中不是必然发生的，总有一次运行你能看到最后一行打印输出。这是由于子线程的初始化顺序和执行速度并不确定，我们无法确定哪个线程中的锁先被执行，因此也无法确定两个线程对锁的具体使用顺序。

但是，可以简单的说明下死锁发生的必然条件：线程 1 锁住了`MUTEX1`并且线程`2`锁住了`MUTEX2`，然后线程 1 试图去访问`MUTEX2`，同时线程`2`试图去访问`MUTEX1`，就会死锁。 因为线程 2 需要等待线程 1 释放`MUTEX1`后，才会释放`MUTEX2`，而与此同时，线程 1 需要等待线程 2 释放`MUTEX2`后才能释放`MUTEX1`，这种情况造成了两个线程都无法释放对方需要的锁，最终死锁。

那么为何某些时候，死锁不会发生？原因很简单，线程 2 在线程 1 锁`MUTEX1`之前，就已经全部执行完了，随之线程 2 的`MUTEX2`和`MUTEX1`被全部释放，线程 1 对锁的获取将不再有竞争者。 同理，线程 1 若全部被执行完，那线程 2 也不会被锁，因此我们在线程 1 中间加一个睡眠，增加死锁发生的概率。如果你在线程 2 中同样的位置也增加一个睡眠，那死锁将必然发生!

#### try_lock

与`lock`方法不同，`try_lock`会**尝试**去获取一次锁，如果无法获取会返回一个错误，因此**不会发生阻塞**:

```rust
use std::{sync::{Mutex, MutexGuard}, thread};
use std::thread::sleep;
use std::time::Duration;

use lazy_static::lazy_static;
lazy_static! {
    static ref MUTEX1: Mutex<i64> = Mutex::new(0);
    static ref MUTEX2: Mutex<i64> = Mutex::new(0);
}

fn main() {
    // 存放子线程的句柄
    let mut children = vec![];
    for i_thread in 0..2 {
        children.push(thread::spawn(move || {
            for _ in 0..1 {
                // 线程1
                if i_thread % 2 == 0 {
                    // 锁住MUTEX1
                    let guard: MutexGuard<i64> = MUTEX1.lock().unwrap();

                    println!("线程 {} 锁住了MUTEX1，接着准备去锁MUTEX2 !", i_thread);

                    // 当前线程睡眠一小会儿，等待线程2锁住MUTEX2
                    sleep(Duration::from_millis(10));

                    // 去锁MUTEX2
                    let guard = MUTEX2.try_lock();
                    println!("线程 {} 获取 MUTEX2 锁的结果: {:?}", i_thread, guard);
                // 线程2
                } else {
                    // 锁住MUTEX2
                    let _guard = MUTEX2.lock().unwrap();

                    println!("线程 {} 锁住了MUTEX2, 准备去锁MUTEX1", i_thread);
                    sleep(Duration::from_millis(10));
                    let guard = MUTEX1.try_lock();
                    println!("线程 {} 获取 MUTEX1 锁的结果: {:?}", i_thread, guard);
                }
            }
        }));
    }

    // 等子线程完成
    for child in children {
        let _ = child.join();
    }

    println!("死锁没有发生");
}
```

为了演示`try_lock`的作用，我们特定使用了之前必定会死锁的代码，并且将`lock`替换成`try_lock`，与之前的结果不同，这段代码将不会再有死锁发生：

```console
线程 0 锁住了MUTEX1，接着准备去锁MUTEX2 !
线程 1 锁住了MUTEX2, 准备去锁MUTEX1
线程 1 获取 MUTEX1 锁的结果: Err("WouldBlock")
线程 0 获取 MUTEX2 锁的结果: Ok(0)
死锁没有发生
```

如上所示，当`try_lock`失败时，会报出一个错误:`Err("WouldBlock")`，接着线程中的剩余代码会继续执行，不会被阻塞。

> 一个有趣的命名规则：在 Rust 标准库中，使用`try_xxx`都会尝试进行一次操作，如果无法完成，就立即返回，不会发生阻塞。例如消息传递章节中的`try_recv`以及本章节中的`try_lock`

## 读写锁 RwLock

`Mutex`会对每次读写都进行加锁，但某些时候，我们需要大量的并发读，`Mutex`就无法满足需求了，此时就可以使用`RwLock`:

```rust
use std::sync::RwLock;

fn main() {
    let lock = RwLock::new(5);

    // 同一时间允许多个读
    {
        let r1 = lock.read().unwrap();
        let r2 = lock.read().unwrap();
        assert_eq!(*r1, 5);
        assert_eq!(*r2, 5);
    } // 读锁在此处被drop

    // 同一时间只允许一个写
    {
        let mut w = lock.write().unwrap();
        *w += 1;
        assert_eq!(*w, 6);

        // 以下代码会阻塞发生死锁，因为读和写不允许同时存在
        // 写锁w直到该语句块结束才被释放，因此下面的读锁依然处于`w`的作用域中
        // let r1 = lock.read();
        // println!("{:?}",r1);
    }// 写锁在此处被drop
}
```

`RwLock`在使用上和`Mutex`区别不大，只有在多个读的情况下不阻塞程序，其他如读写、写读、写写情况下均会对后获取锁的操作进行阻塞。

我们也可以使用`try_write`和`try_read`来尝试进行一次写/读，若失败则返回错误:

```console
Err("WouldBlock")
```

简单总结下`RwLock`:

1. 同时允许多个读，但最多只能有一个写
2. 读和写不能同时存在
3. 读可以使用`read`、`try_read`，写`write`、`try_write`, 在实际项目中，`try_xxx`会安全的多

## Mutex 还是 RwLock

首先简单性上`Mutex`完胜，因为使用`RwLock`你得操心几个问题：

- 读和写不能同时发生，如果使用`try_xxx`解决，就必须做大量的错误处理和失败重试机制
- 当读多写少时，写操作可能会因为一直无法获得锁导致连续多次失败([writer starvation](https://stackoverflow.com/questions/2190090/how-to-prevent-writer-starvation-in-a-read-write-lock-in-pthreads))
- RwLock 其实是操作系统提供的，实现原理要比`Mutex`复杂的多，因此单就锁的性能而言，比不上原生实现的`Mutex`

再来简单总结下两者的使用场景：

- 追求高并发读取时，使用`RwLock`，因为`Mutex`一次只允许一个线程去读取
- 如果要保证写操作的成功性，使用`Mutex`
- 不知道哪个合适，统一使用`Mutex`

需要注意的是，`RwLock`虽然看上去貌似提供了高并发读取的能力，但这个不能说明它的性能比`Mutex`高，事实上`Mutex`性能要好不少，后者**唯一的问题也仅仅在于不能并发读取**。

一个常见的、错误的使用`RwLock`的场景就是使用`HashMap`进行简单读写，因为`HashMap`的读和写都非常快，`RwLock`的复杂实现和相对低的性能反而会导致整体性能的降低，因此一般来说更适合使用`Mutex`。

总之，如果你要使用`RwLock`要确保满足以下两个条件：**并发读，且需要对读到的资源进行"长时间"的操作**，`HashMap`也许满足了并发读的需求，但是往往并不能满足后者："长时间"的操作。

> benchmark 永远是你在迷茫时最好的朋友！

## 三方库提供的锁实现

标准库在设计时总会存在取舍，因为往往性能并不是最好的，如果你追求性能，可以使用三方库提供的并发原语:

- [parking_lot](https://crates.io/crates/parking_lot), 功能更完善、稳定，社区较为活跃，star 较多，更新较为活跃
- [spin](https://crates.io/crates/spin), 在多数场景中性能比`parking_lot`高一点，最近没怎么更新

如果不是追求特别极致的性能，建议选择前者。

## 用条件变量(Condvar)控制线程的同步

`Mutex`用于解决资源安全访问的问题，但是我们还需要一个手段来解决资源访问顺序的问题。而 Rust 考虑到了这一点，为我们提供了条件变量(Condition Variables)，它经常和`Mutex`一起使用，可以让线程挂起，直到某个条件发生后再继续执行，其实`Condvar`我们在之前的多线程章节就已经见到过，现在再来看一个不同的例子：

```rust
use std::sync::{Arc,Mutex,Condvar};
use std::thread::{spawn,sleep};
use std::time::Duration;

fn main() {
    let flag = Arc::new(Mutex::new(false));
    let cond = Arc::new(Condvar::new());
    let cflag = flag.clone();
    let ccond = cond.clone();

    let hdl = spawn(move || {
        let mut lock = cflag.lock().unwrap();
        let mut counter = 0;

        while counter < 3 {
            while !*lock {
                // wait方法会接收一个MutexGuard<'a, T>，且它会自动地暂时释放这个锁，使其他线程可以拿到锁并进行数据更新。
                // 同时当前线程在此处会被阻塞，直到被其他地方notify后，它会将原本的MutexGuard<'a, T>还给我们，即重新获取到了锁，同时唤醒了此线程。
                lock = ccond.wait(lock).unwrap();
            }
            
            *lock = false;

            counter += 1;
            println!("inner counter: {}", counter);
        }
    });

    let mut counter = 0;
    loop {
        sleep(Duration::from_millis(1000));
        *flag.lock().unwrap() = true;
        counter += 1;
        if counter > 3 {
            break;
        }
        println!("outside counter: {}", counter);
        cond.notify_one();
    }
    hdl.join().unwrap();
    println!("{:?}", flag);
}
```

例子中通过主线程来触发子线程实现交替打印输出：

```console
outside counter: 1
inner counter: 1
outside counter: 2
inner counter: 2
outside counter: 3
inner counter: 3
Mutex { data: true, poisoned: false, .. }
```

## 信号量 Semaphore

在多线程中，另一个重要的概念就是信号量，使用它可以让我们精准的控制当前正在运行的任务最大数量。想象一下，当一个新游戏刚开服时(有些较火的老游戏也会，比如`wow`)，往往会控制游戏内玩家的同时在线数，一旦超过某个临界值，就开始进行排队进服。而在实际使用中，也有很多时候，我们需要通过信号量来控制最大并发数，防止服务器资源被撑爆。

本来 Rust 在标准库中有提供一个[信号量实现](https://doc.rust-lang.org/1.8.0/std/sync/struct.Semaphore.html), 但是由于各种原因这个库现在已经不再推荐使用了，因此我们推荐使用`tokio`中提供的`Semaphore`实现: [`tokio::sync::Semaphore`](https://github.com/tokio-rs/tokio/blob/master/tokio/src/sync/semaphore.rs)。

```rust
use std::sync::Arc;
use tokio::sync::Semaphore;

#[tokio::main]
async fn main() {
    let semaphore = Arc::new(Semaphore::new(3));
    let mut join_handles = Vec::new();

    for _ in 0..5 {
        let permit = semaphore.clone().acquire_owned().await.unwrap();
        join_handles.push(tokio::spawn(async move {
            //
            // 在这里执行任务...
            //
            drop(permit);
        }));
    }

    for handle in join_handles {
        handle.await.unwrap();
    }
}
```

上面代码创建了一个容量为 3 的信号量，当正在执行的任务超过 3 时，剩下的任务需要等待正在执行任务完成并减少信号量后到 3 以内时，才能继续执行。

这里的关键其实说白了就在于：信号量的申请和归还，使用前需要申请信号量，如果容量满了，就需要等待；使用后需要释放信号量，以便其它等待者可以继续。

## 总结

在很多时候，消息传递都是非常好用的手段，它可以让我们的数据在任务流水线上不断流转，实现起来非常优雅。

但是它并不能优雅的解决所有问题，因为我们面临的真实世界是非常复杂的，无法用某一种银弹统一解决。当面临消息传递不太适用的场景时，或者需要更好的性能和简洁性时，我们往往需要用锁来解决这些问题，因为锁允许多个线程同时访问同一个资源，简单粗暴。

除了锁之外，其实还有一种并发原语可以帮助我们解决并发访问数据的问题，那就是原子类型 Atomic，在下一章节中，我们会对其进行深入讲解。




================================================
FILE: src/advance/concurrency-with-threads/sync2.md
================================================
# 线程同步：Atomic 原子类型与内存顺序

`Mutex`用起来简单，但是无法并发读，`RwLock`可以并发读，但是使用场景较为受限且性能不够，那么有没有一种全能性选手呢？ 欢迎我们的`Atomic`闪亮登场。

从 Rust1.34 版本后，就正式支持原子类型。原子指的是一系列不可被 CPU 上下文交换的机器指令，这些指令组合在一起就形成了原子操作。在多核 CPU 下，当某个 CPU 核心开始运行原子操作时，会先暂停其它 CPU 内核对内存的操作，以保证原子操作不会被其它 CPU 内核所干扰。

由于原子操作是通过指令提供的支持，因此它的性能相比锁和消息传递会好很多。相比较于锁而言，原子类型不需要开发者处理加锁和释放锁的问题，同时支持修改，读取等操作，还具备较高的并发性能，几乎所有的语言都支持原子类型。

可以看出原子类型是无锁类型，但是无锁不代表无需等待，因为原子类型内部使用了`CAS`循环，当大量的冲突发生时，该等待还是得[等待](https://course.rs/advance/concurrency-with-threads/thread.html#多线程的开销)！但是总归比锁要好。

> CAS 全称是 Compare and swap, 它通过一条指令读取指定的内存地址，然后判断其中的值是否等于给定的前置值，如果相等，则将其修改为新的值

## 使用 Atomic 作为全局变量

原子类型的一个常用场景，就是作为全局变量来使用:

```rust
use std::ops::Sub;
use std::sync::atomic::{AtomicU64, Ordering};
use std::thread::{self, JoinHandle};
use std::time::Instant;

const N_TIMES: u64 = 10000000;
const N_THREADS: usize = 10;

static R: AtomicU64 = AtomicU64::new(0);

fn add_n_times(n: u64) -> JoinHandle<()> {
    thread::spawn(move || {
        for _ in 0..n {
            R.fetch_add(1, Ordering::Relaxed);
        }
    })
}

fn main() {
    let s = Instant::now();
    let mut threads = Vec::with_capacity(N_THREADS);

    for _ in 0..N_THREADS {
        threads.push(add_n_times(N_TIMES));
    }

    for thread in threads {
        thread.join().unwrap();
    }

    assert_eq!(N_TIMES * N_THREADS as u64, R.load(Ordering::Relaxed));

    println!("{:?}",Instant::now().sub(s));
}
```

以上代码启动了数个线程，每个线程都在疯狂对全局变量进行加 1 操作, 最后将它与`线程数 * 加1次数`进行比较，如果发生了因为多个线程同时修改导致了脏数据，那么这两个必将不相等。好在，它没有让我们失望，不仅快速的完成了任务，而且保证了 100%的并发安全性。

当然以上代码的功能其实也可以通过`Mutex`来实现，但是后者的强大功能是建立在额外的性能损耗基础上的，因此性能会逊色不少:

```console
Atomic实现：673ms
Mutex实现: 1136ms
```

可以看到`Atomic`实现会比`Mutex`快**41%**，实际上在复杂场景下还能更快(甚至达到 4 倍的性能差距)！

还有一点值得注意: **和`Mutex`一样，`Atomic`的值具有内部可变性**，你无需将其声明为`mut`：

```rust
use std::sync::Mutex;
use std::sync::atomic::{Ordering, AtomicU64};

struct Counter {
    count: u64
}

fn main() {
    let n = Mutex::new(Counter {
        count: 0
    });

    n.lock().unwrap().count += 1;

    let n = AtomicU64::new(0);

    n.fetch_add(0, Ordering::Relaxed);
}
```

这里有一个奇怪的枚举成员`Ordering::Relaxed`, 看上去很像是排序作用，但是我们并没有做排序操作啊？实际上它用于控制原子操作使用的**内存顺序**。

## 内存顺序

内存顺序是指 CPU 在访问内存时的顺序，该顺序可能受以下因素的影响：

- 代码中的先后顺序
- 编译器优化导致在编译阶段发生改变(内存重排序 reordering)
- 运行阶段因 CPU 的缓存机制导致顺序被打乱

#### 编译器优化导致内存顺序的改变

对于第二点，我们举个例子：

```rust
static mut X: u64 = 0;
static mut Y: u64 = 1;

fn main() {
    ...     // A

    unsafe {
        ... // B
        X = 1;
        ... // C
        Y = 3;
        ... // D
        X = 2;
        ... // E
    }
}
```

假如在`C`和`D`代码片段中，根本没有用到`X = 1`，那么编译器很可能会将`X = 1`和`X = 2`进行合并:

```rust
 ...     // A

unsafe {
    ... // B
    X = 2;
    ... // C
    Y = 3;
    ... // D
    ... // E
}
```

若代码`A`中创建了一个新的线程用于读取全局静态变量`X`，则该线程将无法读取到`X = 1`的结果，因为在编译阶段就已经被优化掉。

#### CPU 缓存导致的内存顺序的改变

假设之前的`X = 1`没有被优化掉，并且在代码片段`A`中有一个新的线程:

```console
initial state: X = 0, Y = 1

THREAD Main     THREAD A
X = 1;          if X == 1 {
Y = 3;              Y *= 2;
X = 2;          }
```

我们来讨论下以上线程状态，`Y`最终的可能值(可能性依次降低):

- `Y = 3`: 线程`Main`运行完后才运行线程`A`，或者线程`A`运行完后再运行线程`Main`
- `Y = 6`: 线程`Main`的`Y = 3`运行完，但`X = 2`还没被运行， 此时线程 A 开始运行`Y *= 2`, 最后才运行`Main`线程的`X = 2`
- `Y = 2`: 线程`Main`正在运行`Y = 3`还没结束，此时线程`A`正在运行`Y *= 2`, 因此`Y`取到了值 1，然后`Main`的线程将`Y`设置为 3， 紧接着就被线程`A`的`Y = 2`所覆盖
- `Y = 2`: 上面的还只是一般的数据竞争，这里虽然产生了相同的结果`2`，但是背后的原理大相径庭: 线程`Main`运行完`Y = 3`，但是 CPU 缓存中的`Y = 3`还没有被同步到其它 CPU 缓存中，此时线程`A`中的`Y *= 2`就开始读取`Y`，结果读到了值`1`，最终计算出结果`2`

甚至更改成:

```console
initial state: X = 0, Y = 1

THREAD Main     THREAD A
X = 1;          if X == 2 {
Y = 3;              Y *= 2;
X = 2;          }
```

还是可能出现`Y = 2`，因为`Main`线程中的`X`和`Y`被同步到其它 CPU 缓存中的顺序未必一致。

#### 限定内存顺序的 5 个规则

在理解了内存顺序可能存在的改变后，你就可以明白为什么 Rust 提供了`Ordering::Relaxed`用于限定内存顺序了，事实上，该枚举有 5 个成员:

- **Relaxed**， 这是最宽松的规则，它对编译器和 CPU 不做任何限制，可以乱序
- **Release 释放**，设定内存屏障(Memory barrier)，保证它之前的操作永远在它之前，但是它后面的操作可能被重排到它前面
- **Acquire 获取**, 设定内存屏障，保证在它之后的访问永远在它之后，但是它之前的操作却有可能被重排到它后面，往往和`Release`在不同线程中联合使用
- **AcqRel**, 是 *Acquire* 和 *Release* 的结合，同时拥有它们俩提供的保证。比如你要对一个 `atomic` 自增 1，同时希望该操作之前和之后的读取或写入操作不会被重新排序
- **SeqCst 顺序一致性**， `SeqCst`就像是`AcqRel`的加强版，它不管原子操作是属于读取还是写入的操作，只要某个线程有用到`SeqCst`的原子操作，线程中该`SeqCst`操作前的数据操作绝对不会被重新排在该`SeqCst`操作之后，且该`SeqCst`操作后的数据操作也绝对不会被重新排在`SeqCst`操作前。

这些规则由于是系统提供的，因此其它语言提供的相应规则也大同小异，大家如果不明白可以看看其它语言的相关解释。

#### 内存屏障的例子

下面我们以`Release`和`Acquire`为例，使用它们构筑出一对内存屏障，防止编译器和 CPU 将屏障前(Release)和屏障后(Acquire)中的数据操作重新排在屏障围成的范围之外:

```rust
use std::thread::{self, JoinHandle};
use std::sync::atomic::{Ordering, AtomicBool};

static mut DATA: u64 = 0;
static READY: AtomicBool = AtomicBool::new(false);

fn reset() {
    unsafe {
        DATA = 0;
    }
    READY.store(false, Ordering::Relaxed);
}

fn producer() -> JoinHandle<()> {
    thread::spawn(move || {
        unsafe {
            DATA = 100;                                 // A
        }
        READY.store(true, Ordering::Release);           // B: 内存屏障 ↑
    })
}

fn consumer() -> JoinHandle<()> {
    thread::spawn(move || {
        while !READY.load(Ordering::Acquire) {}         // C: 内存屏障 ↓

        assert_eq!(100, unsafe { DATA });               // D
    })
}


fn main() {
    loop {
        reset();

        let t_producer = producer();
        let t_consumer = consumer();

        t_producer.join().unwrap();
        t_consumer.join().unwrap();
    }
}
```

原则上，`Acquire`用于读取，而`Release`用于写入。但是由于有些原子操作同时拥有读取和写入的功能，此时就需要使用`AcqRel`来设置内存顺序了。在内存屏障中被写入的数据，都可以被其它线程读取到，不会有 CPU 缓存的问题。

**内存顺序的选择**

1. 不知道怎么选择时，优先使用`SeqCst`，虽然会稍微减慢速度，但是慢一点也比出现错误好
2. 多线程只计数`fetch_add`而不使用该值触发其他逻辑分支的简单使用场景，可以使用`Relaxed`  
   参考 [Which std::sync::atomic::Ordering to use?](https://stackoverflow.com/questions/30407121/which-stdsyncatomicordering-to-use)

## 多线程中使用 Atomic

在多线程环境中要使用`Atomic`需要配合`Arc`：

```rust
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::{hint, thread};

fn main() {
    let spinlock = Arc::new(AtomicUsize::new(1));

    let spinlock_clone = Arc::clone(&spinlock);
    let thread = thread::spawn(move|| {
        spinlock_clone.store(0, Ordering::SeqCst);
    });

    // 等待其它线程释放锁
    while spinlock.load(Ordering::SeqCst) != 0 {
        hint::spin_loop();
    }

    if let Err(panic) = thread.join() {
        println!("Thread had an error: {:?}", panic);
    }
}
```

## Atomic 能替代锁吗

那么原子类型既然这么全能，它可以替代锁吗？答案是不行：

- 对于复杂的场景下，锁的使用简单粗暴，不容易有坑
- `std::sync::atomic`包中仅提供了数值类型的原子操作：`AtomicBool`, `AtomicIsize`, `AtomicUsize`, `AtomicI8`, `AtomicU16`等，而锁可以应用于各种类型
- 在有些情况下，必须使用锁来配合，例如上一章节中使用`Mutex`配合`Condvar`

## Atomic 的应用场景

事实上，`Atomic`虽然对于用户不太常用，但是对于高性能库的开发者、标准库开发者都非常常用，它是并发原语的基石，除此之外，还有一些场景适用：

- 无锁(lock free)数据结构
- 全局变量，例如全局自增 ID, 在后续章节会介绍
- 跨线程计数器，例如可以用于统计指标

以上列出的只是`Atomic`适用的部分场景，具体场景需要大家未来根据自己的需求进行权衡选择。



================================================
FILE: src/advance/concurrency-with-threads/thread.md
================================================
# 使用线程

放在十年前，多线程编程可能还是一个少数人才掌握的核心概念，但是在今天，随着编程语言的不断发展，多线程、多协程、Actor 等并发编程方式已经深入人心，同时多线程编程的门槛也在不断降低，本章节我们来看看在 Rust 中该如何使用多线程。

## 多线程编程的风险

由于多线程的代码是同时运行的，因此我们无法保证线程间的执行顺序，这会导致一些问题：

- 竞态条件(race conditions)，多个线程以非一致性的顺序同时访问数据资源
- 死锁(deadlocks)，两个线程都想使用某个资源，但是又都在等待对方释放资源后才能使用，结果最终都无法继续执行
- 一些因为多线程导致的很隐晦的 BUG，难以复现和解决

虽然 Rust 已经通过各种机制减少了上述情况的发生，但是依然无法完全避免上述情况，因此我们在编程时需要格外的小心，同时本书也会列出多线程编程时常见的陷阱，让你提前规避可能的风险。

## 创建线程

使用 `thread::spawn` 可以创建线程：

```rust
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```

有几点值得注意：

- 线程内部的代码使用闭包来执行
- `main` 线程一旦结束，程序就立刻结束，因此需要保持它的存活，直到其它子线程完成自己的任务
- `thread::sleep` 会让当前线程休眠指定的时间，随后其它线程会被调度运行（上一节并发与并行中有简单介绍过），因此就算你的电脑只有一个 CPU 核心，该程序也会表现的如同多 CPU 核心一般，这就是并发！

来看看输出：

```console
hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 4 from the main thread!
hi number 5 from the spawned thread!
```

如果多运行几次，你会发现好像每次输出会不太一样，因为：虽说线程往往是轮流执行的，但是这一点无法被保证！线程调度的方式往往取决于你使用的操作系统。总之，**千万不要依赖线程的执行顺序**。

## 等待子线程的结束

上面的代码你不但可能无法让子线程从 1 顺序打印到 10，而且可能打印的数字会变少，因为主线程会提前结束，导致子线程也随之结束，更过分的是，如果当前系统繁忙，甚至该子线程还没被创建，主线程就已经结束了！

因此我们需要一个方法，让主线程安全、可靠地等所有子线程完成任务后，再 kill self：

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..5 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```

通过调用 `handle.join`，可以让当前线程阻塞，直到它等待的子线程的结束，在上面代码中，由于 `main` 线程会被阻塞，因此它直到子线程结束后才会输出自己的 `1..5`：

```console
hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
```

以上输出清晰的展示了线程阻塞的作用，如果你将 `handle.join` 放置在 `main` 线程中的 `for` 循环后面，那就是另外一个结果：两个线程交替输出。

## 在线程闭包中使用 move

在[闭包](https://course.rs/advance/functional-programing/closure.html#move-和-fn)章节中，有讲过 `move` 关键字在闭包中的使用可以让该闭包拿走环境中某个值的所有权，同样地，你可以使用 `move` 来将所有权从一个线程转移到另外一个线程。

首先，来看看在一个线程中直接使用另一个线程中的数据会如何：

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```

以上代码在子线程的闭包中捕获了环境中的 `v` 变量，来看看结果：

```console
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --> src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!("Here's a vector: {:?}", v);
  |                                           - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --> src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!("Here's a vector: {:?}", v);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
```

其实代码本身并没有什么问题，问题在于 Rust 无法确定新的线程会活多久（多个线程的结束顺序并不是固定的），所以也无法确定新线程所引用的 `v` 是否在使用过程中一直合法：

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {:?}", v);
    });

    drop(v); // oh no!

    handle.join().unwrap();
}
```

大家要记住，线程的启动时间点和结束时间点是不确定的，因此存在一种可能，当主线程执行完， `v` 被释放掉时，新的线程很可能还没有结束甚至还没有被创建成功，此时新线程对 `v` 的引用立刻就不再合法！

好在报错里进行了提示：```to force the closure to take ownership of v (and any other referenced variables), use the `move` keyword```，让我们使用 `move` 关键字拿走 `v` 的所有权即可：

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();

    // 下面代码会报错borrow of moved value: `v`
    // println!("{:?}",v);
}
```

如上所示，很简单的代码，而且 Rust 的所有权机制保证了数据使用上的安全：`v` 的所有权被转移给新的线程后，`main` 线程将无法继续使用：最后一行代码将报错。

## 线程是如何结束的

之前我们提到 `main` 线程是程序的主线程，一旦结束，则程序随之结束，同时各个子线程也将被强行终止。那么有一个问题，如果父线程不是 `main` 线程，那么父线程的结束会导致什么？自生自灭还是被干掉？

在系统编程中，操作系统提供了直接杀死线程的接口，简单粗暴，但是 Rust 并没有提供这样的接口，原因在于，粗暴地终止一个线程可能会导致资源没有释放、状态混乱等不可预期的结果，一向以安全自称的 Rust，自然不会砸自己的饭碗。

那么 Rust 中线程是如何结束的呢？答案很简单：线程的代码执行完，线程就会自动结束。但是如果线程中的代码不会执行完呢？那么情况可以分为两种进行讨论：

- 线程的任务是一个循环 IO 读取，任务流程类似：IO 阻塞，等待读取新的数据 -> 读到数据，处理完成 -> 继续阻塞等待 ··· -> 收到 socket 关闭的信号 -> 结束线程，在此过程中，绝大部分时间线程都处于阻塞的状态，因此虽然看上去是循环，CPU 占用其实很小，也是网络服务中最最常见的模型
- 线程的任务是一个循环，里面没有任何阻塞，包括休眠这种操作也没有，此时 CPU 很不幸的会被跑满，而且你如果没有设置终止条件，该线程将持续跑满一个 CPU 核心，并且不会被终止，直到 `main` 线程的结束

第一情况很常见，我们来模拟看看第二种情况：

```rust
use std::thread;
use std::time::Duration;
fn main() {
    // 创建一个线程A
    let new_thread = thread::spawn(move || {
        // 再创建一个线程B
        thread::spawn(move || {
            loop {
                println!("I am a new thread.");
            }
        })
    });

    // 等待新创建的线程执行完成
    new_thread.join().unwrap();
    println!("Child thread is finish!");

    // 睡眠一段时间，看子线程创建的子线程是否还在运行
    thread::sleep(Duration::from_millis(100));
}
```

以上代码中，`main` 线程创建了一个新的线程 `A`，同时该新线程又创建了一个新的线程 `B`，可以看到 `A` 线程在创建完 `B` 线程后就立即结束了，而 `B` 线程则在不停地循环输出。

从之前的线程结束规则，我们可以猜测程序将这样执行：`A` 线程结束后，由它创建的 `B` 线程仍在疯狂输出，直到 `main` 线程在 100 毫秒后结束。如果你把该时间增加到几十秒，就可以看到你的 CPU 核心 100% 的盛况了-,-

## 多线程的性能

下面我们从多个方面来看看多线程的性能大概是怎么样的。

#### 创建线程的性能

据不精确估算，创建一个线程大概需要 0.24 毫秒，随着线程的变多，这个值会变得更大，因此线程的创建耗时是不可忽略的，只有当真的需要处理一个值得用线程去处理的任务时，才使用线程，一些鸡毛蒜皮的任务，就无需创建线程了。

#### 创建多少线程合适

因为 CPU 的核心数限制，当任务是 CPU 密集型时，就算线程数超过了 CPU 核心数，也并不能帮你获得更好的性能，因为每个线程的任务都可以轻松让 CPU 的某个核心跑满，既然如此，让线程数等于 CPU 核心数是最好的。

但是当你的任务大部分时间都处于阻塞状态时，就可以考虑增多线程数量，这样当某个线程处于阻塞状态时，会被切走，进而运行其它的线程，典型就是网络 IO 操作，我们可以为每一个进来的用户连接创建一个线程去处理，该连接绝大部分时间都是处于 IO 读取阻塞状态，因此有限的 CPU 核心完全可以处理成百上千的用户连接线程，但是事实上，对于这种网络 IO 情况，一般都不再使用多线程的方式了，毕竟操作系统的线程数是有限的，意味着并发数也很容易达到上限，而且过多的线程也会导致线程上下文切换的代价过大，使用 `async/await` 的 `M:N` 并发模型，就没有这个烦恼。

#### 多线程的开销

下面的代码是一个无锁实现(CAS)的 `Hashmap` 在多线程下的使用：

```rust
for i in 0..num_threads {
    let ht = Arc::clone(&ht);

    let handle = thread::spawn(move || {
        for j in 0..adds_per_thread {
            let key = thread_rng().gen::<u32>();
            let value = thread_rng().gen::<u32>();
            ht.set_item(key, value);
        }
    });

    handles.push(handle);
}

for handle in handles {
    handle.join().unwrap();
}
```

按理来说，既然是无锁实现了，那么锁的开销应该几乎没有，性能会随着线程数的增加接近线性增长，但是真的是这样吗？

下图是该代码在 `48` 核机器上的运行结果：

<img alt="" src="https://pic3.zhimg.com/80/v2-af225672de09c0e377023f5f39dd87eb_1440w.png" class="center"  />

从图上可以明显的看出：吞吐并不是线性增长，尤其从 `16` 核开始，甚至开始肉眼可见的下降，这是为什么呢？

限于书本的篇幅有限，我们只能给出大概的原因：

- 虽然是无锁，但是内部是 CAS 实现，大量线程的同时访问，会让 CAS 重试次数大幅增加
- 线程过多时，CPU 缓存的命中率会显著下降，同时多个线程竞争一个 CPU Cache-line 的情况也会经常发生
- 大量读写可能会让内存带宽也成为瓶颈
- 读和写不一样，无锁数据结构的读往往可以很好地线性增长，但是写不行，因为写竞争太大

总之，多线程的开销往往是在锁、数据竞争、缓存失效上，这些限制了现代化软件系统随着 CPU 核心的增多性能也线性增加的野心。

## 线程屏障(Barrier)

在 Rust 中，可以使用 `Barrier` 让多个线程都执行到某个点后，才继续一起往后执行：

```rust
use std::sync::{Arc, Barrier};
use std::thread;

fn main() {
    let mut handles = Vec::with_capacity(6);
    let barrier = Arc::new(Barrier::new(6));

    for _ in 0..6 {
        let b = barrier.clone();
        handles.push(thread::spawn(move|| {
            println!("before wait");
            b.wait();
            println!("after wait");
        }));
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

上面代码，我们在线程打印出 `before wait` 后增加了一个屏障，目的就是等所有的线程都打印出**before wait**后，各个线程再继续执行：

```console
before wait
before wait
before wait
before wait
before wait
before wait
after wait
after wait
after wait
after wait
after wait
after wait
```

## 线程局部变量(Thread Local Variable)

对于多线程编程，线程局部变量在一些场景下非常有用，而 Rust 通过标准库和三方库对此进行了支持。

#### 标准库 thread_local

使用 `thread_local` 宏可以初始化线程局部变量，然后在线程内部使用该变量的 `with` 方法获取变量值：

```rust
use std::cell::RefCell;
use std::thread;

thread_local!(static FOO: RefCell<u32> = RefCell::new(1));

FOO.with(|f| {
    assert_eq!(*f.borrow(), 1);
    *f.borrow_mut() = 2;
});

// 每个线程开始时都会拿到线程局部变量的FOO的初始值
let t = thread::spawn(move|| {
    FOO.with(|f| {
        assert_eq!(*f.borrow(), 1);
        *f.borrow_mut() = 3;
    });
});

// 等待线程完成
t.join().unwrap();

// 尽管子线程中修改为了3，我们在这里依然拥有main线程中的局部值：2
FOO.with(|f| {
    assert_eq!(*f.borrow(), 2);
});
```

上面代码中，`FOO` 即是我们创建的**线程局部变量**，每个新的线程访问它时，都会使用它的初始值作为开始，各个线程中的 `FOO` 值彼此互不干扰。注意 `FOO` 使用 `static` 声明为生命周期为 `'static` 的静态变量。

可以注意到，线程中对 `FOO` 的使用是通过借用的方式，但是若我们需要每个线程独自获取它的拷贝，最后进行汇总，就有些强人所难了。

你还可以在结构体中使用线程局部变量：

```rust
use std::cell::RefCell;

struct Foo;
impl Foo {
    thread_local! {
        static FOO: RefCell<usize> = RefCell::new(0);
    }
}

fn main() {
    Foo::FOO.with(|x| println!("{:?}", x));
}
```

或者通过引用的方式使用它:

```rust
use std::cell::RefCell;
use std::thread::LocalKey;

thread_local! {
    static FOO: RefCell<usize> = RefCell::new(0);
}
struct Bar {
    foo: &'static LocalKey<RefCell<usize>>,
}
impl Bar {
    fn constructor() -> Self {
        Self {
            foo: &FOO,
        }
    }
}
```

#### 三方库 thread-local

除了标准库外，一位大神还开发了 [thread-local](https://github.com/Amanieu/thread_local-rs) 库，它允许每个线程持有值的独立拷贝：

```rust
use thread_local::ThreadLocal;
use std::sync::Arc;
use std::cell::Cell;
use std::thread;

let tls = Arc::new(ThreadLocal::new());
let mut v = vec![];
// 创建多个线程
for _ in 0..5 {
    let tls2 = tls.clone();
    let handle = thread::spawn(move || {
        // 将计数器加1
        // 请注意，由于线程 ID 在线程退出时会被回收，因此一个线程有可能回收另一个线程的对象
        // 这只能在线程退出后发生，因此不会导致任何竞争条件
        let cell = tls2.get_or(|| Cell::new(0));
        cell.set(cell.get() + 1);
    });
    v.push(handle);
}
for handle in v {
    handle.join().unwrap();
}
// 一旦所有子线程结束，收集它们的线程局部变量中的计数器值，然后进行求和
let tls = Arc::try_unwrap(tls).unwrap();
let total = tls.into_iter().fold(0, |x, y| {
    // 打印每个线程局部变量中的计数器值，发现不一定有5个线程，
    // 因为一些线程已退出，并且其他线程会回收退出线程的对象
    println!("x: {}, y: {}", x, y.get());
    x + y.get()
});

// 和为5
assert_eq!(total, 5);
```

该库不仅仅使用了值的拷贝，而且还能自动把多个拷贝汇总到一个迭代器中，最后进行求和，非常好用。

## 用条件控制线程的挂起和执行

条件变量(Condition Variables)经常和 `Mutex` 一起使用，可以让线程挂起，直到某个条件发生后再继续执行：

```rust
use std::thread;
use std::sync::{Arc, Mutex, Condvar};

fn main() {
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair2 = pair.clone();

    thread::spawn(move|| {
        let (lock, cvar) = &*pair2;
        let mut started = lock.lock().unwrap();
        println!("changing started");
        *started = true;
        cvar.notify_one();
    });

    let (lock, cvar) = &*pair;
    let mut started = lock.lock().unwrap();
    while !*started {
        started = cvar.wait(started).unwrap();
    }

    println!("started changed");
}
```

上述代码流程如下：

1. `main` 线程首先进入 `while` 循环，调用 `wait` 方法挂起等待子线程的通知，并释放了锁 `started`
2. 子线程获取到锁，并将其修改为 `true`，然后调用条件变量的 `notify_one` 方法来通知主线程继续执行

## 只被调用一次的函数

有时，我们会需要某个函数在多线程环境下只被调用一次，例如初始化全局变量，无论是哪个线程先调用函数来初始化，都会保证全局变量只会被初始化一次，随后的其它线程调用就会忽略该函数：

```rust
use std::thread;
use std::sync::Once;

static mut VAL: usize = 0;
static INIT: Once = Once::new();

fn main() {
    let handle1 = thread::spawn(move || {
        INIT.call_once(|| {
            unsafe {
                VAL = 1;
            }
        });
    });

    let handle2 = thread::spawn(move || {
        INIT.call_once(|| {
            unsafe {
                VAL = 2;
            }
        });
    });

    handle1.join().unwrap();
    handle2.join().unwrap();

    println!("{}", unsafe { VAL });
}
```

代码运行的结果取决于哪个线程先调用 `INIT.call_once` （虽然代码具有先后顺序，但是线程的初始化顺序并无法被保证！因为线程初始化是异步的，且耗时较久），若 `handle1` 先，则输出 `1`，否则输出 `2`。

**call_once 方法**

执行初始化过程一次，并且只执行一次。

如果当前有另一个初始化过程正在运行，线程将阻止该方法被调用。

当这个函数返回时，保证一些初始化已经运行并完成，它还保证由执行的闭包所执行的任何内存写入都能被其他线程在这时可靠地观察到。

## 总结

[Rust 的线程模型](https://course.rs/advance/concurrency-with-threads/intro.html)是 `1:1` 模型，因为 Rust 要保持尽量小的运行时。

我们可以使用 `thread::spawn` 来创建线程，创建出的多个线程之间并不存在执行顺序关系，因此代码逻辑千万不要依赖于线程间的执行顺序。

`main` 线程若是结束，则所有子线程都将被终止，如果希望等待子线程结束后，再结束 `main` 线程，你需要使用创建线程时返回的句柄的 `join` 方法。

在线程中无法直接借用外部环境中的变量值，因为新线程的启动时间点和结束时间点是不确定的，所以 Rust 无法保证该线程中借用的变量在使用过程中依然是合法的。你可以使用 `move` 关键字将变量的所有权转移给新的线程，来解决此问题。

父线程结束后，子线程仍在持续运行，直到子线程的代码运行完成或者 `main` 线程的结束。



================================================
FILE: src/advance/difficulties/pointer.md
================================================
# 裸指针、引用和智能指针 TODO



================================================
FILE: src/advance/functional-programing/closure.md
================================================
[Binary file]


================================================
FILE: src/advance/functional-programing/intro.md
================================================
[Binary file]


================================================
FILE: src/advance/functional-programing/iterator.md
================================================
# 迭代器 Iterator

如果你询问一个 Rust 资深开发：写 Rust 项目最需要掌握什么？相信迭代器往往就是答案之一。无论你是编程新手亦或是高手，实际上大概率都用过迭代器，虽然自己可能并没有意识到这一点:)

迭代器允许我们迭代一个连续的集合，例如数组、动态数组 `Vec`、`HashMap` 等，在此过程中，只需关心集合中的元素如何处理，而无需关心如何开始、如何结束、按照什么样的索引去访问等问题。

## For 循环与迭代器

从用途来看，迭代器跟 `for` 循环颇为相似，都是去遍历一个集合，但是实际上它们存在不小的差别，其中最主要的差别就是：**是否通过索引来访问集合**。

例如以下的 JS 代码就是一个循环：

```javascript
let arr = [1, 2, 3];
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
```

在上面代码中，我们设置索引的开始点和结束点，然后再通过索引去访问元素 `arr[i]`，这就是典型的循环，来对比下 Rust 中的 `for`：

```rust
let arr = [1, 2, 3];
for v in arr {
    println!("{}",v);
}
```

首先，不得不说这两语法还挺像！与 JS 循环不同，`Rust`中没有使用索引，它把 `arr` 数组当成一个迭代器，直接去遍历其中的元素，从哪里开始，从哪里结束，都无需操心。因此严格来说，Rust 中的 `for` 循环是编译器提供的语法糖，最终还是对迭代器中的元素进行遍历。

那又有同学要发问了，在 Rust 中数组是迭代器吗？因为在之前的代码中直接对数组 `arr` 进行了迭代，答案是 `No`。那既然数组不是迭代器，为啥咱可以对它的元素进行迭代呢？

简而言之就是数组实现了 `IntoIterator` 特征，Rust 通过 `for` 语法糖，自动把实现了该特征的数组类型转换为迭代器（你也可以为自己的集合类型实现此特征），最终让我们可以直接对一个数组进行迭代，类似的还有：

```rust
for i in 1..10 {
    println!("{}", i);
}
```

直接对数值序列进行迭代，也是很常见的使用方式。

`IntoIterator` 特征拥有一个 `into_iter` 方法，因此我们还可以显式的把数组转换成迭代器：

```rust
let arr = [1, 2, 3];
for v in arr.into_iter() {
    println!("{}", v);
}
```

迭代器是函数语言的核心特性，它赋予了 Rust 远超于循环的强大表达能力，我们将在本章中一一为大家进行展现。

## 惰性初始化

在 Rust 中，迭代器是惰性的，意味着如果你不使用它，那么它将不会发生任何事：

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!("{}", val);
}
```

在 `for` 循环之前，我们只是简单的创建了一个迭代器 `v1_iter`，此时不会发生任何迭代行为，只有在 `for` 循环开始后，迭代器才会开始迭代其中的元素，最后打印出来。

这种惰性初始化的方式确保了创建迭代器不会有任何额外的性能损耗，其中的元素也不会被消耗，只有使用到该迭代器的时候，一切才开始。

## next 方法

对于 `for` 如何遍历迭代器，还有一个问题，它如何取出迭代器中的元素？

先来看一个特征：

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // 省略其余有默认实现的方法
}
```

呦，该特征竟然和迭代器 `iterator` 同名，难不成。。。没错，它们就是有一腿。**迭代器之所以成为迭代器，就是因为实现了 `Iterator` 特征**，要实现该特征，最主要的就是实现其中的 `next` 方法，该方法控制如何从集合中取值，最终返回值的类型是[关联类型](https://course.rs/basic/trait/advance-trait#关联类型) `Item`。

因此，之前问题的答案已经很明显：`for` 循环通过不停调用迭代器上的 `next` 方法，来获取迭代器中的元素。

既然 `for` 可以调用 `next` 方法，是不是意味着我们也可以？来试试：

```rust
fn main() {
    let arr = [1, 2, 3];
    let mut arr_iter = arr.into_iter();

    assert_eq!(arr_iter.next(), Some(1));
    assert_eq!(arr_iter.next(), Some(2));
    assert_eq!(arr_iter.next(), Some(3));
    assert_eq!(arr_iter.next(), None);
}
```

果不其然，将 `arr` 转换成迭代器后，通过调用其上的 `next` 方法，我们获取了 `arr` 中的元素，有两点需要注意：

- `next` 方法返回的是 `Option` 类型，当有值时返回 `Some(i32)`，无值时返回 `None`
- 遍历是按照迭代器中元素的排列顺序依次进行的，因此我们严格按照数组中元素的顺序取出了 `Some(1)`，`Some(2)`，`Some(3)`
- 手动迭代必须将迭代器声明为 `mut` 可变，因为调用 `next` 会改变迭代器其中的状态数据（当前遍历的位置等），而 `for` 循环去迭代则无需标注 `mut`，因为它会帮我们自动完成

总之，`next` 方法对**迭代器的遍历是消耗性的**，每次消耗它一个元素，最终迭代器中将没有任何元素，只能返回 `None`。

#### 例子：模拟实现 for 循环

因为 `for` 循环是迭代器的语法糖，因此我们完全可以通过迭代器来模拟实现它：

```rust
let values = vec![1, 2, 3];

{
    let result = match IntoIterator::into_iter(values) {
        mut iter => loop {
            match iter.next() {
                Some(x) => { println!("{}", x); },
                None => break,
            }
        },
    };
    result
}
```

`IntoIterator::into_iter` 是使用[完全限定](https://course.rs/basic/trait/advance-trait.html#完全限定语法)的方式去调用 `into_iter` 方法，这种调用方式跟 `values.into_iter()` 是等价的。

同时我们使用了 `loop` 循环配合 `next` 方法来遍历迭代器中的元素，当迭代器返回 `None` 时，跳出循环。

## IntoIterator 特征

其实有一个细节，由于 `Vec` 动态数组实现了 `IntoIterator` 特征，因此可以通过 `into_iter` 将其转换为迭代器，那如果本身就是一个迭代器，该怎么办？实际上，迭代器自身也实现了 `IntoIterator`，标准库早就帮我们考虑好了：

```rust
impl<I: Iterator> IntoIterator for I {
    type Item = I::Item;
    type IntoIter = I;

    #[inline]
    fn into_iter(self) -> I {
        self
    }
}
```

最终你完全可以写出这样的奇怪代码：

```rust
fn main() {
    let values = vec![1, 2, 3];

    for v in values.into_iter().into_iter().into_iter() {
        println!("{}",v)
    }
}
```

#### into_iter, iter, iter_mut

在之前的代码中，我们统一使用了 `into_iter` 的方式将数组转化为迭代器，除此之外，还有 `iter` 和 `iter_mut`，聪明的读者应该大概能猜到这三者的区别：

- `into_iter` 会夺走所有权
- `iter` 是借用
- `iter_mut` 是可变借用

其实如果以后见多识广了，你会发现这种问题一眼就能看穿，`into_` 之类的，都是拿走所有权，`_mut` 之类的都是可变借用，剩下的就是不可变借用。

使用一段代码来解释下：

```rust
fn main() {
    let values = vec![1, 2, 3];

    for v in values.into_iter() {
        println!("{}", v)
    }

    // 下面的代码将报错，因为 values 的所有权在上面 `for` 循环中已经被转移走
    // println!("{:?}",values);

    let values = vec![1, 2, 3];
    let _values_iter = values.iter();

    // 不会报错，因为 values_iter 只是借用了 values 中的元素
    println!("{:?}", values);

    let mut values = vec![1, 2, 3];
    // 对 values 中的元素进行可变借用
    let mut values_iter_mut = values.iter_mut();

    // 取出第一个元素，并修改为0
    if let Some(v) = values_iter_mut.next() {
        *v = 0;
    }

    // 输出[0, 2, 3]
    println!("{:?}", values);
}
```

具体解释在代码注释中，就不再赘述，不过有两点需要注意的是：

- `.iter()` 方法实现的迭代器，调用 `next` 方法返回的类型是 `Some(&T)`
- `.iter_mut()` 方法实现的迭代器，调用 `next` 方法返回的类型是 `Some(&mut T)`，因此在 `if let Some(v) = values_iter_mut.next()` 中，`v` 的类型是 `&mut i32`，最终我们可以通过 `*v = 0` 的方式修改其值

#### Iterator 和 IntoIterator 的区别

这两个其实还蛮容易搞混的，但我们只需要记住，`Iterator` 就是迭代器特征，只有实现了它才能称为迭代器，才能调用 `next`。

而 `IntoIterator` 强调的是某一个类型如果实现了该特征，它可以通过 `into_iter`，`iter` 等方法变成一个迭代器。

## 消费者与适配器

消费者是迭代器上的方法，它会消费掉迭代器中的元素，然后返回其类型的值，这些消费者都有一个共同的特点：在它们的定义中，都依赖 `next` 方法来消费元素，因此这也是为什么迭代器要实现 `Iterator` 特征，而该特征必须要实现 `next` 方法的原因。

#### 消费者适配器

只要迭代器上的某个方法 `A` 在其内部调用了 `next` 方法，那么 `A` 就被称为**消费者适配器**：因为 `next` 方法会消耗掉迭代器上的元素，所以方法 `A` 的调用也会消耗掉迭代器上的元素。

其中一个例子是 `sum` 方法，它会拿走迭代器的所有权，然后通过不断调用 `next` 方法对里面的元素进行求和：

```rust
fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);

    // v1_iter 是借用了 v1，因此 v1 可以照常使用
    println!("{:?}",v1);

    // 以下代码会报错，因为 `sum` 拿到了迭代器 `v1_iter` 的所有权
    // println!("{:?}",v1_iter);
}
```

如代码注释中所说明的：在使用 `sum` 方法后，我们将无法再使用 `v1_iter`，因为 `sum` 拿走了该迭代器的所有权：

```rust
fn sum<S>(self) -> S
    where
        Self: Sized,
        S: Sum<Self::Item>,
    {
        Sum::sum(self)
    }

```

从 `sum` 源码中也可以清晰看出，`self` 类型的方法参数拿走了所有权。

#### 迭代器适配器

既然消费者适配器是消费掉迭代器，然后返回一个值。那么迭代器适配器，顾名思义，会返回一个新的迭代器，这是实现链式方法调用的关键：`v.iter().map().filter()...`。

与消费者适配器不同，迭代器适配器是惰性的，意味着你**需要一个消费者适配器来收尾，最终将迭代器转换成一个具体的值**：

```rust
let v1: Vec<i32> = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
```

运行后输出:

```console
warning: unused `Map` that must be used
 --> src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed // 迭代器 map 是惰性的，这里不产生任何效果
```

如上述中文注释所说，这里的 `map` 方法是一个迭代者适配器，它是惰性的，不产生任何行为，因此我们还需要一个消费者适配器进行收尾：

```rust
let v1: Vec<i32> = vec![1, 2, 3];

let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
```

#### collect

上面代码中，使用了 `collect` 方法，该方法就是一个消费者适配器，使用它可以将一个迭代器中的元素收集到指定类型中，这里我们为 `v2` 标注了 `Vec<_>` 类型，就是为了告诉 `collect`：请把迭代器中的元素消费掉，然后把值收集成 `Vec<_>` 类型，至于为何使用 `_`，因为编译器会帮我们自动推导。

为何 `collect` 在消费时要指定类型？是因为该方法其实很强大，可以收集成多种不同的集合类型，`Vec<T>` 仅仅是其中之一，因此我们必须显式的告诉编译器我们想要收集成的集合类型。

还有一点值得注意，`map` 会对迭代器中的每一个值进行一系列操作，然后把该值转换成另外一个新值，该操作是通过闭包 `|x| x + 1` 来完成：最终迭代器中的每个值都增加了 `1`，从 `[1, 2, 3]` 变为 `[2, 3, 4]`。

再来看看如何使用 `collect` 收集成 `HashMap` 集合：

```rust
use std::collections::HashMap;
fn main() {
    let names = ["sunface", "sunfei"];
    let ages = [18, 18];
    let folks: HashMap<_, _> = names.into_iter().zip(ages.into_iter()).collect();

    println!("{:?}",folks);
}
```

`zip` 是一个迭代器适配器，它的作用就是将两个迭代器的内容压缩到一起，形成 `Iterator<Item=(ValueFromA, ValueFromB)>` 这样的新的迭代器，在此处就是形如 `[(name1, age1), (name2, age2)]` 的迭代器。

然后再通过 `collect` 将新迭代器中`(K, V)` 形式的值收集成 `HashMap<K, V>`，同样的，这里必须显式声明类型，然后 `HashMap` 内部的 `KV` 类型可以交给编译器去推导，最终编译器会推导出 `HashMap<&str, i32>`，完全正确！

#### 闭包作为适配器参数

之前的 `map` 方法中，我们使用闭包来作为迭代器适配器的参数，它最大的好处不仅在于可以就地实现迭代器中元素的处理，还在于可以捕获环境值：

```rust
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}
```

`filter` 是迭代器适配器，用于对迭代器中的每个值进行过滤。 它使用闭包作为参数，该闭包的参数 `s` 是来自迭代器中的值，然后使用 `s` 跟外部环境中的 `shoe_size` 进行比较，若相等，则在迭代器中保留 `s` 值，若不相等，则从迭代器中剔除 `s` 值，最终通过 `collect` 收集为 `Vec<Shoe>` 类型。

## 实现 Iterator 特征

之前的内容我们一直基于数组来创建迭代器，实际上，不仅仅是数组，基于其它集合类型一样可以创建迭代器，例如 `HashMap`。 你也可以创建自己的迭代器 —— 只要为自定义类型实现 `Iterator` 特征即可。

首先，创建一个计数器：

```rust
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}
```

我们为计数器 `Counter` 实现了一个关联函数 `new`，用于创建新的计数器实例。下面我们继续为计数器实现 `Iterator` 特征：

```rust
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.count < 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}
```

首先，将该特征的关联类型设置为 `u32`，由于我们的计数器保存的 `count` 字段就是 `u32` 类型， 因此在 `next` 方法中，最后返回的是实际上是 `Option<u32>` 类型。

每次调用 `next` 方法，都会让计数器的值加一，然后返回最新的计数值，一旦计数大于 5，就返回 `None`。

最后，使用我们新建的 `Counter` 进行迭代：

```rust
 let mut counter = Counter::new();

assert_eq!(counter.next(), Some(1));
assert_eq!(counter.next(), Some(2));
assert_eq!(counter.next(), Some(3));
assert_eq!(counter.next(), Some(4));
assert_eq!(counter.next(), Some(5));
assert_eq!(counter.next(), None);
```

#### 实现 Iterator 特征的其它方法

可以看出，实现自己的迭代器非常简单，但是 `Iterator` 特征中，不仅仅是只有 `next` 一个方法，那为什么我们只需要实现它呢？因为其它方法都具有[默认实现](https://course.rs/basic/trait/trait.html#默认实现)，所以无需像 `next` 这样手动去实现，而且这些默认实现的方法其实都是基于 `next` 方法实现的。

下面的代码演示了部分方法的使用：

```rust
let sum: u32 = Counter::new()
    .zip(Counter::new().skip(1))
    .map(|(a, b)| a * b)
    .filter(|x| x % 3 == 0)
    .sum();
assert_eq!(18, sum);
```

其中 `zip`，`map`，`filter` 是迭代器适配器：

- `zip` 把两个迭代器合并成一个迭代器，新迭代器中，每个元素都是一个元组，由之前两个迭代器的元素组成。例如将**形如** `[1, 2, 3, 4, 5]` 和 `[2, 3, 4, 5]` 的迭代器合并后，新的迭代器形如 `[(1, 2),(2, 3),(3, 4),(4, 5)]`
- `map` 是将迭代器中的值经过映射后，转换成新的值`[2, 6, 12, 20]`
- `filter` 对迭代器中的元素进行过滤，若闭包返回 `true` 则保留元素，反之剔除。过滤后的迭代器形如`[6, 12]`

而 `sum` 是消费者适配器，对迭代器中的所有元素求和，最终返回一个 `u32` 值 `18`。

##### enumerate

在之前的流程控制章节，针对 `for` 循环，我们提供了一种方法可以获取迭代时的索引：

```rust
let v = vec![1u64, 2, 3, 4, 5, 6];
for (i,v) in v.iter().enumerate() {
    println!("第{}个值是{}",i,v)
}
```

相信当时，很多读者还是很迷茫的，不知道为什么要这么复杂才能获取到索引，学习本章节后，相信你有了全新的理解，首先 `v.iter()` 创建迭代器，其次
调用 `Iterator` 特征上的方法 `enumerate`，该方法产生一个新的迭代器，其中每个元素均是元组 `(索引，值)`。

因为 `enumerate` 是迭代器适配器，因此我们可以对它返回的迭代器调用其它 `Iterator` 特征方法：

```rust
let v = vec![1u64, 2, 3, 4, 5, 6];
let val = v.iter()
    .enumerate()
    // 每两个元素剔除一个
    // [1, 3, 5]
    .filter(|&(idx, _)| idx % 2 == 0)
    .map(|(_, val)| val)
    // 累加 1+3+5 = 9
    .fold(0u64, |sum, acm| sum + acm);

println!("{}", val);
```

## 迭代器的性能

前面提到，要完成集合遍历，既可以使用 `for` 循环也可以使用迭代器，那么二者之间该怎么选择呢，性能有多大差距呢？

理论分析不会有结果，直接测试最为靠谱：

```rust
#![feature(test)]

extern crate rand;
extern crate test;

fn sum_for(x: &[f64]) -> f64 {
    let mut result: f64 = 0.0;
    for i in 0..x.len() {
        result += x[i];
    }
    result
}

fn sum_iter(x: &[f64]) -> f64 {
    x.iter().sum::<f64>()
}

#[cfg(test)]
mod bench {
    use test::Bencher;
    use rand::{Rng,thread_rng};
    use super::*;

    const LEN: usize = 1024*1024;

    fn rand_array(cnt: u32) -> Vec<f64> {
        let mut rng = thread_rng();
        (0..cnt).map(|_| rng.gen::<f64>()).collect()
    }

    #[bench]
    fn bench_for(b: &mut Bencher) {
        let samples = rand_array(LEN as u32);
        b.iter(|| {
            sum_for(&samples)
        })
    }

    #[bench]
    fn bench_iter(b: &mut Bencher) {
        let samples = rand_array(LEN as u32);
        b.iter(|| {
            sum_iter(&samples)
        })
    }
}
```

上面的代码对比了 `for` 循环和迭代器 `iterator` 完成同样的求和任务的性能对比，可以看到迭代器还要更快一点。

```console
test bench::bench_for  ... bench:     998,331 ns/iter (+/- 36,250)
test bench::bench_iter ... bench:     983,858 ns/iter (+/- 44,673)
```

迭代器是 Rust 的 **零成本抽象**（zero-cost abstractions）之一，意味着抽象并不会引入运行时开销，这与 `Bjarne Stroustrup`（C++ 的设计和实现者）在 `Foundations of C++（2012）` 中所定义的 **零开销**（zero-overhead）如出一辙：

> In general, C++ implementations obey the zero-overhead principle: What you don’t use, you don’t pay for.
> And further: What you do use, you couldn’t hand code any better.
>
> 一般来说，C++的实现遵循零开销原则：没有使用时，你不必为其买单。
> 更进一步说，需要使用时，你也无法写出更优的代码了。
> （翻译一下：用就完事了）

总之，迭代器是 Rust 受函数式语言启发而提供的高级语言特性，可以写出更加简洁、逻辑清晰的代码。编译器还可以通过循环展开（Unrolling）、向量化、消除边界检查等优化手段，使得迭代器和 `for` 循环都有极为高效的执行效率。

所以请放心大胆的使用迭代器，在获得更高的表达力的同时，也不会导致运行时的损失，何乐而不为呢！

## 学习其它方法

迭代器用的好不好，就在于你是否掌握了它的常用方法，且能活学活用，因此多多看看[标准库](https://doc.rust-lang.org/std/iter/trait.Iterator.html)是有好处的，只有知道有什么方法，在需要的时候你才能知道该用什么，就和算法学习一样。

同时，本书在后续章节还提供了对迭代器常用方法的[深入讲解](https://course.rs/std/iterator)，方便大家学习和查阅。



================================================
FILE: src/advance/into-types/converse.md
================================================
# 类型转换


Rust 是类型安全的语言，因此在 Rust 中做类型转换不是一件简单的事，这一章节我们将对 Rust 中的类型转换进行详尽讲解。

> 高能预警：本章节有些难，可以考虑学了进阶后回头再看

## `as`转换

先来看一段代码：

```rust
fn main() {
  let a: i32 = 10;
  let b: u16 = 100;

  if a < b {
    println!("Ten is less than one hundred.");
  }
}
```

能跟着这本书一直学习到这里，说明你对 Rust 已经有了一定的理解，那么一眼就能看出这段代码注定会报错，因为 `a` 和 `b` 拥有不同的类型，Rust 不允许两种不同的类型进行比较。

解决办法很简单，只要把 `b` 转换成 `i32` 类型即可，Rust 中内置了一些基本类型之间的转换，这里使用 `as` 操作符来完成： `if a < (b as i32) {...}`。那么为什么不把 `a` 转换成 `u16` 类型呢？

因为每个类型能表达的数据范围不同，如果把范围较大的类型转换成较小的类型，会造成错误，因此我们需要把范围较小的类型转换成较大的类型，来避免这些问题的发生。

> 使用类型转换需要小心，因为如果执行以下操作 `300_i32 as i8`，你将获得 `44` 这个值，而不是 `300`，因为 `i8` 类型能表达的的最大值为 `2^7 - 1`，使用以下代码可以查看 `i8` 的最大值：

```rust
let a = i8::MAX;
println!("{}",a);
```

下面列出了常用的转换形式：

```rust
fn main() {
   let a = 3.1 as i8;
   let b = 100_i8 as i32;
   let c = 'a' as u8; // 将字符'a'转换为整数，97

   println!("{},{},{}",a,b,c)
}
```

#### 内存地址转换为指针

```rust
let mut values: [i32; 2] = [1, 2];
let p1: *mut i32 = values.as_mut_ptr();
let first_address = p1 as usize; // 将p1内存地址转换为一个整数
let second_address = first_address + 4; // 4 == std::mem::size_of::<i32>()，i32类型占用4个字节，因此将内存地址 + 4
let p2 = second_address as *mut i32; // 访问该地址指向的下一个整数p2
unsafe {
    *p2 += 1;
}
assert_eq!(values[1], 3);
```

#### 强制类型转换的边角知识

1. 转换不具有传递性
   就算 `e as U1 as U2` 是合法的，也不能说明 `e as U2` 是合法的（`e` 不能直接转换成 `U2`）。

## TryInto 转换

在一些场景中，使用 `as` 关键字会有比较大的限制。如果你想要在类型转换上拥有完全的控制而不依赖内置的转换，例如处理转换错误，那么可以使用 `TryInto` ：

```rust
use std::convert::TryInto;

fn main() {
   let a: u8 = 10;
   let b: u16 = 1500;

   let b_: u8 = b.try_into().unwrap();

   if a < b_ {
     println!("Ten is less than one hundred.");
   }
}
```

上面代码中引入了 `std::convert::TryInto` 特征，但是却没有使用它，可能有些同学会为此困惑，主要原因在于**如果你要使用一个特征的方法，那么你需要引入该特征到当前的作用域中**，我们在上面用到了 `try_into` 方法，因此需要引入对应的特征。但是 Rust 又提供了一个非常便利的办法，把最常用的标准库中的特征通过[`std::prelude`](https://course.rs/appendix/prelude.html)模块提前引入到当前作用域中，其中包括了 `std::convert::TryInto`，你可以尝试删除第一行的代码 `use ...`，看看是否会报错。

`try_into` 会尝试进行一次转换，并返回一个 `Result`，此时就可以对其进行相应的错误处理。由于我们的例子只是为了快速测试，因此使用了 `unwrap` 方法，该方法在发现错误时，会直接调用 `panic` 导致程序的崩溃退出，在实际项目中，请不要这么使用，具体见[panic](https://course.rs/basic/result-error/panic.html#调用-panic)部分。

最主要的是 `try_into` 转换会捕获大类型向小类型转换时导致的溢出错误：

```rust
fn main() {
    let b: i16 = 1500;

    let b_: u8 = match b.try_into() {
        Ok(b1) => b1,
        Err(e) => {
            println!("{:?}", e.to_string());
            0
        }
    };
}
```

运行后输出如下 `"out of range integral type conversion attempted"`，在这里我们程序捕获了错误，编译器告诉我们类型范围超出的转换是不被允许的，因为我们试图把 `1500_i16` 转换为 `u8` 类型，后者明显不足以承载这么大的值。

## 通用类型转换

虽然 `as` 和 `TryInto` 很强大，但是只能应用在数值类型上，可是 Rust 有如此多的类型，想要为这些类型实现转换，我们需要另谋出路，先来看看在一个笨办法，将一个结构体转换为另外一个结构体：

```rust
struct Foo {
    x: u32,
    y: u16,
}

struct Bar {
    a: u32,
    b: u16,
}

fn reinterpret(foo: Foo) -> Bar {
    let Foo { x, y } = foo;
    Bar { a: x, b: y }
}
```

简单粗暴，但是从另外一个角度来看，也挺啰嗦的，好在 Rust 为我们提供了更通用的方式来完成这个目的。

#### 强制类型转换

在某些情况下，类型是可以进行隐式强制转换的，虽然这些转换弱化了 Rust 的类型系统，但是它们的存在是为了让 Rust 在大多数场景可以工作(说白了，帮助用户省事)，而不是报各种类型上的编译错误。

首先，在匹配特征时，不会做任何强制转换(除了方法)。一个类型 `T` 可以强制转换为 `U`，不代表 `impl T` 可以强制转换为 `impl U`，例如下面的代码就无法通过编译检查：

```rust
trait Trait {}

fn foo<X: Trait>(t: X) {}

impl<'a> Trait for &'a i32 {}

fn main() {
    let t: &mut i32 = &mut 0;
    foo(t);
}
```

报错如下：

```console
error[E0277]: the trait bound `&mut i32: Trait` is not satisfied
--> src/main.rs:9:9
|
9 |     foo(t);
|         ^ the trait `Trait` is not implemented for `&mut i32`
|
= help: the following implementations were found:
        <&'a i32 as Trait>
= note: `Trait` is implemented for `&i32`, but not for `&mut i32`
```

`&i32` 实现了特征 `Trait`， `&mut i32` 可以转换为 `&i32`，但是 `&mut i32` 依然无法作为 `Trait` 来使用。<!-- 这一段没读懂，代码中的例子好像和上面的文字描述关系不大 -->

#### 点操作符

方法调用的点操作符看起来简单，实际上非常不简单，它在调用时，会发生很多魔法般的类型转换，例如：自动引用、自动解引用，强制类型转换直到类型能匹配等。

假设有一个方法 `foo`，它有一个接收器(接收器就是 `self`、`&self`、`&mut self` 参数)。如果调用 `value.foo()`，编译器在调用 `foo` 之前，需要决定到底使用哪个 `Self` 类型来调用。现在假设 `value` 拥有类型 `T`。

再进一步，我们使用[完全限定语法](https://course.rs/basic/trait/advance-trait.html#完全限定语法)来进行准确的函数调用:

1. 首先，编译器检查它是否可以直接调用 `T::foo(value)`，称之为**值方法调用**
2. 如果上一步调用无法完成(例如方法类型错误或者特征没有针对 `Self` 进行实现，上文提到过特征不能进行强制转换)，那么编译器会尝试增加自动引用，例如会尝试以下调用： `<&T>::foo(value)` 和 `<&mut T>::foo(value)`，称之为**引用方法调用**
3. 若上面两个方法依然不工作，编译器会试着解引用 `T` ，然后再进行尝试。这里使用了 `Deref` 特征 —— 若 `T: Deref<Target = U>` (`T` 可以被解引用为 `U`)，那么编译器会使用 `U` 类型进行尝试，称之为**解引用方法调用**
4. 若 `T` 不能被解引用，且 `T` 是一个定长类型(在编译期类型长度是已知的)，那么编译器也会尝试将 `T` 从定长类型转为不定长类型，例如将 `[i32; 2]` 转为 `[i32]`
5. 若还是不行，那...没有那了，最后编译器大喊一声：汝欺我甚，不干了！

下面我们来用一个例子来解释上面的方法查找算法:

```rust
let array: Rc<Box<[T; 3]>> = ...;
let first_entry = array[0];
```

`array` 数组的底层数据隐藏在了重重封锁之后，那么编译器如何使用 `array[0]` 这种数组原生访问语法通过重重封锁，准确的访问到数组中的第一个元素？

1. 首先， `array[0]` 只是[`Index`](https://doc.rust-lang.org/std/ops/trait.Index.html)特征的语法糖：编译器会将 `array[0]` 转换为 `array.index(0)` 调用，当然在调用之前，编译器会先检查 `array` 是否实现了 `Index` 特征。
2. 接着，编译器检查 `Rc<Box<[T; 3]>>` 是否有实现 `Index` 特征，结果是否，不仅如此，`&Rc<Box<[T; 3]>>` 与 `&mut Rc<Box<[T; 3]>>` 也没有实现。
3. 上面的都不能工作，编译器开始对 `Rc<Box<[T; 3]>>` 进行解引用，把它转变成 `Box<[T; 3]>`
4. 此时继续对 `Box<[T; 3]>` 进行上面的操作 ：`Box<[T; 3]>`， `&Box<[T; 3]>`，和 `&mut Box<[T; 3]>` 都没有实现 `Index` 特征，所以编译器开始对 `Box<[T; 3]>` 进行解引用，然后我们得到了 `[T; 3]`
5. `[T; 3]` 以及它的各种引用都没有实现 `Index` 索引(是不是很反直觉:D，在直觉中，数组都可以通过索引访问，实际上只有数组切片才可以!)，它也不能再进行解引用，因此编译器只能祭出最后的大杀器：将定长转为不定长，因此 `[T; 3]` 被转换成 `[T]`，也就是数组切片，它实现了 `Index` 特征，因此最终我们可以通过 `index` 方法访问到对应的元素。

过程看起来很复杂，但是也还好，挺好理解，如果你现在不能彻底理解，也不要紧，等以后对 Rust 理解更深了，同时需要深入理解类型转换时，再来细细品读本章。

再来看看以下更复杂的例子：

```rust
fn do_stuff<T: Clone>(value: &T) {
    let cloned = value.clone();
}
```

上面例子中 `cloned` 的类型是什么？首先编译器检查能不能进行**值方法调用**， `value` 的类型是 `&T`，同时 `clone` 方法的签名也是 `&T` ： `fn clone(&T) -> T`，因此可以进行值方法调用，再加上编译器知道了 `T` 实现了 `Clone`，因此 `cloned` 的类型是 `T`。

如果 `T: Clone` 的特征约束被移除呢？

```rust
fn do_stuff<T>(value: &T) {
    let cloned = value.clone();
}
```

首先，从直觉上来说，该方法会报错，因为 `T` 没有实现 `Clone` 特征，但是真实情况是什么呢？

我们先来推导一番。 首先通过值方法调用就不再可行，因为 `T` 没有实现 `Clone` 特征，也就无法调用 `T` 的 `clone` 方法。接着编译器尝试**引用方法调用**，此时 `T` 变成 `&T`，在这种情况下， `clone` 方法的签名如下： `fn clone(&&T) -> &T`，接着我们现在对 `value` 进行了引用。 编译器发现 `&T` 实现了 `Clone` 类型(所有的引用类型都可以被复制，因为其实就是复制一份地址)，因此可以推出 `cloned` 也是 `&T` 类型。

最终，我们复制出一份引用指针，这很合理，因为值类型 `T` 没有实现 `Clone`，只能去复制一个指针了。

下面的例子也是自动引用生效的地方：

```rust
#[derive(Clone)]
struct Container<T>(Arc<T>);

fn clone_containers<T>(foo: &Container<i32>, bar: &Container<T>) {
    let foo_cloned = foo.clone();
    let bar_cloned = bar.clone();
}
```

推断下上面的 `foo_cloned` 和 `bar_cloned` 是什么类型？提示: 关键在 `Container` 的泛型参数，一个是 `i32` 的具体类型，一个是泛型类型，其中 `i32` 实现了 `Clone`，但是 `T` 并没有。

首先要复习一下复杂类型派生 `Clone` 的规则：一个复杂类型能否派生 `Clone`，需要它内部的所有子类型都能进行 `Clone`。因此 `Container<T>(Arc<T>)` 是否实现 `Clone` 的关键在于 `T` 类型是否实现了 `Clone` 特征。

上面代码中，`Container<i32>` 实现了 `Clone` 特征，因此编译器可以直接进行值方法调用，此时相当于直接调用 `foo.clone`，其中 `clone` 的函数签名是 `fn clone(&T) -> T`，由此可以看出 `foo_cloned` 的类型是 `Container<i32>`。

然而，`bar_cloned` 的类型却是 `&Container<T>`，这个不合理啊，明明我们为 `Container<T>` 派生了 `Clone` 特征，因此它也应该是 `Container<T>` 类型才对。万事皆有因，我们先来看下 `derive` 宏最终生成的代码大概是啥样的：

```rust
impl<T> Clone for Container<T> where T: Clone {
    fn clone(&self) -> Self {
        Self(Arc::clone(&self.0))
    }
}
```

从上面代码可以看出，派生 `Clone` 能实现的根本是 `T` 实现了[`Clone`特征](https://doc.rust-lang.org/std/clone/trait.Clone.html#derivable)：`where T: Clone`， 因此 `Container<T>` 就没有实现 `Clone` 特征。

编译器接着会去尝试引用方法调用，此时 `&Container<T>` 引用实现了 `Clone`，最终可以得出 `bar_cloned` 的类型是 `&Container<T>`。

当然，也可以为 `Container<T>` 手动实现 `Clone` 特征：

```rust
impl<T> Clone for Container<T> {
    fn clone(&self) -> Self {
        Self(Arc::clone(&self.0))
    }
}
```

此时，编译器首次尝试值方法调用即可通过，因此 `bar_cloned` 的类型变成 `Container<T>`。

这一块儿内容真的挺复杂，每一个坚持看完的读者都是真正的勇士，我也是：为了写好这块儿内容，作者足足花了 **4** 个小时！

#### 变形记(Transmutes)

前方危险，敬请绕行！

类型系统，你让开！我要自己转换这些类型，不成功便成仁！虽然本书大多是关于安全的内容，我还是希望你能仔细考虑避免使用本章讲到的内容。这是你在 Rust 中所能做到的真真正正、彻彻底底、最最可怕的非安全行为，在这里，所有的保护机制都形同虚设。

先让你看看深渊长什么样，开开眼，然后你再决定是否深入： `mem::transmute<T, U>` 将类型 `T` 直接转成类型 `U`，唯一的要求就是，这两个类型占用同样大小的字节数！我的天，这也算限制？这简直就是无底线的转换好吧？看看会导致什么问题：

1. 首先也是最重要的，转换后创建一个任意类型的实例会造成无法想象的混乱，而且根本无法预测。不要把 `3` 转换成 `bool` 类型，就算你根本不会去使用该 `bool` 类型，也不要去这样转换
2. 变形后会有一个重载的返回类型，即使你没有指定返回类型，为了满足类型推导的需求，依然会产生千奇百怪的类型
3. 将 `&` 变形为 `&mut` 是未定义的行为
   - 这种转换永远都是未定义的
   - 不，你不能这么做
   - 不要多想，你没有那种幸运
4. 变形为一个未指定生命周期的引用会导致[无界生命周期](https://course.rs/advance/lifetime/advance.html)
5. 在复合类型之间互相变换时，你需要保证它们的排列布局是一模一样的！一旦不一样，那么字段就会得到不可预期的值，这也是未定义的行为，至于你会不会因此愤怒， **WHO CARES** ，你都用了变形了，老兄！

对于第 5 条，你该如何知道内存的排列布局是一样的呢？对于 `repr(C)` 类型和 `repr(transparent)` 类型来说，它们的布局是有着精确定义的。但是对于你自己的"普通却自信"的 Rust 类型 `repr(Rust)` 来说，它可不是有着精确定义的。甚至同一个泛型类型的不同实例都可以有不同的内存布局。 `Vec<i32>` 和 `Vec<u32>` 它们的字段可能有着相同的顺序，也可能没有。对于数据排列布局来说，**什么能保证，什么不能保证**目前还在 Rust 开发组的[工作任务](https://rust-lang.github.io/unsafe-code-guidelines/layout.html)中呢。

你以为你之前凝视的是深渊吗？不，你凝视的只是深渊的大门。 `mem::transmute_copy<T, U>` 才是真正的深渊，它比之前的还要更加危险和不安全。它从 `T` 类型中拷贝出 `U` 类型所需的字节数，然后转换成 `U`。 `mem::transmute` 尚有大小检查，能保证两个数据的内存大小一致，现在这哥们干脆连这个也丢了，只不过 `U` 的尺寸若是比 `T` 大，会是一个未定义行为。

当然，你也可以通过裸指针转换和 `unions` (todo!)获得所有的这些功能，但是你将无法获得任何编译提示或者检查。裸指针转换和 `unions` 也不是魔法，无法逃避上面说的规则。

`transmute` 虽然危险，但作为一本工具书，知识当然要全面，下面列举两个有用的 `transmute` 应用场景 :)。

- 将裸指针变成函数指针：

```rust
fn foo() -> i32 {
    0
}

let pointer = foo as *const ();
let function = unsafe { 
    // 将裸指针转换为函数指针
    std::mem::transmute::<*const (), fn() -> i32>(pointer) 
};
assert_eq!(function(), 0);
```

- 延长生命周期，或者缩短一个静态生命周期寿命：

```rust
struct R<'a>(&'a i32);

// 将 'b 生命周期延长至 'static 生命周期
unsafe fn extend_lifetime<'b>(r: R<'b>) -> R<'static> {
    std::mem::transmute::<R<'b>, R<'static>>(r)
}

// 将 'static 生命周期缩短至 'c 生命周期
unsafe fn shorten_invariant_lifetime<'b, 'c>(r: &'b mut R<'static>) -> &'b mut R<'c> {
    std::mem::transmute::<&'b mut R<'static>, &'b mut R<'c>>(r)
}
```

以上例子非常先进！但是是非常不安全的 Rust 行为！

## 课后练习
> Rust By Practice，支持代码在线编辑和运行，并提供详细的习题解答。
> - [as](https://practice-zh.course.rs/type-conversions/as.html)
>    - [习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/type-conversions/as.md)
> - [From/Into](https://practice-zh.course.rs/type-conversions/from-into.html)
>    - [习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/type-conversions/from-into.md)
> - [其它转换](https://practice-zh.course.rs/type-conversions/others.html)
>    - [习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/type-conversions/others.md)


================================================
FILE: src/advance/into-types/custom-type.md
================================================
[Binary file]


================================================
FILE: src/advance/into-types/enum-int.md
================================================
# 整数转换为枚举

在 Rust 中，从枚举到整数的转换很容易，但是反过来，就没那么容易，甚至部分实现还挺邪恶, 例如使用`transmute`。

## 一个真实场景的需求

在实际场景中，从整数到枚举的转换有时还是非常需要的，例如你有一个枚举类型，然后需要从外面传入一个整数，用于控制后续的流程走向，此时就需要用整数去匹配相应的枚举(你也可以用整数匹配整数-, -，看看会不会被喷)。

既然有了需求，剩下的就是看看该如何实现，这篇文章的水远比你想象的要深，且看八仙过海各显神通。

## C 语言的实现

对于 C 语言来说，万物皆邪恶，因此我们不讨论安全，只看实现，不得不说很简洁：

```C
#include <stdio.h>

enum atomic_number {
    HYDROGEN = 1,
    HELIUM = 2,
    // ...
    IRON = 26,
};

int main(void)
{
    enum atomic_number element = 26;

    if (element == IRON) {
        printf("Beware of Rust!\n");
    }

    return 0;
}
```

但是在 Rust 中，以下代码：

```rust
enum MyEnum {
    A = 1,
    B,
    C,
}

fn main() {
    // 将枚举转换成整数，顺利通过
    let x = MyEnum::C as i32;

    // 将整数转换为枚举，失败
    match x {
        MyEnum::A => {}
        MyEnum::B => {}
        MyEnum::C => {}
        _ => {}
    }
}
```

就会报错: `MyEnum::A => {} mismatched types, expected i32, found enum MyEnum`。

## 使用三方库

首先可以想到的肯定是三方库，毕竟 Rust 的生态目前已经发展的很不错，类似的需求总是有的，这里我们先使用`num-traits`和`num-derive`来试试。

在`Cargo.toml`中引入：

```toml
[dependencies]
num-traits = "0.2.14"
num-derive = "0.3.3"
```

代码如下:

```rust
use num_derive::FromPrimitive;
use num_traits::FromPrimitive;

#[derive(FromPrimitive)]
enum MyEnum {
    A = 1,
    B,
    C,
}

fn main() {
    let x = 2;

    match FromPrimitive::from_i32(x) {
        Some(MyEnum::A) => println!("Got A"),
        Some(MyEnum::B) => println!("Got B"),
        Some(MyEnum::C) => println!("Got C"),
        None            => println!("Couldn't convert {}", x),
    }
}
```

除了上面的库，还可以使用一个较新的库: [`num_enums`](https://github.com/illicitonion/num_enum)。

## TryFrom + 宏

在 Rust 1.34 后，可以实现`TryFrom`特征来做转换:

```rust
use std::convert::TryFrom;

impl TryFrom<i32> for MyEnum {
    type Error = ();

    fn try_from(v: i32) -> Result<Self, Self::Error> {
        match v {
            x if x == MyEnum::A as i32 => Ok(MyEnum::A),
            x if x == MyEnum::B as i32 => Ok(MyEnum::B),
            x if x == MyEnum::C as i32 => Ok(MyEnum::C),
            _ => Err(()),
        }
    }
}
```

以上代码定义了从`i32`到`MyEnum`的转换，接着就可以使用`TryInto`来实现转换：

```rust
use std::convert::TryInto;

fn main() {
    let x = MyEnum::C as i32;

    match x.try_into() {
        Ok(MyEnum::A) => println!("a"),
        Ok(MyEnum::B) => println!("b"),
        Ok(MyEnum::C) => println!("c"),
        Err(_) => eprintln!("unknown number"),
    }
}
```

但是上面的代码有个问题，你需要为每个枚举成员都实现一个转换分支，非常麻烦。好在可以使用宏来简化，自动根据枚举的定义来实现`TryFrom`特征:

```rust
#[macro_export]
macro_rules! back_to_enum {
    ($(#[$meta:meta])* $vis:vis enum $name:ident {
        $($(#[$vmeta:meta])* $vname:ident $(= $val:expr)?,)*
    }) => {
        $(#[$meta])*
        $vis enum $name {
            $($(#[$vmeta])* $vname $(= $val)?,)*
        }

        impl std::convert::TryFrom<i32> for $name {
            type Error = ();

            fn try_from(v: i32) -> Result<Self, Self::Error> {
                match v {
                    $(x if x == $name::$vname as i32 => Ok($name::$vname),)*
                    _ => Err(()),
                }
            }
        }
    }
}

back_to_enum! {
    enum MyEnum {
        A = 1,
        B,
        C,
    }
}
```

## 邪恶之王 std::mem::transmute

**这个方法原则上并不推荐，但是有其存在的意义，如果要使用，你需要清晰的知道自己为什么使用**。

在之前的类型转换章节，我们提到过非常邪恶的[`transmute`转换](https://course.rs/advance/into-types/converse.html#变形记transmutes)，其实，当你知道数值一定不会超过枚举的范围时(例如枚举成员对应 1，2，3，传入的整数也在这个范围内)，就可以使用这个方法完成变形。

> 最好使用#[repr(..)]来控制底层类型的大小，免得本来需要 i32，结果传入 i64，最终内存无法对齐，产生奇怪的结果

```rust
#[repr(i32)]
enum MyEnum {
    A = 1, B, C
}

fn main() {
    let x = MyEnum::C;
    let y = x as i32;
    let z: MyEnum = unsafe { std::mem::transmute(y) };

    // match the enum that came from an int
    match z {
        MyEnum::A => { println!("Found A"); }
        MyEnum::B => { println!("Found B"); }
        MyEnum::C => { println!("Found C"); }
    }
}
```

既然是邪恶之王，当然得有真本事，无需标准库、也无需 unstable 的 Rust 版本，我们就完成了转换！awesome!??

## 总结

本文列举了常用(其实差不多也是全部了，还有一个 unstable 特性没提到)的从整数转换为枚举的方式，推荐度按照出现的先后顺序递减。

但是推荐度最低，不代表它就没有出场的机会，只要使用边界清晰，一样可以大放光彩，例如最后的`transmute`函数.




================================================
FILE: src/advance/into-types/intro.md
================================================
# 深入类型

Rust 是强类型语言，同时也是强安全语言，这些特性导致了 Rust 的类型注定比一般语言要更深入也更困难。

本章将深入讲解一些进阶的 Rust 类型以及类型转换，希望大家喜欢。




================================================
FILE: src/advance/into-types/sized.md
================================================
[Binary file]


================================================
FILE: src/advance/lifetime/advance.md
================================================
[Binary file]


================================================
FILE: src/advance/lifetime/intro.md
================================================
# 生命周期

何为高阶？一个字：难，二个字：很难，七个字：其实也没那么难。至于到底难不难，还是交给各位看官评判吧 :D 

大家都知道，生命周期在 Rust 中是最难的部分之一，因此相关内容被分成了两个章节：基础和进阶，其中基础部分已经在之前学习过，下面一起来看看真正的`难`字怎么写。





================================================
FILE: src/advance/lifetime/misconceptions.md
================================================
# 一些关于生命周期的误解

https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md


================================================
FILE: src/advance/lifetime/static.md
================================================
# &'static 和 T: 'static

Rust 的难点之一就在于它有不少容易混淆的概念，例如 `&str` 、`str` 与 `String`， 再比如本文标题那两位。不过与字符串也有不同，这两位对于普通用户来说往往是无需进行区分的，但是当大家想要深入学习或使用 Rust 时，它们就会成为成功路上的拦路虎了。

与生命周期的其它章节不同，本文短小精悍，阅读过程可谓相当轻松愉快，话不多说，let's go。

`'static` 在 Rust 中是相当常见的，例如字符串字面值就具有 `'static` 生命周期:

```rust
fn main() {
  let mark_twain: &str = "Samuel Clemens";
  print_author(mark_twain);
}
fn print_author(author: &'static str) {
  println!("{}", author);
}
```

除此之外，特征对象的生命周期也是 `'static`，例如[这里](https://course.rs/compiler/fight-with-compiler/lifetime/closure-with-static.html#特征对象的生命周期)所提到的。

除了 `&'static` 的用法外，我们在另外一种场景中也可以见到 `'static` 的使用:

```rust
use std::fmt::Display;
fn main() {
    let mark_twain = "Samuel Clemens";
    print(&mark_twain);
}

fn print<T: Display + 'static>(message: &T) {
    println!("{}", message);
}
```

在这里，很明显 `'static` 是作为生命周期约束来使用了。 **那么问题来了， `&'static` 和 `T: 'static` 的用法到底有何区别？**

## `&'static`

`&'static` 对于生命周期有着非常强的要求：一个引用必须要活得跟剩下的程序一样久，才能被标注为 `&'static`。

对于字符串字面量来说，它直接被打包到二进制文件中，永远不会被 `drop`，因此它能跟程序活得一样久，自然它的生命周期是 `'static`。

但是，**`&'static` 生命周期针对的仅仅是引用，而不是持有该引用的变量，对于变量来说，还是要遵循相应的作用域规则** :

```rust
use std::{slice::from_raw_parts, str::from_utf8_unchecked};

fn get_memory_location() -> (usize, usize) {
  // “Hello World” 是字符串字面量，因此它的生命周期是 `'static`.
  // 但持有它的变量 `string` 的生命周期就不一样了，它完全取决于变量作用域，对于该例子来说，也就是当前的函数范围
  let string = "Hello World!";
  let pointer = string.as_ptr() as usize;
  let length = string.len();
  (pointer, length)
  // `string` 在这里被 drop 释放
  // 虽然变量被释放，无法再被访问，但是数据依然还会继续存活
}

fn get_str_at_location(pointer: usize, length: usize) -> &'static str {
  // 使用裸指针需要 `unsafe{}` 语句块
  unsafe { from_utf8_unchecked(from_raw_parts(pointer as *const u8, length)) }
}

fn main() {
  let (pointer, length) = get_memory_location();
  let message = get_str_at_location(pointer, length);
  println!(
    "The {} bytes at 0x{:X} stored: {}",
    length, pointer, message
  );
  // 如果大家想知道为何处理裸指针需要 `unsafe`，可以试着反注释以下代码
  // let message = get_str_at_location(1000, 10);
}
```

上面代码有两点值得注意：

- `&'static` 的引用确实可以和程序活得一样久，因为我们通过 `get_str_at_location` 函数直接取到了对应的字符串
- 持有 `&'static` 引用的变量，它的生命周期受到作用域的限制，大家务必不要搞混了

## `T: 'static`

相比起来，这种形式的约束就有些复杂了。

首先，在以下两种情况下，`T: 'static` 与 `&'static` 有相同的约束：`T` 必须活得和程序一样久。

```rust
use std::fmt::Debug;

fn print_it<T: Debug + 'static>( input: T) {
    println!( "'static value passed in is: {:?}", input );
}

fn print_it1( input: impl Debug + 'static ) {
    println!( "'static value passed in is: {:?}", input );
}



fn main() {
    let i = 5;

    print_it(&i);
    print_it1(&i);
}
```

以上代码会报错，原因很简单: `&i` 的生命周期无法满足 `'static` 的约束，如果大家将 `i` 修改为常量，那自然一切 OK。

见证奇迹的时候，请不要眨眼，现在我们来稍微修改下 `print_it` 函数:
```rust
use std::fmt::Debug;

fn print_it<T: Debug + 'static>( input: &T) {
    println!( "'static value passed in is: {:?}", input );
}

fn main() {
    let i = 5;

    print_it(&i);
}
```

这段代码竟然不报错了！原因在于我们约束的是 `T`，但是使用的却是它的引用 `&T`，换而言之，我们根本没有直接使用 `T`，因此编译器就没有去检查 `T` 的生命周期约束！它只要确保 `&T` 的生命周期符合规则即可，在上面代码中，它自然是符合的。

再来看一个例子:

```rust
use std::fmt::Display;

fn main() {
  let r1;
  let r2;
  {
    static STATIC_EXAMPLE: i32 = 42;
    r1 = &STATIC_EXAMPLE;
    let x = "&'static str";
    r2 = x;
    // r1 和 r2 持有的数据都是 'static 的，因此在花括号结束后，并不会被释放
  }

  println!("&'static i32: {}", r1); // -> 42
  println!("&'static str: {}", r2); // -> &'static str

  let r3: &str;

  {
    let s1 = "String".to_string();

    // s1 虽然没有 'static 生命周期，但是它依然可以满足 T: 'static 的约束
    // 充分说明这个约束是多么的弱。。
    static_bound(&s1);

    // s1 是 String 类型，没有 'static 的生命周期，因此下面代码会报错
    r3 = &s1;

    // s1 在这里被 drop
  }
  println!("{}", r3);
}

fn static_bound<T: Display + 'static>(t: &T) {
  println!("{}", t);
}
```

## static 到底针对谁？
大家有没有想过，到底是 `&'static` 这个引用还是该引用指向的数据活得跟程序一样久呢？

**答案是引用指向的数据**，而引用本身是要遵循其作用域范围的，我们来简单验证下：
```rust
fn main() {
    {
        let static_string = "I'm in read-only memory";
        println!("static_string: {}", static_string);

        // 当 `static_string` 超出作用域时，该引用不能再被使用，但是数据依然会存在于 binary 所占用的内存中
    }

    println!("static_string reference remains alive: {}", static_string);
}
```

以上代码不出所料会报错，原因在于虽然字符串字面量 "I'm in read-only memory" 的生命周期是 `'static`，但是持有它的引用并不是，它的作用域在内部花括号 `}` 处就结束了。

## 课后练习

> [Rust By Practice](https://practice-zh.course.rs/lifetime/static.html)，支持代码在线编辑和运行，并提供详细的习题解答。（本节暂无习题解答）


## 总结

总之， `&'static` 和 `T: 'static` 大体上相似，相比起来，后者的使用形式会更加复杂一些。

至此，相信大家对于 `'static` 和 `T: 'static` 也有了清晰的理解，那么我们应该如何使用它们呢？

作为经验之谈，可以这么来:

- 如果你需要添加 `&'static` 来让代码工作，那很可能是设计上出问题了
- 如果你希望满足和取悦编译器，那就使用 `T: 'static`，很多时候它都能解决问题

> 一个小知识，在 Rust 标准库中，有 48 处用到了 &'static ，112 处用到了 `T: 'static` ，看来取悦编译器不仅仅是菜鸟需要的，高手也经常用到 :)




================================================
FILE: src/advance/smart-pointer/box.md
================================================
# `Box<T>` 堆对象分配

关于作者帅不帅，估计争议还挺多的，但是如果说 `Box<T>` 是不是 Rust 中最常见的智能指针，那估计没有任何争议。因为 `Box<T>` 允许你将一个值分配到堆上，然后在栈上保留一个智能指针指向堆上的数据。

之前我们在[所有权章节](https://course.rs/basic/ownership/ownership.html#栈stack与堆heap)简单讲过堆栈的概念，这里再补充一些。

## Rust 中的堆栈

高级语言 Python/Java 等往往会弱化堆栈的概念，但是要用好 C/C++/Rust，就必须对堆栈有深入的了解，原因是两者的内存管理方式不同：前者有 GC 垃圾回收机制，因此无需你去关心内存的细节。

栈内存从高位地址向下增长，且栈内存是连续分配的，一般来说**操作系统对栈内存的大小都有限制**，因此 C 语言中无法创建任意长度的数组。在 Rust 中，`main` 线程的[栈大小是 `8MB`](https://course.rs/compiler/pitfalls/stack-overflow.html)，普通线程是 `2MB`，在函数调用时会在其中创建一个临时栈空间，调用结束后 Rust 会让这个栈空间里的对象自动进入 `Drop` 流程，最后栈顶指针自动移动到上一个调用栈顶，无需程序员手动干预，因而栈内存申请和释放是非常高效的。

与栈相反，堆上内存则是从低位地址向上增长，**堆内存通常只受物理内存限制**，而且通常是不连续的，因此从性能的角度看，栈往往比堆更高。

相比其它语言，Rust 堆上对象还有一个特殊之处，它们都拥有一个所有者，因此受所有权规则的限制：当赋值时，发生的是所有权的转移（只需浅拷贝栈上的引用或智能指针即可），例如以下代码：

```rust
fn main() {
    let b = foo("world");
    println!("{}", b);
}

fn foo(x: &str) -> String {
    let a = "Hello, ".to_string() + x;
    a
}
```

在 `foo` 函数中，`a` 是 `String` 类型，它其实是一个智能指针结构体，该智能指针存储在函数栈中，指向堆上的字符串数据。当被从 `foo` 函数转移给 `main` 中的 `b` 变量时，栈上的智能指针被复制一份赋予给 `b`，而底层数据无需发生改变，这样就完成了所有权从 `foo` 函数内部到 `b` 的转移。

#### 堆栈的性能

很多人可能会觉得栈的性能肯定比堆高，其实未必。 由于我们在后面的性能专题会专门讲解堆栈的性能问题，因此这里就大概给出结论：

- 小型数据，在栈上的分配性能和读取性能都要比堆上高
- 中型数据，栈上分配性能高，但是读取性能和堆上并无区别，因为无法利用寄存器或 CPU 高速缓存，最终还是要经过一次内存寻址
- 大型数据，只建议在堆上分配和使用

总之，栈的分配速度肯定比堆上快，但是读取速度往往取决于你的数据能不能放入寄存器或 CPU 高速缓存。 因此不要仅仅因为堆上性能不如栈这个印象，就总是优先选择栈，导致代码更复杂的实现。

## Box 的使用场景

由于 `Box` 是简单的封装，除了将值存储在堆上外，并没有其它性能上的损耗。而性能和功能往往是鱼和熊掌，因此 `Box` 相比其它智能指针，功能较为单一，可以在以下场景中使用它：

- 特意的将数据分配在堆上
- 数据较大时，又不想在转移所有权时进行数据拷贝
- 类型的大小在编译期无法确定，但是我们又需要固定大小的类型时
- 特征对象，用于说明对象实现了一个特征，而不是某个特定的类型

以上场景，我们在本章将一一讲解，后面车速较快，请系好安全带。

#### 使用 `Box<T>` 将数据存储在堆上

如果一个变量拥有一个数值 `let a = 3`，那变量 `a` 必然是存储在栈上的，那如果我们想要 `a` 的值存储在堆上就需要使用 `Box<T>`：

```rust
fn main() {
    let a = Box::new(3);
    println!("a = {}", a); // a = 3

    // 下面一行代码将报错
    // let b = a + 1; // cannot add `{integer}` to `Box<{integer}>`
}
```

这样就可以创建一个智能指针指向了存储在堆上的 `3`，并且 `a` 持有了该指针。在本章的引言中，我们提到了智能指针往往都实现了 `Deref` 和 `Drop` 特征，因此：

- `println!` 可以正常打印出 `a` 的值，是因为它隐式地调用了 `Deref` 对智能指针 `a` 进行了解引用
- 最后一行代码 ` let b = a + 1` 报错，是因为在表达式中，我们无法自动隐式地执行 `Deref` 解引用操作，你需要使用 `*` 操作符 `let b = *a + 1`，来显式的进行解引用
- `a` 持有的智能指针将在作用域结束（`main` 函数结束）时，被释放掉，这是因为 `Box<T>` 实现了 `Drop` 特征

以上的例子在实际代码中其实很少会存在，因为将一个简单的值分配到堆上并没有太大的意义。将其分配在栈上，由于寄存器、CPU 缓存的原因，它的性能将更好，而且代码可读性也更好。

#### 避免栈上数据的拷贝

当栈上数据转移所有权时，实际上是把数据拷贝了一份，最终新旧变量各自拥有不同的数据，因此所有权并未转移。

而堆上则不然，底层数据并不会被拷贝，转移所有权仅仅是复制一份栈中的指针，再将新的指针赋予新的变量，然后让拥有旧指针的变量失效，最终完成了所有权的转移：

```rust
fn main() {
    // 在栈上创建一个长度为1000的数组
    let arr = [0;1000];
    // 将arr所有权转移arr1，由于 `arr` 分配在栈上，因此这里实际上是直接重新深拷贝了一份数据
    let arr1 = arr;

    // arr 和 arr1 都拥有各自的栈上数组，因此不会报错
    println!("{:?}", arr.len());
    println!("{:?}", arr1.len());

    // 在堆上创建一个长度为1000的数组，然后使用一个智能指针指向它
    let arr = Box::new([0;1000]);
    // 将堆上数组的所有权转移给 arr1，由于数据在堆上，因此仅仅拷贝了智能指针的结构体，底层数据并没有被拷贝
    // 所有权顺利转移给 arr1，arr 不再拥有所有权
    let arr1 = arr;
    println!("{:?}", arr1.len());
    // 由于 arr 不再拥有底层数组的所有权，因此下面代码将报错
    // println!("{:?}", arr.len());
}
```

从以上代码，可以清晰看出大块的数据为何应该放入堆中，此时 `Box` 就成为了我们最好的帮手。

#### 将动态大小类型变为 Sized 固定大小类型

Rust 需要在编译时知道类型占用多少空间，如果一种类型在编译时无法知道具体的大小，那么被称为动态大小类型 DST。

其中一种无法在编译时知道大小的类型是**递归类型**：在类型定义中又使用到了自身，或者说该类型的值的一部分可以是相同类型的其它值，这种值的嵌套理论上可以无限进行下去，所以 Rust 不知道递归类型需要多少空间：

```rust
enum List {
    Cons(i32, List),
    Nil,
}
```

以上就是函数式语言中常见的 `Cons List`，它的每个节点包含一个 `i32` 值，还包含了一个新的 `List`，因此这种嵌套可以无限进行下去，Rust 认为该类型是一个 DST 类型，并给予报错：

```console
error[E0072]: recursive type `List` has infinite size //递归类型 `List` 拥有无限长的大小
 --> src/main.rs:3:1
  |
3 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
4 |     Cons(i32, List),
  |               ---- recursive without indirection
```

此时若想解决这个问题，就可以使用我们的 `Box<T>`：

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}
```

只需要将 `List` 存储到堆上，然后使用一个智能指针指向它，即可完成从 DST 到 Sized 类型(固定大小类型)的华丽转变。

#### 特征对象

在 Rust 中，想实现不同类型组成的数组只有两个办法：枚举和特征对象，前者限制较多，因此后者往往是最常用的解决办法。

```rust
trait Draw {
    fn draw(&self);
}

struct Button {
    id: u32,
}
impl Draw for Button {
    fn draw(&self) {
        println!("这是屏幕上第{}号按钮", self.id)
    }
}

struct Select {
    id: u32,
}

impl Draw for Select {
    fn draw(&self) {
        println!("这个选择框贼难用{}", self.id)
    }
}

fn main() {
    let elems: Vec<Box<dyn Draw>> = vec![Box::new(Button { id: 1 }), Box::new(Select { id: 2 })];

    for e in elems {
        e.draw()
    }
}
```

以上代码将不同类型的 `Button` 和 `Select` 包装成 `Draw` 特征的特征对象，放入一个数组中，`Box<dyn Draw>` 就是特征对象。

其实，特征也是 DST 类型，而特征对象在做的就是将 DST 类型转换为固定大小类型。

## Box 内存布局

先来看看 `Vec<i32>` 的内存布局：

```rust
(stack)    (heap)
┌──────┐   ┌───┐
│ vec1 │──→│ 1 │
└──────┘   ├───┤
           │ 2 │
           ├───┤
           │ 3 │
           ├───┤
           │ 4 │
           └───┘
```

之前提到过 `Vec` 和 `String` 都是智能指针，从上图可以看出，该智能指针存储在栈中，然后指向堆上的数组数据。

那如果数组中每个元素都是一个 `Box` 对象呢？来看看 `Vec<Box<i32>>` 的内存布局：

```rust
                    (heap)
(stack)    (heap)   ┌───┐
┌──────┐   ┌───┐ ┌─→│ 1 │
│ vec2 │──→│B1 │─┘  └───┘
└──────┘   ├───┤    ┌───┐
           │B2 │───→│ 2 │
           ├───┤    └───┘
           │B3 │─┐  ┌───┐
           ├───┤ └─→│ 3 │
           │B4 │─┐  └───┘
           └───┘ │  ┌───┐
                 └─→│ 4 │
                    └───┘
```

上面的 `B1` 代表被 `Box` 分配到堆上的值 `1`。

可以看出智能指针 `vec2` 依然是存储在栈上，然后指针指向一个堆上的数组，该数组中每个元素都是一个 `Box` 智能指针，最终 `Box` 智能指针又指向了存储在堆上的实际值。

因此当我们从数组中取出某个元素时，取到的是对应的智能指针 `Box`，需要对该智能指针进行解引用，才能取出最终的值：

```rust
fn main() {
    let arr = vec![Box::new(1), Box::new(2)];
    let (first, second) = (&arr[0], &arr[1]);
    let sum = **first + **second;
}
```

以上代码有几个值得注意的点：

- 使用 `&` 借用数组中的元素，否则会报所有权错误
- 表达式不能隐式的解引用，因此必须使用 `**` 做两次解引用，第一次将 `&Box<i32>` 类型转成 `Box<i32>`，第二次将 `Box<i32>` 转成 `i32`

## Box::leak

`Box` 中还提供了一个非常有用的关联函数：`Box::leak`，它可以消费掉 `Box` 并且强制目标值从内存中泄漏，读者可能会觉得，这有啥用啊？

其实还真有点用，例如，你可以把一个 `String` 类型，变成一个 `'static` 生命周期的 `&str` 类型：

```rust
fn main() {
   let s = gen_static_str();
   println!("{}", s);
}

fn gen_static_str() -> &'static str{
    let mut s = String::new();
    s.push_str("hello, world");

    Box::leak(s.into_boxed_str())
}
```

在之前的代码中，如果 `String` 创建于函数中，那么返回它的唯一方法就是转移所有权给调用者 `fn move_str() -> String`，而通过 `Box::leak` 我们不仅返回了一个 `&str` 字符串切片，它还是 `'static` 生命周期的！

要知道真正具有 `'static` 生命周期的往往都是编译期就创建的值，例如 `let v = "hello, world"`，这里 `v` 是直接打包到二进制可执行文件中的，因此该字符串具有 `'static` 生命周期，再比如 `const` 常量。

又有读者要问了，我还可以手动为变量标注 `'static` 啊。其实你标注的 `'static` 只是用来忽悠编译器的，但是超出作用域，一样被释放回收。而使用 `Box::leak` 就可以将一个运行期的值转为 `'static`。

#### 使用场景

光看上面的描述，大家可能还是云里雾里、一头雾水。

那么我说一个简单的场景，**你需要一个在运行期初始化的值，但是可以全局有效，也就是和整个程序活得一样久**，那么就可以使用 `Box::leak`，例如有一个存储配置的结构体实例，它是在运行期动态插入内容，那么就可以将其转为全局有效，虽然 `Rc/Arc` 也可以实现此功能，但是 `Box::leak` 是性能最高的。

## 总结

`Box` 背后是调用 `jemalloc` 来做内存管理，所以堆上的空间无需我们的手动管理。与此类似，带 GC 的语言中的对象也是借助于 `Box` 概念来实现的，**一切皆对象 = 一切皆 Box**， 只不过我们无需自己去 `Box` 罢了。

其实很多时候，编译器的鞭笞可以助我们更快的成长，例如所有权规则里的借用、move、生命周期就是编译器在教我们做人，哦不是，是教我们深刻理解堆栈、内存布局、作用域等等你在其它 GC 语言无需去关注的东西。刚开始是很痛苦，但是一旦熟悉了这套规则，写代码的效率和代码本身的质量将飞速上升，直到你可以用 Java 开发的效率写出 Java 代码不可企及的性能和安全性，最终 Rust 语言所谓的开发效率低、心智负担高，对你来说终究不是个事。

因此，不要怪 Rust，**它只是在帮我们成为那个更好的程序员，而这些苦难终究成为我们走向优秀的垫脚石**。



================================================
FILE: src/advance/smart-pointer/cell-refcell.md
================================================
# Cell 和 RefCell

Rust 的编译器之严格，可以说是举世无双。特别是在所有权方面，Rust 通过严格的规则来保证所有权和借用的正确性，最终为程序的安全保驾护航。

但是严格是一把双刃剑，带来安全提升的同时，损失了灵活性，有时甚至会让用户痛苦不堪、怨声载道。因此 Rust 提供了 `Cell` 和 `RefCell` 用于内部可变性，简而言之，可以在拥有不可变引用的同时修改目标数据，对于正常的代码实现来说，这个是不可能做到的（要么一个可变借用，要么多个不可变借用）。

> 内部可变性的实现是因为 Rust 使用了 `unsafe` 来做到这一点，但是对于使用者来说，这些都是透明的，因为这些不安全代码都被封装到了安全的 API 中

## Cell

`Cell` 和 `RefCell` 在功能上没有区别，区别在于 `Cell<T>` 适用于 `T` 实现 `Copy` 的情况：

```rust
use std::cell::Cell;
fn main() {
  let c = Cell::new("asdf");
  let one = c.get();
  c.set("qwer");
  let two = c.get();
  println!("{},{}", one, two);
}
```

以上代码展示了 `Cell` 的基本用法，有几点值得注意：

- "asdf" 是 `&str` 类型，它实现了 `Copy` 特征
- `c.get` 用来取值，`c.set` 用来设置新值

取到值保存在 `one` 变量后，还能同时进行修改，这个违背了 Rust 的借用规则，但是由于 `Cell` 的存在，我们很优雅地做到了这一点，但是如果你尝试在 `Cell` 中存放`String`：

```rust
 let c = Cell::new(String::from("asdf"));
```

编译器会立刻报错，因为 `String` 没有实现 `Copy` 特征：

```console
| pub struct String {
| ----------------- doesn't satisfy `String: Copy`
|
= note: the following trait bounds were not satisfied:
        `String: Copy`
```

## RefCell

由于 `Cell` 类型针对的是实现了 `Copy` 特征的值类型，因此在实际开发中，`Cell` 使用的并不多，因为我们要解决的往往是可变、不可变引用共存导致的问题，此时就需要借助于 `RefCell` 来达成目的。

我们可以将所有权、借用规则与这些智能指针做一个对比：

| Rust 规则                            | 智能指针带来的额外规则                  |
| ------------------------------------ | --------------------------------------- |
| 一个数据只有一个所有者               | `Rc/Arc`让一个数据可以拥有多个所有者    |
| 要么多个不可变借用，要么一个可变借用 | `RefCell`实现编译期可变、不可变引用共存 |
| 违背规则导致**编译错误**             | 违背规则导致**运行时`panic`**           |

可以看出，`Rc/Arc` 和 `RefCell` 合在一起，解决了 Rust 中严苛的所有权和借用规则带来的某些场景下难使用的问题。但是它们并不是银弹，例如 `RefCell` 实际上并没有解决可变引用和引用可以共存的问题，只是将报错从编译期推迟到运行时，从编译器错误变成了 `panic` 异常：

```rust
use std::cell::RefCell;

fn main() {
    let s = RefCell::new(String::from("hello, world"));
    let s1 = s.borrow();
    let s2 = s.borrow_mut();

    println!("{},{}", s1, s2);
}
```

上面代码在编译期不会报任何错误，你可以顺利运行程序：

```console
thread 'main' panicked at 'already borrowed: BorrowMutError', src/main.rs:6:16
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

但是依然会因为违背了借用规则导致了运行期 `panic`，这非常像中国的天网，它也许会被罪犯蒙蔽一时，但是并不会被蒙蔽一世，任何导致安全风险的存在都将不能被容忍，法网恢恢，疏而不漏。

#### RefCell 为何存在

相信肯定有读者有疑问了，这么做有任何意义吗？还不如在编译期报错，至少能提前发现问题，而且性能还更好。

存在即合理，究其根因，在于 Rust 编译期的**宁可错杀，绝不放过**的原则，当编译器不能确定你的代码是否正确时，就统统会判定为错误，因此难免会导致一些误报。

而 `RefCell` 正是**用于你确信代码是正确的，而编译器却发生了误判时**。

对于大型的复杂程序，也可以选择使用 `RefCell` 来让事情简化。例如在 Rust 编译器的[`ctxt结构体`](https://github.com/rust-lang/rust/blob/620d1ee5346bee10ba7ce129b2e20d6e59f0377d/src/librustc/middle/ty.rs#L803-L987)中有大量的 `RefCell` 类型的 `map` 字段，主要的原因是：这些 `map` 会被分散在各个地方的代码片段所广泛使用或修改。由于这种分散在各处的使用方式，导致了管理可变和不可变成为一件非常复杂的任务（甚至不可能），你很容易就碰到编译器抛出来的各种错误。而且 `RefCell` 的运行时错误在这种情况下也变得非常可爱：一旦有人做了不正确的使用，代码会 `panic`，然后告诉我们哪些借用冲突了。

总之，当你确信编译器误报但不知道该如何解决时，或者你有一个引用类型，需要被四处使用和修改然后导致借用关系难以管理时，都可以优先考虑使用 `RefCell`。

#### RefCell 简单总结

- 与 `Cell` 用于可 `Copy` 的值不同，`RefCell` 用于引用
- `RefCell` 只是将借用规则从编译期推迟到程序运行期，并不能帮你绕过这个规则
- `RefCell` 适用于编译期误报或者一个引用被在多处代码使用、修改以至于难于管理借用关系时
- 使用 `RefCell` 时，违背借用规则会导致运行期的 `panic`

## 选择 `Cell` 还是 `RefCell`

根据本文的内容，我们可以大概总结下两者的区别：

- `Cell` 只适用于 `Copy` 类型，用于提供值，而 `RefCell` 用于提供引用
- `Cell` 不会 `panic`，而 `RefCell` 会

#### 性能比较

`Cell` 没有额外的性能损耗，例如以下两段代码的性能其实是一致的：

```rust
// code snipet 1
let x = Cell::new(1);
let y = &x;
let z = &x;
x.set(2);
y.set(3);
z.set(4);
println!("{}", x.get());

// code snipet 2
let mut x = 1;
let y = &mut x;
let z = &mut x;
x = 2;
*y = 3;
*z = 4;
println!("{}", x);
```

虽然性能一致，但代码 `1` 拥有代码 `2` 不具有的优势：它能编译成功:)

与 `Cell` 的 `zero cost` 不同，`RefCell` 其实是有一点运行期开销的，原因是它包含了一个字节大小的“借用状态”指示器，该指示器在每次运行时借用时都会被修改，进而产生一点开销。

总之，当非要使用内部可变性时，首选 `Cell`，只有你的类型没有实现 `Copy` 时，才去选择 `RefCell`。

## 内部可变性

之前我们提到 `RefCell` 具有内部可变性，何为内部可变性？简单来说，对一个不可变的值进行可变借用，但这个并不符合 Rust 的基本借用规则：

```rust
fn main() {
    let x = 5;
    let y = &mut x;
}
```

上面的代码会报错，因为我们不能对一个不可变的值进行可变借用，这会破坏 Rust 的安全性保证，相反，你可以对一个可变值进行不可变借用。原因是：当值不可变时，可能会有多个不可变的引用指向它，此时若将其中一个修改为可变的，会造成可变引用与不可变引用共存的情况；而当值可变时，最多只会有一个可变引用指向它，将其修改为不可变，那么最终依然是只有一个不可变的引用指向它。

虽然基本借用规则是 Rust 的基石，然而在某些场景中，一个值可以在其方法内部被修改，同时对于其它代码不可变，是很有用的：

```rust
// 定义在外部库中的特征
pub trait Messenger {
    fn send(&self, msg: String);
}

// --------------------------
// 我们的代码中的数据结构和实现
struct MsgQueue {
    msg_cache: Vec<String>,
}

impl Messenger for MsgQueue {
    fn send(&self, msg: String) {
        self.msg_cache.push(msg)
    }
}
```

如上所示，外部库中定义了一个消息发送器特征 `Messenger`，它只有一个发送消息的功能：`fn send(&self, msg: String)`，因为发送消息不需要修改自身，因此原作者在定义时，使用了 `&self` 的不可变借用，这个无可厚非。

我们要在自己的代码中使用该特征实现一个异步消息队列，出于性能的考虑，消息先写到本地缓存(内存)中，然后批量发送出去，因此在 `send` 方法中，需要将消息先行插入到本地缓存 `msg_cache` 中。但是问题来了，该 `send` 方法的签名是 `&self`，因此上述代码会报错：

```console
error[E0596]: cannot borrow `self.msg_cache` as mutable, as it is behind a `&` reference
  --> src/main.rs:11:9
   |
2  |     fn send(&self, msg: String);
   |             ----- help: consider changing that to be a mutable reference: `&mut self`
...
11 |         self.msg_cache.push(msg)
   |         ^^^^^^^^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable
```

在报错的同时，编译器大聪明还善意地给出了提示：将 `&self` 修改为 `&mut self`，但是。。。我们实现的特征是定义在外部库中，因此该签名根本不能修改。值此危急关头， `RefCell` 闪亮登场：

```rust
use std::cell::RefCell;
pub trait Messenger {
    fn send(&self, msg: String);
}

pub struct MsgQueue {
    msg_cache: RefCell<Vec<String>>,
}

impl Messenger for MsgQueue {
    fn send(&self, msg: String) {
        self.msg_cache.borrow_mut().push(msg)
    }
}

fn main() {
    let mq = MsgQueue {
        msg_cache: RefCell::new(Vec::new()),
    };
    mq.send("hello, world".to_string());
}
```

这个 MQ 功能很弱，但是并不妨碍我们演示内部可变性的核心用法：通过包裹一层 `RefCell`，成功的让 `&self` 中的 `msg_cache` 成为一个可变值，然后实现对其的修改。

## Rc + RefCell 组合使用

在 Rust 中，一个常见的组合就是 `Rc` 和 `RefCell` 在一起使用，前者可以实现一个数据拥有多个所有者，后者可以实现数据的可变性：

```rust
use std::cell::RefCell;
use std::rc::Rc;
fn main() {
    let s = Rc::new(RefCell::new("我很善变，还拥有多个主人".to_string()));

    let s1 = s.clone();
    let s2 = s.clone();
    // let mut s2 = s.borrow_mut();
    s2.borrow_mut().push_str(", oh yeah!");

    println!("{:?}\n{:?}\n{:?}", s, s1, s2);
}

```

上面代码中，我们使用 `RefCell<String>` 包裹一个字符串，同时通过 `Rc` 创建了它的三个所有者：`s`、`s1`和`s2`，并且通过其中一个所有者 `s2` 对字符串内容进行了修改。

由于 `Rc` 的所有者们共享同一个底层的数据，因此当一个所有者修改了数据时，会导致全部所有者持有的数据都发生了变化。

程序的运行结果也在预料之中：

```console
RefCell { value: "我很善变，还拥有多个主人, oh yeah!" }
RefCell { value: "我很善变，还拥有多个主人, oh yeah!" }
RefCell { value: "我很善变，还拥有多个主人, oh yeah!" }
```

#### 性能损耗

相信这两者组合在一起使用时，很多人会好奇到底性能如何，下面我们来简单分析下。

首先给出一个大概的结论，这两者结合在一起使用的性能其实非常高，大致相当于没有线程安全版本的 C++ `std::shared_ptr` 指针，事实上，C++ 这个指针的主要开销也在于原子性这个并发原语上，毕竟线程安全在哪个语言中开销都不小。

#### 内存损耗

两者结合的数据结构与下面类似：

```rust
struct Wrapper<T> {
    // Rc
    strong_count: usize,
    weak_count: usize,

    // Refcell
    borrow_count: isize,

    // 包裹的数据
    item: T,
}
```

从上面可以看出，从对内存的影响来看，仅仅多分配了三个`usize/isize`，并没有其它额外的负担。

#### CPU 损耗

从 CPU 来看，损耗如下：

- 对 `Rc<T>` 解引用是免费的（编译期），但是 `*` 带来的间接取值并不免费
- 克隆 `Rc<T>` 需要将当前的引用计数跟 `0` 和 `usize::Max` 进行一次比较，然后将计数值加 1
- 释放（drop） `Rc<T>` 需要将计数值减 1， 然后跟 `0` 进行一次比较
- 对 `RefCell` 进行不可变借用，需要将 `isize` 类型的借用计数加 1，然后跟 `0` 进行比较
- 对 `RefCell `的不可变借用进行释放，需要将 `isize` 减 1
- 对 `RefCell` 的可变借用大致流程跟上面差不多，但是需要先跟 `0` 比较，然后再减 1
- 对 `RefCell` 的可变借用进行释放，需要将 `isize` 加 1

其实这些细节不必过于关注，只要知道 CPU 消耗也非常低，甚至编译器还会对此进行进一步优化！

#### CPU 缓存 Miss

唯一需要担心的可能就是这种组合数据结构对于 CPU 缓存是否亲和，这个我们无法证明，只能提出来存在这个可能性，最终的性能影响还需要在实际场景中进行测试。

总之，分析这两者组合的性能还挺复杂的，大概总结下：

- 从表面来看，它们带来的内存和 CPU 损耗都不大
- 但是由于 `Rc` 额外的引入了一次间接取值（`*`），在少数场景下可能会造成性能上的显著损失
- CPU 缓存可能也不够亲和

## 通过 `Cell::from_mut` 解决借用冲突

在 Rust 1.37 版本中新增了两个非常实用的方法：

- Cell::from_mut，该方法将 `&mut T` 转为 `&Cell<T>`
- Cell::as_slice_of_cells，该方法将 `&Cell<[T]>` 转为 `&[Cell<T>]`

这里我们不做深入的介绍，但是来看看如何使用这两个方法来解决一个常见的借用冲突问题：

```rust
fn is_even(i: i32) -> bool {
    i % 2 == 0
}

fn retain_even(nums: &mut Vec<i32>) {
    let mut i = 0;
    for num in nums.iter().filter(|&num| is_even(*num)) {
        nums[i] = *num;
        i += 1;
    }
    nums.truncate(i);
}
```

以上代码会报错：

```console
error[E0502]: cannot borrow `*nums` as mutable because it is also borrowed as immutable
 --> src/main.rs:8:9
  |
7 |     for num in nums.iter().filter(|&num| is_even(*num)) {
  |                ----------------------------------------
  |                |
  |                immutable borrow occurs here
  |                immutable borrow later used here
8 |         nums[i] = *num;
  |         ^^^^ mutable borrow occurs here
```

很明显，报错是因为同时借用了不可变与可变引用，你可以通过索引的方式来避免这个问题：

```rust
fn retain_even(nums: &mut Vec<i32>) {
    let mut i = 0;
    for j in 0..nums.len() {
        if is_even(nums[j]) {
            nums[i] = nums[j];
            i += 1;
        }
    }
    nums.truncate(i);
}
```

但是这样就违背我们的初衷了，毕竟迭代器会让代码更加简洁，那么还有其它的办法吗？

这时就可以使用 `Cell` 新增的这两个方法：

```rust
use std::cell::Cell;

fn retain_even(nums: &mut Vec<i32>) {
    let slice: &[Cell<i32>] = Cell::from_mut(&mut nums[..])
        .as_slice_of_cells();

    let mut i = 0;
    for num in slice.iter().filter(|num| is_even(num.get())) {
        slice[i].set(num.get());
        i += 1;
    }

    nums.truncate(i);
}
```

此时代码将不会报错，因为 `Cell` 上的 `set` 方法获取的是不可变引用 `pub fn set(&self, val: T)`。

当然，以上代码的本质还是对 `Cell` 的运用，只不过这两个方法可以很方便的帮我们把 `&mut [T]` 类型转换成 `&[Cell<T>]` 类型。

## 总结

`Cell` 和 `RefCell` 都为我们带来了内部可变性这个重要特性，同时还将借用规则的检查从编译期推迟到运行期，但是这个检查并不能被绕过，该来早晚还是会来，`RefCell` 在运行期的报错会造成 `panic`。

`RefCell` 适用于编译器误报或者一个引用被在多个代码中使用、修改以至于难于管理借用关系时，还有就是需要内部可变性时。

从性能上看，`RefCell` 由于是非线程安全的，因此无需保证原子性，性能虽然有一点损耗，但是依然非常好，而 `Cell` 则完全不存在任何额外的性能损耗。

`Rc` 跟 `RefCell` 结合使用可以实现多个所有者共享同一份数据，非常好用，但是潜在的性能损耗也要考虑进去，建议对于热点代码使用时，做好 `benchmark`。



================================================
FILE: src/advance/smart-pointer/deref.md
================================================
# Deref 解引用
在开始之前，我们先来看一段代码：
```rust
#[derive(Debug)]
struct Person {
    name: String,
    age: u8
}

impl Person {
    fn new(name: String, age: u8) -> Self {
        Person { name, age}
    }

    fn display(self: &mut Person, age: u8) {
        let Person{name, age} = &self;
    }
}
```

以上代码有一个很奇怪的地方：在 `display` 方法中，`self` 是 `&mut Person` 的类型，接着我们对其取了一次引用 `&self`，此时 `&self` 的类型是 `&&mut Person`，然后我们又将其和 `Person` 类型进行匹配，取出其中的值。

那么问题来了，Rust 不是号称安全的语言吗？为何允许将 `&&mut Person` 跟 `Person` 进行匹配呢？答案就在本章节中，等大家学完后，再回头自己来解决这个问题 :) 下面正式开始咱们的新章节学习。

何为智能指针？能不让你写出 `****s` 形式的解引用，我认为就是智能: )，智能指针的名称来源，主要就在于它实现了 `Deref` 和 `Drop` 特征，这两个特征可以智能地帮助我们节省使用上的负担：

- `Deref` 可以让智能指针像引用那样工作，这样你就可以写出同时支持智能指针和引用的代码，例如 `*T`
- `Drop` 允许你指定智能指针超出作用域后自动执行的代码，例如做一些数据清除等收尾工作

先来看看 `Deref` 特征是如何工作的。

## 通过 `*` 获取引用背后的值

在正式讲解 `Deref` 之前，我们先来看下常规引用的解引用。


常规引用是一个指针类型，包含了目标数据存储的内存地址。对常规引用使用 `*` 操作符，就可以通过解引用的方式获取到内存地址对应的数据值：

```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

这里 `y` 就是一个常规引用，包含了值 `5` 所在的内存地址，然后通过解引用 `*y`，我们获取到了值 `5`。如果你试图执行 `assert_eq!(5, y);`，代码就会无情报错，因为你无法将一个引用与一个数值做比较：

```console
error[E0277]: can't compare `{integer}` with `&{integer}` //无法将{integer} 与&{integer}进行比较
 --> src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`
  |
  = help: the trait `PartialEq<&{integer}>` is not implemented for `{integer}`
                    // 你需要为{integer}实现用于比较的特征PartialEq<&{integer}>
```

## 智能指针解引用

上面所说的解引用方式和其它大多数语言并无区别，但是 Rust 中将解引用提升到了一个新高度。考虑一下智能指针，它是一个结构体类型，如果你直接对它进行 `*myStruct`，显然编译器不知道该如何办，因此我们可以为智能指针结构体实现 `Deref` 特征。

实现 `Deref` 后的智能指针结构体，就可以像普通引用一样，通过 `*` 进行解引用，例如 `Box<T>` 智能指针：

```rust
fn main() {
    let x = Box::new(1);
    let sum = *x + 1;
}
```

智能指针 `x` 被 `*` 解引用为 `i32` 类型的值 `1`，然后再进行求和。

#### 定义自己的智能指针

现在，让我们一起来实现一个智能指针，功能上类似 `Box<T>`。由于 `Box<T>` 本身很简单，并没有包含类如长度、最大长度等信息，因此用一个元组结构体即可。

```rust
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}
```

跟 `Box<T>` 一样，我们的智能指针也持有一个 `T` 类型的值，然后使用关联函数 `MyBox::new` 来创建智能指针。由于还未实现 `Deref` 特征，此时使用 `*` 肯定会报错：

```rust
fn main() {
    let y = MyBox::new(5);

    assert_eq!(5, *y);
}
```

运行后，报错如下：

```console
error[E0614]: type `MyBox<{integer}>` cannot be dereferenced
  --> src/main.rs:12:19
   |
12 |     assert_eq!(5, *y);
   |                   ^^
```

##### 为智能指针实现 Deref 特征

现在来为 `MyBox` 实现 `Deref` 特征，以支持 `*` 解引用操作符：

```rust
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
```

很简单，当解引用 `MyBox` 智能指针时，返回元组结构体中的元素 `&self.0`，有几点要注意的：

- 在 `Deref` 特征中声明了关联类型 `Target`，在之前章节中介绍过，关联类型主要是为了提升代码可读性
- `deref` 返回的是一个常规引用，可以被 `*` 进行解引用

之前报错的代码此时已能顺利编译通过。当然，标准库实现的智能指针要考虑很多边边角角情况，肯定比我们的实现要复杂。

## `*` 背后的原理

当我们对智能指针 `Box` 进行解引用时，实际上 Rust 为我们调用了以下方法：

```rust
*(y.deref())
```

首先调用 `deref` 方法返回值的常规引用，然后通过 `*` 对常规引用进行解引用，最终获取到目标值。

至于 Rust 为何要使用这个有点啰嗦的方式实现，原因在于所有权系统的存在。如果 `deref` 方法直接返回一个值，而不是引用，那么该值的所有权将被转移给调用者，而我们不希望调用者仅仅只是 `*T` 一下，就拿走了智能指针中包含的值。

需要注意的是，`*` 不会无限递归替换，从 `*y` 到 `*(y.deref())` 只会发生一次，而不会继续进行替换然后产生形如 `*((y.deref()).deref())` 的怪物。

## 函数和方法中的隐式 Deref 转换

对于函数和方法的传参，Rust 提供了一个极其有用的隐式转换：`Deref `转换。若一个类型实现了 `Deref` 特征，那它的引用在传给函数或方法时，会根据参数签名来决定是否进行隐式的 `Deref` 转换，例如：

```rust
fn main() {
    let s = String::from("hello world");
    display(&s)
}

fn display(s: &str) {
    println!("{}",s);
}
```

以上代码有几点值得注意：

- `String` 实现了 `Deref` 特征，可以在需要时自动被转换为 `&str` 类型
- `&s` 是一个 `&String` 类型，当它被传给 `display` 函数时，自动通过 `Deref` 转换成了 `&str`
- 必须使用 `&s` 的方式来触发 `Deref`(仅引用类型的实参才会触发自动解引用)

#### 连续的隐式 Deref 转换

如果你以为 `Deref` 仅仅这点作用，那就大错特错了。`Deref` 可以支持连续的隐式转换，直到找到适合的形式为止：

```rust
fn main() {
    let s = MyBox::new(String::from("hello world"));
    display(&s)
}

fn display(s: &str) {
    println!("{}",s);
}
```

这里我们使用了之前自定义的智能指针 `MyBox`，并将其通过连续的隐式转换变成 `&str` 类型：首先 `MyBox` 被 `Deref` 成 `String` 类型，结果并不能满足 `display` 函数参数的要求，编译器发现 `String` 还可以继续 `Deref` 成 `&str`，最终成功的匹配了函数参数。

想象一下，假如 `Rust` 没有提供这种隐式转换，我们该如何调用 `display` 函数？

```rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    display(&(*m)[..]);
}
```

结果不言而喻，肯定是 `&s` 的方式优秀得多。总之，当参与其中的类型定义了 `Deref` 特征时，Rust 会分析该类型并且连续使用 `Deref` 直到最终获得一个引用来匹配函数或者方法的参数类型，这种行为完全不会造成任何的性能损耗，因为完全是在编译期完成。

但是 `Deref` 并不是没有缺点，缺点就是：如果你不知道某个类型是否实现了 `Deref` 特征，那么在看到某段代码时，并不能在第一时间反应过来该代码发生了隐式的 `Deref` 转换。事实上，不仅仅是 `Deref`，在 Rust 中还有各种 `From/Into` 等等会给阅读代码带来一定负担的特征。还是那句话，一切选择都是权衡，有得必有失，得了代码的简洁性，往往就失去了可读性，Go 语言就是一个刚好相反的例子。

再来看一下在方法、赋值中自动应用 `Deref` 的例子：

```rust
fn main() {
    let s = MyBox::new(String::from("hello, world"));
    let s1: &str = &s;
    let s2: String = s.to_string();
}
```

对于 `s1`，我们通过两次 `Deref` 将 `&str` 类型的值赋给了它（**赋值操作需要手动解引用**）；而对于 `s2`，我们在其上直接调用方法 `to_string`，实际上 `MyBox` 根本没有没有实现该方法，能调用 `to_string`，完全是因为编译器对 `MyBox` 应用了 `Deref` 的结果（**方法调用会自动解引用**）。

## Deref 规则总结

在上面，我们零碎的介绍了不少关于 `Deref` 特征的知识，下面来通过较为正式的方式来对其规则进行下总结。

一个类型为 `T` 的对象 `foo`，如果 `T: Deref<Target=U>`，那么，相关 `foo` 的引用 `&foo` 在应用的时候会自动转换为 `&U`。

粗看这条规则，貌似有点类似于 `AsRef`，而跟 `解引用` 似乎风马牛不相及，实际里面有些玄妙之处。

#### 引用归一化

Rust 编译器实际上只能对 `&v` 形式的引用进行解引用操作，那么问题来了，如果是一个智能指针或者 `&&&&v` 类型的呢？ 该如何对这两个进行解引用？

答案是：Rust 会在解引用时自动把智能指针和 `&&&&v` 做引用归一化操作，转换成 `&v` 形式，最终再对 `&v` 进行解引用：

- 把智能指针（比如在库中定义的，Box、Rc、Arc、Cow 等）从结构体脱壳为内部的引用类型，也就是转成结构体内部的 `&v`
- 把多重`&`，例如 `&&&&&&&v`，归一成 `&v`

关于第二种情况，这么干巴巴的说，也许大家会迷迷糊糊的，我们来看一段标准库源码：

```rust
impl<T: ?Sized> Deref for &T {
    type Target = T;

    fn deref(&self) -> &T {
        *self
    }
}
```

在这段源码中，`&T` 被自动解引用为 `T`，也就是 `&T: Deref<Target=T>` 。 按照这个代码，`&&&&T` 会被自动解引用为 `&&&T`，然后再自动解引用为 `&&T`，以此类推， 直到最终变成 `&T`。

PS: 以下是 `LLVM` 编译后的部分中间层代码：

```rust
// Rust 代码
let mut _2: &i32;
let _3: &&&&i32;

bb0: {
    _2 = (*(*(*_3)))
}
```

#### 几个例子

```rust
    fn foo(s: &str) {}

    // 由于 String 实现了 Deref<Target=str>
    let owned = "Hello".to_string();

    // 因此下面的函数可以正常运行：
    foo(&owned);
```

```rust
    use std::rc::Rc;

    fn foo(s: &str) {}

    // String 实现了 Deref<Target=str>
    let owned = "Hello".to_string();
    // 且 Rc 智能指针可以被自动脱壳为内部的 `owned` 引用： &String ，然后 &String 再自动解引用为 &str
    let counted = Rc::new(owned);

    // 因此下面的函数可以正常运行:
    foo(&counted);
```

```rust
    struct Foo;

    impl Foo {
        fn foo(&self) { println!("Foo"); }
    }

    let f = &&Foo;

    f.foo();
    (&f).foo();
    (&&f).foo();
    (&&&&&&&&f).foo();
```

## 三种 Deref 转换

在之前，我们讲的都是不可变的 `Deref` 转换，实际上 Rust 还支持将一个可变的引用转换成另一个可变的引用以及将一个可变引用转换成不可变的引用，规则如下：

- 当 `T: Deref<Target=U>`，可以将 `&T` 转换成 `&U`，也就是我们之前看到的例子
- 当 `T: DerefMut<Target=U>`，可以将 `&mut T` 转换成 `&mut U`
- 当 `T: Deref<Target=U>`，可以将 `&mut T` 转换成 `&U`

来看一个关于 `DerefMut` 的例子：

```rust
struct MyBox<T> {
    v: T,
}

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox { v: x }
    }
}

use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.v
    }
}

use std::ops::DerefMut;

impl<T> DerefMut for MyBox<T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.v
    }
}

fn main() {
    let mut s = MyBox::new(String::from("hello, "));
    display(&mut s)
}

fn display(s: &mut String) {
    s.push_str("world");
    println!("{}", s);
}
```

以上代码有几点值得注意:

- 要实现 `DerefMut` 必须要先实现 `Deref` 特征：`pub trait DerefMut: Deref`
- `T: DerefMut<Target=U>` 解读：将 `&mut T` 类型通过 `DerefMut` 特征的方法转换为 `&mut U` 类型，对应上例中，就是将 `&mut MyBox<String>` 转换为 `&mut String`

对于上述三条规则中的第三条，它比另外两条稍微复杂了点：Rust 可以把可变引用隐式的转换成不可变引用，但反之则不行。

如果从 Rust 的所有权和借用规则的角度考虑，当你拥有一个可变的引用，那该引用肯定是对应数据的唯一借用，那么此时将可变引用变成不可变引用并不会破坏借用规则；但是如果你拥有一个不可变引用，那同时可能还存在其它几个不可变的引用，如果此时将其中一个不可变引用转换成可变引用，就变成了可变引用与不可变引用的共存，最终破坏了借用规则。

## 总结

`Deref` 可以说是 Rust 中最常见的隐式类型转换，而且它可以连续的实现如 `Box<String> -> String -> &str` 的隐式转换，只要链条上的类型实现了 `Deref` 特征。

我们也可以为自己的类型实现 `Deref` 特征，但是原则上来说，只应该为自定义的智能指针实现 `Deref`。例如，虽然你可以为自己的自定义数组类型实现 `Deref` 以避免 `myArr.0[0]` 的使用形式，但是 Rust 官方并不推荐这么做，特别是在你开发三方库时。



================================================
FILE: src/advance/smart-pointer/drop.md
================================================
# Drop 释放资源

在 Rust 中，我们之所以可以一拳打跑 GC 的同时一脚踢翻手动资源回收，主要就归功于 `Drop` 特征，同时它也是智能指针的必备特征之一。

## 学习目标

如何自动和手动释放资源及执行指定的收尾工作

## Rust 中的资源回收

在一些无 GC 语言中，程序员在一个变量无需再被使用时，需要手动释放它占用的内存资源，如果忘记了，那么就会发生内存泄漏，最终臭名昭著的 `OOM` 问题可能就会发生。

而在 Rust 中，你可以指定在一个变量超出作用域时，执行一段特定的代码，最终编译器将帮你自动插入这段收尾代码。这样，就无需在每一个使用该变量的地方，都写一段代码来进行收尾工作和资源释放。不禁让人感叹，Rust 的大腿真粗，香！

没错，指定这样一段收尾工作靠的就是咱这章的主角 - `Drop` 特征。

## 一个不那么简单的 Drop 例子

```rust
struct HasDrop1;
struct HasDrop2;
impl Drop for HasDrop1 {
    fn drop(&mut self) {
        println!("Dropping HasDrop1!");
    }
}
impl Drop for HasDrop2 {
    fn drop(&mut self) {
        println!("Dropping HasDrop2!");
    }
}
struct HasTwoDrops {
    one: HasDrop1,
    two: HasDrop2,
}
impl Drop for HasTwoDrops {
    fn drop(&mut self) {
        println!("Dropping HasTwoDrops!");
    }
}

struct Foo;

impl Drop for Foo {
    fn drop(&mut self) {
        println!("Dropping Foo!")
    }
}

fn main() {
    let _x = HasTwoDrops {
        two: HasDrop2,
        one: HasDrop1,
    };
    let _foo = Foo;
    println!("Running!");
}
```

上面代码虽然长，但是目的其实很单纯，就是为了观察不同情况下变量级别的、结构体内部字段的 `Drop`，有几点值得注意：

- `Drop` 特征中的 `drop` 方法借用了目标的可变引用，而不是拿走了所有权，这里先设置一个悬念，后边会讲
- 结构体中每个字段都有自己的 `Drop`

来看看输出：

```console
Running!
Dropping Foo!
Dropping HasTwoDrops!
Dropping HasDrop1!
Dropping HasDrop2!
```

嗯，结果符合预期，每个资源都成功的执行了收尾工作，虽然 `println!` 这种收尾工作毫无意义 =,=

#### Drop 的顺序

观察以上输出，我们可以得出以下关于 `Drop` 顺序的结论

- **变量级别，按照逆序的方式**，`_x` 在 `_foo` 之前创建，因此 `_x` 在 `_foo` 之后被 `drop`
- **结构体内部，按照顺序的方式**，结构体 `_x` 中的字段按照定义中的顺序依次 `drop`

#### 没有实现 Drop 的结构体

实际上，就算你不为 `_x` 结构体实现 `Drop` 特征，它内部的两个字段依然会调用 `drop`，移除以下代码，并观察输出：

```rust
impl Drop for HasTwoDrops {
    fn drop(&mut self) {
        println!("Dropping HasTwoDrops!");
    }
}
```

原因在于，Rust 自动为几乎所有类型都实现了 `Drop` 特征，因此就算你不手动为结构体实现 `Drop`，它依然会调用默认实现的 `drop` 函数，同时再调用每个字段的 `drop` 方法，最终打印出：

```cnosole
Dropping HasDrop1!
Dropping HasDrop2!
```

## 手动回收

当使用智能指针来管理锁的时候，你可能希望提前释放这个锁，然后让其它代码能及时获得锁，此时就需要提前去手动 `drop`。
但是在之前我们提到一个悬念，`Drop::drop` 只是借用了目标值的可变引用，所以，就算你提前调用了 `drop`，后面的代码依然可以使用目标值，但是这就会访问一个并不存在的值，非常不安全，好在 Rust 会阻止你：

```rust
#[derive(Debug)]
struct Foo;

impl Drop for Foo {
    fn drop(&mut self) {
        println!("Dropping Foo!")
    }
}

fn main() {
    let foo = Foo;
    foo.drop();
    println!("Running!:{:?}", foo);
}
```

报错如下：

```console
error[E0040]: explicit use of destructor method
  --> src/main.rs:37:9
   |
37 |     foo.drop();
   |     ----^^^^--
   |     |   |
   |     |   explicit destructor calls not allowed
   |     help: consider using `drop` function: `drop(foo)`
```

如上所示，编译器直接阻止了我们调用 `Drop` 特征的 `drop` 方法，原因是对于 Rust 而言，不允许显式地调用析构函数（这是一个用来清理实例的通用编程概念）。好在在报错的同时，编译器还给出了一个提示：使用 `drop` 函数。

针对编译器提示的 `drop` 函数，我们可以大胆推测下：它能够拿走目标值的所有权。现在来看看这个猜测正确与否，以下是 `std::mem::drop` 函数的签名：

```rust
pub fn drop<T>(_x: T)
```

如上所示，`drop` 函数确实拿走了目标值的所有权，来验证下：

```rust
fn main() {
    let foo = Foo;
    drop(foo);
    // 以下代码会报错：借用了所有权被转移的值
    // println!("Running!:{:?}", foo);
}
```

Bingo，完美拿走了所有权，而且这种实现保证了后续的使用必定会导致编译错误，因此非常安全！

细心的同学可能已经注意到，这里直接调用了 `drop` 函数，并没有引入任何模块信息，原因是该函数在[`std::prelude`](https://course.rs/appendix/prelude.html)里。

> 事实上，能被显式调用的drop(_x)函数只是个空函数，在拿走目标值的所有权后没有任何操作。而由于其持有目标值的所有权，在drop(_x)函数结束之际，编译器会执行_x真正的析构函数，从而完成释放资源的操作。换句话说，drop(_x)函数只是帮助目标值的所有者提前离开了作用域。https://doc.rust-lang.org/std/mem/fn.drop.html

## Drop 使用场景

对于 Drop 而言，主要有两个功能：

- 回收内存资源
- 执行一些收尾工作

对于第二点，在之前我们已经详细介绍过，因此这里主要对第一点进行下简单说明。

在绝大多数情况下，我们都无需手动去 `drop` 以回收内存资源，因为 Rust 会自动帮我们完成这些工作，它甚至会对复杂类型的每个字段都单独的调用 `drop` 进行回收！但是确实有极少数情况，需要你自己来回收资源的，例如文件描述符、网络 socket 等，当这些值超出作用域不再使用时，就需要进行关闭以释放相关的资源，在这些情况下，就需要使用者自己来解决 `Drop` 的问题。

## 互斥的 Copy 和 Drop

我们无法为一个类型同时实现 `Copy` 和 `Drop` 特征。因为实现了 `Copy` 特征的类型会被编译器隐式的复制，因此非常难以预测析构函数执行的时间和频率。因此这些实现了 `Copy` 的类型无法拥有析构函数。

```rust
#[derive(Copy)]
struct Foo;

impl Drop for Foo {
    fn drop(&mut self) {
        println!("Dropping Foo!")
    }
}
```

以上代码报错如下：

```console
error[E0184]: the trait `Copy` may not be implemented for this type; the type has a destructor
  --> src/main.rs:24:10
   |
24 | #[derive(Copy)]
   |          ^^^^ Copy not allowed on types with destructors
```

## 总结

`Drop` 可以用于许多方面，来使得资源清理及收尾工作变得方便和安全，甚至可以用其创建我们自己的内存分配器！通过 `Drop` 特征和 Rust 所有权系统，你无需担心之后的代码清理，Rust 会自动考虑这些问题。

我们也无需担心意外的清理掉仍在使用的值，这会造成编译器错误：所有权系统确保引用总是有效的，也会确保 `drop` 只会在值不再被使用时被调用一次。



================================================
FILE: src/advance/smart-pointer/intro.md
================================================
# 智能指针

在各个编程语言中，指针的概念几乎都是相同的：**指针是一个包含了内存地址的变量，该内存地址引用或者指向了另外的数据**。

在 Rust 中，最常见的指针类型是引用，引用通过 `&` 符号表示。不同于其它语言，引用在 Rust 中被赋予了更深层次的含义，那就是：借用其它变量的值。引用本身很简单，除了指向某个值外并没有其它的功能，也不会造成性能上的额外损耗，因此是 Rust 中使用最多的指针类型。

而智能指针则不然，它虽然也号称指针，但是它是一个复杂的家伙：通过比引用更复杂的数据结构，包含比引用更多的信息，例如元数据，当前长度，最大可用长度等。总之，Rust 的智能指针并不是独创，在 C++ 或者其他语言中也存在相似的概念。

Rust 标准库中定义的那些智能指针，虽重但强，可以提供比引用更多的功能特性，例如本章将讨论的引用计数智能指针。该智能指针允许你同时拥有同一个数据的多个所有权，它会跟踪每一个所有者并进行计数，当所有的所有者都归还后，该智能指针及指向的数据将自动被清理释放。

引用和智能指针的另一个不同在于前者仅仅是借用了数据，而后者往往可以拥有它们指向的数据，然后再为其它人提供服务。

在之前的章节中，实际上我们已经见识过多种智能指针，例如动态字符串 `String` 和动态数组 `Vec`，它们的数据结构中不仅仅包含了指向底层数据的指针，还包含了当前长度、最大长度等信息，其中 `String` 智能指针还提供了一种担保信息：所有的数据都是合法的 `UTF-8` 格式。

智能指针往往是基于结构体实现，它与我们自定义的结构体最大的区别在于它实现了 `Deref` 和 `Drop` 特征：

- `Deref` 可以让智能指针像引用那样工作，这样你就可以写出同时支持智能指针和引用的代码，例如 `*T`
- `Drop` 允许你指定智能指针超出作用域后自动执行的代码，例如做一些数据清除等收尾工作

智能指针在 Rust 中很常见，我们在本章不会全部讲解，而是挑选几个最常用、最有代表性的进行讲解：

- `Box<T>`，可以将值分配到堆上
- `Rc<T>`，引用计数类型，允许多所有权存在
- `Ref<T>` 和 `RefMut<T>`，允许将借用规则检查从编译期移动到运行期进行



================================================
FILE: src/advance/smart-pointer/rc-arc.md
================================================
# Rc 与 Arc

Rust 所有权机制要求一个值只能有一个所有者，在大多数情况下，都没有问题，但是考虑以下情况：

- 在图数据结构中，多个边可能会拥有同一个节点，该节点直到没有边指向它时，才应该被释放清理
- 在多线程中，多个线程可能会持有同一个数据，但是你受限于 Rust 的安全机制，无法同时获取该数据的可变引用

以上场景不是很常见，但是一旦遇到，就非常棘手，为了解决此类问题，Rust 在所有权机制之外又引入了额外的措施来简化相应的实现：通过引用计数的方式，允许一个数据资源在同一时刻拥有多个所有者。

这种实现机制就是 `Rc` 和 `Arc`，前者适用于单线程，后者适用于多线程。由于二者大部分情况下都相同，因此本章将以 `Rc` 作为讲解主体，对于 `Arc` 的不同之处，另外进行单独讲解。

## `Rc<T>`

引用计数(reference counting)，顾名思义，通过记录一个数据被引用的次数来确定该数据是否正在被使用。当引用次数归零时，就代表该数据不再被使用，因此可以被清理释放。

而 `Rc` 正是引用计数的英文缩写。当我们**希望在堆上分配一个对象供程序的多个部分使用且无法确定哪个部分最后一个结束时，就可以使用 `Rc` 成为数据值的所有者**，例如之前提到的多线程场景就非常适合。

下面是经典的所有权被转移导致报错的例子：

```rust
fn main() {
    let s = String::from("hello, world");
    // s在这里被转移给a
    let a = Box::new(s);
    // 报错！此处继续尝试将 s 转移给 b
    let b = Box::new(s);
}
```

使用 `Rc` 就可以轻易解决：

```rust
use std::rc::Rc;
fn main() {
    let a = Rc::new(String::from("hello, world"));
    let b = Rc::clone(&a);

    assert_eq!(2, Rc::strong_count(&a));
    assert_eq!(Rc::strong_count(&a), Rc::strong_count(&b))
}
```

以上代码我们使用 `Rc::new` 创建了一个新的 `Rc<String>` 智能指针并赋给变量 `a`，该指针指向底层的字符串数据。

智能指针 `Rc<T>` 在创建时，还会将引用计数加 1，此时获取引用计数的关联函数 `Rc::strong_count` 返回的值将是 `1`。

#### Rc::clone

接着，我们又使用 `Rc::clone` 克隆了一份智能指针 `Rc<String>`，并将该智能指针的引用计数增加到 `2`。

由于 `a` 和 `b` 是同一个智能指针的两个副本，因此通过它们两个获取引用计数的结果都是 `2`。

不要被 `clone` 字样所迷惑，以为所有的 `clone` 都是深拷贝。这里的 `clone` **仅仅复制了智能指针并增加了引用计数，并没有克隆底层数据**，因此 `a` 和 `b` 是共享了底层的字符串 `s`，这种**复制效率是非常高**的。当然你也可以使用 `a.clone()` 的方式来克隆，但是从可读性角度，我们更加推荐 `Rc::clone` 的方式。

实际上在 Rust 中，还有不少 `clone` 都是浅拷贝，例如[迭代器的克隆](https://course.rs/compiler/pitfalls/iterator-everywhere.html)。

#### 观察引用计数的变化

使用关联函数 `Rc::strong_count` 可以获取当前引用计数的值，我们来观察下引用计数如何随着变量声明、释放而变化：

```rust
use std::rc::Rc;
fn main() {
        let a = Rc::new(String::from("test ref counting"));
        println!("count after creating a = {}", Rc::strong_count(&a));
        let b =  Rc::clone(&a);
        println!("count after creating b = {}", Rc::strong_count(&a));
        {
            let c =  Rc::clone(&a);
            println!("count after creating c = {}", Rc::strong_count(&c));
        }
        println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}
```

有几点值得注意：

- 由于变量 `c` 在语句块内部声明，当离开语句块时它会因为超出作用域而被释放，所以引用计数会减少 1，事实上这个得益于 `Rc<T>` 实现了 `Drop` 特征
- `a`、`b`、`c` 三个智能指针引用计数都是同样的，并且共享底层的数据，因此打印计数时用哪个都行
- 无法看到的是：当 `a`、`b` 超出作用域后，引用计数会变成 0，最终智能指针和它指向的底层字符串都会被清理释放

#### 不可变引用

事实上，`Rc<T>` 是指向底层数据的不可变的引用，因此你无法通过它来修改数据，这也符合 Rust 的借用规则：要么存在多个不可变借用，要么只能存在一个可变借用。

但是实际开发中我们往往需要对数据进行修改，这时单独使用 `Rc<T>` 无法满足我们的需求，需要配合其它数据类型来一起使用，例如内部可变性的 `RefCell<T>` 类型以及互斥锁 `Mutex<T>`。事实上，在多线程编程中，`Arc` 跟 `Mutex` 锁的组合使用非常常见，它们既可以让我们在不同的线程中共享数据，又允许在各个线程中对其进行修改。

#### 一个综合例子

考虑一个场景，有很多小工具，每个工具都有自己的主人，但是存在多个工具属于同一个主人的情况，此时使用 `Rc<T>` 就非常适合：

```rust
use std::rc::Rc;

struct Owner {
    name: String,
    // ...其它字段
}

struct Gadget {
    id: i32,
    owner: Rc<Owner>,
    // ...其它字段
}

fn main() {
    // 创建一个基于引用计数的 `Owner`.
    let gadget_owner: Rc<Owner> = Rc::new(Owner {
        name: "Gadget Man".to_string(),
    });

    // 创建两个不同的工具，它们属于同一个主人
    let gadget1 = Gadget {
        id: 1,
        owner: Rc::clone(&gadget_owner),
    };
    let gadget2 = Gadget {
        id: 2,
        owner: Rc::clone(&gadget_owner),
    };

    // 释放掉第一个 `Rc<Owner>`
    drop(gadget_owner);

    // 尽管在上面我们释放了 gadget_owner，但是依然可以在这里使用 owner 的信息
    // 原因是在 drop 之前，存在三个指向 Gadget Man 的智能指针引用，上面仅仅
    // drop 掉其中一个智能指针引用，而不是 drop 掉 owner 数据，外面还有两个
    // 引用指向底层的 owner 数据，引用计数尚未清零
    // 因此 owner 数据依然可以被使用
    println!("Gadget {} owned by {}", gadget1.id, gadget1.owner.name);
    println!("Gadget {} owned by {}", gadget2.id, gadget2.owner.name);

    // 在函数最后，`gadget1` 和 `gadget2` 也被释放，最终引用计数归零，随后底层
    // 数据也被清理释放
}
```

以上代码很好的展示了 `Rc<T>` 的用途，当然你也可以用借用的方式，但是实现起来就会复杂得多，而且随着 `Gadget` 在代码的各个地方使用，引用生命周期也将变得更加复杂，毕竟结构体中的引用类型，总是令人不那么愉快，对不？

#### Rc 简单总结

- `Rc/Arc` 是不可变引用，你无法修改它指向的值，只能进行读取，如果要修改，需要配合后面章节的内部可变性 `RefCell` 或互斥锁 `Mutex`
- 一旦最后一个拥有者消失，则资源会自动被回收，这个生命周期是在编译期就确定下来的
- `Rc` 只能用于同一线程内部，想要用于线程之间的对象共享，你需要使用 `Arc`
- `Rc<T>` 是一个智能指针，实现了 `Deref` 特征，因此你无需先解开 `Rc` 指针，再使用里面的 `T`，而是可以直接使用 `T`，例如上例中的 `gadget1.owner.name`

## 多线程无力的 `Rc<T>`

来看看在多线程场景使用 `Rc<T>` 会如何：

```rust
use std::rc::Rc;
use std::thread;

fn main() {
    let s = Rc::new(String::from("多线程漫游者"));
    for _ in 0..10 {
        let s = Rc::clone(&s);
        let handle = thread::spawn(move || {
           println!("{}", s)
        });
    }
}
```

由于我们还没有学习多线程的章节，上面的例子就特地简化了相关的实现。首先通过 `thread::spawn` 创建一个线程，然后使用 `move` 关键字把克隆出的 `s` 的所有权转移到线程中。

能够实现这一点，完全得益于 `Rc` 带来的多所有权机制，但是以上代码会报错：

```console
error[E0277]: `Rc<String>` cannot be sent between threads safely
```

表面原因是 `Rc<T>` 不能在线程间安全的传递，实际上是因为它没有实现 `Send` 特征，而该特征是恰恰是多线程间传递数据的关键，我们会在多线程章节中进行讲解。

当然，还有更深层的原因：由于 `Rc<T>` 需要管理引用计数，但是该计数器并没有使用任何并发原语，因此无法实现原子化的计数操作，最终会导致计数错误。

好在天无绝人之路，一起来看看 Rust 为我们提供的功能类似但是多线程安全的 `Arc`。

## Arc

`Arc` 是 `Atomic Rc` 的缩写，顾名思义：原子化的 `Rc<T>` 智能指针。原子化是一种并发原语，我们在后续章节会进行深入讲解，这里你只要知道它能保证我们的数据能够安全的在线程间共享即可。

#### Arc 的性能损耗

你可能好奇，为何不直接使用 `Arc`，还要画蛇添足弄一个 `Rc`，还有 Rust 的基本数据类型、标准库数据类型为什么不自动实现原子化操作？这样就不存在线程不安全的问题了。

原因在于原子化或者其它锁虽然可以带来的线程安全，但是都会伴随着性能损耗，而且这种性能损耗还不小。因此 Rust 把这种选择权交给你，毕竟需要线程安全的代码其实占比并不高，大部分时候我们开发的程序都在一个线程内。

`Arc` 和 `Rc` 拥有完全一样的 API，修改起来很简单：

```rust
use std::sync::Arc;
use std::thread;

fn main() {
    let s = Arc::new(String::from("多线程漫游者"));
    for _ in 0..10 {
        let s = Arc::clone(&s);
        let handle = thread::spawn(move || {
           println!("{}", s)
        });
    }
}
```

对了，两者还有一点区别：`Arc` 和 `Rc` 并没有定义在同一个模块，前者通过 `use std::sync::Arc` 来引入，后者通过 `use std::rc::Rc`。

## 总结

在 Rust 中，所有权机制保证了一个数据只会有一个所有者，但如果你想要在图数据结构、多线程等场景中共享数据，这种机制会成为极大的阻碍。好在 Rust 为我们提供了智能指针 `Rc` 和 `Arc`，使用它们就能实现多个所有者共享一个数据的功能。

`Rc` 和 `Arc` 的区别在于，后者是原子化实现的引用计数，因此是线程安全的，可以用于多线程中共享数据。

这两者都是只读的，如果想要实现内部数据可修改，必须配合内部可变性 `RefCell` 或者互斥锁 `Mutex` 来一起使用。



================================================
FILE: src/advance/unsafe/inline-asm.md
================================================
# 内联汇编

> 本章内容对于学习 Rust 不是必须的，而且难度很高，大家简单知道有这回事就好，不必非要学会 :D

Rust 提供了 `asm!` 宏，可以让大家在 Rust 代码中嵌入汇编代码，对于一些极致高性能或者底层的场景还是非常有用的，例如操作系统内核开发。但通常来说，大家并不应该在自己的项目中使用到该项技术，它为极客而生！

本章的例子是基于 `x86/x86-64` 汇编的，但是其它架构也是支持的，目前支持的包括：

- x86 和 x86-64
- ARM
- AArch64
- RISC-V

当使用在不支持的平台上时，编译器会给出报错。



## 基本用法

先从一个简单例子开始：

```rust
use std::arch::asm;

unsafe {
    asm!("nop");
}
```

注意 `unsafe` 语句块依然是必不可少的，因为可能在里面插入危险的指令，最终破坏代码的安全性。

上面代码将插入一个 `NOP` 指令( 空操作 ) 到编译器生成的汇编代码中，其中指令作为 `asm!` 的第一个参数传入。

## 输入和输出

上面的代码有够无聊的，来点实际的:

```rust
use std::arch::asm;

let x: u64;
unsafe {
    asm!("mov {}, 5", out(reg) x);
}
assert_eq!(x, 5);
```

这段代码将 `5` 赋给 `u64` 类型的变量 `x`，值得注意的是 `asm!` 的指令参数实际上是一个格式化字符串。至于传给格式化字符串的参数，看起来还是比较陌生的:

- 首先，需要说明目标变量是作为内联汇编的输入还是输出，在本例中，是一个输出 `out`
- 最后，要指定变量将要使用的寄存器，本例中使用通用寄存器 `reg`，编译器会自动选择合适的寄存器

```rust
use std::arch::asm;

let i: u64 = 3;
let o: u64;
unsafe {
    asm!(
        "mov {0}, {1}",
        "add {0}, 5",
        out(reg) o,
        in(reg) i,
    );
}
assert_eq!(o, 8);
```

上面的代码中进一步使用了输入 `in`，将 `5` 加到输入的变量 `i` 上，然后将结果写到输出变量 `o`。实际的操作方式是首先将 `i` 的值拷贝到输出，然后再加上 `5`。

上例还能看出几点：

- `asm!` 允许使用多个格式化字符串，每一个作为单独一行汇编代码存在，看起来跟阅读真实的汇编代码类似
- 输入变量通过 `in` 来声明
- 和以前见过的格式化字符串一样，可以使用多个参数，通过 {0}, {1} 来指定，这种方式特别有用，毕竟在代码中，变量是经常复用的，而这种参数的指定方式刚好可以复用

事实上，还可以进一步优化代码，去掉 `mov` 指令:

```rust
use std::arch::asm;

let mut x: u64 = 3;
unsafe {
    asm!("add {0}, 5", inout(reg) x);
}
assert_eq!(x, 8);
```

又多出一个 `inout` 关键字，但是不难猜，它说明 `x` 即是输入又是输出。与之前的分离方式还有一点很大的区别，这种方式可以保证使用同一个寄存器来完成任务。

当然，你可以在使用 `inout` 的情况下，指定不同的输入和输出:

```rust
use std::arch::asm;

let x: u64 = 3;
let y: u64;
unsafe {
    asm!("add {0}, 5", inout(reg) x => y);
}
assert_eq!(y, 8);
```

## 延迟输出操作数

Rust 编译器对于操作数分配是较为保守的，它会假设 `out` 可以在任何时间被写入，因此 `out` 不会跟其它参数共享它的位置。然而为了保证最佳性能，使用尽量少的寄存器是有必要的，这样它们不必在内联汇编的代码块内保存和重加载。

为了达成这个目标( 共享位置或者说寄存器，以实现减少寄存器使用的性能优化 )，Rust 提供一个 `lateout` 关键字，可以用于任何只在所有输入被消费后才被写入的输出，与之类似的还有一个 `inlateout`。

但是 `inlateout` 在某些场景中是无法使用的，例如下面的例子：

```rust
use std::arch::asm;

let mut a: u64 = 4;
let b: u64 = 4;
let c: u64 = 4;
unsafe {
    asm!(
        "add {0}, {1}",
        "add {0}, {2}",
        inout(reg) a,
        in(reg) b,
        in(reg) c,
    );
}
assert_eq!(a, 12);
```

一旦用了 `inlateout` 后，上面的代码就只能运行在 `Debug` 模式下，原因是 `Debug` 并没有做任何优化，但是 `release` 发布不同，为了性能是要做很多编译优化的。

在编译优化时，编译器可以很容易的为输入 `b` 和 `c` 分配同样的是寄存器，因为它知道它们有同样的值。如果这里使用 `inlateout`， 那么 `a` 和 `c` 就可以被分配到相同的寄存器，在这种情况下，第一条指令将覆盖掉 `c` 的值，最终导致汇编代码产生错误的结果。

因此这里使用 `inout`，那么编译器就会为 `a` 分配一个独立的寄存器.

但是下面的代码又不同，它是可以使用 `inlateout` 的：

```rust
use std::arch::asm;

let mut a: u64 = 4;
let b: u64 = 4;
unsafe {
    asm!("add {0}, {1}", inlateout(reg) a, in(reg) b);
}
assert_eq!(a, 8);
```

原因在于输出只有在所有寄存器都被读取后，才被修改。因此，即使 `a` 和 `b` 被分配了同样的寄存器，代码也会正常工作，不存在之前的覆盖问题。

## 显式指定寄存器

一些指令会要求操作数只能存在特定的寄存器中，因此 Rust 的内联汇编提供了一些限制操作符。

大家应该记得之前出现过的 `reg` 是适用于任何架构的通用寄存器，意味着编译器可以自己选择合适的寄存器，但是当你需要显式地指定寄存器时，很可能会变成平台相关的代码，适用移植性会差很多。例如 `x86` 下的寄存器：`eax`, `ebx`, `ecx`, `ebp`, `esi` 等等。

```rust
use std::arch::asm;

let cmd = 0xd1;
unsafe {
    asm!("out 0x64, eax", in("eax") cmd);
}
```

上面的例子调用 `out` 指令将 `cmd` 变量的值输出到 `0x64` 内存地址中。由于 `out` 指令只接收 `eax` 和它的子寄存器，因此我们需要使用 `eax` 来指定特定的寄存器。

> 显式寄存器操作数无法用于格式化字符串中，例如我们之前使用的 {}，只能直接在字符串中使用 `eax`。同时，该操作数只能出现在最后，也就是在其它操作数后面出现

```rust
use std::arch::asm;

fn mul(a: u64, b: u64) -> u128 {
    let lo: u64;
    let hi: u64;

    unsafe {
        asm!(
            // The x86 mul instruction takes rax as an implicit input and writes
            // the 128-bit result of the multiplication to rax:rdx.
            "mul {}",
            in(reg) a,
            inlateout("rax") b => lo,
            lateout("rdx") hi
        );
    }

    ((hi as u128) << 64) + lo as u128
}
```

这段代码使用了 `mul` 指令，将两个 64 位的输入相乘，生成一个 128 位的结果。

首先将变量 `a` 的值存到寄存器 `reg` 中，其次显式使用寄存器 `rax`，它的值来源于变量 `b`。结果的低 64 位存储在 `rax` 中，然后赋给变量 `lo` ，而结果的高 64 位则存在 `rdx` 中，最后赋给 `hi`。

## Clobbered 寄存器

在很多情况下，无需作为输出的状态都会被内联汇编修改，这个状态被称之为 "clobbered"。

我们需要告诉编译器相关的情况，因为编译器需要在内联汇编语句块的附近存储和恢复这种状态。

```rust
use std::arch::asm;

fn main() {
    // three entries of four bytes each
    let mut name_buf = [0_u8; 12];
    // String is stored as ascii in ebx, edx, ecx in order
    // Because ebx is reserved, the asm needs to preserve the value of it.
    // So we push and pop it around the main asm.
    // (in 64 bit mode for 64 bit processors, 32 bit processors would use ebx)

    unsafe {
        asm!(
            "push rbx",
            "cpuid",
            "mov [rdi], ebx",
            "mov [rdi + 4], edx",
            "mov [rdi + 8], ecx",
            "pop rbx",
            // We use a pointer to an array for storing the values to simplify
            // the Rust code at the cost of a couple more asm instructions
            // This is more explicit with how the asm works however, as opposed
            // to explicit register outputs such as `out("ecx") val`
            // The *pointer itself* is only an input even though it's written behind
            in("rdi") name_buf.as_mut_ptr(),
            // select cpuid 0, also specify eax as clobbered
            inout("eax") 0 => _,
            // cpuid clobbers these registers too
            out("ecx") _,
            out("edx") _,
        );
    }

    let name = core::str::from_utf8(&name_buf).unwrap();
    println!("CPU Manufacturer ID: {}", name);
}
```

例子中，我们使用了`cpuid` 指令。这个指令会将CPU的最大cpuid参数写入`eax`中，同时将CPU的生厂商ID以ASCII字符的形式写入到 `ebx` 、`edx` 和 `ecx` 中。

即使 `eax` 从没有被读取，我们依然需要告知编译器这个寄存器被修改过，这样编译器就可以在执行汇编之前存储寄存器中的值。这个需要通过将输出声明为 `_` 而不是一个具体的变量名，代表着该输出值被丢弃。

这段代码也会绕过一个限制： `ebx` 是一个 LLVM 保留寄存器，意味着 LLVM 会假设它拥有寄存器的全部控制权，并在汇编代码块结束时将寄存器的状态恢复到最开始的状态。由于这个限制，该寄存器无法被用于输入或者输出，除非编译器使用该寄存器的满足一个通用寄存器的需求(例如 `in(reg)` )。 但这样使用后， `reg` 操作数就在使用保留寄存器时变得危险起来，原因是我们可能会无意识的破坏输入或者输出，毕竟它们共享同一个寄存器。

为了解决这个问题，我们使用 `rdi` 来存储指向输出数组的指针，通过 `push` 的方式存储 `ebx`：在汇编代码块的内部读取 `ebx` 的值，然后写入到输出数组。后面再可以通过 `pop` 的方式来回复 `ebx` 到初始的状态。

`push` 和 `pop` 使用完成的 64 位 `rbx` 寄存器，来确保整个寄存器的内容都被保存。如果是在 32 位机器上，代码将使用 `ebx` 替代。

还可以在汇编代码内部使用通用寄存器:

```rust
use std::arch::asm;

// Multiply x by 6 using shifts and adds
let mut x: u64 = 4;
unsafe {
    asm!(
        "mov {tmp}, {x}",
        "shl {tmp}, 1",
        "shl {x}, 2",
        "add {x}, {tmp}",
        x = inout(reg) x,
        tmp = out(reg) _,
    );
}
assert_eq!(x, 4 * 6);
```


## 总结

由于这块儿内容过于专业，本书毕竟是通用的 Rust 学习书籍，因此关于内联汇编就不再赘述。事实上，如果你要真的写出可用的汇编代码，要学习的还很多...

感兴趣的同学可以看看如下英文资料: [Rust Reference](https://doc.rust-lang.org/reference/inline-assembly.html) 和 [Rust By Example](https://doc.rust-lang.org/rust-by-example/unsafe/asm.html#clobbered-registers)。



================================================
FILE: src/advance/unsafe/intro.md
================================================
[Binary file]


================================================
FILE: src/advance/unsafe/superpowers.md
================================================
[Binary file]


================================================
FILE: src/advance/unsafe/ub.md
================================================
# 那些会导致UB的代码

https://www.reddit.com/r/rust/comments/rp44u5/request_for_unsafe_review/


================================================
FILE: src/advance-practice/async.md
================================================
# 深入 Tokio 背后的异步原理

在经过多个章节的深入学习后，Tokio 对我们来说不再是一座隐于云雾中的高山，它其实蛮简单好用的，甚至还有一丝丝的可爱!?

但从现在开始，如果想要进一步的深入 Tokio ，首先需要深入理解 `async` 的原理，其实我们在[之前的章节](https://course.rs/async/intro.html)已经深入学习过，这里结合 Tokio 再来回顾下。

## Future

先来回顾一下 `async fn` 异步函数 :

```rust
use tokio::net::TcpStream;

async fn my_async_fn() {
    println!("hello from async");
    // 通过 .await 创建 socket 连接
    let _socket = TcpStream::connect("127.0.0.1:3000").await.unwrap();
    println!("async TCP operation complete");
    // 关闭socket
}
```

接着对它进行调用获取一个返回值，再在返回值上调用 `.await`：

```rust
#[tokio::main]
async fn main() {
    let what_is_this = my_async_fn();
    // 上面的调用不会产生任何效果

    // ... 执行一些其它代码


    what_is_this.await;
    // 直到 .await 后，文本才被打印，socket 连接也被创建和关闭
}
```

在上面代码中 `my_async_fn` 函数为何可以惰性执行( 直到 .await 调用时才执行)？秘密就在于 `async fn` 声明的函数返回一个 `Future`。

`Future` 是一个实现了 [`std::future::Future`](https://doc.rust-lang.org/std/future/trait.Future.html) 特征的值，该值包含了一系列异步计算过程，而这个过程直到 `.await` 调用时才会被执行。

`std::future::Future` 的定义如下所示:

```rust
use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    fn poll(self: Pin<&mut Self>, cx: &mut Context)
        -> Poll<Self::Output>;
}
```

代码中有几个关键点：

- [关联类型](https://course.rs/basic/trait/advance-trait.html#关联类型) `Output` 是 `Future` 执行完成后返回的值的类型
- `Pin` 类型是在异步函数中进行借用的关键，在[这里](https://course.rs/advance/async/pin-unpin.html)有非常详细的介绍

和其它语言不同，Rust 中的 `Future` 不代表一个发生在后台的计算，而是 `Future` 就代表了计算本身，因此
`Future` 的所有者有责任去推进该计算过程的执行，例如通过 `Future::poll` 函数。听上去好像还挺复杂？但是大家不必担心，因为这些都在 Tokio 中帮你自动完成了 :)

#### 实现 Future

下面来一起实现个五脏俱全的 `Future`，它将：1. 等待某个特定时间点的到来 2. 在标准输出打印文本 3. 生成一个字符串

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::{Duration, Instant};

struct Delay {
    when: Instant,
}

// 为我们的 Delay 类型实现 Future 特征
impl Future for Delay {
    type Output = &'static str;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>)
        -> Poll<&'static str>
    {
        if Instant::now() >= self.when {
            // 时间到了，Future 可以结束
            println!("Hello world");
            // Future 执行结束并返回 "done" 字符串
            Poll::Ready("done")
        } else {
            // 目前先忽略下面这行代码
            cx.waker().wake_by_ref();
            Poll::Pending
        }
    }
}

#[tokio::main]
async fn main() {
    let when = Instant::now() + Duration::from_millis(10);
    let future = Delay { when };

    // 运行并等待 Future 的完成
    let out = future.await;

    // 判断 Future 返回的字符串是否是 "done"
    assert_eq!(out, "done");
}
```

以上代码很清晰的解释了如何自定义一个 `Future`，并指定它如何通过 `poll` 一步一步执行，直到最终完成返回 `"done"` 字符串。

#### async fn 作为 Future

大家有没有注意到，上面代码我们在 `main` 函数中初始化一个 `Future` 并使用 `.await` 对其进行调用执行，如果你是在 `fn main` 中这么做，是会报错的。

原因是 `.await` 只能用于 `async fn` 函数中，因此我们将 `main` 函数声明成 `async fn main` 同时使用 `#[tokio::main]` 进行了标注，此时 `async fn main` 生成的代码类似下面：

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::{Duration, Instant};

enum MainFuture {
    // 初始化，但永远不会被 poll
    State0,
    // 等待 `Delay` 运行，例如 `future.await` 代码行
    State1(Delay),
    // Future 执行完成
    Terminated,
}

impl Future for MainFuture {
    type Output = ();

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>)
        -> Poll<()>
    {
        use MainFuture::*;

        loop {
            match *self {
                State0 => {
                    let when = Instant::now() +
                        Duration::from_millis(10);
                    let future = Delay { when };
                    *self = State1(future);
                }
                State1(ref mut my_future) => {
                    match Pin::new(my_future).poll(cx) {
                        Poll::Ready(out) => {
                            assert_eq!(out, "done");
                            *self = Terminated;
                            return Poll::Ready(());
                        }
                        Poll::Pending => {
                            return Poll::Pending;
                        }
                    }
                }
                Terminated => {
                    panic!("future polled after completion")
                }
            }
        }
    }
}
```

可以看出，编译器会将 `Future` 变成状态机， 其中 `MainFuture` 包含了 `Future` 可能处于的状态：从 `State0` 状态开始，当 `poll` 被调用时， `Future` 会尝试去尽可能的推进内部的状态，若它可以被完成时，就会返回 `Poll::Ready`，其中还会包含最终的输出结果。

若 `Future` 无法被完成，例如它所等待的资源还没有准备好，此时就会返回 `Poll::Pending`，该返回值会通知调用者： `Future` 会在稍后才能完成。

同时可以看到：当一个 `Future` 由其它 `Future` 组成时，调用外层 `Future` 的 `poll` 函数会同时调用一次内部 `Future` 的 `poll` 函数。

## 执行器( Excecutor )

`async fn` 返回 `Future` ，而后者需要通过被不断的 `poll` 才能往前推进状态，同时该 `Future` 还能包含其它 `Future` ，那么问题来了谁来负责调用最外层 `Future` 的 `poll` 函数？

回一下之前的内容，为了运行一个异步函数，我们必须使用 `tokio::spawn` 或 通过 `#[tokio::main]` 标注的 `async fn main` 函数。它们有一个非常重要的作用：将最外层 `Future` 提交给 Tokio 的执行器。该执行器负责调用 `poll` 函数，然后推动 `Future` 的执行，最终直至完成。

#### mini tokio

为了更好理解相关的内容，我们一起来实现一个迷你版本的 Tokio，完整的代码见[这里](https://github.com/tokio-rs/website/blob/master/tutorial-code/mini-tokio/src/main.rs)。

先来看一段基础代码:

```rust
use std::collections::VecDeque;
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::{Duration, Instant};
use futures::task;

fn main() {
    let mut mini_tokio = MiniTokio::new();

    mini_tokio.spawn(async {
        let when = Instant::now() + Duration::from_millis(10);
        let future = Delay { when };

        let out = future.await;
        assert_eq!(out, "done");
    });

    mini_tokio.run();
}

struct MiniTokio {
    tasks: VecDeque<Task>,
}

type Task = Pin<Box<dyn Future<Output = ()> + Send>>;

impl MiniTokio {
    fn new() -> MiniTokio {
        MiniTokio {
            tasks: VecDeque::new(),
        }
    }

    /// 生成一个 Future并放入 mini-tokio 实例的任务队列中
    fn spawn<F>(&mut self, future: F)
    where
        F: Future<Output = ()> + Send + 'static,
    {
        self.tasks.push_back(Box::pin(future));
    }

    fn run(&mut self) {
        let waker = task::noop_waker();
        let mut cx = Context::from_waker(&waker);

        while let Some(mut task) = self.tasks.pop_front() {
            if task.as_mut().poll(&mut cx).is_pending() {
                self.tasks.push_back(task);
            }
        }
    }
}
```

以上代码运行了一个 `async` 语句块 `mini_tokio.spawn(async {...})`， 还创建了一个 `Delay` 实例用于等待所需的时间。看上去相当不错，但这个实现有一个 **重大缺陷**：我们的执行器永远也不会休眠。执行器会持续的循环遍历所有的 `Future` ，然后不停的 `poll` 它们，但是事实上，大多数 `poll` 都是没有用的，因为此时 `Future` 并没有准备好，因此会继续返回 `Poll::Pending` ，最终这个循环遍历会让你的 CPU 疲于奔命，真打工人！

鉴于此，我们的 mini-tokio 只应该在 `Future` 准备好可以进一步运行后，才去 `poll` 它，例如该 `Future` 之前阻塞等待的**资源**已经准备好并可以被使用了，就可以对其进行 `poll`。再比如，如果一个 `Future` 任务在阻塞等待从 TCP socket 中读取数据，那我们只想在 `socket` 中有数据可以读取后才去 `poll` 它，而不是没事就 `poll` 着玩。

回到上面的代码中，mini-tokio 只应该当任务的延迟时间到了后，才去 `poll` 它。 为了实现这个功能，我们需要 `通知 -> 运行` 机制：当任务可以进一步被推进运行时，它会主动通知执行器，然后执行器再来 `poll`。

## Waker

一切的答案都在 `Waker` 中，资源可以用它来通知正在等待的任务：该资源已经准备好，可以继续运行了。

再来看下 `Future::poll` 的定义：

```rust
fn poll(self: Pin<&mut Self>, cx: &mut Context)
    -> Poll<Self::Output>;
```

`Context` 参数中包含有 `waker()`方法。该方法返回一个绑定到当前任务上的 `Waker`，然后 `Waker` 上定义了一个 `wake()` 方法，用于通知执行器相关的任务可以继续执行。

准确来说，当 `Future` 阻塞等待的资源已经准备好时(例如 socket 中有了可读取的数据)，该资源可以调用 `wake()` 方法，来通知执行器可以继续调用该 `Future` 的 `poll` 函数来推进任务的执行。

#### 发送 wake 通知

现在，为 `Delay` 添加下 `Waker` 支持：

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::{Duration, Instant};
use std::thread;

struct Delay {
    when: Instant,
}

impl Future for Delay {
    type Output = &'static str;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>)
        -> Poll<&'static str>
    {
        if Instant::now() >= self.when {
            println!("Hello world");
            Poll::Ready("done")
        } else {
            // 为当前任务克隆一个 waker 的句柄
            let waker = cx.waker().clone();
            let when = self.when;

            // 生成一个计时器线程
            thread::spawn(move || {
                let now = Instant::now();

                if now < when {
                    thread::sleep(when - now);
                }

                waker.wake();
            });

            Poll::Pending
        }
    }
}
```

此时，计时器用来模拟一个阻塞等待的资源，一旦计时结束(该资源已经准备好)，资源会通过 `waker.wake()` 调用通知执行器我们的任务再次被调度执行了。

当然，现在的实现还较为粗糙，等会我们会来进一步优化，在此之前，先来看看如何监听这个 `wake` 通知。

> 当 Future 会返回 `Poll::Pending` 时，一定要确保 `wake` 能被正常调用，否则会导致任务永远被挂起，再也不会被执行器 `poll`。
>
> **忘记在返回 `Poll::Pending` 时调用 `wake` 是很多难以发现 bug 的潜在源头！**

再回忆下最早实现的 `Delay` 代码：

```rust
impl Future for Delay {
    type Output = &'static str;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>)
        -> Poll<&'static str>
    {
        if Instant::now() >= self.when {
            // 时间到了，Future 可以结束
            println!("Hello world");
            // Future 执行结束并返回 "done" 字符串
            Poll::Ready("done")
        } else {
            // 目前先忽略下面这行代码
            cx.waker().wake_by_ref();
            Poll::Pending
        }
    }
}
```

在返回 `Poll::Pending` 之前，先调用了 `cx.waker().wake_by_ref()` ，由于此时我们还没有模拟计时资源，因此这里直接调用了 `wake` 进行通知，这样做会导致当前的 `Future` 被立即再次调度执行。

由此可见，这种通知的控制权是在你手里的，甚至可以像上面代码这样，还没准备好资源，就直接进行 `wake` 通知，但是总归意义不大，而且浪费了 CPU，因为这种 `执行 -> 立即通知再调度 -> 执行` 的方式会造成一个非常繁忙的循环。

#### 处理 wake 通知

下面，让我们更新 mini-tokio 服务，让它能接收 wake 通知：当 `waker.wake()` 被调用后，相关联的任务会被放入执行器的队列中，然后等待执行器的调用执行。

为了实现这一点，我们将使用消息通道来排队存储这些被唤醒并等待调度的任务。有一点需要注意，从消息通道接收消息的线程(执行器所在的线程)和发送消息的线程（唤醒任务时所在的线程）可能是不同的，因此消息( `Waker` )必须要实现 `Send`和 `Sync`，才能跨线程使用。

> 关于 `Send` 和 `Sync` 的具体讲解见[这里](https://course.rs/advance/concurrency-with-threads/send-sync.html)

基于以上理由，选择 `std::sync::mpsc`  重新实现 `MiniTokio` 结构体：

```rust
use std::sync::mpsc;
use std::sync::Arc;

struct MiniTokio {
    scheduled: mpsc::Receiver<Arc<Task>>,
    sender: mpsc::Sender<Arc<Task>>,
}

struct Task {
    // 先空着，后面会填充代码
}
```

`Waker` 实现了 `Sync` 特征，同时还可以被克隆，当 `wake` 被调用时，任务就会被调度执行。

为了实现上述的目的，我们引入了消息通道，当 `waker.wake()` 函数被调用时，任务会被发送到该消息通道中:

```rust
use std::sync::{Arc, Mutex};

struct Task {
    // `Mutex` 是为了让 `Task` 实现 `Sync` 特征，它能保证同一时间只有一个线程可以访问 `Future`。
    // 事实上 `Mutex` 并没有在 Tokio 中被使用，这里我们只是为了简化： Tokio 的真实代码实在太长了 :D
    future: Mutex<Pin<Box<dyn Future<Output = ()> + Send>>>,
    executor: mpsc::Sender<Arc<Task>>,
}

impl Task {
    fn schedule(self: &Arc<Self>) {
        self.executor.send(self.clone());
    }
}
```

接下来，我们需要让 `std::task::Waker` 能准确的找到所需的调度函数 关联起来，对此标准库中提供了一个底层的 API [`std::task::RawWakerVTable`](https://doc.rust-lang.org/std/task/struct.RawWakerVTable.html) 可以用于手动的访问 `vtable`，这种实现提供了最大的灵活性，但是需要大量 `unsafe` 的代码。

因此我们选择更加高级的实现：由 `futures` 包提供的 [`ArcWake`](https://docs.rs/futures/0.3.19/futures/task/trait.ArcWake.html) 特征，只要简单实现该特征，就可以将我们的 `Task` 转变成一个 `waker`。在 `Cargo.toml` 中添加以下包：

```toml
futures = "0.3"
```

然后为我们的任务 `Task` 实现 `ArcWake`:

```rust
use futures::task::{self, ArcWake};
use std::sync::Arc;
impl ArcWake for Task {
    fn wake_by_ref(arc_self: &Arc<Self>) {
        arc_self.schedule();
    }
}
```

当之前的计时器线程调用 `waker.wake()` 时，所在的任务会被推入到消息通道中。因此接下来，我们需要实现接收端的功能，然后 `MiniTokio::run()` 函数中执行该任务:

```rust
impl MiniTokio {
    // 从消息通道中接收任务，然后通过 poll 来执行
    fn run(&self) {
        while let Ok(task) = self.scheduled.recv() {
            task.poll();
        }
    }

    /// 初始化一个新的 mini-tokio 实例
    fn new() -> MiniTokio {
        let (sender, scheduled) = mpsc::channel();

        MiniTokio { scheduled, sender }
    }


    /// 在下面函数中，通过参数传入的 future 被 `Task` 包裹起来，然后会被推入到调度队列中，当 `run` 被调用时，该 future 将被执行
    fn spawn<F>(&self, future: F)
    where
        F: Future<Output = ()> + Send + 'static,
    {
        Task::spawn(future, &self.sender);
    }
}

impl Task {
    fn poll(self: Arc<Self>) {
        // 基于 Task 实例创建一个 waker, 它使用了之前的 `ArcWake`
        let waker = task::waker(self.clone());
        let mut cx = Context::from_waker(&waker);

        // 没有其他线程在竞争锁时，我们将获取到目标 future
        let mut future = self.future.try_lock().unwrap();

        // 对 future 进行 poll
        let _ = future.as_mut().poll(&mut cx);
    }

    // 使用给定的 future 来生成新的任务
    //
    // 新的任务会被推到 `sender` 中，接着该消息通道的接收端就可以获取该任务，然后执行
    fn spawn<F>(future: F, sender: &mpsc::Sender<Arc<Task>>)
    where
        F: Future<Output = ()> + Send + 'static,
    {
        let task = Arc::new(Task {
            future: Mutex::new(Box::pin(future)),
            executor: sender.clone(),
        });

        let _ = sender.send(task);
    }

}
```

首先，我们实现了 `MiniTokio::run()` 函数，它会持续从消息通道中接收被唤醒的任务，然后通过 `poll` 来推动其继续执行。

其次，`MiniTokio::new()` 和 `MiniTokio::spawn()` 使用了消息通道而不是一个 `VecDeque` 。当新任务生成后，这些任务中会携带上消息通道的发送端，当任务中的资源准备就绪时，会使用该发送端将该任务放入消息通道的队列中，等待执行器 `poll`。

`Task::poll()` 函数使用 `futures` 包提供的 `ArcWake` 创建了一个 `waker`，后者可以用来创建 `task::Context`，最终该 `Context` 会被传给执行器调用的 `poll` 函数。

> 注意，Task::poll 和执行器调用的 poll 是完全不同的，大家别搞混了

## 一些遗留问题

至此，我们的程序已经差不多完成，还剩几个遗留问题需要解决下。

#### 在异步函数中生成异步任务

之前实现 `Delay Future` 时，我们提到有几个问题需要解决。Rust 的异步模型允许一个 Future 在执行过程中可以跨任务迁移:

```rust
use futures::future::poll_fn;
use std::future::Future;
use std::pin::Pin;

#[tokio::main]
async fn main() {
    let when = Instant::now() + Duration::from_millis(10);
    let mut delay = Some(Delay { when });

    poll_fn(move |cx| {
        let mut delay = delay.take().unwrap();
        let res = Pin::new(&mut delay).poll(cx);
        assert!(res.is_pending());
        tokio::spawn(async move {
            delay.await;
        });

        Poll::Ready(())
    }).await;
}
```

首先，`poll_fn` 函数使用闭包创建了一个 `Future`，其次，上面代码还创建一个 `Delay` 实例，然后在闭包中，对其进行了一次 `poll` ，接着再将该 `Delay` 实例发送到一个新的任务，在此任务中使用 `.await` 进行了执行。

在例子中，`Delay:poll` 被调用了不止一次，且使用了不同的 `Waker` 实例，在这种场景下，你必须确保调用最近一次 `poll` 函数中的 `Waker` 参数中的`wake`方法。也就是调用最内层 `poll` 函数参数( `Waker` )上的 `wake` 方法。

当实现一个 `Future` 时，很关键的一点就是要假设每次 `poll` 调用都会应用到一个不同的 `Waker` 实例上。因此 `poll` 函数必须要使用一个新的 `waker` 去更新替代之前的 `waker`。

我们之前的 `Delay` 实现中，会在每一次 `poll` 调用时都生成一个新的线程。这么做问题不大，但是当 `poll` 调用较多时会出现明显的性能问题！一个解决方法就是记录你是否已经生成了一个线程，然后只有在没有生成时才去创建一个新的线程。但是一旦这么做，就必须确保线程的 `Waker` 在后续 `poll` 调用中被正确更新，否则你无法唤醒最近的 `Waker` ！

这一段大家可能会看得云里雾里的，没办法，原文就绕来绕去，好在终于可以看代码了。。我们可以通过代码来解决疑惑：

```rust
use std::future::Future;
use std::pin::Pin;
use std::sync::{Arc, Mutex};
use std::task::{Context, Poll, Waker};
use std::thread;
use std::time::{Duration, Instant};

struct Delay {
    when: Instant,
    // 用于说明是否已经生成一个线程
    // Some 代表已经生成， None 代表还没有
    waker: Option<Arc<Mutex<Waker>>>,
}

impl Future for Delay {
    type Output = ();

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
        // 若这是 Future 第一次被调用，那么需要先生成一个计时器线程。
        // 若不是第一次调用(该线程已在运行)，那要确保已存储的 `Waker` 跟当前任务的 `waker` 匹配
        if let Some(waker) = &self.waker {
            let mut waker = waker.lock().unwrap();

            // 检查之前存储的 `waker` 是否跟当前任务的 `waker` 相匹配.
            // 这是必要的，原因是 `Delay Future` 的实例可能会在两次 `poll` 之间被转移到另一个任务中，然后
            // 存储的 waker 被该任务进行了更新。
            // 这种情况一旦发生，`Context` 包含的 `waker` 将不同于存储的 `waker`。
            // 因此我们必须对存储的 `waker` 进行更新
            if !waker.will_wake(cx.waker()) {
                *waker = cx.waker().clone();
            }
        } else {
            let when = self.when;
            let waker = Arc::new(Mutex::new(cx.waker().clone()));
            self.waker = Some(waker.clone());

            // 第一次调用 `poll`，生成计时器线程
            thread::spawn(move || {
                let now = Instant::now();

                if now < when {
                    thread::sleep(when - now);
                }

                // 计时结束，通过调用 `waker` 来通知执行器
                let waker = waker.lock().unwrap();
                waker.wake_by_ref();
            });
        }

        // 一旦 waker 被存储且计时器线程已经开始，我们就需要检查 `delay` 是否已经完成
        // 若计时已完成，则当前 Future 就可以完成并返回 `Poll::Ready`
        if Instant::now() >= self.when {
            Poll::Ready(())
        } else {
            // 计时尚未结束，Future 还未完成，因此返回 `Poll::Pending`.
            //
            // `Future` 特征要求当 `Pending` 被返回时，那我们要确保当资源准备好时，必须调用 `waker` 以通
            // 知执行器。 在我们的例子中，会通过生成的计时线程来保证
            //
            // 如果忘记调用 waker， 那等待我们的将是深渊：该任务将被永远的挂起，无法再执行
            Poll::Pending
        }
    }
}
```

这着实有些复杂(原文。。)，但是简单来看就是：在每次 `poll` 调用时，都会检查 `Context` 中提供的 `waker` 和我们之前记录的 `waker` 是否匹配。若匹配，就什么都不用做，若不匹配，那之前存储的就必须进行更新。

#### Notify

我们之前证明了如何用手动编写的 `waker` 来实现 `Delay Future`。 `Waker` 是 Rust 异步编程的基石，因此绝大多数时候，我们并不需要直接去使用它。例如，在 `Delay` 的例子中， 可以使用 [`tokio::sync::Notify`](https://docs.rs/tokio/1.16.0/tokio/sync/struct.Notify.html) 去实现。

该 `Notify` 提供了一个基础的任务通知机制，它会处理这些 `waker` 的细节，包括确保两次 `waker` 的匹配:

```rust
use tokio::sync::Notify;
use std::sync::Arc;
use std::time::{Duration, Instant};
use std::thread;

async fn delay(dur: Duration) {
    let when = Instant::now() + dur;
    let notify = Arc::new(Notify::new());
    let notify2 = notify.clone();

    thread::spawn(move || {
        let now = Instant::now();

        if now < when {
            thread::sleep(when - now);
        }

        notify2.notify_one();
    });


    notify.notified().await;
}
```

当使用 `Notify` 后，我们就可以轻松的实现如上的 `delay` 函数。

## 总结

在看完这么长的文章后，我们来总结下，否则大家可能还会遗忘:

- 在 Rust 中，`async` 是惰性的，直到执行器 `poll` 它们时，才会开始执行
- `Waker` 是 `Future` 被执行的关键，它可以链接起 `Future` 任务和执行器
- 当资源没有准备时，会返回一个 `Poll::Pending`
- 当资源准备好时，会通过 `waker.wake` 发出通知
- 执行器会收到通知，然后调度该任务继续执行，此时由于资源已经准备好，因此任务可以顺利往前推进了



================================================
FILE: src/advance-practice/bridging-with-sync.md
================================================
# 异步跟同步共存

一些异步程序例如 tokio 指南 章节中的绝大多数例子，它们整个程序都是异步的，包括程序入口 `main` 函数：

```rust
#[tokio::main]
async fn main() {
    println!("Hello world");
}
```

在一些场景中，你可能只想在异步程序中运行一小部分同步代码，这种需求可以考虑下 [`spawn_blocking`](https://docs.rs/tokio/1.16.1/tokio/task/fn.spawn_blocking.html)。

但是在很多场景中，我们只想让程序的某一个部分成为异步的，也许是因为同步代码更好实现，又或许是同步代码可读性、兼容性都更好。例如一个 `GUI` 应用可能想要让 `UI` 相关的代码在主线程中，然后通过另一个线程使用 `tokio` 的运行时来处理一些异步任务。

因此本章节的目标很纯粹：如何在同步代码中使用一小部分异步代码。

## `#[tokio::main]` 的展开

在 Rust 中， `main` 函数不能是异步的，有同学肯定不愿意了，我们在之前章节..不对，就在开头，你还用到了 `async fn main` 的声明方式，怎么就不能异步了呢？

其实，`#[tokio::main]` 该宏仅仅是提供语法糖，目的是让大家可以更简单、更一致的去写异步代码，它会将你写下的`async fn main` 函数替换为：

```rust
fn main() {
    tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()
        .unwrap()
        .block_on(async {
            println!("Hello world");
        })
}
```

注意到上面的 `block_on` 方法了嘛？在我们自己的同步代码中，可以使用它开启一个 `async/await` 世界。

## mini-redis 的同步接口

在下面，我们将一起构建一个同步的 `mini-redis` ，为了实现这一点，需要将 `Runtime` 对象存储起来，然后利用上面提到的 `block_on` 方法。

首先，创建一个文件 `src/blocking_client.rs`，然后使用下面代码将异步的 `Client` 结构体包裹起来:

```rust
use tokio::net::ToSocketAddrs;
use tokio::runtime::Runtime;

pub use crate::client::Message;

/// 建立到 redis 服务端的连接
pub struct BlockingClient {
    /// 之前实现的异步客户端 `Client`
    inner: crate::client::Client,

    /// 一个 `current_thread` 模式的 `tokio` 运行时，
    /// 使用阻塞的方式来执行异步客户端 `Client` 上的操作
    rt: Runtime,
}

pub fn connect<T: ToSocketAddrs>(addr: T) -> crate::Result<BlockingClient> {
    // 构建一个 tokio 运行时： Runtime
    let rt = tokio::runtime::Builder::new_current_thread()
        .enable_all()
        .build()?;

    // 使用运行时来调用异步的连接方法
    let inner = rt.block_on(crate::client::connect(addr))?;

    Ok(BlockingClient { inner, rt })
}
```

在这里，我们使用了一个构造器函数用于在同步代码中执行异步的方法：使用 `Runtime` 上的 `block_on` 方法来执行一个异步方法并返回结果。

有一个很重要的点，就是我们还使用了 [`current_thread`](https://docs.rs/tokio/1.16.1/tokio/runtime/struct.Builder.html#method.new_current_thread) 模式的运行时。这个可不常见，原因是异步程序往往要利用多线程的威力来实现更高的吞吐性能，相对应的模式就是 [`multi_thread`](https://docs.rs/tokio/1.16.1/tokio/runtime/struct.Builder.html#method.new_multi_thread)，该模式会生成多个运行在后台的线程，它们可以高效的实现多个任务的同时并行处理。

但是对于我们的使用场景来说，在同一时间点只需要做一件事，无需并行处理，多个线程并不能帮助到任何事情，因此 `current_thread` 此时成为了最佳的选择。

在构建 `Runtime` 的过程中还有一个 [`enable_all`](https://docs.rs/tokio/1.16.1/tokio/runtime/struct.Builder.html#method.enable_all) 方法调用，它可以开启 `Tokio` 运行时提供的 IO 和定时器服务。

> 由于 `current_thread` 运行时并不生成新的线程，只是运行在已有的主线程上，因此只有当 `block_on` 被调用后，该运行时才能执行相应的操作。一旦 `block_on` 返回，那运行时上所有生成的任务将再次冻结，直到 `block_on` 的再次调用。
>
> 如果这种模式不符合使用场景的需求，那大家还是需要用 `multi_thread` 运行时来代替。事实上，在 tokio 之前的章节中，我们默认使用的就是 `multi_thread` 模式。

```rust
use bytes::Bytes;
use std::time::Duration;

impl BlockingClient {
    pub fn get(&mut self, key: &str) -> crate::Result<Option<Bytes>> {
        self.rt.block_on(self.inner.get(key))
    }

    pub fn set(&mut self, key: &str, value: Bytes) -> crate::Result<()> {
        self.rt.block_on(self.inner.set(key, value))
    }

    pub fn set_expires(
        &mut self,
        key: &str,
        value: Bytes,
        expiration: Duration,
    ) -> crate::Result<()> {
        self.rt.block_on(self.inner.set_expires(key, value, expiration))
    }

    pub fn publish(&mut self, channel: &str, message: Bytes) -> crate::Result<u64> {
        self.rt.block_on(self.inner.publish(channel, message))
    }
}
```

这代码看上去挺长，实际上很简单，通过 `block_on` 将异步形式的 `Client` 的方法变成同步调用的形式。例如 `BlockingClient` 的 `get` 方法实际上是对内部的异步 `get` 方法的同步调用。

与上面的平平无奇相比，下面的代码将更有趣，因为它将 `Client` 转变成一个 `Subscriber` 对象:

```rust
/// 下面的客户端可以进入 pub/sub (发布/订阅) 模式
///
/// 一旦客户端订阅了某个消息通道，那就只能执行 pub/sub 相关的命令。
/// 将`BlockingClient` 类型转换成 `BlockingSubscriber` 是为了防止非 `pub/sub` 方法被调用
pub struct BlockingSubscriber {
    /// 异步版本的 `Subscriber`
    inner: crate::client::Subscriber,

    /// 一个 `current_thread` 模式的 `tokio` 运行时，
    /// 使用阻塞的方式来执行异步客户端 `Client` 上的操作
    rt: Runtime,
}

impl BlockingClient {
    pub fn subscribe(self, channels: Vec<String>) -> crate::Result<BlockingSubscriber> {
        let subscriber = self.rt.block_on(self.inner.subscribe(channels))?;
        Ok(BlockingSubscriber {
            inner: subscriber,
            rt: self.rt,
        })
    }
}

impl BlockingSubscriber {
    pub fn get_subscribed(&self) -> &[String] {
        self.inner.get_subscribed()
    }

    pub fn next_message(&mut self) -> crate::Result<Option<Message>> {
        self.rt.block_on(self.inner.next_message())
    }

    pub fn subscribe(&mut self, channels: &[String]) -> crate::Result<()> {
        self.rt.block_on(self.inner.subscribe(channels))
    }

    pub fn unsubscribe(&mut self, channels: &[String]) -> crate::Result<()> {
        self.rt.block_on(self.inner.unsubscribe(channels))
    }
}
```

由上可知，`subscribe` 方法会使用运行时将一个异步的 `Client` 转变成一个异步的 `Subscriber`，此外，`Subscriber` 结构体有一个非异步的方法 `get_subscribed`，对于这种方法，只需直接调用即可，而无需使用运行时。

## 其它方法

上面介绍的是最简单的方法，但是，如果只有这一种， tokio 也不会如此大名鼎鼎。

#### runtime.spawn

可以通过 `Runtime` 的 `spawn` 方法来创建一个基于该运行时的后台任务：

```rust
use tokio::runtime::Builder;
use tokio::time::{sleep, Duration};

fn main() {
    let runtime = Builder::new_multi_thread()
        .worker_threads(1)
        .enable_all()
        .build()
        .unwrap();

    let mut handles = Vec::with_capacity(10);
    for i in 0..10 {
        handles.push(runtime.spawn(my_bg_task(i)));
    }

    // 在后台任务运行的同时做一些耗费时间的事情
    std::thread::sleep(Duration::from_millis(750));
    println!("Finished time-consuming task.");

    // 等待这些后台任务的完成
    for handle in handles {
        // `spawn` 方法返回一个 `JoinHandle`，它是一个 `Future`，因此可以通过  `block_on` 来等待它完成
        runtime.block_on(handle).unwrap();
    }
}

async fn my_bg_task(i: u64) {
    let millis = 1000 - 50 * i;
    println!("Task {} sleeping for {} ms.", i, millis);

    sleep(Duration::from_millis(millis)).await;

    println!("Task {} stopping.", i);
}
```

运行该程序，输出如下:

```console
Task 0 sleeping for 1000 ms.
Task 1 sleeping for 950 ms.
Task 2 sleeping for 900 ms.
Task 3 sleeping for 850 ms.
Task 4 sleeping for 800 ms.
Task 5 sleeping for 750 ms.
Task 6 sleeping for 700 ms.
Task 7 sleeping for 650 ms.
Task 8 sleeping for 600 ms.
Task 9 sleeping for 550 ms.
Task 9 stopping.
Task 8 stopping.
Task 7 stopping.
Task 6 stopping.
Finished time-consuming task.
Task 5 stopping.
Task 4 stopping.
Task 3 stopping.
Task 2 stopping.
Task 1 stopping.
Task 0 stopping.
```

在此例中，我们生成了 10 个后台任务在运行时中运行，然后等待它们的完成。作为一个例子，想象一下在图形渲染应用( GUI )中，有时候需要通过网络访问远程服务来获取一些数据，那上面的这种模式就非常适合，因为这些网络访问比较耗时，而且不会影响图形的主体渲染，因此可以在主线程中渲染图形，然后使用其它线程来运行 Tokio 的运行时，并通过该运行时使用异步的方式完成网络访问，最后将这些网络访问的结果发送到 GUI 进行数据渲染，例如一个进度条。

还有一点很重要，在本例子中只能使用 `multi_thread` 运行时。如果我们使用了 `current_thread`，你会发现主线程的耗时任务会在后台任务开始之前就完成了。因为在 `current_thread` 模式下，生成的任务只会在 `block_on` 期间才执行。

在 `multi_thread` 模式下，我们并不需要通过 `block_on` 来触发任务的运行，这里仅仅是用来阻塞并等待最终的结果。而除了通过 `block_on` 等待结果外，你还可以：

- 使用消息传递的方式，例如 `tokio::sync::mpsc`，让异步任务将结果发送到主线程，然后主线程通过 `.recv`方法等待这些结果
- 通过共享变量的方式，例如 `Mutex`，这种方式非常适合实现 GUI 的进度条: GUI 在每个渲染帧读取该变量即可。

#### 发送消息

在同步代码中使用异步的另一个方法就是生成一个运行时，然后使用消息传递的方式跟它进行交互。这个方法虽然更啰嗦一些，但是相对于之前的两种方法更加灵活：

```rust
use tokio::runtime::Builder;
use tokio::sync::mpsc;

pub struct Task {
    name: String,
    // 一些信息用于描述该任务
}

async fn handle_task(task: Task) {
    println!("Got task {}", task.name);
}

#[derive(Clone)]
pub struct TaskSpawner {
    spawn: mpsc::Sender<Task>,
}

impl TaskSpawner {
    pub fn new() -> TaskSpawner {
        // 创建一个消息通道用于通信
        let (send, mut recv) = mpsc::channel(16);

        let rt = Builder::new_current_thread()
            .enable_all()
            .build()
            .unwrap();

        std::thread::spawn(move || {
            rt.block_on(async move {
                while let Some(task) = recv.recv().await {
                    tokio::spawn(handle_task(task));
                }

                // 一旦所有的发送端超出作用域被 drop 后，`.recv()` 方法会返回 None，同时 while 循环会退出，然后线程结束
            });
        });

        TaskSpawner {
            spawn: send,
        }
    }

    pub fn spawn_task(&self, task: Task) {
        match self.spawn.blocking_send(task) {
            Ok(()) => {},
            Err(_) => panic!("The shared runtime has shut down."),
        }
    }
}
```

为何说这种方法比较灵活呢？以上面代码为例，它可以在很多方面进行配置。例如，可以使用信号量 [`Semaphore`](https://docs.rs/tokio/1.16.1/tokio/sync/struct.Semaphore.html)来限制当前正在进行的任务数，或者你还可以使用一个消息通道将消息反向发送回任务生成器 `spawner`。

抛开细节，抽象来看，这是不是很像一个 Actor ？



================================================
FILE: src/advance-practice/channels.md
================================================
[Binary file]


================================================
FILE: src/advance-practice/design-pattern.md
================================================
# Rust 设计模式


https://github.com/rust-unofficial/patterns


================================================
FILE: src/advance-practice/frame.md
================================================
[Binary file]


================================================
FILE: src/advance-practice/getting-startted.md
================================================
[Binary file]


================================================
FILE: src/advance-practice/graceful-shutdown.md
================================================
# 优雅的关闭

如果你的服务是一个小说阅读网站，那大概率用不到优雅关闭的，简单粗暴的关闭服务器，然后用户再次请求时获取一个错误就是了。但如果是一个 web 服务或数据库服务呢？当前的连接很可能在做着重要的事情，一旦关闭会导致数据的丢失甚至错误，此时，我们就需要优雅的关闭(graceful shutdown)了。

要让一个异步应用优雅的关闭往往需要做到 3 点：

- 找出合适的关闭时机
- 通知程序的每一个子部分开始关闭
- 在主线程等待各个部分的关闭结果

在本文的下面部分，我们一起来看看该如何做到这三点。如果想要进一步了解在真实项目中该如何使用，大家可以看看 mini-redis 的完整代码实现，特别是 [`src/server.rs`](https://github.com/tokio-rs/mini-redis/blob/master/src/server.rs) 和 [`src/shutdown.rs`](https://github.com/tokio-rs/mini-redis/blob/master/src/shutdown.rs)。

## 找出合适的关闭时机

一般来说，何时关闭是取决于应用自身的，但是一个常用的关闭准则就是当应用收到来自于操作系统的关闭信号时。例如通过 `ctrl + c` 来关闭正在运行的命令行程序。

为了检测来自操作系统的关闭信号，`Tokio` 提供了一个 `tokio::signal::ctrl_c` 函数，它将一直睡眠直到收到对应的信号:

```rust
use tokio::signal;

#[tokio::main]
async fn main() {
    // ... spawn application as separate task ...
    // 在一个单独的任务中处理应用逻辑

    match signal::ctrl_c().await {
        Ok(()) => {},
        Err(err) => {
            eprintln!("Unable to listen for shutdown signal: {}", err);
        },
    }

    //  发送关闭信号给应用所在的任务，然后等待
}
```

## 通知程序的每一个部分开始关闭

大家看到这个标题，不知道会想到用什么技术来解决问题，反正我首先想到的是，真的很像广播哎。。

事实上也是如此，最常见的通知程序各个部分关闭的方式就是使用一个广播消息通道。关于如何实现，其实也不复杂：应用中的每个任务都持有一个广播消息通道的接收端，当消息被广播到该通道时，每个任务都可以收到该消息，并关闭自己:

```rust
let next_frame = tokio::select! {
    res = self.connection.read_frame() => res?,
    _ = self.shutdown.recv() => {
        // 当收到关闭信号后，直接从 `select!` 返回，此时 `select!` 中的另一个分支会自动释放，其中的任务也会结束
        return Ok(());
    }
};
```

在 `mini-redis` 中，当收到关闭消息时，任务会立即结束，但在实际项目中，这种方式可能会过于理想，例如当我们向文件或数据库写入数据时，立刻终止任务可能会导致一些无法预料的错误，因此，在结束前做一些收尾工作会是非常好的选择。

除此之外，还有两点值得注意:

- 将广播消息通道作为结构体的一个字段是相当不错的选择, 例如[这个例子](https://github.com/tokio-rs/mini-redis/blob/master/src/shutdown.rs)
- 还可以使用 [`watch channel`](https://docs.rs/tokio/1.16.1/tokio/sync/watch/index.html) 实现同样的效果，与之前的方式相比，这两种方法并没有太大的区别

## 等待各个部分的结束

在之前章节，我们讲到过一个 [`mpsc`](https://docs.rs/tokio/1/tokio/sync/mpsc/index.html) 消息通道有一个重要特性：当所有发送端都 `drop` 时，消息通道会自动关闭，此时继续接收消息就会报错。

大家发现没？这个特性特别适合优雅关闭的场景：主线程持有消息通道的接收端，然后每个代码部分拿走一个发送端，当该部分结束时，就 `drop` 掉发送端，因此所有发送端被 `drop` 也就意味着所有的部分都已关闭，此时主线程的接收端就会收到错误，进而结束。

```rust
use tokio::sync::mpsc::{channel, Sender};
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    let (send, mut recv) = channel(1);

    for i in 0..10 {
        tokio::spawn(some_operation(i, send.clone()));
    }

    // 等待各个任务的完成
    //
    // 我们需要 drop 自己的发送端，因为等下的 `recv()` 调用会阻塞, 如果不 `drop` ，那发送端就无法被全部关闭
    // `recv` 也将永远无法结束，这将陷入一个类似死锁的困境
    drop(send);

    // 当所有发送端都超出作用域被 `drop` 时 (当前的发送端并不是因为超出作用域被 `drop` 而是手动 `drop` 的)
    // `recv` 调用会返回一个错误
    let _ = recv.recv().await;
}

async fn some_operation(i: u64, _sender: Sender<()>) {
    sleep(Duration::from_millis(100 * i)).await;
    println!("Task {} shutting down.", i);

    // 发送端超出作用域，然后被 `drop`
}
```

关于忘记 `drop` 本身持有的发送端进而导致 bug 的问题，大家可以看看[这篇文章](https://course.rs/compiler/pitfalls/main-with-channel-blocked.html)。



================================================
FILE: src/advance-practice/intro.md
================================================
# 进阶实战: 实现一个简单 redis

在入门实战，你可以说众览半山不咋小，但是能坚持到这里，甚至当完成后，就真的是一览众山小，余敌皆鱼虾了。

在进阶实战中，我们要来真的了，之前的简单命令行程序，是真的简单，但是这次的简单 redis 是真的不简单，在这里你将被迫使用十八般武艺，特别的，我们还将学会 Rust 异步镇山之宝 `tokio` 包的使用。


> 本章在内容上大量借鉴和翻译了 tokio 官方文档[Tokio Tutorial](https://tokio.rs/tokio/tutorial), 但是重新组织了内容形式并融入了很多自己的见解和感悟，给大家提供更好的可读性和知识扩展性




================================================
FILE: src/advance-practice/io.md
================================================
# I/O

本章节中我们将深入学习 Tokio 中的 I/O 操作，了解它的原理以及该如何使用。

Tokio 中的 I/O 操作和 `std` 在使用方式上几无区别，最大的区别就是前者是异步的，例如 Tokio 的读写特征分别是 `AsyncRead` 和 `AsyncWrite`:

- 有部分类型按照自己的所需实现了它们: `TcpStream`，`File`，`Stdout`
- 还有数据结构也实现了它们：`Vec<u8>`、`&[u8]`，这样就可以直接使用这些数据结构作为读写器( reader / writer)

## AsyncRead 和 AsyncWrite

这两个特征为字节流的异步读写提供了便利，通常我们会使用 `AsyncReadExt` 和 `AsyncWriteExt` 提供的工具方法，这些方法都使用 `async` 声明，且需要通过 `.await` 进行调用，

#### async fn read

`AsyncReadExt::read` 是一个异步方法可以将数据读入缓冲区( `buffer` )中，然后返回读取的字节数。

```rust
use tokio::fs::File;
use tokio::io::{self, AsyncReadExt};

#[tokio::main]
async fn main() -> io::Result<()> {
    let mut f = File::open("foo.txt").await?;
    let mut buffer = [0; 10];

    // 由于 buffer 的长度限制，当次的 `read` 调用最多可以从文件中读取 10 个字节的数据
    let n = f.read(&mut buffer[..]).await?;

    println!("The bytes: {:?}", &buffer[..n]);
    Ok(())
}
```

需要注意的是：当 `read` 返回 `Ok(0)` 时，意味着字节流( stream )已经关闭，在这之后继续调用 `read` 会立刻完成，依然获取到返回值 `Ok(0)`。 例如，字节流如果是 `TcpStream` 类型，那 `Ok(0)` 说明该**连接的读取端已经被关闭**(写入端关闭，会报其它的错误)。

#### async fn read_to_end

`AsyncReadExt::read_to_end` 方法会从字节流中读取所有的字节，直到遇到 `EOF` ：

```rust
use tokio::io::{self, AsyncReadExt};
use tokio::fs::File;

#[tokio::main]
async fn main() -> io::Result<()> {
    let mut f = File::open("foo.txt").await?;
    let mut buffer = Vec::new();

    // 读取整个文件的内容
    f.read_to_end(&mut buffer).await?;
    Ok(())
}
```

#### async fn write

`AsyncWriteExt::write` 异步方法会尝试将缓冲区的内容写入到写入器( `writer` )中，同时返回写入的字节数:

```rust
use tokio::io::{self, AsyncWriteExt};
use tokio::fs::File;

#[tokio::main]
async fn main() -> io::Result<()> {
    let mut file = File::create("foo.txt").await?;

    let n = file.write(b"some bytes").await?;

    println!("Wrote the first {} bytes of 'some bytes'.", n);
    Ok(())
}
```

上面代码很清晰，但是大家可能会疑惑 `b"some bytes"` 是什么意思。这种写法可以将一个 `&str` 字符串转变成一个字节数组：`&[u8;10]`，然后 `write` 方法又会将这个 `&[u8;10]` 的数组类型隐式强转为数组切片: `&[u8]`。

#### async fn write_all

`AsyncWriteExt::write_all` 将缓冲区的内容全部写入到写入器中：

```rust
use tokio::io::{self, AsyncWriteExt};
use tokio::fs::File;

#[tokio::main]
async fn main() -> io::Result<()> {
    let mut file = File::create("foo.txt").await?;

    file.write_all(b"some bytes").await?;
    Ok(())
}
```

以上只是部分方法，实际上还有一些实用的方法由于篇幅有限无法列出，大家可以通过 [API 文档](https://docs.rs/tokio/latest/tokio/io/index.html) 查看完整的列表。

## 实用函数

另外，和标准库一样， `tokio::io` 模块包含了多个实用的函数或 API，可以用于处理标准输入/输出/错误等。

例如，`tokio::io::copy` 异步的将读取器( `reader` )中的内容拷贝到写入器( `writer` )中。

```rust
use tokio::fs::File;
use tokio::io;

#[tokio::main]
async fn main() -> io::Result<()> {
    let mut reader: &[u8] = b"hello";
    let mut file = File::create("foo.txt").await?;

    io::copy(&mut reader, &mut file).await?;
    Ok(())
}
```

还记得我们之前提到的字节数组 `&[u8]` 实现了 `AsyncRead` 吗？正因为这个原因，所以这里可以直接将 `&u8` 用作读取器。

## 回声服务( Echo )

就如同写代码必写 `hello, world`，实现 web 服务器，往往会选择实现一个回声服务。该服务会将用户的输入内容直接返回给用户，就像回声壁一样。

具体来说，就是从用户建立的 TCP 连接的 socket 中读取到数据，然后立刻将同样的数据写回到该 socket 中。因此客户端会收到和自己发送的数据一模一样的回复。

下面我们将使用两种稍有不同的方法实现该回声服务。

#### 使用 `io::copy()`

先来创建一个新的 bin 文件，用于运行我们的回声服务：

```console
touch src/bin/echo-server-copy.rs
```

然后可以通过以下命令运行它(跟上一章节的方式相同)：

```console
cargo run --bin echo-server-copy
```

至于客户端，可以简单的使用 `telnet` 的方式来连接，或者也可以使用 `tokio::net::TcpStream`，它的[文档示例](https://docs.rs/tokio/1/tokio/net/struct.TcpStream.html#examples)非常适合大家进行参考。

先来实现一下基本的服务器框架：通过 loop 循环接收 TCP 连接，然后为每一条连接创建一个单独的任务去处理。

```rust
use tokio::io;
use tokio::net::TcpListener;

#[tokio::main]
async fn main() -> io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:6142").await?;

    loop {
        let (mut socket, _) = listener.accept().await?;

        tokio::spawn(async move {
            // 在这里拷贝数据
        });
    }
}
```

下面，来看看重头戏 `io::copy` ，它有两个参数：一个读取器，一个写入器，然后将读取器中的数据直接拷贝到写入器中，类似的实现代码如下：

```rust
io::copy(&mut socket, &mut socket).await
```

这段代码相信大家一眼就能看出问题，由于我们的读取器和写入器都是同一个 socket，因此需要对其进行两次可变借用，这明显违背了 Rust 的借用规则。

##### 分离读写器

显然，使用同一个 socket 是不行的，为了实现目标功能，必须将 `socket` 分离成一个读取器和写入器。

任何一个读写器( reader + writer )都可以使用 `io::split` 方法进行分离，最终返回一个读取器和写入器，这两者可以独自的使用，例如可以放入不同的任务中。

例如，我们的回声客户端可以这样实现，以实现同时并发读写：

```rust
use tokio::io::{self, AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpStream;

#[tokio::main]
async fn main() -> io::Result<()> {
    let socket = TcpStream::connect("127.0.0.1:6142").await?;
    let (mut rd, mut wr) = io::split(socket);

    // 创建异步任务，在后台写入数据
    tokio::spawn(async move {
        wr.write_all(b"hello\r\n").await?;
        wr.write_all(b"world\r\n").await?;

        // 有时，我们需要给予 Rust 一些类型暗示，它才能正确的推导出类型
        Ok::<_, io::Error>(())
    });

    let mut buf = vec![0; 128];

    loop {
        let n = rd.read(&mut buf).await?;

        if n == 0 {
            break;
        }

        println!("GOT {:?}", &buf[..n]);
    }

    Ok(())
}
```

实际上，`io::split` 可以用于任何同时实现了 `AsyncRead` 和 `AsyncWrite` 的值，它的内部使用了 `Arc` 和 `Mutex` 来实现相应的功能。如果大家觉得这种实现有些重，可以使用 Tokio 提供的 `TcpStream`，它提供了两种方式进行分离:

- [`TcpStream::split`](https://docs.rs/tokio/1.15.0/tokio/net/struct.TcpStream.html#method.split)会获取字节流的引用，然后将其分离成一个读取器和写入器。但由于使用了引用的方式，它们俩必须和 `split` 在同一个任务中。 优点就是，这种实现没有性能开销，因为无需 `Arc` 和 `Mutex`。
- [`TcpStream::into_split`](https://docs.rs/tokio/1.15.0/tokio/net/struct.TcpStream.html#method.into_split)还提供了一种分离实现，分离出来的结果可以在任务间移动，内部是通过 `Arc` 实现

再来分析下我们的使用场景，由于 `io::copy()` 调用时所在的任务和 `split` 所在的任务是同一个，因此可以使用性能最高的 `TcpStream::split`:

```rust
tokio::spawn(async move {
    let (mut rd, mut wr) = socket.split();

    if io::copy(&mut rd, &mut wr).await.is_err() {
        eprintln!("failed to copy");
    }
});
```

使用 `io::copy` 实现的完整代码见[此处](https://github.com/tokio-rs/website/blob/master/tutorial-code/io/src/echo-server-copy.rs)。

#### 手动拷贝

程序员往往拥有一颗手动干翻一切的心，因此如果你不想用 `io::copy` 来简单实现，还可以自己手动去拷贝数据:

```rust
use tokio::io::{self, AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpListener;

#[tokio::main]
async fn main() -> io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:6142").await?;

    loop {
        let (mut socket, _) = listener.accept().await?;

        tokio::spawn(async move {
            let mut buf = vec![0; 1024];

            loop {
                match socket.read(&mut buf).await {
                    // 返回值 `Ok(0)` 说明对端已经关闭
                    Ok(0) => return,
                    Ok(n) => {
                        // Copy the data back to socket
                        // 将数据拷贝回 socket 中
                        if socket.write_all(&buf[..n]).await.is_err() {
                            // 非预期错误，由于我们这里无需再做什么，因此直接停止处理
                            return;
                        }
                    }
                    Err(_) => {
                      // 非预期错误，由于我们无需再做什么，因此直接停止处理
                        return;
                    }
                }
            }
        });
    }
}
```

建议这段代码放入一个和之前 `io::copy` 不同的文件中 `src/bin/echo-server.rs` ， 然后使用 `cargo run --bin echo-server` 运行。

下面一起来看看这段代码有哪些值得注意的地方。首先，由于使用了 `write_all` 和 `read` 方法，需要先将对应的特征引入到当前作用域内:

```rust
use tokio::io::{self, AsyncReadExt, AsyncWriteExt};
```

##### 在堆上分配缓冲区

在上面代码中，我们需要将数据从 `socket` 中读取到一个缓冲区 `buffer` 中：

```rust
let mut buf = vec![0; 1024];
```

可以看到，此处的缓冲区是一个 `Vec` 动态数组，它的数据是存储在堆上，而不是栈上(若改成 `let mut buf = [0; 1024];`，则存储在栈上)。

在之前，我们提到过一个数据如果想在 `.await` 调用过程中存在，那它必须存储在当前任务内。在我们的代码中，`buf` 会在 `.await` 调用过程中被使用，因此它必须要存储在任务内。

若该缓冲区数组创建在栈上，那每条连接所对应的任务的内部数据结构看上去可能如下所示：

```rust
struct Task {
    task: enum {
        AwaitingRead {
            socket: TcpStream,
            buf: [BufferType],
        },
        AwaitingWriteAll {
            socket: TcpStream,
            buf: [BufferType],
        }

    }
}
```

可以看到，栈数组要被使用，就必须存储在相应的结构体内，其中两个结构体分别持有了不同的栈数组 `[BufferType]`，这种方式会导致任务结构变得很大。特别地，我们选择缓冲区长度往往会使用分页长度(page size)，因此使用栈数组会导致任务的内存大小变得很奇怪甚至糟糕：`$page-size + 一些额外的字节`。

当然，编译器会帮助我们做一些优化。例如，会进一步优化 `async` 语句块的布局，而不是像上面一样简单的使用 `enum`。在实践中，变量也不会在枚举成员间移动。

但是再怎么优化，任务的结构体至少也会跟其中的栈数组一样大，因此通常情况下，使用堆上的缓冲区会高效实用的多。

> 当任务因为调度在线程间移动时，存储在栈上的数据需要进行保存和恢复，过大的栈上变量会带来不小的数据拷贝开销
>
> 因此，存储大量数据的变量最好放到堆上

##### 处理 EOF

当 TCP 连接的读取端关闭后，再调用 `read` 方法会返回 `Ok(0)`。此时，再继续下去已经没有意义，因此我们需要退出循环。忘记在 EOF 时退出读取循环，是网络编程中一个常见的 bug :

```rust
loop {
    match socket.read(&mut buf).await {
        Ok(0) => return,
        // ... 其余错误处理
    }
}
```

大家不妨深入思考下，如果没有退出循环会怎么样？之前我们提到过，一旦读取端关闭后，那后面的 `read` 调用就会立即返回 `Ok(0)`，而不会阻塞等待，因此这种无阻塞循环会最终导致 CPU 立刻跑到 100% ，并将一直持续下去，直到程序关闭。




================================================
FILE: src/advance-practice/overview.md
================================================
# tokio 概览

对于 Async Rust，最最重要的莫过于底层的异步运行时，它提供了执行器、任务调度、异步 API 等核心服务。简单来说，使用 Rust 提供的 `async/await` 特性编写的异步代码要运行起来，就必须依赖于异步运行时，否则这些代码将毫无用处。

## 异步运行时

Rust 语言本身只提供了异步编程所需的基本特性，例如 `async/await` 关键字，标准库中的 `Future` 特征，官方提供的 `futures` 实用库，这些特性单独使用没有任何用处，因此我们需要一个运行时来将这些特性实现的代码运行起来。

异步运行时是由 Rust 社区提供的，它们的核心是一个 `reactor` 和一个或多个 `executor`(执行器):

- `reactor` 用于提供外部事件的订阅机制，例如 `I/O` 、进程间通信、定时器等
- `executor` 在上一章我们有过深入介绍，它用于调度和执行相应的任务( `Future` )

目前最受欢迎的几个运行时有:

- [`tokio`](https://github.com/tokio-rs/tokio)，目前最受欢迎的异步运行时，功能强大，还提供了异步所需的各种工具(例如 tracing )、网络协议框架(例如 HTTP，gRPC )等等
- [`async-std`](https://github.com/async-rs/async-std)，最大的优点就是跟标准库兼容性较强
- [`smol`](https://github.com/smol-rs/smol), 一个小巧的异步运行时

但是，大浪淘沙，留下的才是金子，随着时间的流逝，`tokio`越来越亮眼，无论是性能、功能还是社区、文档，它在各个方面都异常优秀，时至今日，可以说已成为事实上的标准。

#### 异步运行时的兼容性

为何选择异步运行时这么重要？不仅仅是它们在功能、性能上存在区别，更重要的是当你选择了一个，往往就无法切换到另外一个，除非异步代码很少。

使用异步运行时，往往伴随着对它相关的生态系统的深入使用，因此耦合性会越来越强，直至最后你很难切换到另一个运行时，例如 `tokio` 和 `async-std` ，就存在这种问题。

如果你实在有这种需求，可以考虑使用 [`async-compat`](https://github.com/smol-rs/async-compat)，该包提供了一个中间层，用于兼容 `tokio` 和其它运行时。

#### 结论

相信大家看到现在，心中应该有一个结论了。首先，运行时之间的不兼容性，让我们必须提前选择一个运行时，并且在未来坚持用下去，那这个运行时就应该是最优秀、最成熟的那个，`tokio` 几乎成了不二选择，当然 `tokio` 也有自己的问题：更难上手和运行时之间的兼容性。

如果你只用 `tokio` ，那兼容性自然不是问题，至于难以上手，Rust 这么难，我们都学到现在了，何况区区一个异步运行时，在本书的帮助下，这些都不再是问题：）

## tokio 简介

tokio 是一个纸醉金迷之地，只要有钱就可以为所欲为，哦，抱歉，走错片场了。`tokio` 是 Rust 最优秀的异步运行时框架，它提供了写异步网络服务所需的几乎所有功能，不仅仅适用于大型服务器，还适用于小型嵌入式设备，它主要由以下组件构成：

- 多线程版本的异步运行时，可以运行使用 `async/await` 编写的代码
- 标准库中阻塞 API 的异步版本，例如`thread::sleep`会阻塞当前线程，`tokio`中就提供了相应的异步实现版本
- 构建异步编程所需的生态，甚至还提供了 [`tracing`](https://github.com/tokio-rs/tracing) 用于日志和分布式追踪， 提供 [`console`](https://github.com/tokio-rs/console) 用于 Debug 异步编程

### 优势

下面一起来看看使用 `tokio` 能给你提供哪些优势。

**高性能**

因为快所以快，前者是 Rust 快，后者是 `tokio` 快。 `tokio` 在编写时充分利用了 Rust 提供的各种零成本抽象和高性能特性，而且贯彻了 Rust 的牛逼思想：如果你选择手写代码，那么最好的结果就是跟 `tokio` 一样快！

以下是一张官方提供的性能参考图，大致能体现出 `tokio` 的性能之恐怖:
<img alt="tokio performance" src="https://pica.zhimg.com/80/v2-5f5ca10550ec936427c2919191331ae8_1440w.png" class="center"  />

**高可靠**

Rust 语言的安全可靠性顺理成章的影响了 `tokio` 的可靠性，曾经有一个调查给出了令人乍舌的[结论](https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/)：软件系统 70%的高危漏洞都是由内存不安全性导致的。

在 Rust 提供的安全性之外，`tokio` 还致力于提供一致性的行为表现：无论你何时运行系统，它的预期表现和性能都是一致的，例如不会出现莫名其妙的请求延迟或响应时间大幅增加。

**简单易用**

通过 Rust 提供的 `async/await` 特性，编写异步程序的复杂性相比当初已经大幅降低，同时 `tokio` 还为我们提供了丰富的生态，进一步大幅降低了其复杂性。

同时 `tokio` 遵循了标准库的命名规则，让熟悉标准库的用户可以很快习惯于 `tokio` 的语法，再借助于 Rust 强大的类型系统，用户可以轻松地编写和交付正确的代码。

**使用灵活性**

`tokio` 支持你灵活的定制自己想要的运行时，例如你可以选择多线程 + 任务盗取模式的复杂运行时，也可以选择单线程的轻量级运行时。总之，几乎你的每一种需求在 `tokio` 中都能寻找到支持(画外音：强大的灵活性需要一定的复杂性来换取，并不是免费的午餐)。

### 劣势

虽然 `tokio` 对于大多数需要并发的项目都是非常适合的，但是确实有一些场景它并不适合使用:

- **并行运行 CPU 密集型的任务**。`tokio` 非常适合于 IO 密集型任务，这些 IO 任务的绝大多数时间都用于阻塞等待 IO 的结果，而不是刷刷刷的单烤 CPU。如果你的应用是 CPU 密集型(例如并行计算)，建议使用 [`rayon`](https://github.com/rayon-rs/rayon)，当然，对于其中的 IO 任务部分，你依然可以混用 `tokio`
- **读取大量的文件**。读取文件的瓶颈主要在于操作系统，因为 OS 没有提供异步文件读取接口，大量的并发并不会提升文件读取的并行性能，反而可能会造成不可忽视的性能损耗，因此建议使用线程(或线程池)的方式
- **发送少量 HTTP 请求**。`tokio` 的优势是给予你并发处理大量任务的能力，对于这种轻量级 HTTP 请求场景，`tokio` 除了增加你的代码复杂性，并无法带来什么额外的优势。因此，对于这种场景，你可以使用 [`reqwest`](https://github.com/seanmonstar/reqwest) 库，它会更加简单易用。


> 若大家使用 tokio，那 CPU 密集的任务尤其需要用线程的方式去处理，例如使用 `spawn_blocking` 创建一个阻塞的线程去完成相应 CPU 密集任务。
>
> 原因是：tokio 是协作式的调度器，如果某个 CPU 密集的异步任务是通过 tokio 创建的，那理论上来说，该异步任务需要跟其它的异步任务交错执行，最终大家都得到了执行，皆大欢喜。但实际情况是，CPU 密集的任务很可能会一直霸着着 CPU，此时 tokio 的调度方式决定了该任务会一直被执行，这意味着，其它的异步任务无法得到执行的机会，最终这些任务都会因为得不到资源而饿死。
>
> 而使用 `spawn_blocking` 后，会创建一个单独的 OS 线程，该线程并不会被 tokio 所调度( 被 OS 所调度 )，因此它所执行的 CPU 密集任务也不会导致 tokio 调度的那些异步任务被饿死


## 总结

离开第三方开源社区提供的异步运行时， `async/await` 什么都不是，甚至还不如一堆破铜烂铁，除非你选择根据自己的需求手撸一个。

而 `tokio` 就是那颗皇冠上的夜明珠，也是值得我们投入时间去深入学习的开源库，它的设计原理和代码实现都异常优秀，在之后的章节中，我们将对其进行深入学习和剖析，敬请期待。




================================================
FILE: src/advance-practice/select.md
================================================
# select!

在实际使用时，一个重要的场景就是同时等待多个异步操作的结果，并且对其结果进行进一步处理，在本章节，我们来看看，强大的 `select!` 是如何帮助咱们更好的控制多个异步操作并发执行的。

## tokio::select!

`select!` 允许同时等待多个计算操作，然后当其中一个操作完成时就退出等待:

```rust
use tokio::sync::oneshot;

#[tokio::main]
async fn main() {
    let (tx1, rx1) = oneshot::channel();
    let (tx2, rx2) = oneshot::channel();

    tokio::spawn(async {
        let _ = tx1.send("one");
    });

    tokio::spawn(async {
        let _ = tx2.send("two");
    });

    tokio::select! {
        val = rx1 => {
            println!("rx1 completed first with {:?}", val);
        }
        val = rx2 => {
            println!("rx2 completed first with {:?}", val);
        }
    }

    // 任何一个 select 分支结束后，都会继续执行接下来的代码
}
```

这里用到了两个 `oneshot` 消息通道，虽然两个操作的创建在代码上有先后顺序，但在实际执行时却不这样。因此， `select` 在从两个通道**阻塞等待**接收消息时，`rx1` 和 `rx2` 都有可能被先打印出来。

需要注意，任何一个 `select` 分支完成后，都会继续执行后面的代码，没被执行的分支会被丢弃( `dropped` )。

#### 取消

对于 `Async Rust` 来说，释放( drop )掉一个 `Future` 就意味着取消任务。从上一章节可以得知， `async` 操作会返回一个 `Future`，而后者是惰性的，直到被 `poll` 调用时，才会被执行。一旦 `Future` 被释放，那操作将无法继续，因为所有相关的状态都被释放。

对于 Tokio 的 `oneshot` 的接收端来说，它在被释放时会发送一个关闭通知到发送端，因此发送端可以通过释放任务的方式来终止正在执行的任务。

```rust
use tokio::sync::oneshot;

async fn some_operation() -> String {
    // 在这里执行一些操作...
}

#[tokio::main]
async fn main() {
    let (mut tx1, rx1) = oneshot::channel();
    let (tx2, rx2) = oneshot::channel();

    tokio::spawn(async {
        // 等待 `some_operation` 的完成
        // 或者处理 `oneshot` 的关闭通知
        tokio::select! {
            val = some_operation() => {
                let _ = tx1.send(val);
            }
            _ = tx1.closed() => {
                // 收到了发送端发来的关闭信号
                // `select` 即将结束，此时，正在进行的 `some_operation()` 任务会被取消，任务自动完成，
                // tx1 被释放
            }
        }
    });

    tokio::spawn(async {
        let _ = tx2.send("two");
    });

    tokio::select! {
        val = rx1 => {
            println!("rx1 completed first with {:?}", val);
        }
        val = rx2 => {
            println!("rx2 completed first with {:?}", val);
        }
    }
}
```

上面代码的重点就在于 `tx1.closed` 所在的分支，一旦发送端被关闭，那该分支就会被执行，然后 `select` 会退出，并清理掉还没执行的第一个分支 `val = some_operation()` ，这其中 `some_operation` 返回的 `Future` 也会被清理，根据之前的内容，`Future` 被清理那相应的任务会立即取消，因此 `some_operation` 会被取消，不再执行。

#### Future 的实现

为了更好的理解 `select` 的工作原理，我们来看看如果使用 `Future` 该如何实现。当然，这里是一个简化版本，在实际中，`select!` 会包含一些额外的功能，例如一开始会随机选择一个分支进行 `poll`。

```rust
use tokio::sync::oneshot;
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

struct MySelect {
    rx1: oneshot::Receiver<&'static str>,
    rx2: oneshot::Receiver<&'static str>,
}

impl Future for MySelect {
    type Output = ();

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
        if let Poll::Ready(val) = Pin::new(&mut self.rx1).poll(cx) {
            println!("rx1 completed first with {:?}", val);
            return Poll::Ready(());
        }

        if let Poll::Ready(val) = Pin::new(&mut self.rx2).poll(cx) {
            println!("rx2 completed first with {:?}", val);
            return Poll::Ready(());
        }

        Poll::Pending
    }
}

#[tokio::main]
async fn main() {
    let (tx1, rx1) = oneshot::channel();
    let (tx2, rx2) = oneshot::channel();

    // 使用 tx1 和 tx2

    MySelect {
        rx1,
        rx2,
    }.await;
}
```

`MySelect` 包含了两个分支中的 `Future`，当它被 `poll` 时，第一个分支会先执行。如果执行完成，那取出的值会被使用，然后 `MySelect` 也随之结束。而另一个分支对应的 `Future` 会被释放掉，对应的操作也会被取消。

还记得上一章节中很重要的一段话吗？

> 当一个 `Future` 返回 `Poll::Pending` 时，它必须确保会在某一个时刻通过 `Waker` 来唤醒，不然该 `Future` 将永远地被挂起

但是仔细观察我们之前的代码，里面并没有任何的 `wake` 调用！事实上，这是因为参数 `cx` 被传入了内层的 `poll` 调用。 只要内部的 `Future` 实现了唤醒并且返回了 `Poll::Pending`，那 `MySelect` 也等于实现了唤醒！

## 语法

目前来说，`select!` 最多可以支持 64 个分支，每个分支形式如下：

```rust
<模式> = <async 表达式> => <结果处理>,
```

当 `select` 宏开始执行后，所有的分支会开始并发的执行。当任何一个**表达式**完成时，会将结果跟**模式**进行匹配。若匹配成功，则剩下的表达式会被释放。

最常用的**模式**就是用变量名去匹配表达式返回的值，然后该变量就可以在**结果处理**环节使用。

如果当前的模式不能匹配，剩余的 `async` 表达式将继续并发的执行，直到下一个完成。

由于 `select!` 使用的是一个 `async` 表达式，因此我们可以定义一些更复杂的计算。

例如从在分支中进行 TCP 连接：

```rust
use tokio::net::TcpStream;
use tokio::sync::oneshot;

#[tokio::main]
async fn main() {
    let (tx, rx) = oneshot::channel();

    // 生成一个任务，用于向 oneshot 发送一条消息
    tokio::spawn(async move {
        tx.send("done").unwrap();
    });

    tokio::select! {
        socket = TcpStream::connect("localhost:3465") => {
            println!("Socket connected {:?}", socket);
        }
        msg = rx => {
            println!("received message first {:?}", msg);
        }
    }
}
```

再比如，在分支中进行 TCP 监听:

```rust
use tokio::net::TcpListener;
use tokio::sync::oneshot;
use std::io;

#[tokio::main]
async fn main() -> io::Result<()> {
    let (tx, rx) = oneshot::channel();

    tokio::spawn(async move {
        tx.send(()).unwrap();
    });

    let mut listener = TcpListener::bind("localhost:3465").await?;

    tokio::select! {
        _ = async {
            loop {
                let (socket, _) = listener.accept().await?;
                tokio::spawn(async move { process(socket) });
            }

            // 给予 Rust 类型暗示
            Ok::<_, io::Error>(())
        } => {}
        _ = rx => {
            println!("terminating accept loop");
        }
    }

    Ok(())
}
```

分支中接收连接的循环会一直运行，直到遇到错误才停止，或者当 `rx` 中有值时，也会停止。 `_` 表示我们并不关心这个值，这样使用唯一的目的就是为了结束第一分支中的循环。

## 返回值

`select!` 还能返回一个值:

```rust
async fn computation1() -> String {
    // .. 计算
}

async fn computation2() -> String {
    // .. 计算
}

#[tokio::main]
async fn main() {
    let out = tokio::select! {
        res1 = computation1() => res1,
        res2 = computation2() => res2,
    };

    println!("Got = {}", out);
}
```

需要注意的是，此时 `select!` 的所有分支必须返回一样的类型，否则编译器会报错！

## 错误传播

在 Rust 中使用 `?` 可以对错误进行传播，但是在 `select!` 中，`?` 如何工作取决于它是在分支中的 `async` 表达式使用还是在结果处理的代码中使用:

- 在分支中 `async` 表达式使用会将该表达式的结果变成一个 `Result`
- 在结果处理中使用，会将错误直接传播到 `select!` 之外

```rust
use tokio::net::TcpListener;
use tokio::sync::oneshot;
use std::io;

#[tokio::main]
async fn main() -> io::Result<()> {
    // [设置 `rx` oneshot 消息通道]

    let listener = TcpListener::bind("localhost:3465").await?;

    tokio::select! {
        res = async {
            loop {
                let (socket, _) = listener.accept().await?;
                tokio::spawn(async move { process(socket) });
            }

            Ok::<_, io::Error>(())
        } => {
            res?;
        }
        _ = rx => {
            println!("terminating accept loop");
        }
    }

    Ok(())
}
```

`listener.accept().await?` 是分支表达式中的 `?`，因此它会将表达式的返回值变成 `Result` 类型，然后赋予给 `res` 变量。

与之不同的是，结果处理中的 `res?;` 会让 `main` 函数直接结束并返回一个 `Result`，可以看出，这里 `?` 的用法跟我们平时的用法并无区别。

## 模式匹配

既然是模式匹配，我们需要再来回忆下 `select!` 的分支语法形式:

```rust
<模式> = <async 表达式> => <结果处理>,
```

迄今为止，我们只用了变量绑定的模式，事实上，[任何 Rust 模式](https://course.rs/basic/match-pattern/all-patterns.html)都可以在此处使用。

```rust
use tokio::sync::mpsc;

#[tokio::main]
async fn main() {
    let (mut tx1, mut rx1) = mpsc::channel(128);
    let (mut tx2, mut rx2) = mpsc::channel(128);

    tokio::spawn(async move {
        // 用 tx1 和 tx2 干一些不为人知的事
    });

    tokio::select! {
        Some(v) = rx1.recv() => {
            println!("Got {:?} from rx1", v);
        }
        Some(v) = rx2.recv() => {
            println!("Got {:?} from rx2", v);
        }
        else => {
            println!("Both channels closed");
        }
    }
}
```

上面代码中，`rx` 通道关闭后，`recv()` 方法会返回一个 `None`，可以看到没有任何模式能够匹配这个 `None`，那为何不会报错？秘密就在于 `else` 上：当使用模式去匹配分支时，若之前的所有分支都无法被匹配，那 `else` 分支将被执行。

## 借用

当在 Tokio 中生成( spawn )任务时，其 async 语句块必须拥有其中数据的所有权。而 `select!` 并没有这个限制，它的每个分支表达式可以直接借用数据，然后进行并发操作。只要遵循 Rust 的借用规则，多个分支表达式可以不可变的借用同一个数据，或者在一个表达式可变的借用某个数据。

来看个例子，在这里我们同时向两个 TCP 目标发送同样的数据:

```rust
use tokio::io::AsyncWriteExt;
use tokio::net::TcpStream;
use std::io;
use std::net::SocketAddr;

async fn race(
    data: &[u8],
    addr1: SocketAddr,
    addr2: SocketAddr
) -> io::Result<()> {
    tokio::select! {
        Ok(_) = async {
            let mut socket = TcpStream::connect(addr1).await?;
            socket.write_all(data).await?;
            Ok::<_, io::Error>(())
        } => {}
        Ok(_) = async {
            let mut socket = TcpStream::connect(addr2).await?;
            socket.write_all(data).await?;
            Ok::<_, io::Error>(())
        } => {}
        else => {}
    };

    Ok(())
}
```

有趣的题外话：由于 TCP 的连接过程是在模式中发生，因此当某一个连接过程失败后，它通过 `?` 返回的 `Err` 类型无法匹配 `Ok`，导致另一个分支会继续被执行、继续连接。

如果你把连接过程放在了结果处理中，那连接失败会直接从 `race` 函数中返回，而不是继续执行另一个分支中的连接！

还有一个非常重要的点，**借用规则在分支表达式和结果处理中存在很大的不同**。例如上面代码中，我们在两个分支表达式中分别对 `data` 做了不可变借用，这当然 ok，但是若是两次可变借用，那编译器会立即进行报错。但是转折来了：当在结果处理中进行两次可变借用时，却不会报错，大家可以思考下为什么，提示下：思考下分支在执行完成后会发生什么？

```rust
use tokio::sync::oneshot;

#[tokio::main]
async fn main() {
    let (tx1, rx1) = oneshot::channel();
    let (tx2, rx2) = oneshot::channel();

    let mut out = String::new();

    tokio::spawn(async move {
    });

    tokio::select! {
        _ = rx1 => {
            out.push_str("rx1 completed");
        }
        _ = rx2 => {
            out.push_str("rx2 completed");
        }
    }

    println!("{}", out);
}
```

例如以上代码，就在两个分支的结果处理中分别进行了可变借用，并不会报错。原因就在于：`select!`会保证只有一个分支的结果处理会被运行，然后在运行结束后，另一个分支会被直接丢弃。

## 循环

来看看该如何在循环中使用 `select!`，顺便说一句，跟循环一起使用是最常见的使用方式。

```rust
use tokio::sync::mpsc;

#[tokio::main]
async fn main() {
    let (tx1, mut rx1) = mpsc::channel(128);
    let (tx2, mut rx2) = mpsc::channel(128);
    let (tx3, mut rx3) = mpsc::channel(128);

    loop {
        let msg = tokio::select! {
            Some(msg) = rx1.recv() => msg,
            Some(msg) = rx2.recv() => msg,
            Some(msg) = rx3.recv() => msg,
            else => { break }
        };

        println!("Got {}", msg);
    }

    println!("All channels have been closed.");
}
```

在循环中使用 `select!` 最大的不同就是，当某一个分支执行完成后，`select!` 会继续循环等待并执行下一个分支，直到所有分支最终都完成，最终匹配到 `else` 分支，然后通过 `break` 跳出循环。

老生常谈的一句话：`select!` 中哪个分支先被执行是无法确定的，因此不要依赖于分支执行的顺序！想象一下，在异步编程场景，若 `select!` 按照分支的顺序来执行会如何：若 `rx1` 中总是有数据，那每次循环都只会去处理第一个分支，后面两个分支永远不会被执行。

#### 恢复之前的异步操作

```rust
async fn action() {
    // 一些异步逻辑
}

#[tokio::main]
async fn main() {
    let (mut tx, mut rx) = tokio::sync::mpsc::channel(128);

    let operation = action();
    tokio::pin!(operation);

    loop {
        tokio::select! {
            _ = &mut operation => break,
            Some(v) = rx.recv() => {
                if v % 2 == 0 {
                    break;
                }
            }
        }
    }
}
```

在上面代码中，我们没有直接在 `select!` 分支中调用 `action()` ，而是在 `loop` 循环外面先将 `action()` 赋值给 `operation`，因此 `operation` 是一个 `Future`。

**重点来了**，在 `select!` 循环中，我们使用了一个奇怪的语法 `&mut operation`，大家想象一下，如果不加 `&mut` 会如何？答案是，每一次循环调用的都是一次全新的 `action()`调用，但是当加了 `&mut operatoion` 后，每一次循环调用就变成了对同一次 `action()` 的调用。也就是我们实现了在每次循环中恢复了之前的异步操作！

`select!` 的另一个分支从消息通道收取消息，一旦收到值是偶数，就跳出循环，否则就继续循环。

还有一个就是我们使用了 `tokio::pin!`，具体的细节这里先不介绍，值得注意的点是：如果要在一个引用上使用 `.await`，那么引用的值就必须是不能移动的或者实现了 `Unpin`，关于 `Pin` 和 `Unpin` 可以参见[这里](https://course.rs/async/pin-unpin.html)。

一旦移除 `tokio::pin!` 所在行的代码，然后试图编译，就会获得以下错误:

```console
error[E0599]: no method named `poll` found for struct
     `std::pin::Pin<&mut &mut impl std::future::Future>`
     in the current scope
  --> src/main.rs:16:9
   |
16 | /         tokio::select! {
17 | |             _ = &mut operation => break,
18 | |             Some(v) = rx.recv() => {
19 | |                 if v % 2 == 0 {
...  |
22 | |             }
23 | |         }
   | |_________^ method not found in
   |             `std::pin::Pin<&mut &mut impl std::future::Future>`
   |
   = note: the method `poll` exists but the following trait bounds
            were not satisfied:
           `impl std::future::Future: std::marker::Unpin`
           which is required by
           `&mut impl std::future::Future: std::future::Future`
```

虽然我们已经学了很多关于 `Future` 的知识，但是这个错误依然不太好理解。但是它不难解决：当你试图在**一个引用上调用 `.await` 然后遇到了 `Future 未实现` 这种错误时**，往往只需要将对应的 `Future` 进行固定即可: ` tokio::pin!(operation);`。

#### 修改一个分支

下面一起来看一个稍微复杂一些的 `loop` 循环，首先，我们拥有：

- 一个消息通道可以传递 `i32` 类型的值
- 定义在 `i32` 值上的一个异步操作

想要实现的逻辑是：

- 在消息通道中等待一个偶数出现
- 使用该偶数作为输入来启动一个异步操作
- 等待异步操作完成，与此同时监听消息通道以获取更多的偶数
- 若在异步操作完成前一个新的偶数到来了，终止当前的异步操作，然后接着使用新的偶数开始异步操作

```rust
async fn action(input: Option<i32>) -> Option<String> {
    // 若 input（输入）是None，则返回 None
    // 事实上也可以这么写: `let i = input?;`
    let i = match input {
        Some(input) => input,
        None => return None,
    };

    // 这里定义一些逻辑
}

#[tokio::main]
async fn main() {
    let (mut tx, mut rx) = tokio::sync::mpsc::channel(128);

    let mut done = false;
    let operation = action(None);
    tokio::pin!(operation);

    tokio::spawn(async move {
        let _ = tx.send(1).await;
        let _ = tx.send(3).await;
        let _ = tx.send(2).await;
    });

    loop {
        tokio::select! {
            res = &mut operation, if !done => {
                done = true;

                if let Some(v) = res {
                    println!("GOT = {}", v);
                    return;
                }
            }
            Some(v) = rx.recv() => {
                if v % 2 == 0 {
                    // `.set` 是 `Pin` 上定义的方法
                    operation.set(action(Some(v)));
                    done = false;
                }
            }
        }
    }
}
```

当第一次循环开始时， 第一个分支会立即完成，因为 `operation` 的参数是 `None`。当第一个分支执行完成时，`done` 会变成 `true`，此时第一个分支的条件将无法被满足，开始执行第二个分支。

当第二个分支收到一个偶数时，`done` 会被修改为 `false`，且 `operation` 被设置了值。 此后再一次循环时，第一个分支会被执行，且 `operation` 返回一个 `Some(2)`，因此会触发 `return` ，最终结束循环并返回。

这段代码引入了一个新的语法: `if !done`，在解释之前，先看看去掉后会如何：

```console
thread 'main' panicked at '`async fn` resumed after completion', src/main.rs:1:55
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

```'`async fn` resumed after completion'``` 错误的含义是：`async fn` 异步函数在完成后，依然被恢复了(继续使用)。

回到例子中来，这个错误是由于 `operation` 在它已经调用完成后依然被使用。通常来说，当使用 `.await` 后，调用 `.await` 的值会被消耗掉，因此并不存在这个问题。但是在这例子中，我们在引用上调用 `.await`，因此之后该引用依然可以被使用。

为了避免这个问题，需要在第一个分支的 `operation` 完成后禁止再使用该分支。这里的 `done` 的引入就很好的解决了问题。对于 `select!` 来说 `if !done` 的语法被称为预条件( **precondition** )，该条件会在分支被 `.await` 执行前进行检查。

那大家肯定有疑问了，既然 `operation` 不能再被调用了，我们该如何在有偶数值时，再回到第一个分支对其进行调用呢？答案就是 `operation.set(action(Some(v)));`，该操作会重新使用新的参数设置 `operation`。

## spawn 和 select! 的一些不同

学到现在，相信大家对于 `tokio::spawn` 和 `select!` 已经非常熟悉，它们的共同点就是都可以并发的运行异步操作。
然而它们使用的策略大相径庭。

`tokio::spawn` 函数会启动新的任务来运行一个异步操作，每个任务都是一个独立的对象可以单独被 Tokio 调度运行，因此两个不同的任务的调度都是独立进行的，甚至于它们可能会运行在两个不同的操作系统线程上。鉴于此，生成的任务和生成的线程有一个相同的限制：不允许对外部环境中的值进行借用。

而 `select!` 宏就不一样了，它在同一个任务中并发运行所有的分支。正是因为这样，在同一个任务中，这些分支无法被同时运行。 `select!` 宏在单个任务中实现了多路复用的功能。



================================================
FILE: src/advance-practice/shared-state.md
================================================
[Binary file]


================================================
FILE: src/advance-practice/spawning.md
================================================
[Binary file]


================================================
FILE: src/advance-practice/stream.md
================================================
# Stream

大家有没有想过， Rust 中的迭代器在迭代时能否异步进行？若不可以，是不是有相应的解决方案？

以上的问题其实很重要，因为在实际场景中，迭代一个集合，然后异步的去执行是很常见的需求，好在 Tokio 为我们提供了 `stream`，我们可以在异步函数中对其进行迭代，甚至和迭代器 `Iterator` 一样，`stream` 还能使用适配器，例如 `map` ! Tokio 在 [`StreamExt`](https://docs.rs/tokio-stream/0.1.8/tokio_stream/trait.StreamExt.html) 特征上定义了常用的适配器。

要使用 `stream` ，目前还需要手动引入对应的包：

```rust
tokio-stream = "0.1"
```

> stream 没有放在 `tokio` 包的原因在于标准库中的 `Stream` 特征还没有稳定，一旦稳定后，`stream` 将移动到 `tokio` 中来

## 迭代

目前， Rust 语言还不支持异步的 `for` 循环，因此我们需要 `while let` 循环和 [`StreamExt::next()`](https://docs.rs/tokio-stream/0.1.8/tokio_stream/trait.StreamExt.html#method.next) 一起使用来实现迭代的目的:

```rust
use tokio_stream::StreamExt;

#[tokio::main]
async fn main() {
    let mut stream = tokio_stream::iter(&[1, 2, 3]);

    while let Some(v) = stream.next().await {
        println!("GOT = {:?}", v);
    }
}
```

和迭代器 `Iterator` 类似，`next()` 方法返回一个 `Option<T>`，其中 `T` 是从 `stream` 中获取的值的类型。若收到 `None` 则意味着 `stream` 迭代已经结束。

#### mini-redis 广播

下面我们来实现一个复杂一些的 mini-redis 客户端，完整代码见[这里](https://github.com/tokio-rs/website/blob/master/tutorial-code/streams/src/main.rs)。

在开始之前，首先启动一下完整的 mini-redis 服务器端：

```console
$ mini-redis-server
```

```rust
use tokio_stream::StreamExt;
use mini_redis::client;

async fn publish() -> mini_redis::Result<()> {
    let mut client = client::connect("127.0.0.1:6379").await?;

    // 发布一些数据
    client.publish("numbers", "1".into()).await?;
    client.publish("numbers", "two".into()).await?;
    client.publish("numbers", "3".into()).await?;
    client.publish("numbers", "four".into()).await?;
    client.publish("numbers", "five".into()).await?;
    client.publish("numbers", "6".into()).await?;
    Ok(())
}

async fn subscribe() -> mini_redis::Result<()> {
    let client = client::connect("127.0.0.1:6379").await?;
    let subscriber = client.subscribe(vec!["numbers".to_string()]).await?;
    let messages = subscriber.into_stream();

    tokio::pin!(messages);

    while let Some(msg) = messages.next().await {
        println!("got = {:?}", msg);
    }

    Ok(())
}

#[tokio::main]
async fn main() -> mini_redis::Result<()> {
    tokio::spawn(async {
        publish().await
    });

    subscribe().await?;

    println!("DONE");

    Ok(())
}
```

上面生成了一个异步任务专门用于发布消息到 min-redis 服务器端的 `numbers` 消息通道中。然后，在 `main` 中，我们订阅了 `numbers` 消息通道，并且打印从中接收到的消息。

还有几点值得注意的:

- [`into_stream`](https://docs.rs/mini-redis/0.4.1/mini_redis/client/struct.Subscriber.html#method.into_stream) 会将 `Subscriber` 变成一个 `stream`
- 在 `stream` 上调用 `next` 方法要求该 `stream` 被固定住([`pinned`](https://doc.rust-lang.org/std/pin/index.html))，因此需要调用 `tokio::pin!`

> 关于 Pin 的详细解读，可以阅读[这篇文章](https://course.rs/async/pin-unpin.html)

大家可以去掉 `pin!` 的调用，然后观察下报错，若以后你遇到这种错误，可以尝试使用下 `pin!`。

此时，可以运行下我们的客户端代码看看效果(别忘了先启动前面提到的 mini-redis 服务端):

```console
got = Ok(Message { channel: "numbers", content: b"1" })
got = Ok(Message { channel: "numbers", content: b"two" })
got = Ok(Message { channel: "numbers", content: b"3" })
got = Ok(Message { channel: "numbers", content: b"four" })
got = Ok(Message { channel: "numbers", content: b"five" })
got = Ok(Message { channel: "numbers", content: b"6" })
```

在了解了 `stream` 的基本用法后，我们再来看看如何使用适配器来扩展它。

## 适配器

在前面章节中，我们了解了迭代器有[两种适配器](https://course.rs/advance/functional-programing/iterator.html#消费者与适配器)：

- 迭代器适配器，会将一个迭代器转变成另一个迭代器，例如 `map`，`filter` 等
- 消费者适配器，会消费掉一个迭代器，最终生成一个值，例如 `collect` 可以将迭代器收集成一个集合

与迭代器类似，`stream` 也有适配器，例如一个 `stream` 适配器可以将一个 `stream` 转变成另一个 `stream` ，例如 `map`、`take` 和 `filter`。

在之前的客户端中，`subscribe` 订阅一直持续下去，直到程序被关闭。现在，让我们来升级下，让它在收到三条消息后就停止迭代，最终结束。

```rust
let messages = subscriber
    .into_stream()
    .take(3);
```

这里关键就在于 `take` 适配器，它会限制 `stream` 只能生成最多 `n` 条消息。运行下看看结果：

```console
got = Ok(Message { channel: "numbers", content: b"1" })
got = Ok(Message { channel: "numbers", content: b"two" })
got = Ok(Message { channel: "numbers", content: b"3" })
```

程序终于可以正常结束了。现在，让我们过滤 `stream` 中的消息，只保留数字类型的值:

```rust
let messages = subscriber
    .into_stream()
    .filter(|msg| match msg {
        Ok(msg) if msg.content.len() == 1 => true,
        _ => false,
    })
    .take(3);
```

运行后输出：

```console
got = Ok(Message { channel: "numbers", content: b"1" })
got = Ok(Message { channel: "numbers", content: b"3" })
got = Ok(Message { channel: "numbers", content: b"6" })
```

需要注意的是，适配器的顺序非常重要，`.filter(...).take(3)` 和 `.take(3).filter(...)` 的结果可能大相径庭，大家可以自己尝试下。

现在，还有一件事要做，咱们的消息被不太好看的 `Ok(...)` 所包裹，现在通过 `map` 适配器来简化下:

```rust
let messages = subscriber
    .into_stream()
    .filter(|msg| match msg {
        Ok(msg) if msg.content.len() == 1 => true,
        _ => false,
    })
    .map(|msg| msg.unwrap().content)
    .take(3);
```

注意到 `msg.unwrap` 了吗？大家可能会以为我们是出于示例的目的才这么用，实际上并不是，由于 `filter` 的先执行， `map` 中的 `msg` 只能是 `Ok(...)`，因此 `unwrap` 非常安全。

```console
got = b"1"
got = b"3"
got = b"6"
```

还有一点可以改进的地方：当 `filter` 和 `map` 一起使用时，你往往可以用一个统一的方法来实现 [`filter_map`](https://docs.rs/tokio-stream/0.1.8/tokio_stream/trait.StreamExt.html#method.filter_map)。

```rust
let messages = subscriber
    .into_stream()
    .filter_map(|msg| match msg {
        Ok(msg) if msg.content.len() == 1 => Some(msg.content),
        _ => None,
    })
    .take(3);
```

想要学习更多的适配器，可以看看 [`StreamExt`](https://docs.rs/tokio-stream/0.1.8/tokio_stream/trait.StreamExt.html) 特征。

## 实现 Stream 特征

如果大家还没忘记 `Future` 特征，那 `Stream` 特征相信你也会很快记住，因为它们非常类似：

```rust
use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Stream {
    type Item;

    fn poll_next(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>
    ) -> Poll<Option<Self::Item>>;

    fn size_hint(&self) -> (usize, Option<usize>) {
        (0, None)
    }
}
```

`Stream::poll_next()` 函数跟 `Future::poll` 很相似，区别就是前者为了从 `stream` 收到多个值需要重复的进行调用。 就像在 [`深入async`](https://course.rs/tokio/async.html) 章节提到的那样，当一个 `stream` 没有做好返回一个值的准备时，它将返回一个 `Poll::Pending` ，同时将任务的 `waker` 进行注册。一旦 `stream` 准备好后， `waker` 将被调用。

通常来说，如果想要手动实现一个 `Stream`，需要组合 `Future` 和其它 `Stream`。下面，还记得在[`深入async`](https://course.rs/tokio/async.html) 中构建的 `Delay Future` 吗？现在让我们来更进一步，将它转换成一个 `stream`，每 10 毫秒生成一个值，总共生成 3 次:

```rust
use tokio_stream::Stream;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::Duration;

struct Interval {
    rem: usize,
    delay: Delay,
}

impl Stream for Interval {
    type Item = ();

    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>)
        -> Poll<Option<()>>
    {
        if self.rem == 0 {
            // 去除计时器实现
            return Poll::Ready(None);
        }

        match Pin::new(&mut self.delay).poll(cx) {
            Poll::Ready(_) => {
                let when = self.delay.when + Duration::from_millis(10);
                self.delay = Delay { when };
                self.rem -= 1;
                Poll::Ready(Some(()))
            }
            Poll::Pending => Poll::Pending,
        }
    }
}
```

#### async-stream

手动实现 `Stream` 特征实际上是相当麻烦的事，不幸地是，Rust 语言的 `async/await` 语法目前还不能用于定义 `stream`，虽然相关的工作已经在进行中。

作为替代方案，[`async-stream`](https://docs.rs/async-stream/latest/async_stream/) 包提供了一个 `stream!` 宏，它可以将一个输入转换成 `stream`，使用这个包，上面的代码可以这样实现：

```rust
use async_stream::stream;
use std::time::{Duration, Instant};

stream! {
    let mut when = Instant::now();
    for _ in 0..3 {
        let delay = Delay { when };
        delay.await;
        yield ();
        when += Duration::from_millis(10);
    }
}
```

嗯，看上去还是相当不错的，代码可读性大幅提升！

<!-- todo generators -->
是不是发现了一个关键字 `yield` ，他是用来配合生成器使用的。详见[原文](https://doc.rust-lang.org/beta/unstable-book/language-features/generators.html)



================================================
FILE: src/advance-practice1/graceful-shutdown.md
================================================
# 优雅关闭和资源清理

之前的程序，如果使用 `ctrl-c` 的方法来关闭，所有的线程都会立即停止，这会造成正在请求的用户感知到一个明显的错误。


因此我们需要添加一些优雅关闭( Graceful Shutdown )，以更好的完成资源清理等收尾工作。

## 为线程池实现 Drop

当线程池被 drop 时，需要等待所有的子线程完成它们的工作，然后再退出，下面是一个初步尝试:

```rust
impl Drop for ThreadPool {
    fn drop(&mut self) {
        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
```

这里通过实现 `Drop` 特征来为线程池添加资源收尾工作，代码比较简单，就是依次调用每个线程的 `join` 方法。编译下试试：

```rust
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0507]: cannot move out of `worker.thread` which is behind a mutable reference
  --> src/lib.rs:52:13
   |
52 |             worker.thread.join().unwrap();
   |             ^^^^^^^^^^^^^ ------ `worker.thread` moved due to this method call
   |             |
   |             move occurs because `worker.thread` has type `JoinHandle<()>`, which does not implement the `Copy` trait
   |
note: this function takes ownership of the receiver `self`, which moves `worker.thread`

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello` due to previous error
```

这里的报错很明显，`worker.thread` 试图拿走所有权，但是 `worker` 仅仅是一个可变借用，显然是不可行的。

目前来看，只能将 `thread` 从 `worker` 中移动出来，一个可行的尝试:

```rust
struct Worker {
    id: usize,
    thread: Option<thread::JoinHandle<()>>,
}
```

对于 `Option` 类型，可以使用 `take` 方法拿走内部值的所有权，同时留下一个 `None` 在风中孤独凌乱。继续尝试编译驱动开发模式:

```shell
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `join` found for enum `Option` in the current scope
  --> src/lib.rs:52:27
   |
52 |             worker.thread.join().unwrap();
   |                           ^^^^ method not found in `Option<JoinHandle<()>>`
   |
note: the method `join` exists on the type `JoinHandle<()>`
help: consider using `Option::expect` to unwrap the `JoinHandle<()>` value, panicking if the value is an `Option::None`
   |
52 |             worker.thread.expect("REASON").join().unwrap();
   |                          +++++++++++++++++

error[E0308]: mismatched types
  --> src/lib.rs:72:22
   |
72 |         Worker { id, thread }
   |                      ^^^^^^ expected enum `Option`, found struct `JoinHandle`
   |
   = note: expected enum `Option<JoinHandle<()>>`
            found struct `JoinHandle<_>`
help: try wrapping the expression in `Some`
   |
72 |         Worker { id, thread: Some(thread) }
   |                      +++++++++++++      +
```

先来解决第二个类型不匹配的错误:

```rust
impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        // --snip--

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
```

简单搞定，回头看看第一个错误，既然换了 `Option`，就可以用 `take` 拿走所有权:

```rust
impl Drop for ThreadPool {
    fn drop(&mut self) {
        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
```

注意这种 `if let` 的写法，若 `worker.thread` 已经是 `None`，什么都不会发生，符合我们的预期; 若包含一个线程，那就拿走其所有权，然后调用 `join`。

## 停止工作线程

虽然调用了 `join` ，但是目标线程依然不会停止，原因在于它们在无限的 `loop` 循环等待，看起来需要借用 `channel` 的 `drop` 机制：释放 `sender`发送端后，`receiver` 接收端会收到报错，然后再退出即可。

```rust
pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: Option<mpsc::Sender<Job>>,
}
// --snip--
impl ThreadPool {
    pub fn new(size: usize) -> ThreadPool {
        // --snip--

        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&mut self) {
        drop(self.sender.take());

        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
```

上面做了两处改变:

1. 为 `sender` 增加 `Option` 封装，这样可以用 `take` 拿走所有权，跟之前的 `thread` 一样
2. 主动调用 `drop` 关闭发送端 `sender`

关闭 `sender` 后，将关闭对应的 `channel`，意味着不会再有任何消息被发送。随后，所有的处于无限 `loop` 的接收端将收到一个错误，我们根据错误再进行进一步的处理。


```rust
impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) => {
                    println!("Worker {id} got a job; executing.");

                    job();
                }
                Err(_) => {
                    println!("Worker {id} disconnected; shutting down.");
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
```

为了快速验证代码是否正确，修改 `main` 函数，让其只接收前两个请求:

```rust
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Shutting down.");
}
```

`take` 是迭代器 `Iterator` 上的方法，会限制后续的迭代进行最多两次，然后就结束监听，随后 `ThreadPool` 也将超出作用域并自动触发 `drop`。

```shell
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Shutting down.
Shutting down worker 0
Worker 3 got a job; executing.
Worker 1 disconnected; shutting down.
Worker 2 disconnected; shutting down.
Worker 3 disconnected; shutting down.
Worker 0 disconnected; shutting down.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
```

可以看到，代码按照我们的设想如期运行，至此，一个基于线程池的简单 Web 服务器已经完成，下面是完整的代码:


## 完整代码
```rust
// src/main.rs
use hello::ThreadPool;
use std::fs;
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Shutting down.");
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&mut buffer).unwrap();

    let get = b"GET / HTTP/1.1\r\n";
    let sleep = b"GET /sleep HTTP/1.1\r\n";

    let (status_line, filename) = if buffer.starts_with(get) {
        ("HTTP/1.1 200 OK", "hello.html")
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        ("HTTP/1.1 200 OK", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();

    let response = format!(
        "{}\r\nContent-Length: {}\r\n\r\n{}",
        status_line,
        contents.len(),
        contents
    );

    stream.write_all(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
```

```rust
// src/lib.rs
use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};

pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: Option<mpsc::Sender<Job>>,
}

type Job = Box<dyn FnOnce() + Send + 'static>;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&mut self) {
        drop(self.sender.take());

        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option<thread::JoinHandle<()>>,
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) => {
                    println!("Worker {id} got a job; executing.");

                    job();
                }
                Err(_) => {
                    println!("Worker {id} disconnected; shutting down.");
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
```

### 可以做的更多

事实上，我们还可以做更多，但是受制于篇幅，就不再展开，感兴趣的同学可以自行完成。

- 增加更多的文档
- 为线程池增加测试
- 尽可能移除 `unwrap`，替换为错误处理
- 使用线程池完成其它类型的工作，而不仅仅是本章的 Web 服务器
- 在 `crates.io` 上找到一个线程池实现，然后使用该包实现一个类似的 Web 服务器


## 上一章节的遗留问题

在上一章节的末尾，我们提到将 `let` 替换为 `while let` 后，多线程的优势将荡然无存，原因藏的很隐蔽：

1. `Mutex` 结构体没有提供显式的 `unlock`，要依赖作用域结束后的 `drop` 来自动释放 
2. `let job = receiver.lock().unwrap().recv().unwrap();` 在这行代码中，由于使用了 `let`，右边的任何临时变量会在 `let` 语句结束后立即被 `drop`，因此锁会自动释放
3. 然而 `while let` (还包括 `if let` 和 `match`) 直到最后一个花括号后，才触发 `drop`

```rust
impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!("Worker {id} got a job; executing.");

                job();
            }
        });

        Worker { id, thread }
    }
}
```

根据之前的分析，上面的代码直到 `job()` 任务执行结束后，才会释放锁，去执行另一个请求，最终造成请求排队。



================================================
FILE: src/advance-practice1/intro.md
================================================
# 实践应用：多线程Web服务器

一般来说，现代化的 web 服务器往往都基于更加轻量级的协程或 async/await 等模式实现，但是基于本章的内容，我们还是采取较为传统的多线程的方式来实现，即：一个请求连接分配一个线程去独立处理，当然还有升级版的线程池。

在本章中你将了解：

1. 学习一点 TCP 和 HTTP
2. 在套接字 socket 上监听进入的 TCP 连接
3. 解析 HTTP 请求
4. 创建合适的 HTTP 应答
5. 使用线程池来提升 web 服务器的吞吐量

> 本章的实现方法并不是在 Rust 中实现 Web 服务器的最佳方法，后续章节的 async/await 会更加适合!



================================================
FILE: src/advance-practice1/multi-threads.md
================================================
# 构建多线程 Web 服务器

目前的单线程版本只能依次处理用户的请求：一时间只能处理一个请求连接。随着用户的请求数增多，可以预料的是排在后面的用户可能要等待数十秒甚至超时！

本章我们将解决这个问题，但是首先来模拟一个慢请求场景，看看单线程是否真的如此糟糕。

## 基于单线程模拟慢请求

下面的代码中，使用 sleep 的方式让每次请求持续 5 秒，模拟真实的慢请求:

```rust
// in main.rs
use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--

    let (status_line, filename) = match &request_line[..] {
        "GET / HTTP/1.1" => ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" => {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ => ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    // --snip--
}
```

由于增加了新的请求路径 `/sleep`，之前的 `if else` 被修改为 `match`，需要注意的是，由于 `match` 不会像方法那样自动做引用或者解引用，因此我们需要显式调用: `match &request_line[..]` ，来获取所需的 `&str` 类型。

可以看出，当用户访问 `/sleep` 时，请求会持续 5 秒后才返回，下面来试试，启动服务器后，打开你的浏览器，这次要分别打开两个页面(tab页): `http://127.0.0.1:7878/` 和 `http://127.0.0.1:7878/sleep`。

此时，如果我们连续访问 `/` 路径，那效果跟之前一样：立刻看到请求的页面。但假如先访问 `/sleep` ，接着在另一个页面访问 `/`，就会看到 `/` 的页面直到 5 秒后才会刷出来，验证了请求排队这个糟糕的事实。

至于如何解决，其实办法不少，本章我们来看看一个经典解决方案：线程池。

## 使用线程池改善吞吐

线程池包含一组已生成的线程，它们时刻等待着接收并处理新的任务。当程序接收到新任务时，它会将线程池中的一个线程指派给该任务，在该线程忙着处理时，新来的任务会交给池中剩余的线程进行处理。最终，当执行任务的线程处理完后，它会被重新放入到线程池中，准备处理新任务。

假设线程池中包含 N 个线程，那么可以推断出，服务器将拥有并发处理 N 个请求连接的能力，从而增加服务器的吞吐量。

同时，我们将限制线程池中的线程数量，以保护服务器免受拒绝服务攻击（DoS）的影响：如果针对每个请求创建一个新线程，那么一个人向我们的服务器发出1000万个请求，会直接耗尽资源，导致后续用户的请求无法被处理，这也是拒绝服务名称的来源。

因此，还需对线程池进行一定的架构设计，首先是设定最大线程数的上限，其次维护一个请求队列。池中的线程去队列中依次弹出请求并处理。这样就可以同时并发处理 N 个请求，其中 N 是线程数。

但聪明的读者可能会想到，假如每个请求依然耗时很长，那请求队列依然会堆积，后续的用户请求还是需要等待较长的时间，毕竟你也就 N 个线程，但总归比单线程要强 N 倍吧 :D

当然，线程池依然是较为传统的提升吞吐方法，比较新的有：单线程异步 IO，例如 redis；多线程异步 IO，例如 Rust 的主流 web 框架。事实上，大家在下一个实战项目中，会看到相关技术的应用。

### 为每个请求生成一个线程

这显然不是我们的最终方案，原因在于它会生成无上限的线程数，最终导致资源耗尽。但它确实是一个好的起点:

```rust
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
```

这种实现下，依次访问 `/sleep` 和 `/` 就无需再等待，不错的开始。

### 限制创建线程的数量

原则上，我们希望在上面代码的基础上，尽量少的去修改，下面是一个假想的线程池 API 实现:

```rust
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
```

代码跟之前的类似，也非常简洁明了， `ThreadPool::new(4)` 创建一个包含 4 个线程的线程池，接着通过 `pool.execute` 去分发执行请求。

显然，上面的代码无法编译，下面来逐步实现。

### 使用编译器驱动的方式开发 ThreadPool

你可能听说过测试驱动开发，但听过编译器驱动开发吗？来见识下 Rust 中的绝招吧。

检查之前的代码，看看报什么错:

```shell
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type `ThreadPool`
  --> src/main.rs:11:16
   |
11 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello` due to previous error
```

俗话说，不怕敌人很强，就怕他们不犯错，很好，编译器漏出了破绽。看起来我们需要实现 `ThreadPool` 类型。看起来，还需要添加一个库包，未来线程池的代码都将在这个独立的包中完成，甚至于未来你要实现其它的服务，也可以复用这个多线程库包。

创建 `src/lib.rs` 文件并写入如下代码:

```rust
pub struct ThreadPool;
```

接着在 `main.rs` 中引入:

```rust
// main.rs
use hello::ThreadPool;
```

编译后依然报错:

```shell
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope
  --> src/main.rs:12:28
   |
12 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` due to previous error
```

好，继续实现 `new` 函数 :

```rust
pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -> ThreadPool {
        ThreadPool
    }
}
```

继续检查：

```shell
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for struct `ThreadPool` in the current scope
  --> src/main.rs:17:14
   |
17 |         pool.execute(|| {
   |              ^^^^^^^ method not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` due to previous error
```

这个方法类似于 `thread::spawn`，用于将闭包中的任务交给某个空闲的线程去执行。

其实这里有一个小难点：`execute` 的参数是一个闭包，回忆下之前学过的内容，闭包作为参数时可以由三个特征进行约束: `Fn`、`FnMut` 和 `FnOnce`，选哪个就成为一个问题。由于 `execute` 在实现上类似 `thread::spawn`，我们可以参考下后者的签名如何声明。

```rust
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
    where
        F: FnOnce() -> T,
        F: Send + 'static,
        T: Send + 'static,
```

可以看出，`spawn` 选择 `FnOnce` 作为 `F` 闭包的特征约束，原因是闭包作为任务只需被线程执行一次即可。

`F` 还有一个特征约束 `Send` ，也可以照抄过来，毕竟闭包需要从一个线程传递到另一个线程，至于生命周期约束 `'static`，是因为我们并不知道线程需要多久时间来执行该任务。

```rust
impl ThreadPool {
    // --snip--
    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}
```

在理解 `spawn` 后，就可以轻松写出如上的 `execute` 实现，注意这里的 `FnOnce()` 跟 `spawn` 有所不同，原因是要 `execute` 传入的闭包没有参数也没有返回值。

```shell
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
```

成功编译，但在浏览器访问依然会报之前类似的错误，下面来实现 `execute`。

### `new` 还是 `build`

关于 `ThreadPool` 的构造函数，存在两个选择 `new` 和 `build`。

`new` 往往用于简单初始化一个实例，而 `build` 往往会完成更加复杂的构建工作，例如入门实战中的 `Config::build`。

在这个项目中，我们并不需要在初始化线程池的同时创建相应的线程，因此 `new` 是更适合的选择:

```rust
impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        ThreadPool
    }

    // --snip--
}
```

这里有两点值得注意:

- `usize` 类型包含 `0`，但是创建没有任何线程的线程池显然是无意义的，因此做一下 `assert!` 验证
- `ThreadPool` 拥有不错的[文档注释](https://course.rs/basic/comment.html#文档注释)，甚至包含了可能 `panic` 的情况，通过 `cargo doc --open` 可以访问文档注释

### 存储线程

创建 `ThreadPool` 后，下一步就是存储具体的线程，既然要存放线程，一个绕不过去的问题就是：用什么类型来存放，例如假如使用 `Vec<T>`  来存储，那这个 `T` 应该是什么？

估计还得探索下 `thread::spawn` 的签名，毕竟它生成并返回一个线程:

```rust
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
    where
        F: FnOnce() -> T,
        F: Send + 'static,
        T: Send + 'static,
```

看起来 `JoinHandle<T>` 是我们需要的，这里的 `T` 是传入的闭包任务所返回的，我们的任务无需任何返回，因此 `T` 直接使用 `()` 即可。

```rust
use std::thread;

pub struct ThreadPool {
    threads: Vec<thread::JoinHandle<()>>,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool { threads }
    }
    // --snip--
}
```

如上所示，最终我们使用 `Vec<thread::JoinHandle<()>>` 来存储线程，同时设定了容量上限 `with_capacity(size)`，该方法还可以提前分配好内存空间，比 `Vec::new` 的性能要更好一点。

### 将代码从 ThreadPool 发送到线程中

上面的代码留下一个未实现的 `for` 循环，用于创建和存储线程。

学过多线程一章后，大家应该知道 `thread::spawn` 虽然是生成线程最好的方式，但是它会立即执行传入的任务，然而，在我们的使用场景中，创建线程和执行任务明显是要分离的，因此标准库看起来不再适合。

可以考虑创建一个 `Worker` 结构体，作为 `ThreadPool` 和任务线程联系的桥梁，它的任务是获得将要执行的代码，然后在具体的线程中去执行。想象一个场景：一个餐馆，`Worker` 等待顾客的点餐，然后将具体的点餐信息传递给厨房，感觉类似服务员？

引入 `Worker` 后，就无需再存储 `JoinHandle<()>` 实例，直接存储 `Worker` 实例：该实例内部会存储 `JoinHandle<()>`。下面是新的线程池创建流程:

```rust
use std::thread;

pub struct ThreadPool {
    workers: Vec<Worker>,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --snip--
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle<()>,
}

impl Worker {
    fn new(id: usize) -> Worker {
        // 尚未实现..
        let thread = thread::spawn(|| {});
        // 每个 `Worker` 都拥有自己的唯一 id
        Worker { id, thread }
    }
}
```

由于外部调用者无需知道 `Worker` 的存在，因此这里使用了私有的声明。

大家可以编译下代码，如果出错了，请仔细检查下，是否遗漏了什么，截止目前，代码是完全可以通过编译的，但是任务该怎么执行依然还没有实现。

### 将请求发送给线程

在上面的代码中， `thread::spawn(|| {})` 还没有给予实质性的内容，现在一起来完善下。

首先 `Worker` 结构体需要从线程池 `ThreadPool` 的队列中获取待执行的代码，对于这类场景，消息传递非常适合：我们将使用消息通道( channel )作为任务队列。

```rust
use std::{sync::mpsc, thread};

pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Job>,
}

struct Job;

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
}
```

阅读过之前内容的同学应该知道，消息通道有发送端和接收端，其中线程池 `ThreadPool` 持有发送端，通过 `execute` 方法来发送任务。那么问题来了，谁持有接收端呢？答案是 `Worker`，它的内部线程将接收任务，然后进行处理。

```rust
impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver<Job>) -> Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}
```

看起来很美好，但是很不幸，它会报错: 

```shell
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --> src/lib.rs:26:42
   |
21 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver<Job>`, which does not implement the `Copy` trait
...
26 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello` due to previous error
```

原因也很简单，`receiver` 并没有实现 `Copy`，因此它的所有权在第一次循环中，就被传入到第一个 `Worker` 实例中，后续自然无法再使用。

报错就解决呗，但 Rust 中的 channel 实现是 mpsc，即多生产者单消费者，因此我们无法通过克隆消费者的方式来修复这个错误。当然，发送多条消息给多个接收者也不在考虑范畴，该怎么办？似乎陷入了绝境。

雪上加霜的是，就算 `receiver` 可以克隆，但是你得保证同一个时间只有一个`receiver` 能接收消息，否则一个任务可能同时被多个 `Worker` 执行，因此多个线程需要安全的共享和使用 `receiver`，等等，安全的共享？听上去 `Arc` 这个多所有权结构非常适合，互斥使用？貌似 `Mutex` 很适合，结合一下，`Arc<Mutex<T>>`，这不就是我们之前见过多次的线程安全类型吗？

总之，`Arc` 允许多个 `Worker` 同时持有 `receiver`，而 `Mutex` 可以确保一次只有一个 `Worker` 能从 `receiver` 接收消息。

```rust
use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};
// --snip--

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --snip--
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        // --snip--
    }
}
```

修改后，每一个 Worker 都可以安全的持有 `receiver`，同时不必担心一个任务会被重复执行多次，完美！


### 实现 execute 方法

首先，需要为一个很长的类型创建一个别名, 有多长呢？ 

```rust
// --snip--

type Job = Box<dyn FnOnce() + Send + 'static>;

impl ThreadPool {
    // --snip--

    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
```

创建别名的威力暂时还看不到，敬请期待。总之，这里的工作很简单，将传入的任务包装成 `Job` 类型后，发送出去。

但是还没完，接收的代码也要完善下:

```rust
// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!("Worker {id} got a job; executing.");

            job();
        });

        Worker { id, thread }
    }
}
```

修改后，就可以不停地循环去接收任务，最后进行执行。还可以看到因为之前 `Job` 别名的引入， `new` 函数的签名才没有过度复杂，否则你将看到的是 `fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Box<dyn FnOnce() + Send + 'static>>>>) -> Worker` ，感受下类型别名的威力吧 :D

`lock()` 方法可以获得一个 `Mutex` 锁，至于为何使用 `unwrap`，难道获取锁还能失败？没错，假如当前持有锁的线程 `panic` 了，那么这些等待锁的线程就会获取一个错误，因此 通过 `unwrap` 来让当前等待的线程 `panic` 是一个不错的解决方案，当然你还可以换成 `expect`。

一旦获取到锁里的内容 `mpsc::Receiver<Job>>` 后，就可以调用其上的 `recv` 方法来接收消息，依然是一个 `unwrap`，原因在于持有发送端的线程可能会被关闭，这种情况下直接 `panic` 也是不错的。

`recv` 的调用过程是阻塞的，意味着若没有任何任务，那当前的调用线程将一直等待，直到接收到新的任务。`Mutex<T>` 可以保证同一个任务只会被一个 Worker 获取，不会被重复执行。

```shell
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never read: `workers`
 --> src/lib.rs:7:5
  |
7 |     workers: Vec<Worker>,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: field is never read: `id`
  --> src/lib.rs:48:5
   |
48 |     id: usize,
   |     ^^^^^^^^^

warning: field is never read: `thread`
  --> src/lib.rs:49:5
   |
49 |     thread: thread::JoinHandle<()>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: `hello` (lib) generated 3 warnings
    Finished dev [unoptimized + debuginfo] target(s) in 1.40s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
```

终于，程序如愿运行起来，我们的线程池可以并发处理任务了！从打印的数字可以看到，只有 4 个线程去执行任务，符合我们对线程池的要求，这样再也不用担心系统的线程资源会被消耗殆尽了！


> 注意： 出于缓存的考虑，有些浏览器会对多次同样的请求进行顺序的执行，因此你可能还是会遇到访问 `/sleep` 后，就无法访问另一个 `/sleep` 的问题 :(


## while let 的巨大陷阱

还有一个问题，为啥之前我们不用 `while let` 来循环？例如：

```rust
// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!("Worker {id} got a job; executing.");

                job();
            }
        });

        Worker { id, thread }
    }
}
```

这段代码编译起来没问题，但是并不会产生我们预期的结果：后续请求依然需要等待慢请求的处理完成后，才能被处理。奇怪吧，仅仅是从 `let` 改成 `while let` 就会变成这样？大家可以思考下为什么会这样，具体答案会在下一章节末尾给出，这里先出给一个小提示：`Mutex` 获取的锁在作用域结束后才会被释放。















================================================
FILE: src/advance-practice1/web-server.md
================================================
[Binary file]


================================================
FILE: src/appendix/derive.md
================================================
## 附录 D：派生特征 trait

在本书的各个部分中，我们讨论了可应用于结构体和枚举定义的 `derive` 属性。被 `derive` 标记的对象会自动实现对应的默认特征代码，继承相应的功能。

在本附录中,我们列举了所有标准库存在的 `derive` 特征，每个特征覆盖了以下内容

- 该特征将会派生什么样的操作符和方法
- 由 `derive` 提供什么样的特征实现
- 实现特征对于类型意味着什么
- 你需要什么条件来实现该特征
- 特征示例

如果你希望不同于 `derive` 属性所提供的行为，请查阅 [标准库文档](https://doc.rust-lang.org/std/index.html) 中每个特征的细节以了解如何手动实现它们。

除了本文列出的特征之外，标准库中定义的其它特征不能通过 `derive` 在类型上实现。这些特征不存在有意义的默认行为，所以由你负责以合理的方式实现它们。

一个无法被派生的特征例子是为终端用户处理格式化的 `Display` 。你应该时常考虑使用合适的方法来为终端用户显示一个类型。终端用户应该看到类型的什么部分？他们会找出相关部分吗？对他们来说最关心的数据格式是什么样的？Rust 编译器没有这样的洞察力，因此无法为你提供合适的默认行为。

本附录所提供的可派生特征列表其实并不全面：库可以为其内部的特征实现 `derive` ，因此除了本文列出的标准库 `derive` 之外，还有很多很多其它库的 `derive` 。实现 `derive` 涉及到过程宏的应用，这在[宏章节](https://course.rs/advance/macro.html)中有介绍。

### 用于开发者输出的 `Debug`

`Debug` 特征可以让指定对象输出调试格式的字符串，通过在 `{}` 占位符中增加 `:?` 表明，例如`println!("show you some debug info: {:?}", MyObject);`.

`Debug` 特征允许以调试为目的来打印一个类型的实例，所以程序员可以在执行过程中看到该实例的具体信息。

例如，在使用 `assert_eq!` 宏时， `Debug` 特征是必须的。如果断言失败，这个宏就把给定实例的值打印出来，这样程序员就能看到两个实例为什么不相等。

### 等值比较的 `PartialEq` 和 `Eq`

`PartialEq` 特征可以比较一个类型的实例以检查是否相等，并开启了 `==` 和 `!=` 运算符的功能。

派生的 `PartialEq` 实现了 `eq` 方法。当 `PartialEq` 在结构体上派生时，只有*所有* 的字段都相等时两个实例才相等，同时只要有任何字段不相等则两个实例就不相等。当在枚举上派生时，每一个成员都和其自身相等，且和其他成员都不相等。

例如，当使用 `assert_eq!` 宏时，需要比较一个类型的两个实例是否相等，则 `PartialEq` 特征是必须的。

`Eq` 特征没有方法, 其作用是表明每一个被标记类型的值都等于其自身。 `Eq` 特征只能应用于那些实现了 `PartialEq` 的类型，但并非所有实现了 `PartialEq` 的类型都可以实现 `Eq`。浮点类型就是一个例子：浮点数的实现表明两个非数字（ `NaN` ，not-a-number）值是互不相等的。

例如，对于一个 `HashMap<K, V>` 中的 key 来说， `Eq` 是必须的，这样 `HashMap<K, V>` 就可以知道两个 key 是否一样。

### 次序比较的 `PartialOrd` 和 `Ord`

`PartialOrd` 特征可以让一个类型的多个实例实现排序功能。实现了 `PartialOrd` 的类型可以使用 `<`、 `>`、`<=` 和 `>=` 操作符。一个类型想要实现 `PartialOrd` 的前提是该类型已经实现了 `PartialEq` 。

派生 `PartialOrd` 实现了 `partial_cmp` 方法，一般情况下其返回一个 `Option<Ordering>`，但是当给定的值无法进行排序时将返回 `None`。尽管大多数类型的值都可以比较，但一个无法产生顺序的例子是：浮点类型的非数字值。当在浮点数上调用 `partial_cmp` 时， `NaN` 的浮点数将返回 `None`。

当在结构体上派生时， `PartialOrd` 以在结构体定义中字段出现的顺序比较每个字段的值来比较两个实例。当在枚举上派生时，认为在枚举定义中声明较早的枚举项小于其后的枚举项。

例如，对于来自于 `rand` 包的 `gen_range` 方法来说，当在一个大值和小值指定的范围内生成一个随机值时， `PartialOrd` trait 是必须的。

对于派生了 `Ord` 特征的类型，任何两个该类型的值都能进行排序。 `Ord` 特征实现了 `cmp` 方法，它返回一个 `Ordering` 而不是 `Option<Ordering>`，因为总存在一个合法的顺序。一个类型要想使用 `Ord` 特征，它必须要先实现 `PartialOrd` 和 `Eq` 。当在结构体或枚举上派生时， `cmp` 方法 和 `PartialOrd` 的 `partial_cmp` 方法表现是一致的。

例如，当在 `BTreeSet<T>`（一种基于有序值存储数据的数据结构）上存值时， `Ord` 是必须的。

### 复制值的 `Clone` 和 `Copy`

`Clone` 特征用于创建一个值的深拷贝（deep copy），复制过程可能包含代码的执行以及堆上数据的复制。查阅 [通过 Clone 进行深拷贝](https://course.rs/basic/ownership/ownership.html#克隆深拷贝)获取有关 `Clone` 的更多信息。

派生 `Clone` 实现了 `clone` 方法，当为整个的类型实现 `Clone` 时，在该类型的每一部分上都会调用 `clone` 方法。这意味着类型中所有字段或值也必须实现了 `Clone`，这样才能够派生 `Clone` 。

例如，当在一个切片（slice）上调用 `to_vec` 方法时， `Clone` 是必须的。切片只是一个引用，并不拥有其所包含的实例数据，但是从 `to_vec` 中返回的 Vector 需要拥有实例数据，因此， `to_vec` 需要在每个元素上调用 `clone` 来逐个复制。因此，存储在切片中的类型必须实现 `Clone`。

`Copy` 特征允许你通过只拷贝存储在栈上的数据来复制值(浅拷贝),而无需复制存储在堆上的底层数据。查阅 [通过 Copy 复制栈数据](https://course.rs/basic/ownership/ownership.html#拷贝浅拷贝) 的部分来获取有关 `Copy` 的更多信息。

实际上 `Copy` 特征并不阻止你在实现时使用了深拷贝，只是，我们不应该这么做，毕竟遵循一个语言的惯例是很重要的。当用户看到 `Copy` 时，潜意识就应该知道这是浅拷贝，复制一个值会非常快。

当一个类型的内部字段全部实现了 `Copy` 时，你就可以在该类型上派上 `Copy` 特征。 一个类型如果要实现 `Copy` 它必须先实现 `Clone` ，因为一个类型实现 `Clone` 后，就等于顺便实现了 `Copy` 。

总之， `Copy` 拥有更好的性能，当浅拷贝足够的时候，就不要使用 `Clone` ，不然会导致你的代码运行更慢，对于[性能优化](https://course.rs/profiling/performance/intro.html)来说，一个很大的方面就是减少热点路径深拷贝的发生。

### 固定大小的值映射的 `Hash`

`Hash` 特征允许你使用 `hash` 函数把一个任意大小的实例映射到一个固定大小的值上。派生 `Hash` 实现了 `hash` 方法，对某个类型进行 `hash` 调用，其实就是对该类型下每个字段单独进行 `hash` 调用，然后把结果进行汇总，这意味着该类型下的所有的字段也必须实现了 `Hash`，这样才能够派生 `Hash`。

例如，在 `HashMap<K, V>` 上存储数据，存放 key 的时候， `Hash` 是必须的。

### 默认值的 `Default`

`Default` 特征会帮你创建一个类型的默认值。 派生 `Default` 意味着自动实现了 `default` 函数。 `default` 函数的派生实现调用了类型每部分的 `default` 函数，这意味着类型中所有的字段也必须实现了 `Default`，这样才能够派生 `Default` 。

`Default::default` 函数通常结合结构体更新语法一起使用，这在第五章的 [结构体更新语法](https://course.rs/basic/compound-type/struct.html#结构体更新语法) 部分有讨论。可以自定义一个结构体的一小部分字段而剩余字段则使用 `..Default::default()` 设置为默认值。

例如，当你在 `Option<T>` 实例上使用 `unwrap_or_default` 方法时， `Default` 特征是必须的。如果 `Option<T>` 是 `None` 的话, `unwrap_or_default` 方法将返回 `T` 类型的 `Default::default` 的结果。



================================================
FILE: src/appendix/difficulties.md
================================================
[Binary file]


================================================
FILE: src/appendix/expressions.md
================================================
# 附录 C：表达式

在[语句与表达式](https://course.rs/basic/base-type/statement-expression.html)章节中，我们对表达式有过介绍，下面对这些常用表达式进行一一说明。

### 基本表达式

```rust
let n = 3;
let s = "test";
```

### if 表达式

```rust
fn main() {
    let var1 = 10;

    let var2 = if var1 >= 10 {
        var1
    } else {
        var1 + 10
    };

    println!("{}", var2);
}
```

通过 `if` 表达式将值赋予 `var2`。

你还可以在循环中结合 `continue` 、`break` 来使用：

```rust
let mut v = 0;
for i in 1..10 {
    v = if i == 9 {
        continue
    } else {
        i
    }
}
println!("{}", v);
```

### if let 表达式

```rust
let o = Some(3);
let v = if let Some(x) = o {
    x
} else {
    0
};
```

### match 表达式

```rust
let o = Some(3);
let v = match o {
    Some(x) => x,
    _ => 0
};
```

### loop 表达式

```rust
let mut n = 0;
let v = loop {
    if n == 10 {
        break n
    }
    n += 1;
};
```

### 语句块 {}

```rust
let mut n = 0;
let v = {
    println!("before: {}", n);
    n += 1;
    println!("after: {}", n);
    n
};
println!("{}", v);
```



================================================
FILE: src/appendix/intro.md
================================================
# 附录

附录中包含了一些 Rust 常用概念的快速索引，方便你的日常查询使用。

> 大部分的附录借鉴了 Rust Book 以及相应的 [中文翻译书籍](https://rustwiki.org/zh-CN/book/)，但同时做了一些的修改，增加准确性和阅读流畅度



================================================
FILE: src/appendix/keywords.md
================================================
## 附录 A：关键字

下面的列表包含 Rust 中正在使用或者以后会用到的关键字。因此，这些关键字不能被用作标识符（除了[原生标识符](#原生标识符)），包括函数、变量、参数、结构体字段、模块、包、常量、宏、静态值、属性、类型、特征或生命周期。

### 目前正在使用的关键字

如下关键字目前有对应其描述的功能。

- `as` - 强制类型转换，或`use` 和 `extern crate`包和模块引入语句中的重命名
- `break` - 立刻退出循环
- `const` - 定义常量或原生常量指针（constant raw pointer）
- `continue` - 继续进入下一次循环迭代
- `crate` - 链接外部包
- `dyn` - 动态分发特征对象
- `else` - 作为 `if` 和 `if let` 控制流结构的 fallback
- `enum` - 定义一个枚举类型
- `extern` - 链接一个外部包,或者一个宏变量(该变量定义在另外一个包中)
- `false` - 布尔值 `false`
- `fn` - 定义一个函数或 **函数指针类型** (_function pointer type_)
- `for` - 遍历一个迭代器或实现一个 trait 或者指定一个更高级的生命周期
- `if` - 基于条件表达式的结果来执行相应的分支
- `impl` - 为结构体或者特征实现具体功能
- `in` - `for` 循环语法的一部分
- `let` - 绑定一个变量
- `loop` - 无条件循环
- `match` - 模式匹配
- `mod` - 定义一个模块
- `move` - 使闭包获取其所捕获项的所有权
- `mut` - 在引用、裸指针或模式绑定中使用，表明变量是可变的
- `pub` - 表示结构体字段、`impl` 块或模块的公共可见性
- `ref` - 通过引用绑定
- `return` - 从函数中返回
- `Self` - 实现特征类型的类型别名
- `self` - 表示方法本身或当前模块
- `static` - 表示全局变量或在整个程序执行期间保持其生命周期
- `struct` - 定义一个结构体
- `super` - 表示当前模块的父模块
- `trait` - 定义一个特征
- `true` - 布尔值 `true`
- `type` - 定义一个类型别名或关联类型
- `unsafe` - 表示不安全的代码、函数、特征或实现
- `use` - 在当前代码范围内(模块或者花括号对)引入外部的包、模块等
- `where` - 表示一个约束类型的从句
- `while` - 基于一个表达式的结果判断是否继续循环

### 保留做将来使用的关键字

如下关键字没有任何功能，不过由 Rust 保留以备将来的应用。

- `abstract`
- `async`
- `await`
- `become`
- `box`
- `do`
- `final`
- `macro`
- `override`
- `priv`
- `try`
- `typeof`
- `unsized`
- `virtual`
- `yield`

### 原生标识符

原生标识符（Raw identifiers）允许你使用通常不能使用的关键字，其带有 `r#` 前缀。

例如，`match` 是关键字。如果尝试编译如下使用 `match` 作为名字的函数：

```rust,ignore,does_not_compile
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```

会得到这个错误：

```text
error: expected identifier, found keyword `match`
 --> src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```

该错误表示你不能将关键字 `match` 用作函数标识符。你可以使用原生标识符将 `match` 作为函数名称使用：

<span class="filename">文件名: src/main.rs</span>

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```

此代码编译没有任何错误。注意 `r#` 前缀需同时用于函数名定义和 `main` 函数中的调用。

原生标识符允许使用你选择的任何单词作为标识符，即使该单词恰好是保留关键字。 此外，原生标识符允许你使用其它 Rust 版本编写的库。比如，`try` 在 Rust 2015 edition 中不是关键字，却在 Rust 2018 edition 是关键字。所以如果用 2015 edition 编写的库中带有 `try` 函数，在 2018 edition 中调用时就需要使用原始标识符语法，在这里是 `r#try`。



================================================
FILE: src/appendix/operators.md
================================================
## 附录 B：运算符与符号

该附录包含了 Rust 目前出现过的各种符号，这些符号之前都分散在各个章节中。

### 运算符

表 B-1 包含了 Rust 中的运算符、上下文中的示例、简短解释以及该运算符是否可重载。如果一个运算符是可重载的，则该运算符上用于重载的特征也会列出。

下表中，`expr` 是表达式，`ident` 是标识符，`type` 是类型，`var` 是变量，`trait` 是特征，`pat` 是匹配分支(pattern)。

<span class="caption">表 B-1：运算符</span>

| 运算符                    | 示例                                                    | 解释                               | 是否可重载     |
| ------------------------- | ------------------------------------------------------- | ---------------------------------- | -------------- |
| `!`                       | `ident!(...)`, `ident!{...}`, `ident![...]`             | 宏展开                             |                |
| `!`                       | `!expr`                                                 | 按位非或逻辑非                     | `Not`          |
| `!=`                      | `var != expr`                                           | 不等比较                           | `PartialEq`    |
| `%`                       | `expr % expr`                                           | 算术求余                           | `Rem`          |
| `%=`                      | `var %= expr`                                           | 算术求余与赋值                     | `RemAssign`    |
| `&`                       | `&expr`, `&mut expr`                                    | 借用                               |                |
| `&`                       | `&type`, `&mut type`, `&'a type`, `&'a mut type`        | 借用指针类型                       |                |
| `&`                       | `expr & expr`                                           | 按位与                             | `BitAnd`       |
| `&=`                      | `var &= expr`                                           | 按位与及赋值                       | `BitAndAssign` |
| `&&`                      | `expr && expr`                                          | 逻辑与                             |                |
| `*`                       | `expr * expr`                                           | 算术乘法                           | `Mul`          |
| `*=`                      | `var *= expr`                                           | 算术乘法与赋值                     | `MulAssign`    |
| `*`                       | `*expr`                                                 | 解引用                             |                |
| `*`                       | `*const type`, `*mut type`                              | 裸指针                           |                |
| `+`                       | `trait + trait`, `'a + trait`                           | 复合类型限制                       |                |
| `+`                       | `expr + expr`                                           | 算术加法                           | `Add`          |
| `+=`                      | `var += expr`                                           | 算术加法与赋值                     | `AddAssign`    |
| `,`                       | `expr, expr`                                            | 参数以及元素分隔符                 |                |
| `-`                       | `- expr`                                                | 算术取负                           | `Neg`          |
| `-`                       | `expr - expr`                                           | 算术减法                           | `Sub`          |
| `-=`                      | `var -= expr`                                           | 算术减法与赋值                     | `SubAssign`    |
| `->`                      | `fn(...) -> type`, <code>&vert;...&vert; -> type</code> | 函数与闭包，返回类型               |                |
| `.`                       | `expr.ident`                                            | 成员访问                           |                |
| `..`                      | `..`, `expr..`, `..expr`, `expr..expr`                  | 右半开区间                         | PartialOrd     |
| `..=`                     | `..=expr`, `expr..=expr`                                | 闭合区间                           | PartialOrd     |
| `..`                      | `..expr`                                                | 结构体更新语法                     |                |
| `..`                      | `variant(x, ..)`, `struct_type { x, .. }`               | “代表剩余部分”的模式绑定           |                |
| `...`                     | `expr...expr`                                           | (不推荐使用，用`..=`替代) 闭合区间 |                |
| `/`                       | `expr / expr`                                           | 算术除法                           | `Div`          |
| `/=`                      | `var /= expr`                                           | 算术除法与赋值                     | `DivAssign`    |
| `:`                       | `pat: type`, `ident: type`                              | 约束                               |                |
| `:`                       | `ident: expr`                                           | 结构体字段初始化                   |                |
| `:`                       | `'a: loop {...}`                                        | 循环标志                           |                |
| `;`                       | `expr;`                                                 | 语句和语句结束符                   |                |
| `;`                       | `[...; len]`                                            | 固定大小数组语法的部分             |                |
| `<<`                      | `expr << expr`                                          | 左移                               | `Shl`          |
| `<<=`                     | `var <<= expr`                                          | 左移与赋值                         | `ShlAssign`    |
| `<`                       | `expr < expr`                                           | 小于比较                           | `PartialOrd`   |
| `<=`                      | `expr <= expr`                                          | 小于等于比较                       | `PartialOrd`   |
| `=`                       | `var = expr`, `ident = type`                            | 赋值/等值                          |                |
| `==`                      | `expr == expr`                                          | 等于比较                           | `PartialEq`    |
| `=>`                      | `pat => expr`                                           | 匹配分支语法的部分                 |                |
| `>`                       | `expr > expr`                                           | 大于比较                           | `PartialOrd`   |
| `>=`                      | `expr >= expr`                                          | 大于等于比较                       | `PartialOrd`   |
| `>>`                      | `expr >> expr`                                          | 右移                               | `Shr`          |
| `>>=`                     | `var >>= expr`                                          | 右移与赋值                         | `ShrAssign`    |
| `@`                       | `ident @ pat`                                           | 模式绑定                           |                |
| `^`                       | `expr ^ expr`                                           | 按位异或                           | `BitXor`       |
| `^=`                      | `var ^= expr`                                           | 按位异或与赋值                     | `BitXorAssign` |
| <code>&vert;</code>       | <code>pat &vert; pat</code>                             | 模式匹配中的多个可选条件           |                |
| <code>&vert;</code>       | <code>expr &vert; expr</code>                           | 按位或                             | `BitOr`        |
| <code>&vert;=</code>      | <code>var &vert;= expr</code>                           | 按位或与赋值                       | `BitOrAssign`  |
| <code>&vert;&vert;</code> | <code>expr &vert;&vert; expr</code>                     | 逻辑或                             |                |
| `?`                       | `expr?`                                                 | 错误传播                           |                |

### 非运算符符号

<span class="caption">表 B-2：独立语法</span>

| 符号                                        | 解释                                                   |
| ------------------------------------------- | ------------------------------------------------------ |
| `'ident`                                    | 生命周期名称或循环标签                                 |
| `...u8`, `...i32`, `...f64`, `...usize`, 等 | 指定类型的数值常量                                     |
| `"..."`                                     | 字符串常量                                             |
| `r"..."`, `r#"..."#`, `r##"..."##`, etc.    | 原生字符串, 未转义字符                                 |
| `b"..."`                                    | 将 `&str` 转换成 `&[u8; N]` 类型的数组                 |
| `br"..."`, `br#"..."#`, `br##"..."##`, 等   | 原生字节字符串，原生和字节字符串字面值的结合           |
| `'...'`                                     | Char 字符                                              |
| `b'...'`                                    | ASCII 字节                                             |
| <code>&vert;...&vert; expr</code>           | 闭包                                                   |
| `!`                                         | 代表总是空的类型，用于发散函数(无返回值函数)           |
| `_`                                         | 模式绑定中表示忽略的意思；也用于增强整型字面值的可读性 |

表 B-3 展示了模块和对象调用路径的语法。

<span class="caption">表 B-3：路径相关语法</span>

| 符号                                    | 解释                                                              |
| --------------------------------------- | ----------------------------------------------------------------- |
| `ident::ident`                          | 命名空间路径                                                      |
| `::path`                                | 从当前的包的根路径开始的相对路径                                  |
| `self::path`                            | 与当前模块相对的路径（如一个显式相对路径）                        |
| `super::path`                           | 与父模块相对的路径                                                |
| `type::ident`, `<type as trait>::ident` | 关联常量、关联函数、关联类型                                      |
| `<type>::...`                           | 不可以被直接命名的关联项类型（如 `<&T>::...`，`<[T]>::...`， 等） |
| `trait::method(...)`                    | 使用特征名进行方法调用，以消除方法调用的二义性                    |
| `type::method(...)`                     | 使用类型名进行方法调用, 以消除方法调用的二义性                    |
| `<type as trait>::method(...)`          | 将类型转换为特征，再进行方法调用,以消除方法调用的二义性           |

表 B-4 展示了使用泛型参数时用到的符号。

<span class="caption">表 B-4：泛型</span>

| 符号                           | 解释                                                                                              |
| ------------------------------ | ------------------------------------------------------------------------------------------------- |
| `path<...>`                    | 为一个类型中的泛型指定具体参数（如 `Vec<u8>`）                                                    |
| `path::<...>`, `method::<...>` | 为一个泛型、函数或表达式中的方法指定具体参数，通常指双冒号(turbofish)（如 `"42".parse::<i32>()`） |
| `fn ident<...> ...`            | 泛型函数定义                                                                                      |
| `struct ident<...> ...`        | 泛型结构体定义                                                                                    |
| `enum ident<...> ...`          | 泛型枚举定义                                                                                      |
| `impl<...> ...`                | 实现泛型                                                                                          |
| `for<...> type`                | 高阶生命周期限制                                                                                  |
| `type<ident=type>`             | 泛型，其一个或多个相关类型必须被指定为特定类型（如 `Iterator<Item=T>`）                           |

表 B-5 展示了使用特征约束来限制泛型参数的符号。

<span class="caption">表 B-5：特征约束</span>

| 符号                          | 解释                                                                                     |
| ----------------------------- | ---------------------------------------------------------------------------------------- |
| `T: U`                        | 泛型参数 `T`需实现`U`类型                                                                |
| `T: 'a`                       | 泛型 `T` 的生命周期必须长于 `'a`（意味着该类型不能传递包含生命周期短于 `'a` 的任何引用） |
| `T : 'static`                 | 泛型 T 只能使用声明周期为'static 的引用                                                  |
| `'b: 'a`                      | 生命周期`'b`必须长于生命周期`'a`                                                         |
| `T: ?Sized`                   | 使用一个不定大小的泛型类型                                                               |
| `'a + trait`, `trait + trait` | 多个类型组成的复合类型限制                                                               |

表 B-6 展示了宏以及在一个对象上定义属性的符号。

<span class="caption">表 B-6：宏与属性</span>

| 符号                                        | 解释     |
| ------------------------------------------- | -------- |
| `#[meta]`                                   | 外部属性 |
| `#![meta]`                                  | 内部属性 |
| `$ident`                                    | 宏替换   |
| `$ident:kind`                               | 宏捕获   |
| `$(…)…`                                     | 宏重复   |
| `ident!(...)`, `ident!{...}`, `ident![...]` | 宏调用   |

表 B-7 展示了写注释的符号。

<span class="caption">表 B-7：注释</span>

| 符号       | 注释                 |
| ---------- | -------------------- |
| `//`       | 行注释               |
| `//!`      | 内部行(hang)文档注释 |
| `///`      | 外部行文档注释       |
| `/*...*/`  | 块注释               |
| `/*!...*/` | 内部块文档注释       |
| `/**...*/` | 外部块文档注释       |

表 B-8 展示了出现在使用元组时的符号。

<span class="caption">表 B-8：元组</span>

| 符号                     | 解释                                                                     |
| ------------------------ | ------------------------------------------------------------------------ |
| `()`                     | 空元组（亦称单元），即是字面值也是类型                                   |
| `(expr)`                 | 括号表达式                                                               |
| `(expr,)`                | 单一元素元组表达式                                                       |
| `(type,)`                | 单一元素元组类型                                                         |
| `(expr, ...)`            | 元组表达式                                                               |
| `(type, ...)`            | 元组类型                                                                 |
| `expr(expr, ...)`        | 函数调用表达式；也用于初始化元组结构体 `struct` 以及元组枚举 `enum` 变体 |
| `expr.0`, `expr.1`, etc. | 元组索引                                                                 |

表 B-9 展示了使用大括号的上下文。

<span class="caption">表 B-9：大括号</span>

| 符号         | 解释         |
| ------------ | ------------ |
| `{...}`      | 代码块表达式 |
| `Type {...}` | 结构体字面值 |

表 B-10 展示了使用方括号的上下文。

<span class="caption">表 B-10：方括号</span>

| 符号                                               | 解释                                                                                                     |
| -------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |
| `[...]`                                            | 数组                                                                                                     |
| `[expr; len]`                                      | 数组里包含`len`个`expr`                                                                                  |
| `[type; len]`                                      | 数组里包含了`len`个`type`类型的对象                                                                      |
| `expr[expr]`                                       | 集合索引。 重载（`Index`, `IndexMut`）                                                                   |
| `expr[..]`, `expr[a..]`, `expr[..b]`, `expr[a..b]` | 集合索引，也称为集合切片，索引要实现以下特征中的其中一个：`Range`，`RangeFrom`，`RangeTo` 或 `RangeFull` |



================================================
FILE: src/appendix/prelude.md
================================================
# 附录 E：prelude 模块



================================================
FILE: src/appendix/rust-version.md
================================================
# 附录 F：Rust 版本发布

## Rust 版本说明

早在第一章，我们见过 `cargo new` 在 _Cargo.toml_ 中增加了一些有关 `edition` 的元数据。本附录将解释其意义！

与其它语言相比，Rust 的更新迭代较为频繁（得益于精心设计过的发布流程以及 Rust 语言开发者团队管理）：

- 每 6 周发布一个迭代版本
- 2 - 3 年发布一个新的大版本：每一个版本会结合已经落地的功能，并提供一个清晰的带有完整更新文档和工具的功能包。新版本会作为常规的 6 周发布过程的一部分发布。

好处在于，可以满足不同的用户群体的需求：

- 对于活跃的 Rust 用户，他们总是能很快获取到新的语言内容，毕竟，尝鲜是技术爱好者的共同特点:)
- 对于一般的用户，edition 的发布会告诉这些用户：Rust 语言相比上次大版本发布，有了重大的改进，值得一看
- 对于 Rust 语言开发者，可以让他们的工作成果更快的被世人所知，不必锦衣夜行

在本文档编写时，Rust 已经有三个版本：Rust 2015、2018、2021。本书基于 `Rust 2021 edition` 编写。

_Cargo.toml_ 中的 `edition` 字段表明代码应该使用哪个版本编译。如果该字段不存在，其默认为 `2021` 以提供后向兼容性。

每个项目都可以选择不同于默认的 `Rust 2021 edition` 的版本。这样，版本可能会包含不兼容的修改，比如新版本中新增的关键字可能会与老代码中的标识符冲突并导致错误。不过，除非你选择应用这些修改，否则旧代码依然能够被编译，即便你升级了编译器版本。

所有 Rust 编译器都支持任何之前存在的编译器版本，并可以链接任何支持版本的包。编译器修改只影响最初的解析代码的过程。因此，如果你使用 `Rust 2021` 而某个依赖使用 `Rust 2018`，你的项目仍旧能够编译并使用该依赖。反之，若项目使用 `Rust 2018` 而依赖使用 `Rust 2021` 亦可工作。

有一点需要明确：大部分功能在所有版本中都能使用。开发者使用任何 Rust 版本将能继续接收最新稳定版的改进。然而在一些情况，主要是增加了新关键字的时候，则可能出现了只能用于新版本的功能。只需切换版本即可利用新版本的功能。

请查看 [Edition Guide](https://rust-lang-nursery.github.io/edition-guide/) 了解更多细节，这是一个完全介绍版本的书籍，包括如何通过 `cargo fix` 自动将代码迁移到新版本。

## Rust 自身开发流程

本附录介绍 Rust 语言自身是如何开发的以及这如何影响作为 Rust 开发者的你。

### 无停滞稳定

作为一个语言，Rust **十分** 注重代码的稳定性。我们希望 Rust 成为你代码坚实的基础，假如持续地有东西在变，这个希望就实现不了。但与此同时，如果不能实验新功能的话，在发布之前我们又无法发现其中重大的缺陷，而一旦发布便再也没有修改的机会了。

对于这个问题我们的解决方案被称为 “无停滞稳定”（“stability without stagnation”），其指导性原则是：无需担心升级到最新的稳定版 Rust。每次升级应该是无痛的，并应带来新功能，更少的 Bug 和更快的编译速度。

### Choo, Choo! ~~ 小火车发布流程启动

开发 Rust 语言是基于一个**火车时刻表**来进行的：所有的开发工作在 Master 分支上完成，但是发布就像火车时刻表一样，拥有不同的时间，发布采用的软件发布列车模型，被用于思科 IOS 等其它软件项目。Rust 有三个 **发布通道**（_release channel_）：

- Nightly
- Beta
- Stable（稳定版）

大部分 Rust 开发者主要采用稳定版通道，不过希望实验新功能的开发者可能会使用 nightly 或 beta 版。

如下是一个开发和发布过程如何运转的例子：假设 Rust 团队正在进行 Rust 1.5 的发布工作。该版本发布于 2015 年 12 月，这个版本和时间显然比较老了，不过这里只是为了提供一个真实的版本。Rust 新增了一项功能：一个 `master` 分支的新提交。每天晚上，会产生一个新的 nightly 版本。每天都是发布版本的日子，而这些发布由发布基础设施自动完成。所以随着时间推移，发布轨迹看起来像这样，版本一天一发：

```text
nightly: * - - * - - *
```

每 6 周时间，是准备发布新版本的时候了！Rust 仓库的 `beta` 分支会从用于 nightly 的 `master` 分支产生。现在，有了两个发布版本：

```text
nightly: * - - * - - *
                     |
beta:                *
```

大部分 Rust 用户不会主要使用 beta 版本，不过在 CI 系统中对 beta 版本进行测试能够帮助 Rust 发现可能的回归缺陷（regression）。同时，每天仍产生 nightly 发布：

```text
nightly: * - - * - - * - - * - - *
                     |
beta:                *
```

比如我们发现了一个回归缺陷。好消息是在这些缺陷流入稳定发布之前还有一些时间来测试 beta 版本！fix 被合并到 `master`，为此 nightly 版本得到了修复，接着这些 fix 将 backport 到 `beta` 分支，一个新的 beta 发布就产生了：

```text
nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
```

第一个 beta 版的 6 周后，是发布稳定版的时候了！`stable` 分支从 `beta` 分支生成：

```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
```

好的！Rust 1.5 发布了！然而，我们忘了些东西：因为又过了 6 周，我们还需发布 **新版** Rust 的 beta 版，Rust 1.6。所以从 `beta` 分支生成 `stable` 分支后，新版的 `beta` 分支也再次从 `nightly` 生成：

```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
```

这被称为 “train model”，因为每 6 周，一个版本 “离开车站”（“leaves the station”），不过从 beta 通道到达稳定通道还有一段旅程。

Rust 每 6 周发布一个版本，如时钟般准确。如果你知道了某个 Rust 版本的发布时间，就可以知道下个版本的时间：6 周后。每 6 周发布版本的一个好的方面是下一班车会来得更快。如果特定版本碰巧缺失某个功能也无需担心：另一个版本很快就会到来！这有助于减少因临近发版时间而偷偷释出未经完善的功能的压力。

多亏了这个过程，你总是可以切换到下一版本的 Rust 并验证是否可以轻易的升级：如果 beta 版不能如期工作，你可以向 Rust 团队报告并在发布稳定版之前得到修复！beta 版造成的破坏是非常少见的，不过 `rustc` 也不过是一个软件，可能会存在 Bug。

### 不稳定功能

这个发布模型中另一个值得注意的地方：不稳定功能（unstable features）。Rust 使用一个被称为 “功能标记”（“feature flags”）的技术来确定给定版本的某个功能是否启用。如果新功能正在积极地开发中，其提交到了 `master`，因此会出现在 nightly 版中，不过会位于一个 **功能标记** 之后。作为用户，如果你希望尝试这个正在开发的功能，则可以在源码中使用合适的标记来开启，不过必须使用 nightly 版。

如果使用的是 beta 或稳定版 Rust，则不能使用任何功能标记。这是在新功能被宣布为永久稳定之前获得实用价值的关键。这既满足了希望使用最尖端技术的同学，那些坚持稳定版的同学也知道其代码不会被破坏。这就是无停滞稳定。

本书只包含稳定的功能，因为还在开发中的功能仍可能改变，当其进入稳定版时肯定会与编写本书的时候有所不同。你可以在网上获取 nightly 版的文档。

### Rustup 和 Rust Nightly 的职责

#### 安装 Rust Nightly 版本

Rustup 使得改变不同发布通道的 Rust 更为简单，其在全局或分项目的层次工作。其默认会安装稳定版 Rust。例如为了安装 nightly：

```text
$ rustup install nightly
```

你会发现 `rustup` 也安装了所有的 **工具链**（_toolchains_， Rust 和其相关组件）。如下是一位作者的 Windows 计算机上的例子：

```powershell
> rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
```

#### 在指定目录使用 Rust Nightly

如你所见，默认是稳定版。大部分 Rust 用户在大部分时间使用稳定版。你可能也会这么做，不过如果你关心最新的功能，可以为特定项目使用 nightly 版。为此，可以在项目目录使用 `rustup override` 来设置当前目录 `rustup` 使用 nightly 工具链：

```text
$ cd ~/projects/needs-nightly
$ rustup override set nightly
```

现在，每次在 *~/需要 nightly 的项目/*下(在项目的根目录下，也就是 `Cargo.toml` 所在的目录) 调用 `rustc` 或 `cargo`，`rustup` 会确保使用 nightly 版 Rust。在你有很多 Rust 项目时大有裨益！

### RFC 过程和团队

那么你如何了解这些新功能呢？Rust 开发模式遵循一个 **Request For Comments (RFC) 过程**。如果你希望改进 Rust，可以编写一个提议，也就是 RFC。

任何人都可以编写 RFC 来改进 Rust，同时这些 RFC 会被 Rust 团队评审和讨论，他们由很多不同分工的子团队组成。这里是 [Rust 官网](https://www.rust-lang.org/governance) 上所有团队的总列表，其包含了项目中每个领域的团队：语言设计、编译器实现、基础设施、文档等。各个团队会阅读相应的提议和评论，编写回复，并最终达成接受或回绝功能的一致。

如果功能被接受了，在 Rust 仓库会打开一个 issue，人们就可以实现它。实现功能的人可能不是最初提议功能的人！当实现完成后，其会合并到 `master` 分支并位于一个特性开关（feature gate）之后，正如[不稳定功能](#不稳定功能) 部分所讨论的。

在稍后的某个时间，一旦使用 nightly 版的 Rust 团队能够尝试这个功能了，团队成员会讨论这个功能在 nightly 中运行的情况，并决定是否应该进入稳定版。如果决定继续推进，特性开关会移除，然后这个功能就被认为是稳定的了！乘着“发布的列车”，最终在新的稳定版 Rust 中出现。



================================================
FILE: src/appendix/rust-versions/1.58.md
================================================
# Rust 新版解读 | 1.58 | 重点: 格式化字符串捕获环境中的值

众所周知，Rust 小版本发布非常频繁，6 周就发布一次，因此通常不会有特别值得普通用户关注的内容，但是这次 1.58 版本不同，新增了(stable 化了)一个非常好用的功能： **在格式化字符串时捕获环境中的值**。

> Rust 1.58 官方 release doc: [Announcing Rust 1.58.0 | Rust Blog](https://blog.rust-lang.org/2022/01/13/Rust-1.58.0.html)

## 在格式化字符串时捕获环境中的值

在以前，想要输出一个函数的返回值，你需要这么做：

```rust
fn get_person() -> String {
    String::from("sunface")
}
fn main() {
    let p = get_person();
    println!("Hello, {}!", p);                // implicit position
    println!("Hello, {0}!", p);               // explicit index
    println!("Hello, {person}!", person = p);
}
```

问题倒也不大，但是一旦格式化字符串长了后，就会非常冗余，而在 1.58 后，我们可以这么写：

```rust
fn get_person() -> String {
    String::from("sunface")
}
fn main() {
    let person = get_person();
    println!("Hello, {person}!");
}
```

是不是清晰、简洁了很多？甚至还可以将环境中的值用于格式化参数:

```rust
let (width, precision) = get_format();
for (name, score) in get_scores() {
  println!("{name}: {score:width$.precision$}");
}
```

但也有局限，它只能捕获普通的变量，对于更复杂的类型（例如表达式），可以先将它赋值给一个变量或使用以前的 `name = expression` 形式的格式化参数。

目前除了 `panic!` 外，其它接收格式化参数的宏，都可以使用新的特性。对于 `panic!` 而言，如果还在使用 `2015版本` 或 `2018版本` 版本 ，那 `panic!("{ident}")` 依然会被当成 正常的字符串来处理，同时编译器会给予 `warn` 提示。而对于 `2021版本` ，则可以正常使用:

```rust
fn get_person() -> String {
    String::from("sunface")
}
fn main() {
    let person = get_person();
    panic!("Hello, {person}!");
}
```

输出:

```console
thread 'main' panicked at 'Hello, sunface!', src/main.rs:6:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

## 比 unwrap 更危险的 unwrap_unchecked

在 1.58 中为 `Option` 和 `Result` 新增了 `unwrap_unchecked` 方法，与 `unwrap` 遇到错误或者空值直接 `panic` 不同，`unwrap_unchecked` 遇到错误时处理方式糟糕的多：

```rust
fn get_num() -> Option<i32> {
   None
}
fn main() {
    unsafe {
        let n = get_num().unwrap_unchecked();
    }
}
```

输出如下：

```console
zsh: segmentation fault  cargo run
```

嗯，段错误了，对比下 `panic`，有一种泪流满面的冲动：我要这不安全的方法何用？

其实，还真有些用：

- 想要较小的可执行文件时（嵌入式，WASM 等），该方法就可以大显身手。因为 `panic` 会导致[二进制可执行文件变大不少](https://zhuanlan.zhihu.com/p/445465092)
- 它还可以提高一点性能， 因为编译器可能无法优化掉 `unwrap` 的指令分支， 虽然它只会增加区区几条分支预测指令



================================================
FILE: src/appendix/rust-versions/1.59.md
================================================
# Rust 新版解读 | 1.59 | 重点: 内联汇编、解构式赋值

Rust 团队于今天凌晨( 2022-02-25 )发布了最新的 1.59 版本，其中最引人瞩目的特性应该就是支持在代码中内联汇编了，一起来看看。

## 内联汇编( inline assembly )

该特性对于需要底层控制的应用非常有用，例如想要控制底层执行、访问特定的机器指令等。

例如，如果目标平台是 `x86-64` 时，你可以这么写：

```rust
use std::arch::asm;

// 使用 shifts 和 adds 实现 x 乘以 6
let mut x: u64 = 4;
unsafe {``
    asm!(
        "mov {tmp}, {x}",
        "shl {tmp}, 1",
        "shl {x}, 2",
        "add {x}, {tmp}",
        x = inout(reg) x,
        tmp = out(reg) _,
    );
}
assert_eq!(x, 4 * 6);
```

大家发现没，这里的格式化字符串的使用方式跟我们平时的 `println!`、`format!` 并无区别， 除了 `asm!` 之外， `global_asm!` 宏也可以这么使用。

内联汇编中使用的汇编语言和指令取决于相应的机器平台，截至目前，Rust 支持以下平台的内联汇编：

- x86 和 x86-64
- ARM
- AArch64
- RISC-V

如果大家希望深入了解，可以看官方的 [Reference](https://doc.rust-lang.org/nightly/reference/inline-assembly.html) 文档，同时在 [Rust Exercise](https://zh.exercise.rs/unsafe/inline-asm) 中提供了更多的示例(目前正在翻译中..)。

## 解构式赋值( Destructuring assignments)

现在你可以在赋值语句的左式中使用元组、切片和结构体模式了。

```rust
let (a, b, c, d, e);

(a, b) = (1, 2);
[c, .., d, _] = [1, 2, 3, 4, 5];
Struct { e, .. } = Struct { e: 5, f: 3 };

assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);
```

这种使用方式跟 `let` 保持了一致性，但是需要注意，使用 `+=` 的赋值语句还不支持解构式赋值。

## const 泛型

#### 为参数设置默认值

现在我们可以为 const 泛型参数设置默认值：

```rust
struct ArrayStorage<T, const N: usize = 2> {
    arr: [T; N],
}

impl<T> ArrayStorage<T> {
    fn new(a: T, b: T) -> ArrayStorage<T> {
        ArrayStorage {
            arr: [a, b],
        }
    }
}
```

#### 取消参数顺序的限制

在之前版本中，类型参数必须要在所有的 const 泛型参数之前，现在，这个限制被放宽了，例如你可以这样交替排列它们：

```rust
fn cartesian_product<
    T, const N: usize,
    U, const M: usize,
    V, F
>(a: [T; N], b: [U; M], f: F) -> [[V; N]; M]
where
    F: FnMut(&T, &U) -> V
{
    // ...
}
```

## 缩小二进制文件体积：删除 debug 信息

对于受限的环境来说，缩小编译出的二进制文件体积是非常重要的。

以往我们可以在二进制文件被创建后，手动的来完成。现在 cargo 和 rustc 支持在链接( linked )后就删除 debug 信息，在 `Cargo.toml` 中新增以下配置：

```toml
[profile.release]
strip = "debuginfo"
```

以上配置会将 `release` 二进制文件中的 debug 信息移除。你也可以使用 `"symbols"` 或 `true` 选项来移除所有支持的 `symbol` 信息。

根据 reddit 网友的测试，如果使用了 `strip = true`，那编译后的体积将大幅减少(50% 左右):

- 先使用 `lto = true` : 4,397,320 bytes
- 再使用 `strip = true` : 2,657,304 bytes
- 最后 `opt-level = "z"` : 1,857,680 bytes

如果是 WASM，还可以使用以下配置进一步减少体积:

```toml
[package.metadata.wasm-pack.profile.release]
wasm-opt = ['-Os']
```

[github 上一个开源仓库](https://github.com/rsadsb/adsb_deku/blob/master/CHANGELOG.md#unreleased)也证明了这一点，总体来看，这个配置的效果是非常显著的！

## 默认关闭增量编译

1.59.0 版本默认关闭了增量编译的功能（你可以通过环境变量显式地启用：`RUSTC_FORCE_INCREMENTAL=1` ），这会降低已知 Bug [#94124](https://github.com/rust-lang/rust/issues/94124) 的影响，该 Bug 会导致增量编译过程中的反序列化错误和 `panic`。

不过大家也不用担心，这个 Bug 会在 1.60.0 版本修复，也就是 6 周后，增量编译会重新设置为默认开启，如果没有意外的话 :)

## 稳定化的 API 列表

一些方法和特征实现现在已经可以 stable 中使用，具体见[官方发布说明](https://blog.rust-lang.org/2022/02/24/Rust-1.59.0.html#stabilized-apis)



================================================
FILE: src/appendix/rust-versions/1.60.md
================================================
# Rust 新版解读 | 1.60 | 重点: 查看 Cargo 构建耗时详情、Cargo Feature 增加新语法

> 原文链接: https://blog.rust-lang.org/2022/04/07/Rust-1.60.0.html


通过 [rustup](https://www.rust-lang.org/tools/install) 安装的同学可以使用以下命令升级到 1.60 版本:
```shell
$ rustup update stable
```

## 基于源码的代码覆盖
rustc 新增了基于 LLVM 的代码覆盖率测量，想要测试的同学可以通过以下方式重新构建你的项目:
```shell
$ RUSTFLAGS="-C instrument-coverage" cargo build
```

运行新生成的可执行文件将在当前目录下产生一个 `default.profraw` 文件( 路径和文件名可以通过环境变量进行[覆盖](https://doc.rust-lang.org/stable/rustc/instrument-coverage.html#running-the-instrumented-binary-to-generate-raw-coverage-profiling-data) )。

`llvm-tools-preview` 组件包含了 `llvm-profdata`，可以用于处理和合并<ruby>原生的测量结果输出<rt>raw profile output)</rt></ruby>(测量区域执行数)。

`llvm-cov` 用于报告生成，它将 `llvm-profdata` 处理后的输出跟二进制可执行文件自身相结合，对于前者大家可能好理解，但是为何要跟后者可执行文件相结合呢？原因在于可执行文件中嵌入了一个从计数器到实际源代码单元的映射。

```shell
rustup component add llvm-tools-preview
$(rustc --print sysroot)/lib/rustlib/x86_64-unknown-linux-gnu/bin/llvm-profdata merge -sparse default.profraw -o default.profdata
$(rustc --print sysroot)/lib/rustlib/x86_64-unknown-linux-gnu/bin/llvm-cov show -Xdemangler=rustfilt target/debug/coverage-testing \
    -instr-profile=default.profdata \
    -show-line-counts-or-regions \
    -show-instantiations
```

基于一个简单的 hello world 可执行文件，执行以上命令就可以获得如下带有标记的结果：
```rust
1|      1|fn main() {
2|      1|    println!("Hello, world!");
3|      1|}
```

从结果中可以看出：每一行代码都已经被成功覆盖。

如果大家还想要了解更多，可以看下[官方的 rustc 文档](https://doc.rust-lang.org/rustc/instrument-coverage.html)。目前来说，基准功能已经稳定了，并将以某种形式存在于未来所有的 Rust 发布版本中。 但输出格式和产生这些输出的 LLVM 工具可能依然会发生变化，基于此，大家在使用时需要确保 `llvm-tools-preview` 和 rustc ( 用于编译代码的 )使用了相同的版本。

## 查看 Cargo 构建耗时
新版本中，以下命令已经可以正常使用了:
```shell
$ cargo build --timings
   Compiling hello-world v0.1.0 (hello-world)
      Timing report saved to target/cargo-timings/cargo-timing-20220318T174818Z.html
    Finished dev [unoptimized + debuginfo] target(s) in 0.98s
```

此命令会生成一个 `cargo build` 的耗时详情报告，除了上面提到的路径外，报告还会被拷贝到 `target/cargo-timings/cargo-timing.html`。这里是一个[在线示例](https://blog.rust-lang.org/images/2022-04-07-timing.html)。该报告在你需要提升构建速度时会非常有用，更多的信息请[查看文档](https://doc.rust-lang.org/nightly/cargo/reference/timings.html)。

## Cargo Feature 的新语法

> 关于 Cargo Features ，强烈推荐大家看看 [Cargo 使用指南](https://course.rs/cargo/reference/features/intro.html)，可能是目前最好的中文翻译版本。

新版本为 Cargo Features 引入了两个新的语法: 命名空间 ( Namespaced )和弱依赖，它们可以让 features 跟可选依赖进行更好的交互。

Cargo 支持[可选依赖](https://course.rs/cargo/reference/features/intro.html#可选依赖)已经很久了，例如以下代码所示:
```toml
[dependencies]
jpeg-decoder = { version = "0.1.20", default-features = false, optional = true }

[features]
# 通过开启 jpeg-decoder 依赖的 "rayon` feture，来启用并行化处理
parallel = ["jpeg-decoder/rayon"]
```

这个例子有两点值得注意：

- 可选依赖 `jpeg-decoder` 隐式地定义了一个同名的 feature，当启用 `jpeg-decoder` feature 时将同时启用 `jpeg-decoder`
- `"jpeg-decoder/rayon"` 语法会启用 `jpeg-decoder` 依赖，并且还会启用 `jpeg-decoder` 依赖的 `rayon` feature

而命名空间正是为了处理第一个问题而出现的。新版本中，我们可以在 `[features]` 中使用 `dep:` 前缀来显式地引用一个可选的依赖。再无需像第一点一样：先隐式的将可选依赖暴露为一个 feature，再通过 feature 来启用它。

这样一来，我们将能更好的定义可选依赖所对应的 feture，包括将可选依赖隐藏在一个更具描述性的 feature 名称后面。

弱依赖用于处理第二点: 根据第二点，`optional-dependency/feature-name` 必定会启用 `optional-dependency` 这个可选依赖。然而在一些场景中，我们只希望在其它 features 已经启用了可选依赖 `optional-dependency` 时才去启用 `feature-name` 这个 feature。

从 1.60 开始，我们可以使用 `"package-name?/feature-name"` 这种带有 `?` 形式的语法: 只有当其它项已经启用了可选依赖 `package-name` 的情况下才去开启给定的 feature `feature-name`。

> 译者注：简单来说，要启用 `feature` 必须需要别人先启用了其前置的可选依赖，再也无法像之前的第二点一样，既能开启可选依赖，又能启用 feature。

例如，我们希望为自己的库增加一些序列化功能，它需要开启某个可选依赖中的指定 feature，可以这么做:
```toml
[dependencies]
serde = { version = "1.0.133", optional = true }
rgb = { version = "0.8.25", optional = true }

[features]
serde = ["dep:serde", "rgb?/serde"]
```

这里定义了以下关系:

1. 开启 `serde` feature 将启用可选的 `serde` 依赖
2. 只有当 `rgb` 依赖在其它地方已经被启用后，此处才能启用 `rgb` 的 `serde` feature

## 增量编译重启开启
在 [1.59 更新说明中](https://course.rs/appendix/rust-versions/1.59.html)，我们有提到因为某些问题，增量编译被默认关闭了，现在官方修复了其中一些，并且确认目前的状态不会再影响用户的使用，因此在 1.60 版本中，增量编译又重新默认开启了。

## Instant 单调性保证
> 译者注：Instant 可以获取当前的时间，因此保证其单调增长是非常重要的，例如 uuid 的生成往往依赖于时间戳的单调增长，一旦时间回退，就可能出现 uuid 重复的情况。

在目前所有的平台上，`Instant` 会去尝试使用系统提供的 API 来保证单调性行为( 目前主要针对 tier 1 的平台 )。然而在实际场景中，这种单调性偶尔会因为硬件、虚拟化或操作系统bug 等原因而失效。

为了解决这些失效或是平台没有提供 API 的情况，`Instant::duration_since`, `Instant::elapsed` 和 `Instant::sub` 现在饱和为零( 这里不太好翻译，原文是 now saturate to zero，大概意思是非负？)。而在老版本中，这种时间回退的情况会导致 panic。

`Instant::checked_duration_since` 也可以用于检测和处理单调性失败或 `Instants` 的减法顺序不正确的情况。

但是目前的解决方法会遮掩一些错误的发生，因此在未来版本中，Rust 可能会重新就某些场景引入 panic 机制。

在 1.60 版本前，单调性主要通过标准库的互斥锁 Mutex 或原子性 atomic 来保证，但是在 `Instant::now()` 调用频繁时，可能会导致明显的性能问题。



================================================
FILE: src/appendix/rust-versions/1.61.md
================================================
[Binary file]


================================================
FILE: src/appendix/rust-versions/1.62.md
================================================
# Rust 新版解读 | 1.62 | 重点: Cargo add，#[default] 枚举变量，Linux 上更薄更快的 Mutex，裸机 x86_64 构架

> 原文链接: https://blog.rust-lang.org/2022/06/30/Rust-1.62.0.html
> 翻译 by ：[AllanDowney](https://github.com/AllanDowney)

通过 [rustup](https://www.rust-lang.org/tools/install) 安装的同学可以使用以下命令升级到 1.62 版本:

```shell
$ rustup update stable
```

## Cargo add

现在可以使用 `cargo add` 直接从命令行添加新的依赖项。此命令支持指定功能和版本。它还可以用来修改现有的依赖关系。

例如:

```rust
$ cargo add log
$ cargo add serde --features derive
$ cargo add nom@5
```

有关更多信息，请参阅 [cargo 文档](https://doc.rust-lang.org/nightly/cargo/commands/cargo-add.html)。

## `#[default]` 枚举变量

如果指定枚举默认变量，现在可以使用 `#[derive(Default)]`。例如，到目前为止，您必须手动为此枚举写入 `Default` ：

```rust
#[derive(Default)]
enum Maybe<T> {
    #[default]
    Nothing,
    Something(T),
}
```

到目前为止，只允许将“单元”变量（没有字段的变量）标记为#[default]。[RFC](https://rust-lang.github.io/rfcs/3107-derive-default-enum.html) 中提供了有关此功能的更多信息。

## Linux 上更薄更快的 Mutex

以前，Linux 上的 `pthreads` 库支持 `Mutex`、`Condvar` 和 `RwLock` 。 `pthreads 锁` 支持比 Rust API 本身更多的功能，包括运行时配置，并且设计用于比 Rust 提供的静态保证更少的语言中。

例如，`Mutex` 实现是 40 个字节，不能被移动(move)。这迫使标准库在后台为使用 `pthreads` 的平台的每个新 `Mutex` 分配一个 `Box`。

现在 Rust 的标准库在 Linux 上提供了这些锁的原始 futex 实现，它非常轻量级，不需要额外分配。在 1.62.0 中，`Mutex` 在 Linux 上的内部状态只需要 5 个字节，尽管在未来的版本中可能会发生变化。

这是提高 Rust 的锁类型效率的长期努力的一部分，包括以前在 Windows 上的改进，如取消绑定其原语。您可以在[跟踪问题](https://github.com/rust-lang/rust/issues/93740)中了解更多有关这方面的信息。

## 裸机 `x86_64` 构架

现在更容易为 `x86_64` 构建无操作系统的二进制文件，例如在编写内核时。`x86_64-unknown-none` 构架已升级到第 2 层，可以用 `rustup` 安装。

```rust
$ rustup target add x86_64-unknown-none
$ rustc --target x86_64-unknown-none my_no_std_program.rs
```

您可以在 [Embedded Rust book](https://docs.rust-embedded.org/book/intro/no-std.html) 中阅读更多关于使用 `no_std` 进行开发的信息。



================================================
FILE: src/appendix/rust-versions/1.63.md
================================================
[Binary file]


================================================
FILE: src/appendix/rust-versions/1.64.md
================================================
# Rust 新版解读 | 1.64 | 重点: `IntoFuture` , Cargo 优化

> Rust 1.64 官方 release doc: [Announcing Rust 1.64.0 | Rust Blog](https://blog.rust-lang.org/2022/09/22/Rust-1.64.0.html)

通过 [rustup](https://www.rust-lang.org/tools/install) 安装的同学可以使用以下命令升级到 1.64 版本:

```shell
$ rustup update stable
```

## 使用 `IntoFuture` 增强 `.await`

1.64 稳定了 `IntoFuture` trait，不同于用在 `for ... in ...` 的 `IntoIterator` trait，`IntoFuture` 增强了 `.awiat` 关键字。现在 `.await` 可以 await 除了 futures 外，还可以 await 任何实现了 `IntoFuture` trait 并经此转换成 `Future` 的对象。这可以让你的 api 对用户更加优化。

举一个用在网络存储供应端的例子：

```rust
pub struct Error { ... }
pub struct StorageResponse { ... }:
pub struct StorageRequest(bool);

impl StorageRequest {
    /// 实例化一个 `StorageRequest` 
    pub fn new() -> Self { ... }
    /// 是否开启 debug 模式
    pub fn set_debug(self, b: bool) -> Self { ... }
    /// 发送请求并接受回复
    pub async fn send(self) -> Result<StorageResponse, Error> { ... }
}
```

通常地使用方法可能类似如下代码：

```rust
let response = StorageRequest::new()  // 1. 实例化
    .set_debug(true)                  // 2. 设置一些选项
    .send()                           // 3. 构造 future
    .await?;                          // 4. 执行 future ，传递 error
```

这个代码已经不错了，不过 1.64 后可以做的更好。使用 `IntoFuture` ，把第三步的 “构造 future ” 和 第四步的 “执行 future ” 合并到一个步骤里：

``` RUST
let response = StorageRequest::new()  // 1. 实例化
    .set_debug(true)                  // 2. 设置一些选项
    .await?;                          // 3. 构造并执行 future ，传递 error
```

想要实现上面的效果，我们需要给 `StorageRequest` 实现 `IntoFuture` trait。`IntoFuture` 需要确定好要返回的 future，可以用下面的代码来实现：

``` rust
// 首先需要引入一些必须的类型
use std::pin::Pin;
use std::future::{Future, IntoFuture};

pub struct Error { ... }
pub struct StorageResponse { ... }
pub struct StorageRequest(bool);

impl StorageRequest {
    /// 实例化一个 `StorageRequest` 
    pub fn new() -> Self { ... }
    /// 是否开启 debug 模式
    pub fn set_debug(self, b: bool) -> Self { ... }
    /// 发送请求并接受回复
    pub async fn send(self) -> Result<StorageResponse, Error> { ... }
}

// 新的实现内容
// 1. 定义好返回的 future 类型
pub type StorageRequestFuture = Pin<Box<dyn Future<Output = Result<StorageResponse, Error>> + Send + 'static>>
// 2. 给 `StorageRequest` 实现 `IntoFuture`
impl IntoFuture for StorageRequest {
    type IntoFuture = StorageRequestFuture;
    type Output = <StorageRequestFuture as Future>::Output;
    fn into_future(self) -> Self::IntoFuture {
        Box::pin(self.send())
    }
}
```

这确实需要多写一点实现代码，不过可以给用户提供一个更简单的 api 。

未来，Rust 异步团队 希望能够通过给类型别名提供 `impl Trait` [Type Alias Impl Trait](https://rust-lang.github.io/impl-trait-initiative/explainer/tait.html)，来简化定义 futures 实现 `IntoFuture` 的代码；再想办法移除 `Box` 来提升性能。


## `core` 和 `alloc` 中和 C 语言兼容的 FFI 类型

当调用 C-ABI 或者调用 C-ABI 的时候，Rust 代码通常会使用诸如 `c_uint` 或者 `c_ulong` 的类型别名来匹配目标语言里的对应类型。

在次之前，这些类型别名仅在 `std` 里可用，而在嵌入式或者其它仅能使用 `core` 或者 `alloc` 的场景下无法使用。

1.64 里在 `core::ffi` 里提供了所有 `c_*` 的类型别名，还有 `core::ffi::CStr` 对应 C 的字符串，还有仅用 `alloc` 库情况下可以用 `alloc::ffi::CString` 来对应 C 的字符串。


## 可以通过 rustup 来使用 rust-analyzer 

rust-analyzer 现在被加进 Rust 工具集里了。这让在各平台上下载使用 rust-analyzer 更加方便。通过 [rustup component](https://rust-lang.github.io/rustup/concepts/components.html) 来安装：

```shell
rustup component add rust-analyzer
```

目前，使用 rustup 安装的版本，需要这样启用：

```shell
rustup run stable rust-analyzer
```

下一次 rustup 的发布本把会提供一个内置的代理，来运行对应版本的 rust-analyzer 。


## Cargo 优化，workspace 继承和多目标构建

当在一个 Cargo workspace 里管理多个相关的库/产品时，现在可以避免在多个库里使用相同的字段值了，比如相同的版本号，仓库链接，`rust-version`。在更新的时候也可以更容易地保持这些信息地一致性。更多细节可以参考：

* [workspace.package](https://doc.rust-lang.org/cargo/reference/workspaces.html#the-package-table)
* [workspace.dependencies](https://doc.rust-lang.org/cargo/reference/workspaces.html#the-dependencies-table)
* ["inheriting a dependency from a workspace"](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#inheriting-a-dependency-from-a-workspace)

另外在构建多个目标地时候，现在可以直接传递多个 `--target` 选项给 `cargo build` 来一次性编译所有目标。也可以在 `.cargo/config.toml` 里设置一个 `build.target` 的 array 来改变默认构建时的对象。

## 稳定API && Others

更多稳定API列表和其它更新内容，请参考原文最后 [stabilized-apis](https://blog.rust-lang.org/2022/09/22/Rust-1.64.0.html#stabilized-apis)


================================================
FILE: src/appendix/rust-versions/1.65.md
================================================
# Rust 新版解读 | 1.65 | 重点: 泛型关联类型，新绑定语法！

> Rust 1.65 官方 release doc: [Announcing Rust 1.65.0 | Rust Blog](https://blog.rust-lang.org/2022/11/03/Rust-1.65.0.html)

通过 [rustup](https://www.rust-lang.org/tools/install) 安装的同学可以使用以下命令升级到 1.65 版本:

```shell
$ rustup update stable
```

## 泛型关联类型 Generic associated types (GATs)

关联类型（associated types）里现在可以加上生命周期、类型、const泛型了，类似于：

```rust
trait Foo {
    type Bar<'x>;
}
```

三言两语说不清这个变化的好处，看几个例子来感受一下：

```rust
/// 一个类似于 `Iterator` 的 trait ，可以借用 `Self`。
trait LendingIterator {
    type Item<'a> where Self: 'a;

    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}

/// 可以给智能指针类型，比如 `Rc` 和 `Arc` 实现的 trait，来实现指针类型的泛用性
trait PointerFamily {
    type Pointer<T>: Deref<Target = T>;

    fn new<T>(value: T) -> Self::Pointer<T>;
}

/// 允许借用数组对象，对不需要连续存储数据的固定长度数组类型很有用
trait BorrowArray<T> {
    type Array<'x, const N: usize> where Self: 'x;

    fn borrow_array<'a, const N: usize>(&'a self) -> Self::Array<'a, N>;
}
```

泛型关联类型十分通用，能够写出许多之前无法实现的模式。更多的信息可以参考下面的链接：

* [2021/08/03/GAT稳定版本推进](https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html)
* [2022/10/28/GAT稳定版本发布公告](https://blog.rust-lang.org/2022/10/28/gats-stabilization.html)

第一个对上面的例子进行了更深入的讨论，第二个讨论了一些已知的局限性。

更深入的阅读可以在关联类型的 [nightly reference](https://doc.rust-lang.org/nightly/reference/items/associated-items.html#associated-types) 和 [原始 RFC](https://rust-lang.github.io/rfcs/1598-generic_associated_types.html)（已经过去6.5年了！） 里找到。

## `let` - `else` 语法

新的 `let` 语法，尝试模式匹配，找不到匹配的情况下执行发散的 `else` 块。

```rust
let PATTERN: TYPE = EXPRESSION else {
    DIVERGING_CODE;
};
```

常规的 `let` 语法仅能使用 `irrefutable patterns`，直译为不可反驳的模式，也就是一定要匹配上。一般情况下都是单个变量绑定，也用在解开结构体，元组，数组等复合类型上。原先并不适用条件匹配，比如从枚举里确定枚举值。直到现在我们有了 `let` - `else`。这是 `refutable pattern`，直译为可反驳的模式，能够像常规 `let` 一样匹配并绑定变量到周围范围内，在模式不匹配的时候执行发送的 `else` （可以是 `break`, `return`, `panic!`）。 

```rust
fn get_count_item(s: &str) -> (u64, &str) {
    let mut it = s.split(' ');
    let (Some(count_str), Some(item)) = (it.next(), it.next()) else {
        panic!("Can't segment count item pair: '{s}'");
    };
    let Ok(count) = u64::from_str(count_str) else {
        panic!("Can't parse integer: '{count_str}'");
    };
    (count, item)
}
assert_eq!(get_count_item("3 chairs"), (3, "chairs"));
```

`if` - `else` 和 `match` 或者 `if let` 最大不一样的地方是变量绑定的范围，在此之前你需要多写一点重复的代码和一次外层的 `let` 绑定来完成：

```rust
    let (count_str, item) = match (it.next(), it.next()) {
        (Some(count_str), Some(item)) => (count_str, item),
        _ => panic!("Can't segment count item pair: '{s}'"),
    };
    let count = if let Ok(count) = u64::from_str(count_str) {
        count
    } else {
        panic!("Can't parse integer: '{count_str}'");
    };
```

## `break` 跳出标记过的代码块

块表达式现在可以标记为 `break` 的目标，来达到提前终止块的目的。这听起来有点像 `goto` 语法，不过这并不是随意的跳转，只能从块里跳转到块末尾。这在之前已经可以用 `loop` 块来实现了，你可能大概率见过这种总是只执行一次的 `loop`。

1.65 可以直接给块语句添加标记来提前退出了，还可以携带返回值：

```rust
let result = 'block: {
    do_thing();
    if condition_not_met() {
        break 'block 1;
    }
    do_next_thing();
    if condition_not_met() {
        break 'block 2;
    }
    do_last_thing();
    3
};
```


## Others

其它更新细节，和稳定的API列表，参考[原Blog](https://blog.rust-lang.org/2022/11/03/Rust-1.65.0.html)


================================================
FILE: src/appendix/rust-versions/1.66.md
================================================
# Rust 新版解读 | 1.66 | 重点: 有字段枚举的显示判别

> Rust 1.66 官方 release doc: [Announcing Rust 1.66.0 | Rust Blog](https://blog.rust-lang.org/2022/12/15/Rust-1.66.0.html)

通过 [rustup](https://www.rust-lang.org/tools/install) 安装的同学可以使用以下命令升级到 1.66 版本:

```shell
$ rustup update stable
```

## 对有字段枚举的显示判别

枚举的显示判别在跨语言传递值时很关键，需要两个语言里每个枚举值的判别是一致的，比如：

```rust
#[repr(u8)]
enum Bar {
    A,
    B,
    C = 42,
    D,
}
```

这个例子里，枚举 `Bar` 使用了 `u8` 作为原语表形(representation)，并且 `Bar::C` 使用 42 来判别，其它没有显示判别的枚举值会按照源码里地顺序自动地递增赋值，这里的 `Bar::A` 是0，`Bar::B` 是1，`Bar::D` 是43。如果没有显示判别，那就只能在 `Bar::B` 和 `Bar::C` 之间加上 40 个无意义的枚举值了。

在1.66之前，枚举的显示判别只能用在无字段枚举上。现在对有字段枚举的显示判别也稳定了：

```rust
#[repr(u8)]
enum Foo {
    A(u8),
    B(i8),
    C(bool) = 42,
}
```

注意：可以通过 `as` 转换（比如 `Bar::C as u8` ）来判断一个无字段枚举的判别值，但是 Rust 还没有给有字段枚举提供语言层面上的获取原始判别值的方法，只能通过 unsafe 的代码来检查有字段枚举的判别值。考虑到这个使用场景往往出现在必须使用 unsafe 代码的跨语言的 FFI 里，希望这没有造成太大的负担。如果你的确需要的话，参考 `std::mem::discriminant`。

## 黑盒方法 `core::hint::black_box`

当对编译器产生的代码做基准测试时，常常需要阻止一些优化，比如下面的代码里， `push_cap` 在一个循环里执行了4次 `Vec::push` ：

```rust
fn push_cap(v: &mut Vec<i32>) {
    for i in 0..4 {
        v.push(i);
    }
}

pub fn bench_push() -> Duration { 
    let mut v = Vec::with_capacity(4);
    let now = Instant::now();
    push_cap(&mut v);
    now.elapsed()
}
```

如果你检查一下在 x86_64 机器上编译的优化输出结果，你会注意到整个 `push_cap` 方法都被优化掉了...

```text
example::bench_push:
  sub rsp, 24
  call qword ptr [rip + std::time::Instant::now@GOTPCREL]
  lea rdi, [rsp + 8]
  mov qword ptr [rsp + 8], rax
  mov dword ptr [rsp + 16], edx
  call qword ptr [rip + std::time::Instant::elapsed@GOTPCREL]
  add rsp, 24
  ret
```

现在可以通过调用 `black_box` 来避免类似情况的发送。 虽然实际上 `black_box` 内部只会取走值并直接返回，但是编译器会认为这个方法可能做任何事情。

``` rust
use std::hint::black_box;

fn push_cap(v: &mut Vec<i32>) {
    for i in 0..4 {
        v.push(i);
        black_box(v.as_ptr());
    }
}
```

这样就可以得到展开循环的[结果](https://rust.godbolt.org/z/Ws1GGbY6Y)：

```text
  mov dword ptr [rbx], 0
  mov qword ptr [rsp + 8], rbx
  mov dword ptr [rbx + 4], 1
  mov qword ptr [rsp + 8], rbx
  mov dword ptr [rbx + 8], 2
  mov qword ptr [rsp + 8], rbx
  mov dword ptr [rbx + 12], 3
  mov qword ptr [rsp + 8], rbx
```

你还能发现结果里有 `black_box` 带来的副作用，无意义的 `mov qword ptr [rsp + 8], rbx` 指令在每一次循环后出现，用来获取 `v.as_ptr()` 作为参数传递给并未真正使用的方法。

注意到上面的例子里，`push` 指令都不用考虑内存分配的问题，这是因为编译器运行在 `Vec::with_capacity(4)` 的条件下。你可以尝试改动一下 `black_box` 的位置或者在多处使用，来看看其对编译的优化输出的影响。


## `cargo remove`

1.62里我们引入了 `cargo add` 来通过命令行给你的项目增加依赖项。现在可以使用 `cargo remove` 来移除依赖了。


## Others

其它更新细节，和稳定的API列表，参考[原Blog](https://blog.rust-lang.org/2022/12/15/Rust-1.66.0.html#stabilized-apis)




================================================
FILE: src/appendix/rust-versions/1.67.md
================================================
# Rust 新版解读 | 1.67 | `#[must_use]` in `async fn`

> Rust 1.67 官方 release doc: [Announcing Rust 1.67.0 | Rust Blog](https://blog.rust-lang.org/2023/01/26/Rust-1.67.0.html)

通过 [rustup](https://www.rust-lang.org/tools/install) 安装的同学可以使用以下命令升级到 1.67 版本:

```shell
$ rustup update stable
```

2023新年好！大年初五更新的新版本，来看看有什么新变化~

## `#[must_use]` 作用于 `async fn` 上

注明了 `#[must_use]` 的 `async` 函数会把该属性应用在返回的 `impl Future` 结果上。`Future` trait 已经注明了 `#[must_use]` ，所以所有实现了 `Future` 的类型都会自动加上 `#[must_use]`。

所以在 1.67 版本，编译器会警告返回值没有被使用：

```rust
#[must_use]
async fn bar() -> u32 { 0 }

async fn caller() {
    bar().await;
}
```

```text
warning: unused output of future returned by `bar` that must be used
 --> src/lib.rs:5:5
  |
5 |     bar().await;
  |     ^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
```

## `std::sync::mpsc` 实现更新

标准库里的 mpsc（多生产者单消费者） 通道自从 1.0 版本就有了，这次版本更新将其实现修改成了基于 [`crossbeam-channel`](https://crates.io/crates/crossbeam-channel)。不涉及到API的变更，但是修改了一些已有的bug，提升了性能和代码可维护性。用户应该不太会感知到明显的变化。


## Others

其它更新细节，和稳定的API列表，参考[原Blog](https://blog.rust-lang.org/2023/01/26/Rust-1.67.0.html#stabilized-apis)




================================================
FILE: src/appendix/rust-versions/1.68.md
================================================
# Rust 新版解读 | 1.68 | crates index 优化

> Rust 1.68 官方 release doc: [Announcing Rust 1.68.0 | Rust Blog](https://blog.rust-lang.org/2023/03/09/Rust-1.68.0.html)

通过 [rustup](https://www.rust-lang.org/tools/install) 安装的同学可以使用以下命令升级到 1.68 版本:

```shell
$ rustup update stable
```


## Cargo 稀疏注册协议 （sparse protocol）

Cargo的“稀疏”注册协议已经稳定，它是用来读取注册在 crates.io 上的 crates 的索引的基础设施。以前的 git 协议（目前仍然是默认协议）会克隆一个包括所有 crates 的索引的仓库，但这已经开始遇到扩展限制问题，在更新该仓库时会出现明显的延迟。新协议应在访问 crates.io 时提供显着的性能提升，因为它只会下载有关实际用到的 crates 的索引。

要使用新的协议，需要设置环境变量 `CARGO_REGISTRIES_CRATES_IO_PROTOCOL=sparse` ，或者编辑 `.cargo/config.toml` 文件添加：

```text
[registries.crates-io]
protocol = "sparse"
```

稀疏注册协议目前计划于 1.70.0 版本成为默认的协议。更多细节可以看官方博客的 [announcement](https://blog.rust-lang.org/inside-rust/2023/01/30/cargo-sparse-protocol.html)， [RFC 2789](https://rust-lang.github.io/rfcs/2789-sparse-index.html)， 当前 Cargo Book 的 [文档](https://doc.rust-lang.org/stable/cargo/reference/registry-index.html#sparse-protocol)


## 局部 `Pin` 构造

新增的 `pin!` 宏能够用 `T` 构造一个 `Pin<&mut T>` ，从而匿名捕获在局部状态内。这通常叫做 堆栈固定（stack-pinning），同时这个堆栈也可以被 `async fn` 或者 代码块 来捕获住。这个宏和一些 crates 里提供的（比如 `tokio::pin!`）很像，但是标准库可以利用 `Pin` 的内部结构和 临时生命周期拓展([Temporary lifetime extension](https://doc.rust-lang.org/stable/reference/destructors.html#temporary-lifetime-extension))来实现出更像表达式的宏。

```rust
/// Runs a future to completion.
fn block_on<F: Future>(future: F) -> F::Output {
    let waker_that_unparks_thread = todo!();
    let mut cx = Context::from_waker(&waker_that_unparks_thread);
    // Pin the future so it can be polled.
    let mut pinned_future = pin!(future);
    loop {
        match pinned_future.as_mut().poll(&mut cx) {
            Poll::Pending => thread::park(),
            Poll::Ready(result) => return result,
        }
    }
}
```

在这个例子中，原来的 `future` 将被移动到一个临时的局部区域，由新的 `pinned_future` 引用，类型为 `Pin<&mut F>`，并且该 pin 受制于正常的借用检查器以确保它不会超过局部作用域。


## `alloc` 默认错误处理

当 Rust 内存分配失败时，类似于 `Box::new` 和 `Vec::push` 的 API 无法反映出这个错误，从而采取了一些不同的措施。当使用 `std` 时，程序会打印 `stderr` 然后中止。从 Rust 1.68.0 开始，包含 `std` 的二进制程序仍然会继续这样，而不保护 `std` 只包含 `alloc` 的二进制程序会对内存分配错误调用 `panic!`，如果需要可以再进一步通过 `#[panic_handler]` 来调整其行为。

未来，`std` 也可能会改成这样。


## Others

其它更新细节，和稳定的API列表，参考[原Blog](https://blog.rust-lang.org/2023/03/09/Rust-1.68.0.html#stabilized-apis)





================================================
FILE: src/appendix/rust-versions/1.69.md
================================================
# Rust 新版解读 | 1.69 | cargo fix

> Rust 1.69 官方 release doc: [Announcing Rust 1.69.0 | Rust Blog](https://blog.rust-lang.org/2023/04/20/Rust-1.69.0.html)

通过 [rustup](https://www.rust-lang.org/tools/install) 安装的同学可以使用以下命令升级到 1.69 版本:

```shell
$ rustup update stable
```

## Cargo 提供自动修复建议

在 Rust 1.29.0 版本添加的 `cargo fix` 子命令，能够自动修复一些简单的编译错误。从那以后，能够自动修复的错误/警告原因的数量一直在稳步增加。此外，还增加了对自动修复一些简单的 Clippy 警告的支持。

为了让更多人注意到这些能力，现在当检测到可自动修复的错误时，Cargo 会建议运行 `cargo fix` 或 `cargo clippy --fix` 命令：

```shell
warning: unused import: `std::hash::Hash`
 --> src/main.rs:1:5
  |
1 | use std::hash::Hash;
  |     ^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: `foo` (bin "foo") generated 1 warning (run `cargo fix --bin "foo"` to apply 1 suggestion)
```

注意上面的完整命令（即包含 `--bin foo`）仅在你想要精确修复一个单独的 crate 时需要附上。默认执行 workspace 下所有 fixs 只需要 `cargo fix` 。

## 构建脚本默认不再包含调试信息

为了提高编译速度，Cargo 现在默认避免在构建脚本中发出调试信息。构建脚本成功执行时不会有可见的效果，但构建脚本中的回溯（backtraces）将包含更少的信息。

所以如果想要 debug 构建脚本，需要额外开启调试信息，在 `Cargo.toml` 文件里添加

```text
[profile.dev.build-override]
debug = true
[profile.release.build-override]
debug = true
```

## Others

其它更新细节，和稳定的API列表，参考[原Blog](https://blog.rust-lang.org/2023/04/20/Rust-1.69.0.html#stabilized-apis)




================================================
FILE: src/appendix/rust-versions/1.70.md
================================================
[Binary file]


================================================
FILE: src/appendix/rust-versions/1.71.md
================================================
# Rust 新版解读 | 1.71 | C-unwind API

> Rust 1.71 官方 release doc: [Announcing Rust 1.71.0 | Rust Blog](https://blog.rust-lang.org/2023/07/13/Rust-1.71.0.html)

通过 [rustup](https://www.rust-lang.org/tools/install) 安装的同学可以使用以下命令升级到 1.71 版本:

```shell
$ rustup update stable
```

## C-unwind API

1.71.0 稳定了 `C-unwind` 和其他 `-unwind` 后缀的ABI，具体见[列表](https://github.com/rust-lang/rust/issues/74990#issuecomment-1363473645)

非强制unwinding的结果在这个RFC的[表格](https://github.com/rust-lang/rfcs/blob/master/text/2945-c-unwind-abi.md#abi-boundaries-and-unforced-unwinding)里。

带有 `-unwind` 后缀的ABI在由于 `panic` 或者 C++ 的异常(exception) 而执行 unwinding 时，穿过 ABI 边界会更安全，除此以外和没有 `-unwind` 后缀的 ABI 基本等效。使用 `panic=unwind` 可以有效地让异常从一种语言堆栈展开(stack unwind)到另一种语言而不需要中止进程（只要这个异常的产生和捕获都是在同一种语言内进行的）。而 `panic=abort` 通常会立刻中止进程。

这次稳定不会影响已有的ABI（比如 `C`），通过这些ABI的 unwinding 仍然是 UB 未定义行为。未来的 Rust 版本会按照这个RFC来修复这些ABI（通常会在边界处abort）。我们鼓励需要unwind穿过ABI边界的用户使用新的 ABI 来确保未来的兼容性。

译者注：或许以下一些概念对理解上面这个更新内容有一些帮助：

* [FFI](https://doc.rust-lang.org/nomicon/ffi.html)
* [what-is-stack-unwinding](https://stackoverflow.com/questions/2331316/what-is-stack-unwinding)
* [Rust Unwinding](https://doc.rust-lang.org/nomicon/unwinding.html)

## 调试器可视化属性

1.71.0 稳定了新的属性：`#[debug_visualizer(natvis_file = "...")]` 和 `#[debug_visualizer(gdb_script_file = "...")]`。它们允许植入 Nativis 描述和 GDB 脚本到 Rust 库里来改善通过调试器查看这些库数据结构时的输出结果。Rust本身有给标准库打包类似的脚本，如今这个特性让库作者也可以给其用户提供类似的体验了。

具体细节查看：[the-debugger_visualizer-attribute](https://doc.rust-lang.org/nightly/reference/attributes/debugger.html#the-debugger_visualizer-attribute)

## raw-dylib 动态库链接

在 Windows 平台上，通过在 `#[link]` 里使用新的选项 `kind="raw-dylib"`，Rust 现在支持使用动态库且编译期不需要依赖这个动态库。

这避免了要求用户安装这些库（这在跨平台交叉编译的时候尤为困难），也避免了在crates指明需要链接的库的具体版本。

使用新的属性 `#[link_ordinal]`， Rust 也支持通过动态库的符号顺序而不是符号名称来进行符号绑定。

## 线程局部常量初始化

其实是 1.59 稳定进标准库的功能（没有在更新说明和文档里提过）。[文档](https://doc.rust-lang.org/stable/std/macro.thread_local.html)

```rust
use std::cell::RefCell;
use std::thread;

thread_local!(static FOO: RefCell<u32> = RefCell::new(1));

FOO.with(|f| {
    assert_eq!(*f.borrow(), 1);
    *f.borrow_mut() = 2;
});

// each thread starts out with the initial value of 1
let t = thread::spawn(move|| {
    FOO.with(|f| {
        assert_eq!(*f.borrow(), 1);
        *f.borrow_mut() = 3;
    });
});

// wait for the thread to complete and bail out on panic
t.join().unwrap();

// we retain our original value of 2 despite the child thread
FOO.with(|f| {
    assert_eq!(*f.borrow(), 2);
});
```

## Others

其它更新细节，和稳定的API列表，参考[原Blog](https://blog.rust-lang.org/2023/07/13/Rust-1.71.0.html#stabilized-apis)




================================================
FILE: src/appendix/rust-versions/1.72.md
================================================
# Rust 新版解读 | 1.72 | feature启用提示

> Rust 1.72 官方 release doc: [Announcing Rust 1.72.0 | Rust Blog](https://blog.rust-lang.org/2023/08/24/Rust-1.72.0.html)

通过 [rustup](https://www.rust-lang.org/tools/install) 安装的同学可以使用以下命令升级到 1.72 版本:

```shell
$ rustup update stable
```

## 警告可能有用的 `cfg` 禁用项

一直以来都支持的通过 `cfg` 条件编译部分代码，例如在开启特定 feature 时的函数，或者针对特定平台的逻辑。之前编译器会直接无视掉这些代码，现在会记录这些符号名称和对应的 `cfg` 条件，因此可以警告你正在调用一个特定 feature 下的函数，需要启用 feature：

```text
   Compiling my-project v0.1.0 (/tmp/my-project)
error[E0432]: unresolved import `rustix::io_uring`
   --> src/main.rs:1:5
    |
1   | use rustix::io_uring;
    |     ^^^^^^^^^^^^^^^^ no `io_uring` in the root
    |
note: found an item that was configured out
   --> /home/username/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rustix-0.38.8/src/lib.rs:213:9
    |
213 | pub mod io_uring;
    |         ^^^^^^^^
    = note: the item is gated behind the `io_uring` feature

For more information about this error, try `rustc --explain E0432`.
error: could not compile `my-project` (bin "my-project") due to previous error
```

## 不受限制的常量计算时间

之前为了避免用户自定义的常量在编译期间进行估算时，陷入死循环或占用无限制的时间，Rust 之前会限制用作常量计算的语句数目。然而一些特殊的有创造性的 Rust 代码还是会超过这个限制，进而产生编译错误；更糟糕的情况是，是否达到限制的是会随着用户调用库的不同而变化的。

现在，可以在编译时执行无限制的常量计算。而为了避免长时间编译没有反馈，编译器会在编译时代码运行一段时间后发出一条消息，并在每次翻倍的一段时间后重复该消息。默认情况下，编译器还将在捕获无限循环的大量步骤后报错提示 `const_eval_long_run` ，但可以用 `allow(const_eval_long_run)` 允许特别长的常量计算。

## Clippy lints 上升到 rustc

几个原本由 Clippy 提供的 lints，提升到 rustc 里：

* [`clippy::undropped_manually_drops`](https://rust-lang.github.io/rust-clippy/rust-1.71.0/index.html#undropped_manually_drops) => [`undropped-manually-drops`](https://doc.rust-lang.org/1.72.0/rustc/lints/listing/deny-by-default.html#undropped-manually-drops) (deny) 
  * 无作用的 `ManullyDrop`
* [`clippy::invalid_utf8_in_unchecked`](https://rust-lang.github.io/rust-clippy/rust-1.71.0/index.html#invalid_utf8_in_unchecked) => [`invalid_from_utf8_unchecked`](https://doc.rust-lang.org/1.72.0/rustc/lints/listing/deny-by-default.html#invalid-from-utf8-unchecked) (deny) 或 [`invalid_from_utf8`](https://doc.rust-lang.org/1.72.0/rustc/lints/listing/warn-by-default.html#invalid-from-utf8) (warn)
  * 检查调用 `std::str::from_utf8_unchecked` 和 `std::str::from_utf8_unchecked_mut` 转换不合法的 UTF-8 字面量，这会违反了 safety 前提，导致未定义行为
  * 检查 `std::str::from_utf8` 和 `std::str::from_utf8_mut` 转换不合法的 UTF-8 字面量，这会永远返回错误。
* [`clippy::cmp_nan`](https://rust-lang.github.io/rust-clippy/rust-1.71.0/index.html#cmp_nan) => [`invalid_nan_comparisons`](https://doc.rust-lang.org/1.72.0/rustc/lints/listing/warn-by-default.html#invalid-nan-comparisons) (warn)
  * 检查使用 `f32::NAN` 或者 `f64::NAN` 参与比较，`NAN` 在比较时无任何意义，即使与自己比较也是无意义行为，建议使用 `is_nan()` 方法
* [`clippy::cast_ref_to_mut`](https://rust-lang.github.io/rust-clippy/rust-1.71.0/index.html#cast_ref_to_mut) => [`invalid_reference_casting`](https://doc.rust-lang.org/1.72.0/rustc/lints/listing/allowed-by-default.html#invalid-reference-casting) (allow)
  * 检查不使用内部可变性的从 `&T` 到 `&mut T` 的转换，这会导致未定义行为。当前这个lint本身还有些问题，所以是 `allow` 级别，预计会在 1.73 版本修正后变为默认 `deny` 

## 未来对 Windows 的支持

未来的 release 版本里会放弃对 win10 以前的系统的官方支持，Rust 1.75 将成为最后一个支持 windows 7,8,8.1的版本，2024 年 2 月起的 rust 1.76 将仅支持 win10 及后续版本 （ target : tier-1 ）。详情见提案 [MCP 651](https://github.com/rust-lang/compiler-team/issues/651)


## Others

其它更新细节，和稳定的API列表，参考[原Blog](https://blog.rust-lang.org/2023/08/24/Rust-1.72.0.html#stabilized-apis)



================================================
FILE: src/appendix/rust-versions/1.73.md
================================================
# Rust 新版解读 | 1.73 | panic 报错展示优化

> Rust 1.73 官方 release doc: [Announcing Rust 1.73.0 | Rust Blog](https://blog.rust-lang.org/2023/10/05/Rust-1.73.0.html)

通过 [rustup](https://www.rust-lang.org/tools/install) 安装的同学可以使用以下命令升级到 1.73 版本:

```shell
$ rustup update stable
```

## 更简洁的 panic 报错信息

默认的 panic handler 会把报错信息单独列出一行，当报错信息很长、包含多行或者嵌套结构的时候可读性会更强。

```rust
fn main() {
    let file = "ferris.txt";
    panic!("oh no! {file:?} not found!");
}
```

Rust 1.73 之前的：
```shell
thread 'main' panicked at 'oh no! "ferris.txt" not found!', src/main.rs:3:5
```

Rust 1.73 之后的：
```shell
thread 'main' panicked at src/main.rs:3:5:
oh no! "ferris.txt" not found!
```

另外，由 `assert_eq` 和 `assert_ne` 产生的 panic 消息也把自定义信息部分（第三个参数）的展示位置改动了一下：

```rust
fn main() {
    assert_eq!("🦀", "🐟", "ferris is not a fish");
}
```

Rust 1.73 之前的：
```shell
thread 'main' panicked at 'assertion failed: `(left == right)`
 left: `"🦀"`,
right: `"🐟"`: ferris is not a fish', src/main.rs:2:5
```

Rust 1.73 之后的：
```shell
thread 'main' panicked at src/main.rs:2:5:
assertion `left == right` failed: ferris is not a fish
 left: "🦀"
right: "🐟"
```

## 线程局部初始化

如 [RFC 3184](https://github.com/rust-lang/rfcs/blob/master/text/3184-thread-local-cell-methods.md) 提案， `LocalKey<Cell<T>>` 和 `LocalKey<RefCell<T>>` 现在可以直接用 `get()`, `set()`, `take()` 和 `replace()` 方法来操作，不再需要写 `with(|inner|...)` 的闭包形式。声明线程静态局部变量的宏 `thread_local!` 内部就是使用的就是 `LocalKey<T>`。

新的方法让代码更简洁，也避免了默认值在新线程运行额外的初始化代码。

```rust
thread_local! {
    static THINGS: Cell<Vec<i32>> = Cell::new(Vec::new());
}

fn f() {
    // before:
    THINGS.with(|i| i.set(vec![1, 2, 3]));
    // now:
    THINGS.set(vec![1, 2, 3]);

    // ...

    // before:
    let v = THINGS.with(|i| i.take());
    // now:
    let v: Vec<i32> = THINGS.take();
}
```

## Others

其它更新细节，和稳定的API列表，参考[原Blog](https://blog.rust-lang.org/2023/10/05/Rust-1.73.0.html#stabilized-apis)



================================================
FILE: src/appendix/rust-versions/1.74.md
================================================
[Binary file]


================================================
FILE: src/appendix/rust-versions/1.75.md
================================================
[Binary file]


================================================
FILE: src/appendix/rust-versions/1.76.md
================================================
[Binary file]


================================================
FILE: src/appendix/rust-versions/1.77.md
================================================
[Binary file]


================================================
FILE: src/appendix/rust-versions/1.78.md
================================================
# Rust 新版解读 | 1.78 | 诊断属性宏

> Rust 1.78 官方 release doc: [Announcing Rust 1.78.0 | Rust Blog](https://blog.rust-lang.org/2024/05/02/Rust-1.78.0.html)

通过 [rustup](https://www.rust-lang.org/tools/install) 安装的同学可以使用以下命令升级到 1.78 版本:

```shell
$ rustup update stable
```

## 诊断属性宏

Rust 现在支持 `#[diagnostic]` 属性命名空间，用于影响编译器错误消息。这些被视为提示，编译器不需要使用它们，也不会因为提供了编译器不认识的诊断而报错。这种灵活性允许源代码提供诊断，即使不是所有编译器都支持，无论是不同版本还是完全不同的实现。

随着这个命名空间的出现，第一个支持的属性 `#[diagnostic::on_unimplemented]` 也随之而来，可以放在一个 trait 上，用于自定义当需要但未在类型上实现该 trait 时的消息。考虑下面来自[稳定 PR](https://github.com/rust-lang/rust/pull/119888/) 里的示例：

```rust
#[diagnostic::on_unimplemented(
    message = "My Message for `ImportantTrait<{A}>` is not implemented for `{Self}`",
    label = "My Label",
    note = "Note 1",
    note = "Note 2"
)]
trait ImportantTrait<A> {}

fn use_my_trait(_: impl ImportantTrait<i32>) {}

fn main() {
    use_my_trait(String::new());
}
```

此前，编译器会给出一个内置错误，如下：

```shell
error[E0277]: the trait bound `String: ImportantTrait<i32>` is not satisfied
  --> src/main.rs:12:18
   |
12 |     use_my_trait(String::new());
   |     ------------ ^^^^^^^^^^^^^ the trait `ImportantTrait<i32>` is not implemented for `String`
   |     |
   |     required by a bound introduced by this call
   |
```

现在，使用 `#[diagnostic::on_unimplemented]`，自定义消息填充主要错误行，自定义标签放在源输出上。原始标签仍然写在帮助输出中，任何自定义注释也会被写入。 (这些细节未来可能会发生变化。)

```shell
error[E0277]: My Message for `ImportantTrait<i32>` is not implemented for `String`
  --> src/main.rs:12:18
   |
12 |     use_my_trait(String::new());
   |     ------------ ^^^^^^^^^^^^^ My Label
   |     |
   |     required by a bound introduced by this call
   |
   = help: the trait `ImportantTrait<i32>` is not implemented for `String`
   = note: Note 1
   = note: Note 2
```

对于 trait 作者来说，如果你能提供更好的提示，而不是仅仅给出缺失部分，这种诊断就更有用。例如，这是标准库中的一个示例：

```rust
#[diagnostic::on_unimplemented(
    message = "the size for values of type `{Self}` cannot be known at compilation time",
    label = "doesn't have a size known at compile-time"
)]
pub trait Sized {}
```

更多信息，请参考[诊断工具属性命名空间](https://doc.rust-lang.org/stable/reference/attributes/diagnostics.html#the-diagnostic-tool-attribute-namespace)的参考部分。

## 不安全前提断言

Rust 标准库有许多用于不安全函数前提的断言，但历史上它们只在标准库的 `#[cfg(debug_assertions)]` 构建中启用，以避免影响发布性能。然而，由于标准库通常以发布模式编译和分发，大多数 Rust 开发者根本没有执行这些检查。

现在，这些断言的条件被延迟到代码生成，因此它们将根据用户自己对调试断言的设置进行检查（在调试和测试构建中默认启用）。这个变化有助于用户捕获他们代码中的未定义行为。

例如，`slice::from_raw_parts` 需要一个对齐的非空指针。下面故意错位指针的使用有未定义行为，虽然如果你运气不好，它可能在过去看起来“工作”，但调试断言现在可以捕获它：

```rust
fn main() {
    let slice: &[u8] = &[1, 2, 3, 4, 5];
    let ptr = slice.as_ptr();

    // 创建一个 `ptr` 的偏移量，它总是比 `u16` 的正确对齐少一个
    let i = usize::from(ptr as usize & 1 == 0);
    
    let slice16: &[u16] = unsafe { std::slice::from_raw_parts(ptr.add(i).cast::<u16>(), 2) };
    dbg!(slice16);
}
```

在调试构建中，这将导致一个 panic：

```shell
thread 'main' panicked at library/core/src/panicking.rs:220:5:
unsafe precondition(s) violated: slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
thread caused non-unwinding panic. aborting.
```

## 确定性重新对齐

标准库有一些函数可以改变指针和切片的对齐方式，但以前它们有一些注意事项，使它们在实践中难以依赖，如果你严格遵循它们的文档。这些注意事项主要是为了保护对 `const` 的判断，但它们只对非 `const` 使用稳定。现在它们承诺根据实际输入具有一致的运行时行为。

* [`pointer::align_offset`](https://doc.rust-lang.org/std/primitive.pointer.html#method.align_offset) 计算改变指针到给定对齐方式所需的偏移量。如果不可能，它将返回 `usize::MAX`，但以前允许它始终返回 `usize::MAX`，现在这种行为被移除。

* [`slice::align_to`](https://doc.rust-lang.org/std/primitive.slice.html#method.align_to) 和 [`slice::align_to_mut`](https://doc.rust-lang.org/std/primitive.slice.html#method.align_to_mut) 都将切片转换为对齐的中间切片和剩余的不对齐头和尾切片。这些方法现在承诺返回最大可能的中间部分，而不允许实现返回不那么优化的东西，比如将所有东西作为头切片返回。

## Others

其它更新细节，和稳定的API列表，参考[原Blog](https://blog.rust-lang.org/2024/05/02/Rust-1.78.0.html#stabilized-apis)



================================================
FILE: src/appendix/rust-versions/1.79.md
================================================
# Rust 新版解读 | 1.79 | 内联 const，临时变量生命周期延长

> Rust 1.79 官方 release doc: [Announcing Rust 1.79.0 | Rust Blog](https://blog.rust-lang.org/2024/06/13/Rust-1.79.0.html)

通过 [rustup](https://www.rust-lang.org/tools/install) 安装的同学可以使用以下命令升级到 1.79 版本:

```shell
$ rustup update stable
```

## 内联 `const` 表达式

如今可以写内联 const 块 `const {...}` 作为表达式，显式地进入 const 上下文，而不需要额外的声明（例如，定义 `const` 常量或 Trait 的关联常量）。

与 const 常量 `const ITEM: ... = ...` 不同，内联 const 里类型可以被推断而不需要显式写出，并且还能使用泛型参数。来看一个很实用的例子：

```rust
const EMPTY: Option<Vec<u8>> = None;
let foo = [EMPTY; 100];
```

如今可以写成如下形式，（foo 的类型 `Option<T>` 可以不标注，可以根据上下文推断出来）

```rust
let foo = [const { None }; 100];
```

泛型的例子：

```rust
fn create_none_array<T, const N: usize>() -> [Option<T>; N] {
    [const { None }; N]
}
```

更多细节见[参考文档](https://doc.rust-lang.org/nightly/reference/expressions/block-expr.html#const-blocks)

## 关联类型约束

Rust 1.79 稳定了一些关联类型约束的语法，允许我们在类型约束里写其它类型约束，即 `T: Trait<Assoc: Bounds...>`。这避免了提供额外的显式泛型类型来约束关联类型。

这个新特性允许我们在一些情况下更简单地指定好约束关系，解决了一些之前不可能或者会引入额外不必要约束的场景。

- **`where` 子句** - 在这个位置，这等同于将约束拆分为两个（或更多）`where` 语句。例如，`where T: Trait<Assoc: Bound>` 等同于 `where T: Trait, <T as Trait>::Assoc: Bound`。
- **Supertraits** - 类似于上面，`trait CopyIterator: Iterator<Item: Copy> {}`。这也等同于将约束拆分为两个（或更多）`where` 语句；不过当 trait 被使用时，这个对关联类型 Item 的约束是隐含的。
- **关联类型 Item 约束** - 允许约束与 trait 的关联类型相关的嵌套类型约束。例如 `trait Trait { type Assoc: Trait2<Assoc2: Copy>; }`。
- **模糊类型约束**（RPIT: return position `impl Trait`, TAIT: type alias `impl Trait`） - 允许约束与模糊类型相关的关联类型。例如 `impl Iterator<Item: Copy>` 定义了 Item 满足 Copy 的迭代器，而不必实际命名该约束。

更多细节见 [issue](https://github.com/rust-lang/rust/pull/122055/#issue-2170532454)

译注：很绕，但是整体上就是一次让 Rust 编译器变得更符合你期望它应该正常工作的样子的更新。

## 临时变量生命周期延长

现在，在 `match` 和 `if` 结构中构造并立刻被使用的临时变量的生命周期会自动延长。这与代码结构中的临时变量生命周期延长的效果一致。

```rust
let a = if true {
    ..;
    &temp() // used to error, but now gets lifetime extended
} else {
    ..;
    &temp() // used to error, but now gets lifetime extended
};

let a = match () {
    _ => {
        ..;
        &temp() // used to error, but now gets lifetime extended
    }
};

// 之前已有的代码块临时变量生命周期延长
let a = {
    ..;
    &temp() // lifetime is extended
};
```

## Others

其它更新细节，和稳定的 API 列表，参考[原Blog](https://blog.rust-lang.org/2024/06/13/Rust-1.79.0.html#stabilized-apis)



================================================
FILE: src/appendix/rust-versions/1.80.md
================================================
[Binary file]


================================================
FILE: src/appendix/rust-versions/1.81.md
================================================
[Binary file]


================================================
FILE: src/appendix/rust-versions/1.82.md
================================================
# Rust 新版解读 | 1.82 | 超大更新

> Rust 1.82 官方 release doc: [Announcing Rust 1.82.0 | Rust Blog](https://blog.rust-lang.org/2024/09/05/Rust-1.82.0.html)

通过 [rustup](https://www.rust-lang.org/tools/install) 安装的同学可以使用以下命令升级到 1.82 版本:

```shell
$ rustup update stable
```

## `cargo info` 命令

Cargo 现在有一个 [`info` 子命令](https://doc.rust-lang.org/nightly/cargo/commands/cargo-info.html)，用于显示注册表中包的信息，满足了[长期以来的请求](https://github.com/rust-lang/cargo/issues/948)，距离其十周年纪念日仅差一点！多年来，已经编写了许多类似的第三方扩展，这个实现最初是作为 [cargo-information](https://crates.io/crates/cargo-information) 开发的，现合并到 Cargo 本身中。

例如，以下是你可能会看到的 `cargo info cc` 的输出：

```text
cc #build-dependencies
A build-time dependency for Cargo build scripts to assist in invoking the native
C compiler to compile native C code into a static archive to be linked into Rust
code.
version: 1.1.23 (latest 1.1.30)
license: MIT OR Apache-2.0
rust-version: 1.63
documentation: https://docs.rs/cc
homepage: https://github.com/rust-lang/cc-rs
repository: https://github.com/rust-lang/cc-rs
crates.io: https://crates.io/crates/cc/1.1.23
features:
  jobserver = []
  parallel  = [dep:libc, dep:jobserver]
note: to see how you depend on cc, run `cargo tree --invert --package cc@1.1.23`
```

默认情况下，`cargo info` 描述本地 `Cargo.lock` 中的包版本（如果有的话）。如你所见，它还会指示是否有更新的版本，`cargo info cc@1.1.30` 将报告该版本的信息。

## Apple 相关编译目标支持等级提升

### macOS on 64-bit ARM 现在是 Tier 1

适用于 macOS 的 64 位 ARM（M1 系列或更高版本的 Apple Silicon CPU）的 Rust 目标 `aarch64-apple-darwin` 现在是一个 Tier 1 目标，表明我们对它的工作状态有最高的保证。正如 [平台支持](https://doc.rust-lang.org/stable/rustc/platform-support.html) 页面所述，Rust 仓库中的每个更改在合并之前必须在每个 Tier 1 目标上通过完整的测试。此前 `darwin` 在 Rust 1.49 中作为 Tier 2 引入，使其在 `rustup` 中可用。这一新的里程碑使 `aarch64-apple-darwin` 目标与 64 位 ARM Linux 以及 X86 macOS、Linux 和 Windows 目标处于同等地位。

### Mac Catalyst 目标现在是 Tier 2

[Mac Catalyst](https://developer.apple.com/mac-catalyst/) 是苹果的一项技术，允许在 Mac 上原生运行 iOS 应用程序。这对于测试特定于 iOS 的代码特别有用，因为 `cargo test --target=aarch64-apple-ios-macabi --target=x86_64-apple-ios-macabi` 基本上可以直接工作（与通常的 iOS 目标相比，后者需要在外部工具打包后才能在原生设备或模拟器上运行）。

[这些目标](https://doc.rust-lang.org/nightly/rustc/platform-support/apple-ios-macabi.html) 现在是 Tier 2，可以通过 `rustup target add aarch64-apple-ios-macabi x86_64-apple-ios-macabi` 下载，现在是更新你的 CI 管道以测试你的代码是否也能在类似 iOS 的环境中运行的好时机。

## 精确捕获 `use<..>` 语法

Rust 现在支持在某些 `impl Trait` 边界中使用 `use<..>` 语法来控制哪些泛型生命周期参数被捕获。

Rust 中的 `Return-position impl Trait`（RPIT）类型会*捕获*某些泛型参数。捕获一个泛型参数允许该参数在隐藏类型中使用。这反过来会影响借用检查。

在 Rust 2021 及更早版本中，生命周期参数在裸函数和固有 impl 的函数和方法中的不透明类型中不会被捕获，除非这些生命周期参数在语法上被提及。例如，这是一个错误：

```rust
//@ edition: 2021
fn f(x: &()) -> impl Sized { x }
```

```text
error[E0700]: hidden type for `impl Sized` captures lifetime that does not appear in bounds
 --> src/main.rs:1:30
  |
1 | fn f(x: &()) -> impl Sized { x }
  |         ---     ----------   ^
  |         |       |
  |         |       opaque type defined here
  |         hidden type `&()` captures the anonymous lifetime defined here
  |
help: add a `use<...>` bound to explicitly capture `'_`
  |
1 | fn f(x: &()) -> impl Sized + use<'_> { x }
  |                            +++++++++
```

通过新的 `use<..>` 语法，我们可以按照错误提示修复这个问题，如下所示：

```rust
fn f(x: &()) -> impl Sized + use<'_> { x }
```

以前，正确修复这类错误需要定义一个虚拟特征，通常称为 `Captures`，并按如下方式使用它：

```rust
trait Captures<T: ?Sized> {}
impl<T: ?Sized, U: ?Sized> Captures<T> for U {}
fn f(x: &()) -> impl Sized + Captures<&'_ ()> { x }
```

这被称为 ["the `Captures` trick"](https://github.com/rust-lang/rfcs/blob/master/text/3498-lifetime-capture-rules-2024.md#the-captures-trick)，它有点复杂和微妙。现在不再需要了。
还有一种不太正确但更方便的修复方法，通常称为 ["the outlives trick"](https://github.com/rust-lang/rfcs/blob/master/text/3498-lifetime-capture-rules-2024.md#the-outlives-trick)。编译器甚至以前建议这样做。这个技巧看起来像这样：

```rust
fn f(x: &()) -> impl Sized + '_ { x }
```

在这个简单的情况下，这个技巧在细微的原因上与 `+ use<'_>` 完全等价，原因在 [RFC 3498](https://github.com/rust-lang/rfcs/blob/master/text/3498-lifetime-capture-rules-2024.md) 中有解释。然而，在实际情况下，这会过度约束返回的不透明类型的边界。比如如下代码里：

```rust
struct Ctx<'cx>(&'cx u8);

fn f<'cx, 'a>(
    cx: Ctx<'cx>,
    x: &'a u8,
) -> impl Iterator<Item = &'a u8> + 'cx {
    core::iter::once_with(move || {
        eprintln!("LOG: {}", cx.0);
        x
    })
//~^ ERROR lifetime may not live long enough
}
```

我们不能移除 `+ 'cx`，因为生命周期被用于隐藏类型中，因此必须被捕获。我们也不能添加 `'a: 'cx`的约束，因为这些生命周期实际上并不相关，并且通常情况下 `'a` 不会比 `'cx` 更长。然而，如果我们改为写 `+ use<'cx, 'a>`，这将有效并具有正确的约束。


有一些限制正在稳定化。`use<..>` 语法目前不能出现在特征或特征实现中，并且必须列出所有在作用域内的泛型类型和常量参数。我们希望随着时间的推移解除这些限制。

请注意，在 Rust 2024 中，上面的例子将“直接工作”，而不需要 `use<..>` 语法（或任何技巧）。这是因为在新版本中，不透明类型将自动捕获所有在作用域内的生命周期参数。这是一个更好的默认设置，我们已经看到了很多关于这如何清理代码的证据。在 Rust 2024 中，`use<..>` 语法将作为一种重要的方式来选择退出该默认设置。

有关 `use<..>` 语法、捕获以及这如何应用于 Rust 2024 的更多详细信息，请参阅版本指南中的 ["RPIT lifetime capture rules"](https://doc.rust-lang.org/nightly/edition-guide/rust-2024/rpit-lifetime-capture.html) 章节。有关整体方向的详细信息，请参阅我们最近的博客文章 ["Changes to `impl Trait` in Rust 2024"]([2024-09-05-impl-trait-capture-rules.md](https://blog.rust-lang.org/2024/09/05/impl-trait-capture-rules.html))。

## 创建原始指针的原生语法

不安全代码有时必须处理可能悬空、未对齐或不指向有效数据的指针。这种情况常见于 `repr(packed)` 结构体。在这种情况下，避免创建引用非常重要，因为这会导致未定义行为。这意味着通常的 `&` 和 `&mut` 操作符不能使用，因为它们会创建引用——即使引用立即被转换为原始指针，也无法避免未定义行为。

多年来，宏 `std::ptr::addr_of!` 和 `std::ptr::addr_of_mut!` 一直服务于这个目的。现在是为这个操作提供适当原生语法的时候了：`addr_of!(expr)` 变成了 `&raw const expr`，而 `addr_of_mut!(expr)` 变成了 `&raw mut expr`。例如：

```rust
#[repr(packed)]
struct Packed {
    not_aligned_field: i32,
}

fn main() {
    let p = Packed { not_aligned_field: 1_82 };

    // This would be undefined behavior!
    // It is rejected by the compiler.
    // let ptr = &p.not_aligned_field as *const i32;

    // This is the old way of creating a pointer.
    let ptr = std::ptr::addr_of!(p.not_aligned_field);

    // This is the new way.
    let ptr = &raw const p.not_aligned_field;

    // Accessing the pointer has not changed.
    // Note that `val = *ptr` would be undefined behavior because
    // the pointer is not aligned!
    let val = unsafe { ptr.read_unaligned() };
}
```

原生语法更加清晰地将表达式解释为[位置表达式(place expressions)](https://www.ralfj.de/blog/2024/08/14/places.html)。它还避免了在提到创建指针的操作时使用“取地址”的术语。指针[不仅仅是地址](https://rust-lang.github.io/rfcs/3559-rust-has-provenance.html)，因此 Rust 正在摆脱诸如“取地址”之类的**强化了指针和地址之间的错误等价关系**术语。

## `unsafe extern` 里的 `safe` 部分

Rust 代码可以使用来自外部代码的函数和静态变量。这些外部项的类型签名在 `extern` 块中提供。历史上，`extern` 块中的所有项在调用时都是不安全的，但我们不需要在 `extern` 块本身上写 `unsafe`。

然而，如果 `extern` 块中的签名不正确，那么使用该项将导致未定义行为。这是编写 `extern` 块的人的错误，还是使用该项的人的错误？

我们决定，编写 `extern` 块的人有责任确保其中包含的所有签名都是正确的，因此我们现在允许编写 `unsafe extern`：

```rust
unsafe extern {  
    pub safe static TAU: f64;
    pub safe fn sqrt(x: f64) -> f64;
    pub unsafe fn strlen(p: *const u8) -> usize;
}
```

这样做的一个好处是，`unsafe extern` 块中的项可以被标记为安全的调用。在上面的例子中，我们可以在不使用 `unsafe` 的情况下调用 `sqrt` 或读取 `TAU`。没有标记为 `safe` 或 `unsafe` 的项会被保守地认为是 `unsafe`。

在未来的版本中，我们将通过 lint 鼓励使用 `unsafe extern`。从 Rust 2024开始，使用 `unsafe extern` 将是必需的。

有关更多详细信息，请参阅[RFC 3484](https://github.com/rust-lang/rfcs/blob/master/text/3484-unsafe-extern-blocks.md)和版本指南中的["Unsafe extern blocks"](https://doc.rust-lang.org/nightly/edition-guide/rust-2024/unsafe-extern.html)章节。

### 不安全的属性

一些 Rust 属性，例如[`no_mangle`](https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute)，可以在没有 `unsafe` 块的情况下[导致未定义行为](https://github.com/rust-lang/rust/issues/28179)。如果是常规代码，我们会要求它们放在 `unsafe {}`块中，但到目前为止，属性还没有类似的语法。为了反映这些属性可以破坏 Rust 的安全保证，它们现在被认为是“不安全”的，应该写成如下形式：

```rust
#[unsafe(no_mangle)]
pub fn my_global_function() { }
```

属性的旧形式（不带 `unsafe`）目前仍然被接受，但未来可能会被 lint 警告，并且在 Rust 2024中将成为错误。

这会影响以下属性：
- `no_mangle`
- `link_section`
- `export_name`

有关更多详细信息，请参阅版本指南中的["Unsafe attributes"](https://doc.rust-lang.org/nightly/edition-guide/rust-2024/unsafe-attributes.html)章节。

## 省略模式匹配中的空类型

现在可以省略通过值匹配空（即无法实例化的）类型的模式：

```rust
use std::convert::Infallible;
pub fn unwrap_without_panic<T>(x: Result<T, Infallible>) -> T {
    let Ok(x) = x; // the `Err` case does not need to appear
    x
}
```

这适用于空类型，例如没有变体的 `enum Void {}`，或者具有可见空字段且没有 `#[non_exhaustive]` 属性的结构体和枚举。它在与 `!` 类型结合使用时也特别有用，尽管该类型目前仍不稳定。

仍然有一些情况下必须编写空模式。由于未初始化值和 unsafe 代码的原因，如果通过引用、指针或联合字段访问空类型，则不允许省略模式：

```rust
pub fn unwrap_ref_without_panic<T>(x: &Result<T, Infallible>) -> &T {
    match x {
        Ok(x) => x,
        // 由于引用，此分支不能省略
        Err(infallible) => match *infallible {},
    }
}
```

为了避免干扰希望支持多个 Rust 版本的 crate，尽管可以删除，但带有空模式的 `match` 分支尚未报告为“不可达代码”警告。

## 浮点数 NaN 语义与 `const`

对浮点数值（类型为 `f32` 和 `f64`）的操作以其微妙性而闻名。原因之一是存在“NaN 值”：这是“不是一个数字(not a number)”的缩写，用于表示例如 `0.0 / 0.0` 的结果。NaN 值的微妙之处在于存在多个可能的 NaN 值：NaN 值有一个符号，可以通过 `f.is_sign_positive()` 检查，它还有一个可以通过 `f.to_bits()` 提取的“有效载荷”——然而，这两者都被 `==` 完全忽略（在 NaN 上总是返回 `false`）。尽管在硬件架构之间标准化浮点操作的行为取得了非常成功的努力，但何时 NaN 是正数或负数以及其确切有效载荷的细节在不同架构之间有所不同。更复杂的是，Rust 及其 LLVM 后端在保证数值结果不变的情况下对浮点操作进行优化，但这些优化可以改变产生的 NaN 值。例如，`f * 1.0` 可能会优化为 `f`。然而，如果 `f` 是 NaN，这可能会改变结果的确切位模式！

在这个版本中，Rust 标准化了一套 NaN 值的行为规则。这套规则并不是完全确定的，这意味着像 `(0.0 / 0.0).is_sign_positive()` 这样的操作结果可能会根据硬件架构、优化级别和周围代码的不同而有所不同。旨在完全可移植的代码应避免使用 `to_bits`，并应使用 `f.signum() == 1.0` 而不是 `f.is_sign_positive()`。然而，这些规则经过精心选择，仍然允许在 Rust 代码中实现高级数据表示技术，如 *NaN boxing*。有关确切规则的更多细节，请查看我们的[文档](https://doc.rust-lang.org/std/primitive.f32.html#nan-bit-patterns)。

随着 NaN 值的语义确定，此版本还允许在 `const fn` 中使用浮点数操作。由于上述原因，像 `(0.0 / 0.0).is_sign_positive()` 这样的操作在编译时和运行时可能会产生不同的结果；这不是一个错误，代码不能依赖 `const fn` 总是产生完全相同的结果。

## 常量作为汇编立即数

`const` 汇编操作数现在提供了一种使用整数作为立即数的方法，而无需先将它们存储在寄存器中。例如，我们手动实现一个 [`write`](https://man7.org/linux/man-pages/man2/write.2.html) 系统调用：

```rust
const WRITE_SYSCALL: c_int = 0x01; // 系统调用 1 是 `write`
const STDOUT_HANDLE: c_int = 0x01; // `stdout` 的文件句柄是 1
const MSG: &str = "Hello, world!\n";

let written: usize;

// 签名: `ssize_t write(int fd, const void buf[], size_t count)`
unsafe {
    core::arch::asm!(
        "mov rax, {SYSCALL} // rax 保存系统调用号",
        "mov rdi, {OUTPUT}  // rdi 是 `fd` (第一个参数)",
        "mov rdx, {LEN}     // rdx 是 `count` (第三个参数)",
        "syscall            // 调用系统调用",
        "mov {written}, rax // 保存返回值",
        SYSCALL = const WRITE_SYSCALL,
        OUTPUT = const STDOUT_HANDLE,
        LEN = const MSG.len(),
        in("rsi") MSG.as_ptr(), // rsi 是 `buf *` (第二个参数)
        written = out(reg) written,
    );
}

assert_eq!(written, MSG.len());
```

输出:

```text
Hello, world!
```

[Playground 链接](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=0cf8e21335b38011b49156c6c65929bc).

在上面的代码中，`LEN = const MSG.len()` 这样的语句将格式说明符 `LEN` 填充为一个立即数，其值为 `MSG.len()`。这可以在生成的汇编代码中看到（值为 `14`）：

```asm
lea     rsi, [rip + .L__unnamed_3]
mov     rax, 1    # rax 保存系统调用号
mov     rdi, 1    # rdi 是 `fd` (第一个参数)
mov     rdx, 14   # rdx 是 `count` (第三个参数)
syscall # 调用系统调用
mov     rax, rax  # 保存返回值
```

更多详情请参见 [参考文档](https://doc.rust-lang.org/reference/inline-assembly.html)。

## 安全地访问不安全的 `static`

现在允许以下代码：

```rust
static mut STATIC_MUT: Type = Type::new();
extern "C" {
    static EXTERN_STATIC: Type;
}
fn main() {
     let static_mut_ptr = &raw mut STATIC_MUT;
     let extern_static_ptr = &raw const EXTERN_STATIC;
}
```

在表达式上下文中，`STATIC_MUT` 和 `EXTERN_STATIC` 是 [位置表达式](https://doc.rust-lang.org/reference/expressions.html#place-expressions-and-value-expressions)。以前，编译器的安全检查不知道原始引用操作符实际上并不影响操作数的位置，将其视为可能对指针进行读或写。然而，实际上它只是创建了一个指针，并没有不安全的行为。

放宽这一限制可能会导致一些不安全的块现在被报告为未使用，如果你拒绝 `unused_unsafe` 提示，但它们现在只在旧版本中才有用。如果你想支持多个版本的 Rust，可以在这些不安全的块上添加 `#[allow(unused_unsafe)]` 注解，如下例所示：

```diff
 static mut STATIC_MUT: Type = Type::new();
 fn main() {
+    #[allow(unused_unsafe)]
     let static_mut_ptr = unsafe { std::ptr::addr_of_mut!(STATIC_MUT) };
 }
```

未来的 Rust 版本预计会将此功能推广到其他在此位置安全的表达式，而不仅仅是静态变量。

## Others

其它更新细节，和稳定的 API 列表，参考[原Blog](https://blog.rust-lang.org/2024/10/17/Rust-1.82.0.html#stabilized-apis)



================================================
FILE: src/appendix/rust-versions/1.83.md
================================================
[Binary file]


================================================
FILE: src/appendix/rust-versions/1.84.md
================================================
# Rust 新版解读 | 1.84 | Const 能力拓展

> Rust 1.84 官方 release doc: [Announcing Rust 1.84.0 | Rust Blog](https://blog.rust-lang.org/2025/01/09/Rust-1.84.0.html)

通过 [rustup](https://www.rust-lang.org/tools/install) 安装的同学可以使用以下命令升级到 1.84 版本:

```shell
$ rustup update stable
```

## Cargo 在依赖版本选择中考虑 Rust 版本

1.84.0 稳定了支持最低 Rust 版本（MSRV, minimum supported Rust version）的解析器，该解析器优先选择与项目声明的 MSRV （`Cargo.toml` 里的 `package.rust_version`） 兼容的依赖版本。通过支持 MSRV 的版本选择，维护者可以减少支持旧工具链的工作量，因为不再需要为每个依赖手动选择旧版本。

你可以通过 `.cargo/config.toml` 启用支持 MSRV 的解析器：

```toml
[resolver]
incompatible-rust-versions = "fallback"
```

然后在添加依赖时：

```bash
$ cargo add clap
    Updating crates.io index
warning: ignoring clap@4.5.23 (which requires rustc 1.74) to maintain demo's rust-version of 1.60
      Adding clap v4.0.32 to dependencies
    Updating crates.io index
     Locking 33 packages to latest Rust 1.60 compatible versions
      Adding clap v4.0.32 (available: v4.5.23, requires Rust 1.74)
```

在 CI 中[验证最新依赖](https://doc.rust-lang.org/cargo/guide/continuous-integration.html#verifying-latest-dependencies)时，你可以覆盖此行为：

```bash
$ CARGO_RESOLVER_INCOMPATIBLE_RUST_VERSIONS=allow cargo update
    Updating crates.io index
     Locking 12 packages to latest compatible versions
    Updating clap v4.0.32 -> v4.5.23
```

你也可以通过在 `Cargo.toml` 清单文件中设置 [`package.resolver = "3"`](https://doc.rust-lang.org/cargo/reference/resolver.html#resolver-versions) 来启用此功能，但这需要将 MSRV 提升到 1.84。对于使用 Rust 2024 的项目（将在 1.85 中稳定），新的解析器将默认启用。

这为库作者在决定采用新 Rust 工具链功能的策略时提供了更大的灵活性。以前，库采用新 Rust 工具链的功能会迫使使用旧 Rust 版本的下游用户要么升级工具链，要么手动选择与工具链兼容的旧版本库（并避免运行 `cargo update`）。现在，这些用户将能够自动使用与其旧工具链兼容的旧库版本。

有关决定 MSRV 策略时的更多注意事项，请参阅[文档](https://doc.rust-lang.org/cargo/reference/rust-version.html#setting-and-updating-rust-version)。

## 新 trait 求解器的迁移开始

Rust 编译器正在迁移到新的 trait 求解器实现。下一代 trait 求解器是 Rust 类型系统核心组件的重新实现。它不仅负责检查 trait 边界（例如 `Vec<T>: Clone`）是否成立，还被类型系统的许多其他部分使用，例如规范化（确定 `<Vec<T> as IntoIterator>::Item` 的基础类型）和类型等价（检查 `T` 和 `U` 是否相同）。

在 1.84 中，新求解器用于检查 trait 实现的一致性。从高层次来看，一致性负责确保在考虑其他 crate 中尚未编写或不可见的代码时，给定类型的 trait 实现最多只有一个。

此稳定化修复了旧实现中的一些主要理论上的正确性问题，导致可能会报告以前未报告的“trait 冲突实现”错误。根据 [Crater](https://github.com/rust-lang/crater/) 对可用代码的评估，我们预计受影响的模式非常罕见。此次稳定版本还提高了我们证明实现不重叠的能力，在某些情况下允许编写更多代码。

有关更多详细信息，请参阅之前的[博客文章](https://blog.rust-lang.org/inside-rust/2024/12/04/trait-system-refactor-initiative.html)和[稳定报告](https://github.com/rust-lang/rust/pull/130654)。

## 严格来源 API

在 Rust 中，[指针不仅仅是“整数”或“地址”](https://rust-lang.github.io/rfcs/3559-rust-has-provenance.html)。例如，“释放后使用”是未定义行为，即使你“幸运”并且在读取/写入之前重新分配了释放的内存。另一个例子是，通过从 `&i32` 引用派生的指针写入是未定义行为，即使通过不同指针写入同一地址是合法的。这里的底层模式是，指针的计算方式很重要，而不仅仅是计算结果的地址。因此，我们说指针具有**来源**：要完全描述 Rust 中与指针相关的未定义行为，我们不仅需要知道指针指向的地址，还需要跟踪它是从哪些其他指针“派生”的。

大多数情况下，程序员不需要过多担心来源，指针的派生方式非常清晰。然而，当将指针转换为整数并返回时，结果指针的来源是不明确的。在此版本中，Rust 添加了一组 API，可以在许多情况下替代整数指针转换的使用，从而避免此类转换固有的歧义。特别是，现在可以在不将指针转换为整数(或反方向将整数转换成指针)的情况下实现使用对齐指针的最低有效位存储额外信息的模式。这使得代码更易于推理，更易于编译器分析，并且还有益于像 [Miri](https://github.com/rust-lang/miri) 这样的工具和像 [CHERI](https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/) 这样的架构，旨在检测和诊断指针滥用。

有关更多详细信息，请参阅标准库中关于[来源](https://doc.rust-lang.org/std/ptr/index.html#provenance)的文档。

## Others

其它更新细节，和稳定的 API 列表，包括上述 `provenance` 相关 API，参考[原Blog](https://blog.rust-lang.org/2025/01/09/Rust-1.84.0.html#stabilized-apis)



================================================
FILE: src/appendix/rust-versions/1.85.md
================================================
# Rust 新版解读 | 1.85 | Rust 2024 稳定版、`async` 闭包

> Rust 1.85 官方 release doc: [Announcing Rust 1.85.0 | Rust Blog](https://blog.rust-lang.org/2025/02/20/Rust-1.85.0.html)

通过 [rustup](https://www.rust-lang.org/tools/install) 安装的同学可以使用以下命令升级到 1.85 版本:

```shell
$ rustup update stable
```

## Rust 2024

我们很高兴地宣布，Rust 2024 版现已稳定！
大的新版本也是一种用于选择可能带来向后兼容性风险的更改的机制。有关如何实现此目标的详细信息以及迁移的详细说明，请参阅[版本指南](https://doc.rust-lang.org/edition-guide/editions/index.html)。

[版本指南](https://doc.rust-lang.org/edition-guide/rust-2024/index.html)里包含了每个更改的详细信息，这里有一份简要总结：

- 语言
  - [RPIT 生命周期捕获规则](https://doc.rust-lang.org/edition-guide/rust-2024/rpit-lifetime-capture.html) — 当 `use<..>` 不存在时，更改 `impl Trait` 类型对参数的默认捕获。
  - [`if let` 临时作用域](https://doc.rust-lang.org/edition-guide/rust-2024/temporary-if-let-scope.html) — 更改 `if let` 表达式的临时作用域。
  - [尾表达式临时作用域](https://doc.rust-lang.org/edition-guide/rust-2024/temporary-tail-expr-scope.html) — 更改块中尾表达式的临时作用域。
  - [预留模式匹配的人性化改进](https://doc.rust-lang.org/edition-guide/rust-2024/match-ergonomics.html) — 禁止某些模式组合以避免混淆并为未来的改进留出空间。
  - [不安全的 `extern` 块](https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-extern.html) — `extern` 块现在需要 `unsafe` 关键字。
  - [不安全属性](https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-attributes.html) — `export_name`、`link_section` 和 `no_mangle` 属性现在必须标记为 `unsafe`。
  - [`unsafe_op_in_unsafe_fn` 警告](https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html) — [`unsafe_op_in_unsafe_fn`](https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn) lint 现在默认警告，要求在 `unsafe` 函数中显式使用 `unsafe {}` 块。
  - [禁止引用 `static mut`](https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html) — 对 `static mut` 项的引用现在会生成默认拒绝的错误。
  - [Never 类型 fallback 更改](https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html) — 更改了 never 类型 `!` 的强制转换方式，并将 [`never_type_fallback_flowing_into_unsafe`](https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#never-type-fallback-flowing-into-unsafe) lint 级别更改为“拒绝”。
  - [宏片段说明符](https://doc.rust-lang.org/edition-guide/rust-2024/macro-fragment-specifiers.html) — `macro_rules!` 宏中的 `expr` 宏片段说明符现在也匹配 `const` 和 `_` 表达式。
  - [缺失的宏片段说明符](https://doc.rust-lang.org/edition-guide/rust-2024/missing-macro-fragment-specifiers.html) — [`missing_fragment_specifier`](https://doc.rust-lang.org/rustc/lints/listing/deny-by-default.html#missing-fragment-specifier) lint 现在是一个错误，拒绝没有片段说明符类型的宏元变量。
  - [`gen` 关键字](https://doc.rust-lang.org/edition-guide/rust-2024/gen-keyword.html) — 保留 `gen` 关键字，以便将来添加生成器块。
  - [保留语法](https://doc.rust-lang.org/edition-guide/rust-2024/reserved-syntax.html) — 保留 `#"foo"#` 风格的字符串和 `##` 标记，以便将来更改如何解析受保护的字符串字面量。
- 标准库
  - [prelude 的更改](https://doc.rust-lang.org/edition-guide/rust-2024/prelude.html) — 将 `Future` 和 `IntoFuture` 添加到 prelude 中。
  - [为 `Box<[T]>` 添加 `IntoIterator`](https://doc.rust-lang.org/edition-guide/rust-2024/intoiterator-box-slice.html) — 更改了迭代器与 `Box<[T]>` 的工作方式。
  - [新不安全的函数](https://doc.rust-lang.org/edition-guide/rust-2024/newly-unsafe-functions.html) — `std::env::set_var`、`std::env::remove_var` 和 `std::os::unix::process::CommandExt::before_exec` 现在是不安全的函数。
- Cargo
  - [Cargo: Rust 版本感知解析器](https://doc.rust-lang.org/edition-guide/rust-2024/cargo-resolver.html) — 更改默认依赖解析器行为以考虑 `rust-version` 字段。
  - [Cargo: 表和键名一致性](https://doc.rust-lang.org/edition-guide/rust-2024/cargo-table-key-names.html) — 删除了一些过时的 `Cargo.toml` 键。
  - [Cargo: 报错错误使用默认特性开关的继承情况](https://doc.rust-lang.org/edition-guide/rust-2024/cargo-inherited-default-features.html) — 更改了 `default-features = false` 与继承的工作区依赖项的工作方式。
- Rustdoc
  - [Rustdoc 组合测试](https://doc.rust-lang.org/edition-guide/rust-2024/rustdoc-doctests.html) — 文档测试现在组合成一个可执行文件，显著提高了性能。
  - [Rustdoc 嵌套 `include!` 更改](https://doc.rust-lang.org/edition-guide/rust-2024/rustdoc-nested-includes.html) — 更改了嵌套 `include!` 文件的相对路径行为。
- Rustfmt
  - [Rustfmt: 样式版本](https://doc.rust-lang.org/edition-guide/rust-2024/rustfmt-style-edition.html) — 引入了“样式版本”的概念，允许你分开控制格式化版本与 Rust 版本。
  - [Rustfmt: 格式化修复](https://doc.rust-lang.org/edition-guide/rust-2024/rustfmt-formatting-fixes.html) — 大量修复了各种情况的格式化问题。
  - [Rustfmt: 原始标识符排序](https://doc.rust-lang.org/edition-guide/rust-2024/rustfmt-raw-identifier-sorting.html) — 更改了诸如 `r#async` 带有 `r#` 标识符的排序方式。
  - [Rustfmt: 带数字的排序](https://doc.rust-lang.org/edition-guide/rust-2024/rustfmt-version-sorting.html) — 更改了包含整数的标识符的排序方式。

### 迁移到 2024

指南包含了所有新功能的迁移说明，以及[将现有项目迁移到新版本](https://doc.rust-lang.org/edition-guide/editions/transitioning-an-existing-project-to-a-new-edition.html)的一般说明。
在许多情况下，`cargo fix` 可以自动完成必要的更改。你甚至可能会发现，2024 版不需要对你的代码进行任何更改！

请注意，通过 `cargo fix` 进行的自动修复非常保守，以避免更改代码的语义。在许多情况下，你可能希望保持代码不变并使用 Rust 2024 的新语义；例如，继续使用 `expr` 宏匹配器，并忽略条件表达式的转换，因为你希望使用新的 2024 版 drop 顺序语义。`cargo fix` 的结果不应被视为建议，而只是保持行为的保守转换。

## `async` 闭包

Rust 现在支持异步闭包，如 `async || {}`，它在调用时返回 future。这类似于 `async fn`，它也可以从本地环境中捕获值，就像普通闭包和函数之间的区别一样。标准库 prelude 中还提供了 3 个类似的 trait：`AsyncFn`、`AsyncFnMut` 和 `AsyncFnOnce`。

在某些情况下，你可以通过普通闭包和异步块来近似实现这一点，例如 `|| async {}`。然而，这种内部块返回的 future 无法从闭包捕获中借用，但 `async` 闭包可以做到这一点：

```rust
let mut vec: Vec<String> = vec![];

let closure = async || {
    vec.push(ready(String::from("")).await);
};
```

此外，使用 `Fn` trait 返回 `Future` 时，无法正确表达函数签名，但你可以使用 `AsyncFn` trait 来编写：

```rust
use core::future::Future;
async fn f<Fut>(_: impl for<'a> Fn(&'a u8) -> Fut)
where
    Fut: Future<Output = ()>,
{ todo!() }

async fn f2(_: impl for<'a> AsyncFn(&'a u8))
{ todo!() }

async fn main() {
    async fn g(_: &u8) { todo!() }
    f(g).await;
    //~^ ERROR 类型不匹配
    //~| ERROR 一个类型比另一个更通用

    f2(g).await; // 没问题！
}
```

因此，`async` 闭包为这两个问题提供了一流的解决方案！有关更多详细信息，请参阅 [RFC 3668](https://rust-lang.github.io/rfcs/3668-async-closures.html) 和[稳定报告](https://github.com/rust-lang/rust/pull/132706)。

## 从诊断中隐藏 trait 实现

新的 `#[diagnostic::do_not_recommend]` 属性是给编译器的一个提示，不要将注释的 trait 实现显示为诊断消息的一部分。对于库作者来说，这是一种防止编译器提出可能无益或误导的建议的方式。例如：

```rust
pub trait Foo {}
pub trait Bar {}

impl<T: Foo> Bar for T {}

struct MyType;

fn main() {
    let _object: &dyn Bar = &MyType;
}
```

```text
error[E0277]: 未满足 trait 绑定 `MyType: Bar`
 --> src/main.rs:9:29
  |
9 |     let _object: &dyn Bar = &MyType;
  |                             ^^^^ trait `Foo` 未为 `MyType` 实现
  |
note: 需要 `MyType` 实现 `Bar`
 --> src/main.rs:4:14
  |
4 | impl<T: Foo> Bar for T {}
  |         ---  ^^^     ^
  |         |
  |         在此处引入的未满足的 trait 绑定
  = note: 需要将 `&MyType` 转换为 `&dyn Bar`
```

对于某些 API，实现 `Foo` 并通过该泛型实现间接获得 `Bar` 可能是有意义的。对于其他 API，可能期望大多数用户直接实现 `Bar`，因此 `Foo` 建议是一个误导。在这种情况下，添加诊断提示将更改错误消息如下：

```rust
#[diagnostic::do_not_recommend]
impl<T: Foo> Bar for T {}
```

```text
error[E0277]: 未满足 trait 绑定 `MyType: Bar`
  --> src/main.rs:10:29
   |
10 |     let _object: &dyn Bar = &MyType;
   |                             ^^^^ trait `Bar` 未为 `MyType` 实现
   |
   = note: 需要将 `&MyType` 转换为 `&dyn Bar`
```

有关原始动机，请参阅 [RFC 2397](https://rust-lang.github.io/rfcs/2397-do-not-recommend.html)，以及当前的[参考](https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-diagnosticdo_not_recommend-attribute)以获取更多详细信息。

## 元组的 `FromIterator` 和 `Extend`

早期版本的 Rust 为 `(T, U)` 元组对的迭代器实现了便利的 trait，使其行为类似于 `Iterator::unzip`，其中 `Extend` 在 1.56 版中实现，`FromIterator` 在 1.79 版中实现。这些现在已*扩展*到更多的元组长度，从单例 `(T,)` 到 12 个元素长的 `(T1, T2, .., T11, T12)`。例如，你现在可以使用 `collect()` 一次性分发到多个集合中：

```rust
use std::collections::{LinkedList, VecDeque};
fn main() {
    let (squares, cubes, tesseracts): (Vec<_>, VecDeque<_>, LinkedList<_>) =
        (0i32..10).map(|i| (i * i, i.pow(3), i.pow(4))).collect();
    println!("{squares:?}");
    println!("{cubes:?}");
    println!("{tesseracts:?}");
}
```

```text
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
[0, 1, 8, 27, 64, 125, 216, 343, 512, 729]
[0, 1, 16, 81, 256, 625, 1296, 2401, 4096, 6561]
```

## `std::env::home_dir()` 的更新

`std::env::home_dir()` 已被弃用多年，因为如果设置了 `HOME` 环境变量（这不是 Windows 上的标准配置），它可能会在某些 Windows 配置中给出令人惊讶的结果。我们之前避免更改其行为，因为担心与依赖此非标准配置的代码的兼容性。鉴于该函数已被弃用很长时间，我们现在将其行为更新为错误修复，后续版本将取消对该函数的弃用。

## Others

其它更新细节，和稳定的 API 列表，参考[原Blog](https://blog.rust-lang.org/2025/02/20/Rust-1.85.0.html#stabilized-apis)



================================================
FILE: src/appendix/rust-versions/1.86.md
================================================
# Rust 新版解读 | 1.86 | Trait upcasting

> Rust 1.86 官方 release doc: [Announcing Rust 1.86.0 | Rust Blog](https://blog.rust-lang.org/2025/04/03/Rust-1.86.0/)

通过 [rustup](https://www.rust-lang.org/tools/install) 安装的同学可以使用以下命令升级到 1.86 版本:

```shell
$ rustup update stable
```

## 特征向上转型(Trait upcasting)

本次更新包含了一个期待已久的功能————特征对象的向上转型能力。如果一个特征拥有 [supertrait](https://doc.rust-lang.org/reference/items/traits.html#supertraits)，你可以将指向该特征对象的引用强制转换为指向 supertrait 对象的引用：

```rust
trait Trait: Supertrait {}
trait Supertrait {}

fn upcast(x: &dyn Trait) -> &dyn Supertrait {
    x
}
```

该功能同样适用于其他类型的（智能）指针，例如 `Arc<dyn Trait> -> Arc<dyn Supertrait>` 或 `*const dyn Trait -> *const dyn Supertrait`。

此前需要通过特征内部定义 `upcast` 方法（如 `fn as_supertrait(&self) -> &dyn Supertrait` ）来实现，且仅适用于单一引用/指针类型。现在不再需要此类变通方案。

需注意：这意味着特征对象的裸指针具有一个特别的约束：“泄漏”一个指向无效虚表的裸指针到安全代码可能导致未定义行为。当前尚不清楚在严格受控环境下临时创建此类裸指针是否会立即引发未定义行为，因此应避免在任何条件下创建此类指针（Miri 会强制执行此约束）。

特征向上转型在与 `Any` 特征结合时尤为实用，无需添加特征方法或使用外部crate即可将特征对象向上转型为 `dyn Any` 来调用 `Any` 的向下转型方法：

```rust
use std::any::Any;

trait MyAny: Any {}

impl dyn MyAny {
    fn downcast_ref<T>(&self) -> Option<&T> {
        (self as &dyn Any).downcast_ref()
    }
}
```

更多细节请参阅[Rust参考文档中关于特征向上转型的内容](https://doc.rust-lang.org/reference/type-coercions.html#unsized-coercions)。

## HashMap和切片现支持可变索引多个元素

借用检查器原先会阻止通过重复调用 `get_mut` 方法获取的借用同时使用。为安全地支持获取多个可变引用，标准库现在为切片和 `HashMap` 提供 `get_disjoint_mut` 辅助方法，可同时获取多个元素的可变引用。示例取自 [`slice::get_disjoint_mut` API 文档](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.get_disjoint_mut)：

```rust
let v = &mut [1, 2, 3];
if let Ok([a, b]) = v.get_disjoint_mut([0, 2]) {
    *a = 413;
    *b = 612;
}
assert_eq!(v, &[413, 2, 612]);

if let Ok([a, b]) = v.get_disjoint_mut([0..1, 1..3]) {
    a[0] = 8;
    b[0] = 88;
    b[1] = 888;
}
assert_eq!(v, &[8, 88, 888]);

if let Ok([a, b]) = v.get_disjoint_mut([1..=2, 0..=0]) {
    a[0] = 11;
    a[1] = 111;
    b[0] = 1;
}
assert_eq!(v, &[1, 11, 111]);
```

## 允许安全函数标记 `#[target_feature]` 属性

此前仅 `unsafe` 函数可标记 `#[target_feature]` 属性，因未启用目标特性时调用此类函数会导致未定义行为。本次更新稳定了 `target_feature_11` 特性，允许*安全*函数标记该属性。

标记目标特性的安全函数仅可被同标记函数安全调用，但不可传递给以 `Fn*` 特征约束的泛型函数，且仅支持在标记函数内部强制转换为函数指针。

在未标记函数内部可通过 `unsafe` 块调用，但调用者需确保目标特性可用：

```rust
#[target_feature(enable = "avx2")]
fn requires_avx2() {
    // ... 省略
}

#[target_feature(enable = "avx2")]
fn safe_callsite() {
    requires_avx2(); // 安全调用
}

fn unsafe_callsite() {
    if is_x86_feature_detected!("avx2") {
        unsafe { requires_avx2() }; // 需手动验证
    }
}
```

详情参阅 [`target_features_11` RFC](https://github.com/rust-lang/rfcs/blob/master/text/2396-target-feature-1.1.md)。

## 为保障内存安全添加指针非空调试断言

编译器现会在以下场景插入调试断言：对非零大小类型的读写操作前，以及将指针重新借用为引用时。例如以下代码在启用调试断言时将触发 panic：

```rust
let _x = *std::ptr::null::<u8>();
let _x = &*std::ptr::null::<u8>();
```

自Rust 1.53.0起简单案例已产生警告，新运行时检查可检测任意复杂场景。这些断言仅在调试模式下生效，因此**不应该**依赖其保障内存安全。且调试模式禁用的依赖项（如标准库）即使被调试模式代码调用也不会触发断言。

## 默认启用 `missing_abi` lint 警告

在 extern 块和函数中省略 ABI（如 `extern {}` 和 `extern fn`）现在会触发 `missing_abi` lint 警告。`extern` 关键字后省略 ABI 始终隐式采用 `"C"` ABI，现建议显式指定（如 `extern "C" {}` 和 `extern "C" fn`）。

参阅[显式外部 ABI RFC](https://rust-lang.github.io/rfcs/3722-explicit-extern-abis.html)获取详情。

## 1.87.0版本目标弃用警告

Tier-2 目标 `i586-pc-windows-msvc` 将在Rust 1.87.0移除。该目标与更流行的`i686-pc-windows-msvc`的区别在于不要求SSE2指令支持，所有`windows`目标（除`win7`目标外）的最低要求系统版本，即 Windows 10 本身就需要SSE2指令。

当前使用该目标的用户应在1.87.0发布前迁移至`i686-pc-windows-msvc`。详情参见[重大变更提案](https://github.com/rust-lang/compiler-team/issues/840)。

## Others

其它更新细节，和稳定的 API 列表，参考[原Blog](https://blog.rust-lang.org/2025/04/03/Rust-1.86.0.html#stabilized-apis)



================================================
FILE: src/appendix/rust-versions/1.87.md
================================================
# Rust 新版解读 | 1.87 | 十周年🎉

[Rust 1.0](https://blog.rust-lang.org/2015/05/15/Rust-1.0/) 十周年🎉

> Rust 1.87 官方 release doc: [Announcing Rust 1.87.0 | Rust Blog](https://blog.rust-lang.org/2025/05/15/Rust-1.87.0/)

通过 [rustup](https://www.rust-lang.org/tools/install) 安装的同学可以使用以下命令升级到 1.87 版本:

```shell
$ rustup update stable
```

## 匿名管道

1.87 版本为标准库添加了匿名管道支持，包括与 `std::process::Command` 输入/输出方法的集成。例如，现在可以相对简单地合并标准输出和标准错误流，如下所示，而过去需要额外线程或平台特定函数才能实现。

```rust
use std::process::Command;
use std::io::Read;

let (mut recv, send) = std::io::pipe()?;

let mut command = Command::new("path/to/bin")
    // 标准输出和标准错误都会写入同一个管道，实现合并
    .stdout(send.try_clone()?)
    .stderr(send)
    .spawn()?;

let mut output = Vec::new();
recv.read_to_end(&mut output)?;

// 必须在进程退出前读取管道内容，避免程序输出过多时填满系统缓冲区
assert!(command.wait()?.success());
```

## 安全的架构内置函数

大多数仅因需要启用目标特性而被标记为不安全的 `std::arch` 内置函数，现在可以在已启用相应特性的安全代码中调用。例如，以下使用手动内置函数实现数组求和的示例程序，现在核心循环可以使用安全代码。

```rust
#![forbid(unsafe_op_in_unsafe_fn)]

use std::arch::x86_64::*;

fn sum(slice: &[u32]) -> u32 {
    #[cfg(target_arch = "x86_64")]
    {
        if is_x86_feature_detected!("avx2") {
            // 安全性：我们已检测到运行时启用了该特性，因此调用此函数是安全的
            return unsafe { sum_avx2(slice) };
        }
    }

    slice.iter().sum()
}

#[target_feature(enable = "avx2")]
#[cfg(target_arch = "x86_64")]
fn sum_avx2(slice: &[u32]) -> u32 {
    // 安全性：__m256i 和 u32 具有相同的有效性
    let (prefix, middle, tail) = unsafe { slice.align_to::<__m256i>() };
    
    let mut sum = prefix.iter().sum::<u32>();
    sum += tail.iter().sum::<u32>();
    
    // 在 1.87 中核心循环现在是完全安全的代码，因为内置函数要求与函数定义匹配的目标特性 (avx2)
    let mut base = _mm256_setzero_si256();
    for e in middle.iter() {
        base = _mm256_add_epi32(base, *e);
    }
    
    // 安全性：__m256i 和 u32 具有相同的有效性
    let base: [u32; 8] = unsafe { std::mem::transmute(base) };
    sum += base.iter().sum::<u32>();
    
    sum
}
```

## `asm!` 跳转到 Rust 代码

内联汇编 (`asm!`) 现在可以跳转到 Rust 代码中的 labeled 代码块。这为底层编程提供了更大灵活性，例如在操作系统内核中实现优化控制流，或更高效地与硬件交互。

- `asm!` 宏现在支持 label 标签语法，作为跳转目标
- label 必须是返回类型为 `()` 或 `!` 的块表达式
- 跳转时会执行该块，然后继续执行 `asm!` 块之后的代码
- 在同一 `asm!` 里使用调用中使用 output 和 label 仍处于[unstable](https://github.com/rust-lang/rust/issues/119364)的

```rust
unsafe {
    asm!(
        "jmp {}",
        label {
            println!("从汇编跳转而来！");
        }
    );
}
```

更多细节请参阅[参考文档](https://doc.rust-lang.org/nightly/reference/inline-assembly.html#r-asm.operand-type.supported-operands.label)。

## 特征定义中 `impl Trait` 的精确捕获 (`+ use<...>`)

本版本稳定了在特征定义中使用 `impl Trait` 返回类型时指定具体捕获的泛型类型和生命周期的功能。这扩展了 [1.82](https://blog.rust-lang.org/2024/10/17/Rust-1.82.0/#precise-capturing-use-syntax) 版本中对非特征函数的稳定支持。

一些示例解语法：

```rust
trait Foo {
    fn method<'a>(&'a self) -> impl Sized;
    
    // ... 解语法后类似：
    type Implicit1<'a>: Sized;
    fn method_desugared<'a>(&'a self) -> Self::Implicit1<'a>;
    
    // ... 而使用精确捕获时 ...
    fn precise<'a>(&'a self) -> impl Sized + use<Self>;
    
    // ... 解语法后类似：
    type Implicit2: Sized;
    fn precise_desugared<'a>(&'a self) -> Self::Implicit2;
}
```

## Others

其它更新细节，和稳定的 API 列表，参考[原Blog](https://blog.rust-lang.org/2025/05/15/Rust-1.87.0/#stabilized-apis)



================================================
FILE: src/appendix/rust-versions/1.88.md
================================================
# Rust 新版解读 | 1.88 | let_chains

> Rust 1.88 官方 release doc: [Announcing Rust 1.88.0 | Rust Blog](https://blog.rust-lang.org/2025/06/26/Rust-1.88.0/)

通过 [rustup](https://www.rust-lang.org/tools/install) 安装的同学可以使用以下命令升级到 1.88 版本:

```shell
$ rustup update stable
```

## let 链式表达式

该特性允许在 `if` 和 `while` 条件中使用 `&&` 连接的 `let` 语句，甚至可以与布尔表达式混合使用，从而减少 `if`/`if let` 和 `while`/`while let` 之间的差异。`let` 子表达式中的模式可以是不可反驳或可反驳的，绑定变量可以在链式后续部分和代码体中使用。

例如，以下代码片段组合了多个条件，之前需要嵌套 `if let` 和 `if` 块才能实现：

```rust
if let Channel::Stable(v) = release_info()
    && let Semver { major, minor, .. } = v
    && major == 1
    && minor == 88
{
    println!("`let_chains` 在此版本中已稳定");
}
```

由于一些边界场景难以兼容，let 链式表达式仅在 Rust 2024 版本中可用，因为该特性依赖于 [`if let` 临时作用域](https://doc.rust-lang.org/edition-guide/rust-2024/temporary-if-let-scope.html) 变更以实现更一致的析构顺序。

## 裸函数

Rust 现在支持编写没有编译器生成的收尾代码和序言的裸函数，允许完全控制特定函数的生成汇编代码。这是在 `global_asm!` 块中定义函数的更符合人体工程学的替代方案。裸函数使用 `#[unsafe(naked)]` 属性标记，其函数体由单个 `naked_asm!` 调用组成。

例如：

```rust
#[unsafe(naked)]
pub unsafe extern "sysv64" fn wrapping_add(a: u64, b: u64) -> u64 {
    // 等同于 `a.wrapping_add(b)`。
    core::arch::naked_asm!(
        "lea rax, [rdi + rsi]",
        "ret"
    );
}
```

手写的汇编块定义了整个函数体：与非裸函数不同，编译器不会对参数或返回值添加任何特殊处理。裸函数用于 Rust 的 [compiler-builtins](https://github.com/rust-lang/compiler-builtins)、操作系统和嵌入式应用程序等场景。

## 布尔配置

`cfg` 谓词现在支持布尔字面量 `true` 和 `false`，分别作为始终启用或禁用的配置。这适用于 Rust 的[条件编译](https://doc.rust-lang.org/reference/conditional-compilation.html)中的 `cfg` 和 `cfg_attr` 属性以及内置的 `cfg!` 宏，也适用于 Cargo `[target]` 表中的[配置](https://doc.rust-lang.org/cargo/reference/config.html#target)和[清单](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#platform-specific-dependencies)。

此前，空谓词列表可以用于无条件配置，例如 `cfg(all())` 用于启用，`cfg(any())` 用于禁用，但这种含义相当隐式且容易搞反。`cfg(true)` 和 `cfg(false)` 提供了一种更直接的方式来表达你的意图。

具体背景细节可以参考 [RFC-3695](https://rust-lang.github.io/rfcs/3695-cfg-boolean-literals.html)

## Cargo 自动缓存清理

从 1.88.0 开始，Cargo 将自动对其主目录中的缓存运行垃圾回收！

构建时，Cargo 会下载并缓存所需的依赖项。历史上，这些下载的文件永远不会被清理，导致 Cargo 主目录中的磁盘使用量无限增长。在此版本中，Cargo 引入了垃圾回收机制来自动清理旧文件（例如 `.crate` 文件）。Cargo 将删除从网络下载且 3 个月内未访问的文件，以及从本地系统获取且 1 个月内未访问的文件。请注意，如果在离线状态下运行（使用 `--offline` 或 `--frozen`），则不会进行此自动垃圾回收。

Cargo 1.78 以后会跟踪所需的访问信息以进行此垃圾回收。这是在实际清理开始之前引入的，以减少仍使用早期版本的用户的缓存更换。如果你经常使用比 1.78 版本更早的 Cargo 版本，并且希望某些仅由旧版本访问的 crate 不被重新下载，你可以在 Cargo 配置中设置 `cache.auto-clean-frequency = "never"`，如[文档](https://doc.rust-lang.org/nightly/cargo/reference/config.html#cache)所述。

有关更多信息，请参阅此功能的原始[不稳定公告](https://blog.rust-lang.org/2023/12/11/cargo-cache-cleaning/)。该设计的某些部分仍不稳定，例如 [cargo#13060](https://github.com/rust-lang/cargo/issues/13060) 中跟踪的 `gc` 子命令，因此仍有更多值得期待的内容！

## Others

其它更新细节，和稳定的 API 列表，参考[原Blog](https://blog.rust-lang.org/2025/06/26/Rust-1.88.0/#stabilized-apis)



================================================
FILE: src/appendix/rust-versions/1.89.md
================================================
[Binary file]


================================================
FILE: src/appendix/rust-versions/intro.md
================================================
# 附录 G：Rust 更新版本列表

本目录包含了 Rust 历次版本更新的重要内容解读，需要注意，每个版本实际更新的内容要比这里记录的更多，全部内容请访问每节开头的官方链接查看。



================================================
FILE: src/basic/comment.md
================================================
# 注释和文档

好的代码会说话，好的程序员不写注释，这些都是烂大街的“编程界俚语”。但是，如果你真的遇到一个不写注释的项目或程序员，那一定会对它/他“刮目相看”。

在之前的章节我们学习了包和模块如何使用，在此章节将进一步学习如何书写文档注释，以及如何使用 `cargo doc` 生成项目的文档，最后将以一个包、模块和文档的综合性例子，来将这些知识融会贯通。

## 注释的种类

在 Rust 中，注释分为三类：

- 代码注释，用于说明某一块代码的功能，读者往往是同一个项目的协作开发者
- 文档注释，支持 `Markdown`，对项目描述、公共 API 等用户关心的功能进行介绍，同时还能提供示例代码，目标读者往往是想要了解你项目的人
- 包和模块注释，严格来说这也是文档注释中的一种，它主要用于说明当前包和模块的功能，方便用户迅速了解一个项目

通过这些注释，实现了 Rust 极其优秀的文档化支持，甚至你还能在文档注释中写测试用例，省去了单独写测试用例的环节，我直呼好家伙！

## 代码注释

显然之前的刮目相看是打了引号的，想要去掉引号，该写注释的时候，就老老实实的，不过写时需要遵循八字原则：**围绕目标，言简意赅**，记住，洋洋洒洒那是用来形容文章的，不是形容注释！

代码注释方式有两种：

#### 行注释 `//`

```rust
fn main() {
    // 我是Sun...
    // face
    let name = "sunface";
    let age = 18; // 今年好像是18岁
}
```

如上所示，行注释可以放在某一行代码的上方，也可以放在当前代码行的后方。如果超出一行的长度，需要在新行的开头也加上 `//`。

当注释行数较多时，你还可以使用**块注释**

#### 块注释`/* ..... */`

```rust
fn main() {
    /*
        我
        是
        S
        u
        n
        ... 哎，好长!
    */
    let name = "sunface";
    let age = "???"; // 今年其实。。。挺大了
}
```

如上所示，只需要将注释内容使用 `/* */` 进行包裹即可。

你会发现，Rust 的代码注释跟其它语言并没有区别，主要区别其实在于文档注释这一块，也是本章节内容的重点。

## 文档注释

当查看一个 `crates.io` 上的包时，往往需要通过它提供的文档来浏览相关的功能特性、使用方式，这种文档就是通过文档注释实现的。

Rust 提供了 `cargo doc` 的命令，可以用于把这些文档注释转换成 `HTML` 网页文件，最终展示给用户浏览，这样用户就知道这个包是做什么的以及该如何使用。

#### 文档行注释 `///`

本书的一大特点就是废话不多，因此我们开门见山：

````rust
/// `add_one` 将指定值加1
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
````

以上代码有几点需要注意：

- 文档注释需要位于 `lib` 类型的包中，例如 `src/lib.rs` 中
- 文档注释可以使用 `markdown`语法！例如 `# Examples` 的标题，以及代码块高亮
- 被注释的对象需要使用 `pub` 对外可见，记住：文档注释是给用户看的，**内部实现细节不应该被暴露出去**

咦？文档注释中的例子，为什看上去像是能运行的样子？竟然还是有 `assert_eq` 这种常用于测试目的的宏。 嗯，你的感觉没错，详细内容会在本章后面讲解，容我先卖个关子。

#### 文档块注释 `/** ... */`

与代码注释一样，文档也有块注释，当注释内容多时，使用块注释可以减少 `///` 的使用：

````rust
/** `add_two` 将指定值加2

# Examples

```
let arg = 5;
let answer = my_crate::add_two(arg);

assert_eq!(7, answer);
```
*/
pub fn add_two(x: i32) -> i32 {
    x + 2
}
````

#### 查看文档 cargo doc

锦衣不夜行，这是中国人的传统美德。我们写了这么漂亮的文档注释，当然要看看网页中是什么效果咯。

很简单，运行 `cargo doc` 可以直接生成 `HTML` 文件，放入*target/doc*目录下。

当然，为了方便，我们使用 `cargo doc --open` 命令，可以在生成文档后，自动在浏览器中打开网页，最终效果如图所示：

<img alt="" src="https://pic2.zhimg.com/80/v2-926c91d429e2933a6a3ae3233fc56b1c_1440w.png" class="center"  />

非常棒，而且非常简单，这就是 Rust 工具链的强大之处。

#### 常用文档标题

之前我们见到了在文档注释中该如何使用 `markdown`，其中包括 `# Examples` 标题。除了这个标题，还有一些常用的，你可以在项目中酌情使用：

- **Panics**：函数可能会出现的异常状况，这样调用函数的人就可以提前规避
- **Errors**：描述可能出现的错误及什么情况会导致错误，有助于调用者针对不同的错误采取不同的处理方式
- **Safety**：如果函数使用 `unsafe` 代码，那么调用者就需要注意一些使用条件，以确保 `unsafe` 代码块的正常工作

话说回来，这些标题更多的是一种惯例，如果你非要用中文标题也没问题，但是最好在团队中保持同样的风格 :)

## 包和模块级别的注释

除了函数、结构体等 Rust 项的注释，你还可以给包和模块添加注释，需要注意的是，**这些注释要添加到包、模块的最上方**！

与之前的任何注释一样，包级别的注释也分为两种：行注释 `//!` 和块注释 `/*! ... */`。

现在，为我们的包增加注释，在 `src/lib.rs` 包根的最上方，添加：

```rust
/*! lib包是world_hello二进制包的依赖包，
 里面包含了compute等有用模块 */

pub mod compute;
```

然后再为该包根的子模块 `src/compute.rs` 添加注释：

```rust
//! 计算一些你口算算不出来的复杂算术题


/// `add_one`将指定值加1
///
```

运行 `cargo doc --open` 查看下效果：

<img alt="" src="https://pic3.zhimg.com/80/v2-38dbea938884c159e74f777c6f49e3af_1440w.png" class="center"  />

包模块注释，可以让用户从整体的角度理解包的用途，对于用户来说是非常友好的，就和一篇文章的开头一样，总是要对文章的内容进行大致的介绍，让用户在看的时候心中有数。

至此，关于如何注释的内容，就结束了，那么注释还能用来做什么？可以玩出花来吗？答案是`Yes`.

## 文档测试(Doc Test)

相信读者之前都写过单元测试用例，其中一个很蛋疼的问题就是，随着代码的进化，单元测试用例经常会失效，过段时间后（为何是过段时间？应该这么问，有几个开发喜欢写测试用例 =,=），你发现需要连续修改不少处代码，才能让测试重新工作起来。然而，在 Rust 中，大可不必。

在之前的 `add_one` 中，我们写的示例代码非常像是一个单元测试的用例，这是偶然吗？并不是。因为 Rust 允许我们在文档注释中写单元测试用例！方法就如同之前做的：

````rust
/// `add_one` 将指定值加1
///
/// # Examples11
///
/// ```
/// let arg = 5;
/// let answer = world_hello::compute::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
````

以上的注释不仅仅是文档，还可以作为单元测试的用例运行，使用 `cargo test` 运行测试：

```console
Doc-tests world_hello

running 2 tests
test src/compute.rs - compute::add_one (line 8) ... ok
test src/compute.rs - compute::add_two (line 22) ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 1.00s
```

可以看到，文档中的测试用例被完美运行，而且输出中也明确提示了 `Doc-tests world_hello`，意味着这些测试的名字叫 `Doc test` 文档测试。

> 需要注意的是，你可能需要使用类如 `world_hello::compute::add_one(arg)` 的完整路径来调用函数，因为测试是在另外一个独立的线程中运行的

#### 造成 panic 的文档测试

文档测试中的用例还可以造成 `panic`：

````rust
/// # Panics
///
/// The function panics if the second argument is zero.
///
/// ```rust
/// // panics on division by zero
/// world_hello::compute::div(10, 0);
/// ```
pub fn div(a: i32, b: i32) -> i32 {
    if b == 0 {
        panic!("Divide-by-zero error");
    }

    a / b
}
````

以上测试运行后会 `panic`：

```console
---- src/compute.rs - compute::div (line 38) stdout ----
Test executable failed (exit code 101).

stderr:
thread 'main' panicked at 'Divide-by-zero error', src/compute.rs:44:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

如果想要通过这种测试，可以添加 `should_panic`：

````rust
/// # Panics
///
/// The function panics if the second argument is zero.
///
/// ```rust,should_panic
/// // panics on division by zero
/// world_hello::compute::div(10, 0);
/// ```
````

通过 `should_panic`，告诉 Rust 我们这个用例会导致 `panic`，这样测试用例就能顺利通过。

#### 保留测试，隐藏文档

在某些时候，我们希望保留文档测试的功能，但是又要将某些测试用例的内容从文档中隐藏起来：

````rust
/// ```
/// # // 使用#开头的行会在文档中被隐藏起来，但是依然会在文档测试中运行
/// # fn try_main() -> Result<(), String> {
/// let res = world_hello::compute::try_div(10, 0)?;
/// # Ok(()) // returning from try_main
/// # }
/// # fn main() {
/// #    try_main().unwrap();
/// #
/// # }
/// ```
pub fn try_div(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err(String::from("Divide-by-zero"))
    } else {
        Ok(a / b)
    }
}
````

以上文档注释中，我们使用 `#` 将不想让用户看到的内容隐藏起来，但是又不影响测试用例的运行，最终用户将只能看到那行没有隐藏的 `let res = world_hello::compute::try_div(10, 0)?;`：

<img alt="" src="https://pic1.zhimg.com/80/v2-d1b98f5e70b7f8c8fb9aecce325dba0e_1440w.png" class="center"  />

## 文档注释中的代码跳转

Rust 在文档注释中还提供了一个非常强大的功能，那就是可以实现对外部项的链接：

#### 跳转到标准库

```rust
/// `add_one` 返回一个[`Option`]类型
pub fn add_one(x: i32) -> Option<i32> {
    Some(x + 1)
}
```

此处的 **[`Option`]** 就是一个链接，指向了标准库中的 `Option` 枚举类型，有两种方式可以进行跳转:

- 在 IDE 中，使用 `Command + 鼠标左键`(macOS)，`CTRL + 鼠标左键`(Windows)
- 在文档中直接点击链接

再比如，还可以使用路径的方式跳转：

```rust
use std::sync::mpsc::Receiver;

/// [`Receiver<T>`]   [`std::future`].
///
///  [`std::future::Future`] [`Self::recv()`].
pub struct AsyncReceiver<T> {
    sender: Receiver<T>,
}

impl<T> AsyncReceiver<T> {
    pub async fn recv() -> T {
        unimplemented!()
    }
}
```

#### 使用完整路径跳转到指定项

除了跳转到标准库，你还可以通过指定具体的路径跳转到自己代码或者其它库的指定项，例如在 `lib.rs` 中添加以下代码：

```rust
pub mod a {
    /// `add_one` 返回一个[`Option`]类型
    /// 跳转到[`crate::MySpecialFormatter`]
    pub fn add_one(x: i32) -> Option<i32> {
        Some(x + 1)
    }
}

pub struct MySpecialFormatter;
```

使用 `crate::MySpecialFormatter` 这种路径就可以实现跳转到 `lib.rs` 中定义的结构体上。

#### 同名项的跳转

如果遇到同名项，可以使用标示类型的方式进行跳转：

```rust
/// 跳转到结构体  [`Foo`](struct@Foo)
pub struct Bar;

/// 跳转到同名函数 [`Foo`](fn@Foo)
pub struct Foo {}

/// 跳转到同名宏 [`foo!`]
pub fn Foo() {}

#[macro_export]
macro_rules! foo {
  () => {}
}
```

## 文档搜索别名

Rust 文档支持搜索功能，我们可以为自己的类型定义几个别名，以实现更好的搜索展现，当别名命中时，搜索结果会被放在第一位：

```rust
#[doc(alias = "x")]
#[doc(alias = "big")]
pub struct BigX;

#[doc(alias("y", "big"))]
pub struct BigY;
```

结果如下图所示：
<img alt="" src="https://pic1.zhimg.com/80/v2-1ab5b19d2bd06f3d83204d062b399bcd_1440w.png" class="center"  />

## 一个综合例子

这个例子我们将重点应用几个知识点：

- 文档注释
- 一个项目可以包含两个包：二进制可执行包和 `lib` 包（库包），它们的包根分别是 `src/main.rs` 和 `src/lib.rs`
- 在二进制包中引用 `lib` 包
- 使用 `pub use` 再导出 API，并观察文档

首先，使用 `cargo new art` 创建一个 Package `art`：

```console
Created binary (application) `art` package
```

系统提示我们创建了一个二进制 `Package`，根据[之前章节](https://course.rs/basic/crate-module/crate.html)学过的内容，可以知道该 `Package` 包含一个同名的二进制包：包名为 `art`，包根为 `src/main.rs`，该包可以编译成二进制然后运行。

现在，在 `src` 目录下创建一个 `lib.rs` 文件，同样，根据之前学习的知识，创建该文件等于又创建了一个库类型的包，包名也是 `art`，包根为 `src/lib.rs`，该包是是库类型的，因此往往作为依赖库被引入。

将以下内容添加到 `src/lib.rs` 中：

````rust
//! # Art
//!
//!  未来的艺术建模库，现在的调色库

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    //! 定义颜色的类型

    /// 主色
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// 副色
    #[derive(Debug,PartialEq)]
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    //! 实用工具，目前只实现了调色板
    use crate::kinds::*;

    /// 将两种主色调成副色
    /// ```rust
    /// use art::utils::mix;
    /// use art::kinds::{PrimaryColor,SecondaryColor};
    /// assert!(matches!(mix(PrimaryColor::Yellow, PrimaryColor::Blue), SecondaryColor::Green));
    /// ```
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {
        SecondaryColor::Green
    }
}
````

在库包的包根 `src/lib.rs` 下，我们又定义了几个子模块，同时将子模块中的三个项通过 `pub use` 进行了再导出。

接着，将下面内容添加到 `src/main.rs` 中：

```rust
use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let blue = PrimaryColor::Blue;
    let yellow = PrimaryColor::Yellow;
    println!("{:?}",mix(blue, yellow));
}
```

在二进制可执行包的包根 `src/main.rs` 下，我们引入了库包 `art` 中的模块项，同时使用 `main` 函数作为程序的入口，该二进制包可以使用 `cargo run` 运行：

```console
Green
```

至此，库包完美提供了用于调色的 API，二进制包引入这些 API 完美的实现了调色并打印输出。

最后，再来看看文档长啥样：

<img alt="" src="https://pic1.zhimg.com/80/v2-e9ef7351458fd01020b35990c3daf222_1440w.png" class="center"  />

## 总结

在 Rust 中，注释分为三个主要类型：代码注释、文档注释、包和模块注释，每个注释类型都拥有两种形式：行注释和块注释，熟练掌握包模块和注释的知识，非常有助于我们创建工程性更强的项目。

如果读者看到这里对于包模块还是有些模糊，强烈建议回头看看相关的章节以及本章节的最后一个综合例子。

## 课后练习

> [Rust By Practice](https://practice-zh.course.rs/comments-docs.html)，支持代码在线编辑和运行，并提供详细的习题解答。（本节暂无习题解答）


================================================
FILE: src/basic/flow-control.md
================================================
# 流程控制

80 后应该都对学校的小混混记忆犹新，在那个时代，小混混们往往都认为自己是地下王者，管控着地下事务的流程，在我看来，他们就像代码中的流程控制一样，无处不在，很显眼，但是又让人懒得重视。

言归正传，Rust 程序是从上而下顺序执行的，在此过程中，我们可以通过循环、分支等流程控制方式，更好的实现相应的功能。

## 使用 if 来做分支控制

> if else 无处不在 -- 鲁迅

但凡你能找到一门编程语言没有 `if else`，那么一定更要反馈给鲁迅，反正不是我说的 :) 总之，只要你拥有其它语言的编程经验，就一定会有以下认知：`if else` **表达式**根据条件执行不同的代码分支：

```rust
if condition == true {
    // A...
} else {
    // B...
}
```

该代码读作：若 `condition` 的值为 `true`，则执行 `A` 代码，否则执行 `B` 代码。

先看下面代码：

```rust
fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!("The value of number is: {}", number);
}
```

以上代码有以下几点要注意：

- **`if` 语句块是表达式**，这里我们使用 `if` 表达式的返回值来给 `number` 进行赋值：`number` 的值是 `5`
- 用 `if` 来赋值时，要保证每个分支返回的类型一样（事实上，这种说法不完全准确，见[这里](https://course.rs/appendix/expressions.html#if表达式)），此处返回的 `5` 和 `6` 就是同一个类型，如果返回类型不一致就会报错

```console
error[E0308]: if and else have incompatible types
 --> src/main.rs:4:18
  |
4 |       let number = if condition {
  |  __________________^
5 | |         5
6 | |     } else {
7 | |         "six"
8 | |     };
  | |_____^ expected integer, found &str // 期望整数类型，但却发现&str字符串切片
  |
  = note: expected type `{integer}`
             found type `&str`
```

## 使用 else if 来处理多重条件

可以将 `else if` 与 `if`、`else` 组合在一起实现更复杂的条件分支判断：

```rust
fn main() {
    let n = 6;

    if n % 4 == 0 {
        println!("number is divisible by 4");
    } else if n % 3 == 0 {
        println!("number is divisible by 3");
    } else if n % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```

程序执行时，会按照自上至下的顺序执行每一个分支判断，一旦成功，则跳出 `if` 语句块，最终本程序会匹配执行 `else if n % 3 == 0` 的分支，输出 `"number is divisible by 3"`。

有一点要注意，就算有多个分支能匹配，也只有第一个匹配的分支会被执行！

如果代码中有大量的 `else if ` 会让代码变得极其丑陋，不过不用担心，下一章的 `match` 专门用以解决多分支模式匹配的问题。

# 循环控制

循环无处不在，上到数钱，下到数年，你能想象的很多场景都存在循环，因此它也是流程控制中最重要的组成部分之一。

在 Rust 语言中有三种循环方式：`for`、`while` 和 `loop`，其中 `for` 循环是 Rust 循环王冠上的明珠。

## for 循环

`for` 循环是 Rust 的大杀器：

```rust
fn main() {
    for i in 1..=5 {
        println!("{}", i);
    }
}
```

以上代码循环输出一个从 1 到 5 的序列，简单粗暴，核心就在于 `for` 和 `in` 的联动，语义表达如下：

```rust
for 元素 in 集合 {
  // 使用元素干一些你懂我不懂的事情
}
```

这个语法跟 JavaScript 还蛮像，应该挺好理解。

注意，使用 `for` 时我们往往使用集合的引用形式，除非你不想在后面的代码中继续使用该集合（比如我们这里使用了 `container` 的引用）。如果不使用引用的话，所有权会被转移（move）到 `for` 语句块中，后面就无法再使用这个集合了)：

```rust
for item in &container {
  // ...
}
```

> 对于实现了 `copy` 特征的数组（例如 [i32; 10]）而言， `for item in arr` 并不会把 `arr` 的所有权转移，而是直接对其进行了拷贝，因此循环之后仍然可以使用 `arr` 。

如果想在循环中，**修改该元素**，可以使用 `mut` 关键字：

```rust
for item in &mut collection {
  // ...
}
```

总结如下：

| 使用方法                      | 等价使用方式                                      | 所有权     |
| ----------------------------- | ------------------------------------------------- | ---------- |
| `for item in collection`      | `for item in IntoIterator::into_iter(collection)` | 转移所有权 |
| `for item in &collection`     | `for item in collection.iter()`                   | 不可变借用 |
| `for item in &mut collection` | `for item in collection.iter_mut()`               | 可变借用   |

如果想在循环中**获取元素的索引**：

```rust
fn main() {
    let a = [4, 3, 2, 1];
    // `.iter()` 方法把 `a` 数组变成一个迭代器
    for (i, v) in a.iter().enumerate() {
        println!("第{}个元素是{}", i + 1, v);
    }
}
```

有同学可能会想到，如果我们想用 `for` 循环控制某个过程执行 10 次，但是又不想单独声明一个变量来控制这个流程，该怎么写？

```rust
for _ in 0..10 {
  // ...
}
```

可以用 `_` 来替代 `i` 用于 `for` 循环中，在 Rust 中 `_` 的含义是忽略该值或者类型的意思，如果不使用 `_`，那么编译器会给你一个 `变量未使用的` 的警告。

**两种循环方式优劣对比**

以下代码，使用了两种循环方式：

```rust
// 第一种
let collection = [1, 2, 3, 4, 5];
for i in 0..collection.len() {
  let item = collection[i];
  // ...
}

// 第二种
for item in collection {

}
```

第一种方式是循环索引，然后通过索引下标去访问集合，第二种方式是直接循环集合中的元素，优劣如下：

- **性能**：第一种使用方式中 `collection[index]` 的索引访问，会因为边界检查(Bounds Checking)导致运行时的性能损耗 —— Rust 会检查并确认 `index` 是否落在集合内，但是第二种直接迭代的方式就不会触发这种检查，因为编译器会在编译时就完成分析并证明这种访问是合法的
- **安全**：第一种方式里对 `collection` 的索引访问是非连续的，存在一定可能性在两次访问之间，`collection` 发生了变化，导致脏数据产生。而第二种直接迭代的方式是连续访问，因此不存在这种风险( 由于所有权限制，在访问过程中，数据并不会发生变化)。

由于 `for` 循环无需任何条件限制，也不需要通过索引来访问，因此是最安全也是最常用的，通过与下面的 `while` 的对比，我们能看到为什么 `for` 会更加安全。

## `continue`

使用 `continue` 可以跳过当前当次的循环，开始下次的循环：

```rust
 for i in 1..4 {
     if i == 2 {
         continue;
     }
     println!("{}", i);
 }
```

上面代码对 1 到 3 的序列进行迭代，且跳过值为 2 时的循环，输出如下：

```console
1
3
```

## `break`

使用 `break` 可以直接跳出当前整个循环：

```rust
 for i in 1..4 {
     if i == 2 {
         break;
     }
     println!("{}", i);
 }
```

上面代码对 1 到 3 的序列进行迭代，在遇到值为 2 时的跳出整个循环，后面的循环不再执行，输出如下：

```console
1
```

## while 循环

如果你需要一个条件来循环，当该条件为 `true` 时，继续循环，条件为 `false`，跳出循环，那么 `while` 就非常适用：

```rust
fn main() {
    let mut n = 0;

    while n <= 5  {
        println!("{}!", n);

        n = n + 1;
    }

    println!("我出来了！");
}
```

该 `while` 循环，只有当 `n` 小于等于 `5` 时，才执行，否则就立刻跳出循环，因此在上述代码中，它会先从 `0` 开始，满足条件，进行循环，然后是 `1`，满足条件，进行循环，最终到 `6` 的时候，大于 5，不满足条件，跳出 `while` 循环，执行 `我出来了` 的打印，然后程序结束：

```console
0!
1!
2!
3!
4!
5!
我出来了！
```

当然，你也可以用其它方式组合实现，例如 `loop`（无条件循环，将在下面介绍） + `if` + `break`：

```rust
fn main() {
    let mut n = 0;

    loop {
        if n > 5 {
            break
        }
        println!("{}", n);
        n+=1;
    }

    println!("我出来了！");
}
```

可以看出，在这种循环场景下，`while` 要简洁的多。

**while vs for**

我们也能用 `while` 来实现 `for` 的功能：

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index = index + 1;
    }
}
```

这里，代码对数组中的元素进行计数。它从索引 `0` 开始，并接着循环直到遇到数组的最后一个索引（这时，`index < 5` 不再为真）。运行这段代码会打印出数组中的每一个元素：

```console
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
```

数组中的所有五个元素都如期被打印出来。尽管 `index` 在某一时刻会到达值 5，不过循环在其尝试从数组获取第六个值（会越界）之前就停止了。

但这个过程很容易出错；如果索引长度不正确会导致程序 **_panic_**。这也使程序更慢，因为编译器增加了运行时代码来对每次循环的每个元素进行条件检查。

`for`循环代码如下：

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!("the value is: {}", element);
    }
}
```

可以看出，`for` 并不会使用索引去访问数组，因此更安全也更简洁，同时避免 `运行时的边界检查`，性能更高。

## loop 循环

对于循环而言，`loop` 循环毋庸置疑，是适用面最高的，它可以适用于所有循环场景（虽然能用，但是在很多场景下， `for` 和 `while` 才是最优选择），因为 `loop` 就是一个简单的无限循环，你可以在内部实现逻辑通过 `break` 关键字来控制循环何时结束。

使用 `loop` 循环一定要打起精神，否则你会写出下面的跑满你一个 CPU 核心的疯子代码：

```rust,ignore
fn main() {
    loop {
        println!("again!");
    }
}
```

该循环会不停的在终端打印输出，直到你使用 `Ctrl-C` 结束程序：

```console
again!
again!
again!
again!
^Cagain!
```

**注意**，不要轻易尝试上述代码，如果你电脑配置不行，可能会死机！！！

因此，当使用 `loop` 时，必不可少的伙伴是 `break` 关键字，它能让循环在满足某个条件时跳出：

```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
```

以上代码当 `counter` 递增到 `10` 时，就会通过 `break` 返回一个 `counter * 2` 的值，最后赋给 `result` 并打印出来。

这里有几点值得注意：

- **break 可以单独使用，也可以带一个返回值**，有些类似 `return`
- **loop 是一个表达式**，因此可以返回一个值

## 课后练习

> [Rust By Practice](https://practice-zh.course.rs/flow-control.html)，支持代码在线编辑和运行，并提供详细的[习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/flow-control.md)。



================================================
FILE: src/basic/formatted-output.md
================================================
# 格式化输出

提到格式化输出，可能很多人立刻就想到 `"{}"`，但是 Rust 能做到的远比这个多的多，本章节我们将深入讲解格式化输出的各个方面。

## 满分初印象

先来一段代码，看看格式化输出的初印象：

```rust
println!("Hello");                 // => "Hello"
println!("Hello, {}!", "world");   // => "Hello, world!"
println!("The number is {}", 1);   // => "The number is 1"
println!("{:?}", (3, 4));          // => "(3, 4)"
println!("{value}", value=4);      // => "4"
println!("{} {}", 1, 2);           // => "1 2"
println!("{:04}", 42);             // => "0042" with leading zeros
```

可以看到 `println!` 宏接受的是可变参数，第一个参数是一个字符串常量，它表示最终输出字符串的格式，包含其中形如 `{}` 的符号是**占位符**，会被 `println!` 后面的参数依次替换。

## `print!`，`println!`，`format!`

它们是 Rust 中用来格式化输出的三大金刚，用途如下：

- `print!` 将格式化文本输出到标准输出，不带换行符
- `println!` 同上，但是在行的末尾添加换行符
- `format!` 将格式化文本输出到 `String` 字符串

在实际项目中，最常用的是 `println!` 及 `format!`，前者常用来调试输出，后者常用来生成格式化的字符串：

```rust
fn main() {
    let s = "hello";
    println!("{}, world", s);
    let s1 = format!("{}, world", s);
    print!("{}", s1);
    print!("{}\n", "!");
}
```

其中，`s1` 是通过 `format!` 生成的 `String` 字符串，最终输出如下：

```console
hello, world
hello, world!
```

#### `eprint!`，`eprintln!`

除了三大金刚外，还有两大护法，使用方式跟 `print!`，`println!` 很像，但是它们输出到标准错误输出：

```rust
eprintln!("Error: Could not complete task")
```

它们仅应该被用于输出错误信息和进度信息，其它场景都应该使用 `print!` 系列。

## `{}` 与 `{:?}`

与其它语言常用的 `%d`，`%s` 不同，Rust 特立独行地选择了 `{}` 作为格式化占位符（说到这个，有点想吐槽下，Rust 中自创的概念其实还挺多的，真不知道该夸奖还是该吐槽-,-），事实证明，这种选择非常正确，它帮助用户减少了很多使用成本，你无需再为特定的类型选择特定的占位符，统一用 `{}` 来替代即可，剩下的类型推导等细节只要交给 Rust 去做。

与 `{}` 类似，`{:?}` 也是占位符：

- `{}` 适用于实现了 `std::fmt::Display` 特征的类型，用来以更优雅、更友好的方式格式化文本，例如展示给用户
- `{:?}` 适用于实现了 `std::fmt::Debug` 特征的类型，用于调试场景

其实两者的选择很简单，当你在写代码需要调试时，使用 `{:?}`，剩下的场景，选择 `{}`。

#### `Debug` 特征

事实上，为了方便我们调试，大多数 Rust 类型都实现了 `Debug` 特征或者支持派生该特征：

```rust
#[derive(Debug)]
struct Person {
    name: String,
    age: u8
}

fn main() {
    let i = 3.1415926;
    let s = String::from("hello");
    let v = vec![1, 2, 3];
    let p = Person{name: "sunface".to_string(), age: 18};
    println!("{:?}, {:?}, {:?}, {:?}", i, s, v, p);
}
```

对于数值、字符串、数组，可以直接使用 `{:?}` 进行输出，但是对于结构体，需要[派生`Debug`](https://course.rs/appendix/derive.html)特征后，才能进行输出，总之很简单。

#### `Display` 特征

与大部分类型实现了 `Debug` 不同，实现了 `Display` 特征的 Rust 类型并没有那么多，往往需要我们自定义想要的格式化方式：

```rust
let i = 3.1415926;
let s = String::from("hello");
let v = vec![1, 2, 3];
let p = Person {
    name: "sunface".to_string(),
    age: 18,
};
println!("{}, {}, {}, {}", i, s, v, p);
```

运行后可以看到 `v` 和 `p` 都无法通过编译，因为没有实现 `Display` 特征，但是你又不能像派生 `Debug` 一般派生 `Display`，只能另寻他法：

- 使用 `{:?}` 或 `{:#?}`
- 为自定义类型实现 `Display` 特征
- 使用 `newtype` 为外部类型实现 `Display` 特征

下面来一一看看这三种方式。

#### `{:#?}`

`{:#?}` 与 `{:?}` 几乎一样，唯一的区别在于它能更优美地输出内容：

```console
// {:?}
[1, 2, 3], Person { name: "sunface", age: 18 }

// {:#?}
[
    1,
    2,
    3,
], Person {
    name: "sunface",
}
```

因此对于 `Display` 不支持的类型，可以考虑使用 `{:#?}` 进行格式化，虽然理论上它更适合进行调试输出。

#### 为自定义类型实现 `Display` 特征

如果你的类型是定义在当前作用域中的，那么可以为其实现 `Display` 特征，即可用于格式化输出：

```rust
struct Person {
    name: String,
    age: u8,
}

use std::fmt;
impl fmt::Display for Person {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "大佬在上，请受我一拜，小弟姓名{}，年芳{}，家里无田又无车，生活苦哈哈",
            self.name, self.age
        )
    }
}
fn main() {
    let p = Person {
        name: "sunface".to_string(),
        age: 18,
    };
    println!("{}", p);
}
```

如上所示，只要实现 `Display` 特征中的 `fmt` 方法，即可为自定义结构体 `Person` 添加自定义输出：

```console
大佬在上，请受我一拜，小弟姓名sunface，年芳18，家里无田又无车，生活苦哈哈
```

#### 为外部类型实现 `Display` 特征

在 Rust 中，无法直接为外部类型实现外部特征，但是可以使用[`newtype`](https://course.rs/advance/into-types/custom-type.html#newtype)解决此问题：

```rust
struct Array(Vec<i32>);

use std::fmt;
impl fmt::Display for Array {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "数组是：{:?}", self.0)
    }
}
fn main() {
    let arr = Array(vec![1, 2, 3]);
    println!("{}", arr);
}
```

`Array` 就是我们的 `newtype`，它将想要格式化输出的 `Vec` 包裹在内，最后只要为 `Array` 实现 `Display` 特征，即可进行格式化输出：

```console
数组是：[1, 2, 3]
```

至此，关于 `{}` 与 `{:?}` 的内容已介绍完毕，下面让我们正式开始格式化输出的旅程。

## 位置参数

除了按照依次顺序使用值去替换占位符之外，还能让指定位置的参数去替换某个占位符，例如 `{1}`，表示用第二个参数替换该占位符（索引从 0 开始）：

```rust
fn main() {
    println!("{}{}", 1, 2); // =>"12"
    println!("{1}{0}", 1, 2); // =>"21"
    // => Alice, this is Bob. Bob, this is Alice
    println!("{0}, this is {1}. {1}, this is {0}", "Alice", "Bob");
    println!("{1}{}{0}{}", 1, 2); // => 2112
}
```

## 具名参数

除了像上面那样指定位置外，我们还可以为参数指定名称：

```rust
fn main() {
    println!("{argument}", argument = "test"); // => "test"
    println!("{name} {}", 1, name = 2); // => "2 1"
    println!("{a} {c} {b}", a = "a", b = 'b', c = 3); // => "a 3 b"
}
```

需要注意的是：**带名称的参数必须放在不带名称参数的后面**，例如下面代码将报错：

```rust
println!("{abc} {1}", abc = "def", 2);
```

```rust
error: positional arguments cannot follow named arguments
 --> src/main.rs:4:36
   |
 4 | println!("{abc} {1}", abc = "def", 2);
   |                             -----  ^ positional arguments must be before named arguments
   |                             |
   |                             named argument
```

## 格式化参数

格式化输出，意味着对输出格式会有更多的要求，例如只输出浮点数的小数点后两位：

```rust
fn main() {
    let v = 3.1415926;
    // Display => 3.14
    println!("{:.2}", v);
    // Debug => 3.14
    println!("{:.2?}", v);
}
```

上面代码只输出小数点后两位。同时我们还展示了 `{}` 和 `{:?}` 的用法，后面如无特殊区别，就只针对 `{}` 提供格式化参数说明。

接下来，让我们一起来看看 Rust 中有哪些格式化参数。

### 宽度

宽度用来指示输出目标的长度，如果长度不够，则进行填充和对齐：

#### 字符串填充

字符串格式化默认使用空格进行填充，并且进行左对齐。

```rust
fn main() {
    //-----------------------------------
    // 以下全部输出 "Hello x    !"
    // 为"x"后面填充空格，补齐宽度5
    println!("Hello {:5}!", "x");
    // 使用参数5来指定宽度
    println!("Hello {:1$}!", "x", 5);
    // 使用x作为占位符输出内容，同时使用5作为宽度
    println!("Hello {1:0$}!", 5, "x");
    // 使用有名称的参数作为宽度
    println!("Hello {:width$}!", "x", width = 5);
    //-----------------------------------

    // 使用参数5为参数x指定宽度，同时在结尾输出参数5 => Hello x    !5
    println!("Hello {:1$}!{}", "x", 5);
}
```

#### 数字填充:符号和 0

数字格式化默认也是使用空格进行填充，但与字符串左对齐不同的是，数字是右对齐。

```rust
fn main() {
    // 宽度是5 => Hello     5!
    println!("Hello {:5}!", 5);
    // 显式的输出正号 => Hello +5!
    println!("Hello {:+}!", 5);
    // 宽度5，使用0进行填充 => Hello 00005!
    println!("Hello {:05}!", 5);
    // 负号也要占用一位宽度 => Hello -0005!
    println!("Hello {:05}!", -5);
}
```

### 对齐

```rust
fn main() {
    // 以下全部都会补齐5个字符的长度
    // 左对齐 => Hello x    !
    println!("Hello {:<5}!", "x");
    // 右对齐 => Hello     x!
    println!("Hello {:>5}!", "x");
    // 居中对齐 => Hello   x  !
    println!("Hello {:^5}!", "x");

    // 对齐并使用指定符号填充 => Hello x&&&&!
    // 指定符号填充的前提条件是必须有对齐字符
    println!("Hello {:&<5}!", "x");
}
```

### 精度

精度可以用于控制浮点数的精度或者字符串的长度

```rust
fn main() {
    let v = 3.1415926;
    // 保留小数点后两位 => 3.14
    println!("{:.2}", v);
    // 带符号保留小数点后两位 => +3.14
    println!("{:+.2}", v);
    // 不带小数 => 3
    println!("{:.0}", v);
    // 通过参数来设定精度 => 3.1416，相当于{:.4}
    println!("{:.1$}", v, 4);

    let s = "hi我是Sunface孙飞";
    // 保留字符串前三个字符 => hi我
    println!("{:.3}", s);
    // {:.*}接收两个参数，第一个是精度，第二个是被格式化的值 => Hello abc!
    println!("Hello {:.*}!", 3, "abcdefg");
}
```

### 进制

可以使用 `#` 号来控制数字的进制输出：

- `#b`, 二进制
- `#o`, 八进制
- `#x`, 小写十六进制
- `#X`, 大写十六进制
- `x`, 不带前缀的小写十六进制

```rust
fn main() {
    // 二进制 => 0b11011!
    println!("{:#b}!", 27);
    // 八进制 => 0o33!
    println!("{:#o}!", 27);
    // 十进制 => 27!
    println!("{}!", 27);
    // 小写十六进制 => 0x1b!
    println!("{:#x}!", 27);
    // 大写十六进制 => 0x1B!
    println!("{:#X}!", 27);

    // 不带前缀的十六进制 => 1b!
    println!("{:x}!", 27);

    // 使用0填充二进制，宽度为10 => 0b00011011!
    println!("{:#010b}!", 27);
}
```

### 指数

```rust
fn main() {
    println!("{:2e}", 1000000000); // => 1e9
    println!("{:2E}", 1000000000); // => 1E9
}
```

### 指针地址

```rust
let v= vec![1, 2, 3];
println!("{:p}", v.as_ptr()) // => 0x600002324050
```

### 转义

有时需要输出 `{`和`}`，但这两个字符是特殊字符，需要进行转义：

```rust
fn main() {
    // "{{" 转义为 '{'   "}}" 转义为 '}'   "\"" 转义为 '"'
    // => Hello "{World}" 
    println!(" Hello \"{{World}}\" ");

    // 下面代码会报错，因为占位符{}只有一个右括号}，左括号被转义成字符串的内容
    // println!(" {{ Hello } ");
    // 也不可使用 '\' 来转义 "{}"
    // println!(" \{ Hello \} ")
}
```

## 在格式化字符串时捕获环境中的值（Rust 1.58 新增）

在以前，想要输出一个函数的返回值，你需要这么做：

```rust
fn get_person() -> String {
    String::from("sunface")
}
fn main() {
    let p = get_person();
    println!("Hello, {}!", p);                // implicit position
    println!("Hello, {0}!", p);               // explicit index
    println!("Hello, {person}!", person = p);
}
```

问题倒也不大，但是一旦格式化字符串长了后，就会非常冗余，而在 1.58 后，我们可以这么写：

```rust
fn get_person() -> String {
    String::from("sunface")
}
fn main() {
    let person = get_person();
    println!("Hello, {person}!");
}
```

是不是清晰、简洁了很多？甚至还可以将环境中的值用于格式化参数:

```rust
let (width, precision) = get_format();
for (name, score) in get_scores() {
  println!("{name}: {score:width$.precision$}");
}
```

但也有局限，它只能捕获普通的变量，对于更复杂的类型（例如表达式），可以先将它赋值给一个变量或使用以前的 `name = expression` 形式的格式化参数。
目前除了 `panic!` 外，其它接收格式化参数的宏，都可以使用新的特性。对于 `panic!` 而言，如果还在使用 `2015版本` 或 `2018版本`，那 `panic!("{ident}")` 依然会被当成 正常的字符串来处理，同时编译器会给予 `warn` 提示。而对于 `2021版本` ，则可以正常使用:

```rust
fn get_person() -> String {
    String::from("sunface")
}
fn main() {
    let person = get_person();
    panic!("Hello, {person}!");
}
```

输出:

```console
thread 'main' panicked at 'Hello, sunface!', src/main.rs:6:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

## 课后练习

> [Rust By Practice](https://practice-zh.course.rs/formatted-output.html)，支持代码在线编辑和运行，并提供详细的习题解答。（本节暂无习题解答）

## 总结

把这些格式化都牢记在脑中是不太现实的，也没必要，我们要做的就是知道 Rust 支持相应的格式化输出，在需要之时，读者再来查阅本文即可。

还是那句话，[<<Rust 语言圣经>>](https://github.com/sunface/rust-course)不仅仅是 Rust 学习书籍，还是一本厚重的工具书！

至此，Rust 的基础内容学习已经全部完成，下面我们将学习 Rust 的高级进阶内容，正式开启你的高手之路。



================================================
FILE: src/basic/intro.md
================================================
# Rust 基本概念

从现在开始，我们正式踏入了 Rust 大陆，这片广袤而神秘的世界，在这个世界中，将接触到很多之前都没有听过的概念：

- 所有权、借用、生命周期
- 宏编程
- 模式匹配

类似的还有很多，不过不用怕，引用武林外传一句话：咱上面有人。有本书在，一切虚妄终将烟消云散。

本章主要介绍 Rust 的基础语法、数据类型、项目结构等，学完本章，你将对 Rust 代码有一个清晰、完整的认识。

开始之前先通过一段代码来简单浏览下 Rust 的语法：

```rust
// Rust 程序入口函数，跟其它语言一样，都是 main，该函数目前无返回值
fn main() {
    // 使用let来声明变量，进行绑定，a是不可变的
    // 此处没有指定a的类型，编译器会默认根据a的值为a推断类型：i32，有符号32位整数
    // 语句的末尾必须以分号结尾
    let a = 10;
    // 主动指定b的类型为i32
    let b: i32 = 20;
    // 这里有两点值得注意：
    // 1. 可以在数值中带上类型:30i32表示数值是30，类型是i32
    // 2. c是可变的，mut是mutable的缩写
    let mut c = 30i32;
    // 还能在数值和类型中间添加一个下划线，让可读性更好
    let d = 30_i32;
    // 跟其它语言一样，可以使用一个函数的返回值来作为另一个函数的参数
    let e = add(add(a, b), add(c, d));

    // println!是宏调用，看起来像是函数但是它返回的是宏定义的代码块
    // 该函数将指定的格式化字符串输出到标准输出中(控制台)
    // {}是占位符，在具体执行过程中，会把e的值代入进来
    println!("( a + b ) + ( c + d ) = {}", e);
}

// 定义一个函数，输入两个i32类型的32位有符号整数，返回它们的和
fn add(i: i32, j: i32) -> i32 {
    // 返回相加值，这里可以省略return
    i + j
}
```

> 注意
> 在上面的 `add` 函数中，不要为 `i+j` 添加 `;`，这会改变语法导致函数返回 `()` 而不是 `i32`，具体参见[语句和表达式](https://course.rs/basic/base-type/statement-expression.html)。

有几点可以留意下：

- 字符串使用双引号 `""` 而不是单引号 `''`，Rust 中单引号是留给单个字符类型（`char`）使用的
- Rust 使用 `{}` 来作为格式化输出占位符，其它语言可能使用的是 `%s`，`%d`，`%p` 等，由于 `println!` 会自动推导出具体的类型，因此无需手动指定



================================================
FILE: src/basic/lifetime.md
================================================
[Binary file]


================================================
FILE: src/basic/method.md
================================================
# 方法 Method

从面向对象语言过来的同学对于方法肯定不陌生，`class` 里面就充斥着方法的概念。在 Rust 中，方法的概念也大差不差，往往和对象成对出现：

```rust
object.method()
```

例如读取一个文件写入缓冲区，如果用函数的写法 `read(f, buffer)`，用方法的写法 `f.read(buffer)`。不过与其它语言 `class` 跟方法的联动使用不同（这里可能要修改下），Rust 的方法往往跟结构体、枚举、特征(Trait)一起使用，特征将在后面几章进行介绍。

## 定义方法

Rust 使用 `impl` 来定义方法，例如以下代码：

```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    // new是Circle的关联函数，因为它的第一个参数不是self，且new并不是关键字
    // 这种方法往往用于初始化当前结构体的实例
    fn new(x: f64, y: f64, radius: f64) -> Circle {
        Circle {
            x: x,
            y: y,
            radius: radius,
        }
    }

    // Circle的方法，&self表示借用当前的Circle结构体
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}
```

我们这里先不详细展开讲解，只是先建立对方法定义的大致印象。下面的图片将 Rust 方法定义与其它语言的方法定义做了对比：

<img alt="" src="https://pica.zhimg.com/80/v2-0d848e960f3279999eab4b1317f6538e_1440w.png" class="center"/>

可以看出，其它语言中所有定义都在 `class` 中，但是 Rust 的对象定义和方法定义是分离的，这种数据和使用分离的方式，会给予使用者极高的灵活度。

再来看一个例子：

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```

该例子定义了一个 `Rectangle` 结构体，并且在其上定义了一个 `area` 方法，用于计算该矩形的面积。

`impl Rectangle {}` 表示为 `Rectangle` 实现方法（`impl` 是实现 _implementation_ 的缩写），这样的写法表明 `impl` 语句块中的一切都是跟 `Rectangle` 相关联的。

#### self、&self 和 &mut self

接下来的内容非常重要，请大家仔细看。在 `area` 的签名中，我们使用 `&self` 替代 `rectangle: &Rectangle`，`&self` 其实是 `self: &Self` 的简写（注意大小写）。在一个 `impl` 块内，`Self` 指代被实现方法的结构体类型，`self` 指代此类型的实例，换句话说，`self` 指代的是 `Rectangle` 结构体实例，这样的写法会让我们的代码简洁很多，而且非常便于理解：我们为哪个结构体实现方法，那么 `self` 就是指代哪个结构体的实例。

需要注意的是，`self` 依然有所有权的概念：

- `self` 表示 `Rectangle` 的所有权转移到该方法中，这种形式用的较少
- `&self` 表示该方法对 `Rectangle` 的不可变借用
- `&mut self` 表示可变借用

总之，`self` 的使用就跟函数参数一样，要严格遵守 Rust 的所有权规则。

回到上面的例子中，选择 `&self` 的理由跟在函数中使用 `&Rectangle` 是相同的：我们并不想获取所有权，也无需去改变它，只是希望能够读取结构体中的数据。如果想要在方法中去改变当前的结构体，需要将第一个参数改为 `&mut self`。仅仅通过使用 `self` 作为第一个参数来使方法获取实例的所有权是很少见的，这种使用方式往往用于把当前的对象转成另外一个对象时使用，转换完后，就不再关注之前的对象，且可以防止对之前对象的误调用。

简单总结下，使用方法代替函数有以下好处：

- 不用在函数签名中重复书写 `self` 对应的类型
- 代码的组织性和内聚性更强，对于代码维护和阅读来说，好处巨大

#### 方法名跟结构体字段名相同

在 Rust 中，允许方法名跟结构体的字段名相同：

```rust
impl Rectangle {
    fn width(&self) -> bool {
        self.width > 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!("The rectangle has a nonzero width; it is {}", rect1.width);
    }
}
```

当我们使用 `rect1.width()` 时，Rust 知道我们调用的是它的方法，如果使用 `rect1.width`，则是访问它的字段。

一般来说，方法跟字段同名，往往适用于实现 `getter` 访问器，例如:

```rust
mod my {
    pub struct Rectangle {
        width: u32,
        pub height: u32,
    }

    impl Rectangle {
        pub fn new(width: u32, height: u32) -> Self {
            Rectangle { width, height }
        }
        pub fn width(&self) -> u32 {
            return self.width;
        }
        pub fn height(&self) -> u32 {
            return self.height;
        }
    }
}

fn main() {
    let rect1 = my::Rectangle::new(30, 50);

    println!("{}", rect1.width()); // OK
    println!("{}", rect1.height()); // OK
    // println!("{}", rect1.width); // Error - the visibility of field defaults to private
    println!("{}", rect1.height); // OK
}
```

当从模块外部访问结构体时，结构体的字段默认是私有的，其目的是隐藏信息（封装）。我们如果想要从模块外部获取 `Rectangle` 的字段，只需把它的 `new`， `width` 和 `height` 方法设置为公开可见，那么用户就可以创建一个矩形，同时通过访问器 `rect1.width()` 和 `rect1.height()` 方法来获取矩形的宽度和高度。

因为 `width` 字段是私有的，当用户访问 `rect1.width` 字段时，就会报错。注意在此例中，`Self` 指代的就是被实现方法的结构体 `Rectangle`。

特别的是，这种默认的可见性（私有的）可以通过 `pub` 进行覆盖，这样对于模块外部来说，就可以直接访问使用 `pub` 修饰的字段而无需通过访问器。这种可见性仅当从定义结构的模块外部访问时才重要，并且具有隐藏信息（封装）的目的。

> ### `->` 运算符到哪去了？
>
> 在 C/C++ 语言中，有两个不同的运算符来调用方法：`.` 直接在对象上调用方法，而 `->` 在一个对象的指针上调用方法，这时需要先解引用指针。换句话说，如果 `object` 是一个指针，那么 `object->something()` 和 `(*object).something()` 是一样的。
>
> Rust 并没有一个与 `->` 等效的运算符；相反，Rust 有一个叫 **自动引用和解引用**的功能。方法调用是 Rust 中少数几个拥有这种行为的地方。
>
> 他是这样工作的：当使用 `object.something()` 调用方法时，Rust 会自动为 `object` 添加 `&`（视可见性添加`&mut`)、 `*` 以便使 `object` 与方法签名匹配。也就是说，这些代码是等价的：
>
> ```rust
> # #[derive(Debug,Copy,Clone)]
> # struct Point {
> #     x: f64,
> #     y: f64,
> # }
> #
> # impl Point {
> #    fn distance(&self, other: &Point) -> f64 {
> #        let x_squared = f64::powi(other.x - self.x, 2);
> #        let y_squared = f64::powi(other.y - self.y, 2);
> #
> #        f64::sqrt(x_squared + y_squared)
> #    }
> # }
> # let p1 = Point { x: 0.0, y: 0.0 };
> # let p2 = Point { x: 5.0, y: 6.5 };
> p1.distance(&p2);
> (&p1).distance(&p2);
> ```
>
> 第一行看起来简洁的多。这种自动引用的行为之所以有效，是因为方法有一个明确的接收者———— `self` 的类型。在给出接收者和方法名的前提下，Rust 可以明确地计算出方法是仅仅读取（`&self`），做出修改（`&mut self`）或者是获取所有权（`self`）。事实上，Rust 对方法接收者的隐式借用让所有权在实践中更友好。

## 带有多个参数的方法

方法和函数一样，可以使用多个参数：

```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
```

## 关联函数

现在大家可以思考一个问题，如何为一个结构体定义一个构造器方法？也就是接受几个参数，然后构造并返回该结构体的实例。其实答案在开头的代码片段中就给出了，很简单，参数中不包含 `self` 即可。

这种定义在 `impl` 中且没有 `self` 的函数被称之为**关联函数**： 因为它没有 `self`，不能用 `f.read()` 的形式调用，因此它是一个函数而不是方法，它又在 `impl` 中，与结构体紧密关联，因此称为关联函数。

在之前的代码中，我们已经多次使用过关联函数，例如 `String::from`，用于创建一个动态字符串。

```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn new(w: u32, h: u32) -> Rectangle {
        Rectangle { width: w, height: h }
    }
}
```

> Rust 中有一个约定俗成的规则，使用 `new` 来作为构造器的名称，出于设计上的考虑，Rust 特地没有用 `new` 作为关键字。

因为是函数，所以不能用 `.` 的方式来调用，我们需要用 `::` 来调用，例如 `let sq = Rectangle::new(3, 3);`。这个方法位于结构体的命名空间中：`::` 语法用于关联函数和模块创建的命名空间。

## 多个 impl 定义

Rust 允许我们为一个结构体定义多个 `impl` 块，目的是提供更多的灵活性和代码组织性，例如当方法多了后，可以把相关的方法组织在同一个 `impl` 块中，那么就可以形成多个 `impl` 块，各自完成一块儿目标：

```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```

当然，就这个例子而言，我们没必要使用两个 `impl` 块，这里只是为了演示方便。

## 为枚举实现方法

枚举类型之所以强大，不仅仅在于它好用、可以[同一化类型](https://course.rs/basic/compound-type/enum.html#同一化类型)，还在于，我们可以像结构体一样，为枚举实现方法：

```rust
#![allow(unused)]
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&self) {
        // 在这里定义方法体
    }
}

fn main() {
    let m = Message::Write(String::from("hello"));
    m.call();
}
```

除了结构体和枚举，我们还能为特征(trait)实现方法，这将在下一章进行讲解，在此之前，先来看看泛型。

## 课后练习

> [Rust By Practice](https://practice-zh.course.rs/method.html)，支持代码在线编辑和运行，并提供详细的[习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/method.md)。



================================================
FILE: src/basic/variable.md
================================================
# 变量绑定与解构

鉴于本书的目标读者（别慌，来到这里就说明你就是目标读者）已经熟练掌握其它任意一门编程语言，因此这里就不再对何为变量进行赘述，让我们开门见山来谈谈，为何 Rust 选择了手动设定变量的可变性。

## 为何要手动设置变量的可变性？

在其它大多数语言中，要么只支持声明可变的变量，要么只支持声明不可变的变量（例如函数式语言），前者为编程提供了灵活性，后者为编程提供了安全性，而 Rust 比较野，选择了两者我都要，既要灵活性又要安全性。

能想要学习 Rust，说明我们的读者都是相当有水平的程序员了，你们应该能理解**一切选择皆是权衡**，那么两者都要的权衡是什么呢？这就是 Rust 开发团队为我们做出的贡献，两者都要意味着 Rust 语言底层代码的实现复杂度大幅提升，因此 Salute to The Rust Team!

除了以上两个优点，还有一个很大的优点，那就是运行性能上的提升，因为将本身无需改变的变量声明为不可变在运行期会避免一些多余的 `runtime` 检查。

## 变量命名

在命名方面，和其它语言没有区别，不过当给变量命名时，需要遵循 [Rust 命名规范](https://course.rs/practice/naming.html)。

> Rust 语言有一些**关键字**（_keywords_），和其他语言一样，这些关键字都是被保留给 Rust 语言使用的，因此，它们不能被用作变量或函数的名称。在 [附录 A](https://course.rs/appendix/keywords.html) 中可找到关键字列表。

## 变量绑定

在其它语言中，我们用 `var a = "hello world"` 的方式给 `a` 赋值，也就是把等式右边的 `"hello world"` 字符串赋值给变量 `a` ，而在 Rust 中，我们这样写： `let a = "hello world"` ，同时给这个过程起了另一个名字：**变量绑定**。

为何不用赋值而用绑定呢（其实你也可以称之为赋值，但是绑定的含义更清晰准确）？这里就涉及 Rust 最核心的原则——**所有权**，简单来讲，任何内存对象都是有主人的，而且一般情况下完全属于它的主人，绑定就是把这个对象绑定给一个变量，让这个变量成为它的主人（聪明的读者应该能猜到，在这种情况下，该对象之前的主人就会丧失对该对象的所有权），像极了我们的现实世界，不是吗？

那为什么要引进“所有权”这个新的概念呢？请稍安勿躁，时机一旦成熟，我们就回来继续讨论这个话题。

## 变量可变性

Rust 的变量在默认情况下是**不可变的**。前文提到，这是 Rust 团队为我们精心设计的语言特性之一，让我们编写的代码更安全，性能也更好。当然你可以通过 `mut` 关键字让变量变为**可变的**，让设计更灵活。

如果变量 `a` 不可变，那么一旦为它绑定值，就不能再修改 `a`。举个例子，在我们的工程目录下使用 `cargo new variables` 新建一个项目，叫做 _variables_ 。

然后在新建的 _variables_ 目录下，编辑 _src/main.rs_ ，改为下面代码：

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

保存文件，再使用 `cargo run` 运行它，迎面而来的是一条错误提示：

```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

error: aborting due to previous error
```

具体的错误原因是 `cannot assign twice to immutable variable x`（无法对不可变的变量进行重复赋值），因为我们想为不可变的 `x` 变量再次赋值。

这种错误是为了避免无法预期的错误发生在我们的变量上：一个变量往往被多处代码所使用，其中一部分代码假定该变量的值永远不会改变，而另外一部分代码却无情的改变了这个值，在实际开发过程中，这个错误是很难被发现的，特别是在多线程编程中。

这种规则让我们的代码变得非常清晰，只有你想让你的变量改变时，它才能改变，这样就不会造成心智上的负担，也给别人阅读代码带来便利。

但是可变性也非常重要，否则我们就要像 ClojureScript 那样，每次要改变，就要重新生成一个对象，在拥有大量对象的场景，性能会变得非常低下，内存拷贝的成本异常的高。

在 Rust 中，可变性很简单，只要在变量名前加一个 `mut` 即可, 而且这种显式的声明方式还会给后来人传达这样的信息：嗯，这个变量在后面代码部分会发生改变。

为了让变量声明为可变,将 _src/main.rs_ 改为以下内容：

```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

运行程序将得到下面结果：

```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```

选择可变还是不可变，更多的还是取决于你的使用场景，例如不可变可以带来安全性，但是丧失了灵活性和性能（如果你要改变，就要重新创建一个新的变量，这里涉及到内存对象的再分配）。而可变变量最大的好处就是使用上的灵活性和性能上的提升。

例如，在使用大型数据结构或者热点代码路径（被大量频繁调用）的情形下，在同一内存位置更新实例可能比复制并返回新分配的实例要更快。使用较小的数据结构时，通常创建新的实例并以更具函数式的风格来编写程序，可能会更容易理解，所以值得以较低的性能开销来确保代码清晰。

## 使用下划线开头忽略未使用的变量

如果你创建了一个变量却不在任何地方使用它，Rust 通常会给你一个警告，因为这可能会是个 BUG。但是有时创建一个不会被使用的变量是有用的，比如你正在设计原型或刚刚开始一个项目。这时**你希望告诉 Rust 不要警告未使用的变量，为此可以用下划线作为变量名的开头**：

```rust
fn main() {
    let _x = 5;
    let y = 10;
}
```

使用 `cargo run` 运行下试试:

```shell
warning: unused variable: `y`
 --> src/main.rs:3:9
  |
3 |     let y = 10;
  |         ^ help: 如果 y 故意不被使用，请添加一个下划线前缀: `_y`
  |
  = note: `#[warn(unused_variables)]` on by default
```

可以看到，两个变量都是只有声明，没有使用，但是编译器却独独给出了 `y` 未被使用的警告，充分说明了 `_` 变量名前缀在这里发挥的作用。

值得注意的是，这里编译器还很善意的给出了提示（Rust 的编译器非常强大，这里的提示只是小意思）：将 `y` 修改 `_y` 即可。这里就不再给出代码，留给大家手动尝试并观察下运行结果。

更多关于 `_x` 的使用信息，请阅读后面的[模式匹配章节](https://course.rs/basic/match-pattern/all-patterns.html?highlight=_#使用下划线开头忽略未使用的变量)。

## 变量解构

`let` 表达式不仅仅用于变量的绑定，还能进行复杂变量的解构：从一个相对复杂的变量中，匹配出该变量的一部分内容：

```rust
fn main() {
    let (a, mut b): (bool,bool) = (true, false);
    // a = true,不可变; b = false，可变
    println!("a = {:?}, b = {:?}", a, b);

    b = true;
    assert_eq!(a, b);
}
```

### 解构式赋值

在 [Rust 1.59](https://course.rs/appendix/rust-versions/1.59.html) 版本后，我们可以在赋值语句的左式中使用元组、切片和结构体模式了。

```rust
struct Struct {
    e: i32
}

fn main() {
    let (a, b, c, d, e);

    (a, b) = (1, 2);
    // _ 代表匹配一个值，但是我们不关心具体的值是什么，因此没有使用一个变量名而是使用了 _
    [c, .., d, _] = [1, 2, 3, 4, 5];
    Struct { e, .. } = Struct { e: 5 };

    assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);
}
```

这种使用方式跟之前的 `let` 保持了一致性，但是 `let` 会重新绑定，而这里仅仅是对之前绑定的变量进行再赋值。

需要注意的是，使用 `+=` 的赋值语句还不支持解构式赋值。

> 这里用到了模式匹配的一些语法，如果大家看不懂没关系，可以在学完模式匹配章节后，再回头来看。

## 变量和常量之间的差异

变量的值不能更改可能让你想起其他另一个很多语言都有的编程概念：**常量**(_constant_)。与不可变变量一样，常量也是绑定到一个常量名且不允许更改的值，但是常量和变量之间存在一些差异：

- 常量不允许使用 `mut`。**常量不仅仅默认不可变，而且自始至终不可变**，因为常量在编译完成后，已经确定它的值。
- 常量使用 `const` 关键字而不是 `let` 关键字来声明，并且值的类型**必须**标注。

我们将在下一节[数据类型](https://course.rs/basic/base-type/index.html)中介绍，因此现在暂时无需关心细节。

下面是一个常量声明的例子，其常量名为 `MAX_POINTS`，值设置为 `100,000`。（Rust 常量的命名约定是全部字母都使用大写，并使用下划线分隔单词，另外对数字字面量可插入下划线以提高可读性）：

```rust
const MAX_POINTS: u32 = 100_000;
```

常量可以在任意作用域内声明，包括全局作用域，在声明的作用域内，常量在程序运行的整个过程中都有效。对于需要在多处代码共享一个不可变的值时非常有用，例如游戏中允许玩家赚取的最大点数或光速。

> 在实际使用中，最好将程序中用到的硬编码值都声明为常量，对于代码后续的维护有莫大的帮助。如果将来需要更改硬编码的值，你也只需要在代码中更改一处即可。

## 变量遮蔽(shadowing)

Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的，如下所示：

```rust
fn main() {
    let x = 5;
    // 在main函数的作用域内对之前的x进行遮蔽
    let x = x + 1;

    {
        // 在当前的花括号作用域内，对之前的x进行遮蔽
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
```

这个程序首先将数值 `5` 绑定到 `x`，然后通过重复使用 `let x =` 来遮蔽之前的 `x`，并取原来的值加上 `1`，所以 `x` 的值变成了 `6`。第三个 `let` 语句同样遮蔽前面的 `x`，取之前的值并乘上 `2`，得到的 `x` 最终值为 `12`。当运行此程序，将输出以下内容：

```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
   ...
The value of x in the inner scope is: 12
The value of x is: 6
```

这和 `mut` 变量的使用是不同的，第二个 `let` 生成了完全不同的新变量，两个变量只是恰好拥有同样的名称，涉及一次内存对象的再分配
，而 `mut` 声明的变量，可以修改同一个内存地址上的值，并不会发生内存对象的再分配，性能要更好。

变量遮蔽的用处在于，如果你在某个作用域内无需再使用之前的变量（在被遮蔽后，无法再访问到之前的同名变量），就可以重复的使用变量名字，而不用绞尽脑汁去想更多的名字。

例如，假设有一个程序要统计一个空格字符串的空格数量：

```rust
// 字符串类型
let spaces = "   ";
// usize数值类型
let spaces = spaces.len();
```

这种结构是允许的，因为第一个 `spaces` 变量是一个字符串类型，第二个 `spaces` 变量是一个全新的变量且和第一个具有相同的变量名，且是一个数值类型。所以变量遮蔽可以帮我们节省些脑细胞，不用去想如 `spaces_str` 和 `spaces_num` 此类的变量名；相反我们可以重复使用更简单的 `spaces` 变量名。如果你不用 `let` :

```rust,
let mut spaces = "   ";
spaces = spaces.len();
```

运行一下，你就会发现编译器报错：

```console
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&str`, found `usize`

error: aborting due to previous error
```

显然，Rust 对类型的要求很严格，不允许将整数类型 `usize` 赋值给字符串类型。`usize` 是一种 CPU 相关的整数类型，在[数值类型](https://course.rs/basic/base-type/numbers.html#整数类型)中有详细介绍。

万事开头难，到目前为止，都进展很顺利，那下面开始，咱们正式进入 Rust 的类型世界，看看有哪些挑战在前面等着大家。


## 课后练习

> [Rust By Practice](https://practice-zh.course.rs/variables.html)，支持代码在线编辑和运行，并提供详细的[习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/variables.md)。




================================================
FILE: src/basic/base-type/char-bool.md
================================================
[Binary file]


================================================
FILE: src/basic/base-type/function.md
================================================
[Binary file]


================================================
FILE: src/basic/base-type/index.md
================================================
# 基本类型

当一门语言不谈类型时，你得小心，这大概率是动态语言（别拍我，我承认是废话）。但是把类型大张旗鼓的用多个章节去讲的，Rust 是其中之一。

Rust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。 基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型（一般意义上来说），由以下组成：

- 数值类型：有符号整数 (`i8`, `i16`, `i32`, `i64`, `isize`)、 无符号整数 (`u8`, `u16`, `u32`, `u64`, `usize`) 、浮点数 (`f32`, `f64`)、以及有理数、复数
- 字符串：字符串字面量和字符串切片 `&str`
- 布尔类型：`true` 和 `false`
- 字符类型：表示单个 Unicode 字符，存储为 4 个字节
- 单元类型：即 `()` ，其唯一的值也是 `()`

## 类型推导与标注

与 Python、JavaScript 等动态语言不同，Rust 是一门静态类型语言，也就是编译器必须在编译期知道我们所有变量的类型，但这不意味着你需要为每个变量指定类型，因为 **Rust 编译器很聪明，它可以根据变量的值和上下文中的使用方式来自动推导出变量的类型**，同时编译器也不够聪明，在某些情况下，它无法推导出变量类型，需要手动去给予一个类型标注，关于这一点在 [Rust 语言初印象](https://course.rs/first-try/hello-world.html#rust-语言初印象) 中有过展示。

来看段代码：

```rust
let guess = "42".parse().expect("Not a number!");
```

先忽略 `.parse().expect..` 部分，这段代码的目的是将字符串 `"42"` 进行解析，而编译器在这里无法推导出我们想要的类型：整数？浮点数？字符串？因此编译器会报错：

```console
$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^ consider giving `guess` a type
```

因此我们需要提供给编译器更多的信息，例如给 `guess` 变量一个**显式的类型标注**：`let guess: i32 = ...` 或者 `"42".parse::<i32>()`。



================================================
FILE: src/basic/base-type/numbers.md
================================================
# 数值类型

我朋友有一个领导（读者：你朋友？黑人问号）说过一句话：所有代码就是 0 和 1 ，简单的很。咱不评价这句话的正确性，但是计算机底层由 01 组成倒是真的。

计算机和数值关联在一起的时间，远比我们想象的要长，因此数值类型可以说是有计算机以来就有的类型，下面内容将深入讨论 Rust 的数值类型以及相关的运算符。


Rust 使用一个相对传统的语法来创建整数（`1`，`2`，...）和浮点数（`1.0`，`1.1`，...）。整数、浮点数的运算和你在其它语言上见过的一致，都是通过常见的运算符来完成。

> 不仅仅是数值类型，Rust 也允许在复杂类型上定义运算符，例如在自定义类型上定义 `+` 运算符，这种行为被称为运算符重载，Rust 具体支持的可重载运算符见[附录 B](https://course.rs/appendix/operators.html#运算符)。

## 整数类型

**整数**是没有小数部分的数字。之前使用过的 `i32` 类型，表示有符号的 32 位整数（ `i` 是英文单词 _integer_ 的首字母，与之相反的是 `u`，代表无符号 `unsigned` 类型）。下表显示了 Rust 中的内置的整数类型：

| 长度       | 有符号类型 | 无符号类型 |
| ---------- | ---------- | ---------- |
| 8 位       | `i8`       | `u8`       |
| 16 位      | `i16`      | `u16`      |
| 32 位      | `i32`      | `u32`      |
| 64 位      | `i64`      | `u64`      |
| 128 位     | `i128`     | `u128`     |
| 视架构而定 | `isize`    | `usize`    |

类型定义的形式统一为：`有无符号 + 类型大小(位数)`。**无符号数**表示数字只能取正数和 0，而**有符号**则表示数字可以取正数、负数还有 0。就像在纸上写数字一样：当要强调符号时，数字前面可以带上正号或负号；然而，当很明显确定数字为正数时，就不需要加上正号了。有符号数字以[补码](https://en.wikipedia.org/wiki/Two%27s_complement)形式存储。

每个有符号类型规定的数字范围是 -(2<sup>n - 1</sup>) ~ 2<sup>n -
1</sup> - 1，其中 `n` 是该定义形式的位长度。因此 `i8` 可存储数字范围是 -(2<sup>7</sup>) ~ 2<sup>7</sup> - 1，即 -128 ~ 127。无符号类型可以存储的数字范围是 0 ~ 2<sup>n</sup> - 1，所以 `u8` 能够存储的数字为 0 ~ 2<sup>8</sup> - 1，即 0 ~ 255。

此外，`isize` 和 `usize` 类型取决于程序运行的计算机 CPU 类型： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位。

整型字面量可以用下表的形式书写：

| 数字字面量         | 示例          |
| ------------------ | ------------- |
| 十进制             | `98_222`      |
| 十六进制           | `0xff`        |
| 八进制             | `0o77`        |
| 二进制             | `0b1111_0000` |
| 字节 (仅限于 `u8`) | `b'A'`        |

这么多类型，有没有一个简单的使用准则？答案是肯定的， Rust 整型默认使用 `i32`，例如 `let i = 1`，那 `i` 就是 `i32` 类型，因此你可以首选它，同时该类型也往往是性能最好的。`isize` 和 `usize` 的主要应用场景是用作集合的索引。


#### 整型溢出

假设有一个 `u8` ，它可以存放从 0 到 255 的值。那么当你将其修改为范围之外的值，比如 256，则会发生**整型溢出**。关于这一行为 Rust 有一些有趣的规则：当在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 _panic_(崩溃,Rust 使用这个术语来表明程序因错误而退出)。

在当使用 `--release` 参数进行 release 模式构建时，Rust **不**检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（_two’s complement wrapping_）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 `u8` 的情况下，256 变成 0，257 变成 1，依此类推。程序不会 _panic_，但是该变量的值可能不是你期望的值。依赖这种默认行为的代码都应该被认为是错误的代码。

要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：

- 使用 `wrapping_*` 方法在所有模式下都按照补码循环溢出规则处理，例如 `wrapping_add`
- 如果使用 `checked_*` 方法时发生溢出，则返回 `None` 值
- 使用 `overflowing_*` 方法返回该值和一个指示是否存在溢出的布尔值
- 使用 `saturating_*` 方法，可以限定计算后的结果不超过目标类型的最大值或低于最小值，例如:

```rust
assert_eq!(100u8.saturating_add(1), 101);
assert_eq!(u8::MAX.saturating_add(127), u8::MAX);
```

下面是一个演示`wrapping_*`方法的示例：

```rust
fn main() {
    let a : u8 = 255;
    let b = a.wrapping_add(20);
    println!("{}", b);  // 19
}
```

## 浮点类型

**浮点类型数字** 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： `f32` 和 `f64`，分别为 32 位和 64 位大小。默认浮点类型是 `f64`，在现代的 CPU 中它的速度与 `f32` 几乎相同，但精度更高。

下面是一个演示浮点数的示例：

```rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```

浮点数根据 `IEEE-754` 标准实现。`f32` 类型是单精度浮点型，`f64` 为双精度。

#### 浮点数陷阱

浮点数由于底层格式的特殊性，导致了如果在使用浮点数时不够谨慎，就可能造成危险，有两个原因：

1. **浮点数往往是你想要数字的近似表达**
   浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制，例如 `0.1` 在二进制上并不存在精确的表达形式，但是在十进制上就存在。这种不匹配性导致一定的歧义性，更多的，虽然浮点数能代表真实的数值，但是由于底层格式问题，它往往受限于定长的浮点数精度，如果你想要表达完全精准的真实数字，只有使用无限精度的浮点数才行

2. **浮点数在某些特性上是反直觉的**
   例如大家都会觉得浮点数可以进行比较，对吧？是的，它们确实可以使用 `>`，`>=` 等进行比较，但是在某些场景下，这种直觉上的比较特性反而会害了你。因为 `f32` ， `f64` 上的比较运算实现的是 `std::cmp::PartialEq` 特征(类似其他语言的接口)，但是并没有实现 `std::cmp::Eq` 特征，但是后者在其它数值类型上都有定义，说了这么多，可能大家还是云里雾里，用一个例子来举例：

Rust 的 `HashMap` 数据结构，是一个 KV 类型的 Hash Map 实现，它对于 `K` 没有特定类型的限制，但是要求能用作 `K` 的类型必须实现了 `std::cmp::Eq` 特征，因此这意味着你无法使用浮点数作为 `HashMap` 的 `Key`，来存储键值对，但是作为对比，Rust 的整数类型、字符串类型、布尔类型都实现了该特征，因此可以作为 `HashMap` 的 `Key`。

为了避免上面说的两个陷阱，你需要遵守以下准则：

- 避免在浮点数上测试相等性
- 当结果在数学上可能存在未定义时，需要格外的小心

来看个小例子:

```rust
fn main() {
  // 断言0.1 + 0.2与0.3相等
  assert!(0.1 + 0.2 == 0.3);
}
```

你可能以为，这段代码没啥问题吧，实际上它会 _panic_（程序崩溃，抛出异常），因为二进制精度问题，导致了 0.1 + 0.2 并不严格等于 0.3，它们可能在小数点 N 位后存在误差。

那如果非要进行比较呢？可以考虑用这种方式 `(0.1_f64 + 0.2 - 0.3).abs() < 0.00001` ，具体小于多少，取决于你对精度的需求。

讲到这里，相信大家基本已经明白了，为什么操作浮点数时要格外的小心，但是还不够，下面再来一段代码，直接震撼你的灵魂：

```rust
fn main() {
    let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);
    let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);

    println!("abc (f32)");
    println!("   0.1 + 0.2: {:x}", (abc.0 + abc.1).to_bits());
    println!("         0.3: {:x}", (abc.2).to_bits());
    println!();

    println!("xyz (f64)");
    println!("   0.1 + 0.2: {:x}", (xyz.0 + xyz.1).to_bits());
    println!("         0.3: {:x}", (xyz.2).to_bits());
    println!();

    assert!(abc.0 + abc.1 == abc.2);
    assert!(xyz.0 + xyz.1 == xyz.2);
}
```

运行该程序，输出如下:

```console
abc (f32)
   0.1 + 0.2: 3e99999a
         0.3: 3e99999a

xyz (f64)
   0.1 + 0.2: 3fd3333333333334
         0.3: 3fd3333333333333

thread 'main' panicked at 'assertion failed: xyz.0 + xyz.1 == xyz.2',
➥ch2-add-floats.rs.rs:14:5
note: run with `RUST_BACKTRACE=1` environment variable to display
➥a backtrace
```

仔细看，对 `f32` 类型做加法时，`0.1 + 0.2` 的结果是 `3e99999a`，`0.3` 也是 `3e99999a`，因此 `f32` 下的 `0.1 + 0.2 == 0.3` 通过测试，但是到了 `f64` 类型时，结果就不一样了，因为 `f64` 精度高很多，因此在小数点非常后面发生了一点微小的变化，`0.1 + 0.2` 以 `4` 结尾，但是 `0.3` 以`3`结尾，这个细微区别导致 `f64` 下的测试失败了，并且抛出了异常。

是不是**blow your mind away**? 没关系，在本书的后续章节中类似的直击灵魂的地方还很多，这就是敢号称 `Rust语言圣经（Rust Course）` 的底气！

#### NaN

对于数学上未定义的结果，例如对负数取平方根 `-42.1.sqrt()` ，会产生一个特殊的结果：Rust 的浮点数类型使用 `NaN` (not a number) 来处理这些情况。

**所有跟 `NaN` 交互的操作，都会返回一个 `NaN`**，而且 `NaN` 不能用来比较，下面的代码会崩溃：

```rust
fn main() {
  let x = (-42.0_f32).sqrt();
  assert_eq!(x, x);
}
```

出于防御性编程的考虑，可以使用 `is_nan()` 等方法，可以用来判断一个数值是否是 `NaN` ：

```rust
fn main() {
    let x = (-42.0_f32).sqrt();
    if x.is_nan() {
        println!("未定义的数学行为")
    }
}
```

## 数字运算

Rust 支持所有数字类型的基本数学运算：加法、减法、乘法、除法和取模运算。下面代码各使用一条 `let` 语句来说明相应运算的用法：

```rust
fn main() {
    // 加法
    let sum = 5 + 10;

    // 减法
    let difference = 95.5 - 4.3;

    // 乘法
    let product = 4 * 30;

    // 除法
    let quotient = 56.7 / 32.2;

    // 求余
    let remainder = 43 % 5;
}
```

这些语句中的每个表达式都使用了数学运算符，并且计算结果为一个值，然后绑定到一个变量上。[附录 B](https://course.rs/appendix/operators.html#运算符) 中给出了 Rust 提供的所有运算符的列表。

再来看一个综合性的示例：

```rust
fn main() {
  // 编译器会进行自动推导，给予twenty i32的类型
  let twenty = 20;
  // 类型标注
  let twenty_one: i32 = 21;
  // 通过类型后缀的方式进行类型标注：22是i32类型
  let twenty_two = 22i32;

  // 只有同样类型，才能运算
  let addition = twenty + twenty_one + twenty_two;
  println!("{} + {} + {} = {}", twenty, twenty_one, twenty_two, addition);

  // 对于较长的数字，可以用_进行分割，提升可读性
  let one_million: i64 = 1_000_000;
  println!("{}", one_million.pow(2));

  // 定义一个f32数组，其中42.0会自动被推导为f32类型
  let forty_twos = [
    42.0,
    42f32,
    42.0_f32,
  ];

  // 打印数组中第一个值，并控制小数位为2位
  println!("{:.2}", forty_twos[0]);
}
```



## 位运算

Rust 的位运算基本上和其他语言一样

| 运算符  | 说明                                                   |
| ------- | ------------------------------------------------------ |
| & 位与  | 相同位置均为1时则为1，否则为0                          |
| \| 位或 | 相同位置只要有1时则为1，否则为0                        |
| ^ 异或  | 相同位置不相同则为1，相同则为0                         |
| ! 位非  | 把位中的0和1相互取反，即0置为1，1置为0                 |
| << 左移 | 所有位向左移动指定位数，右位补0                        |
| >> 右移 | 所有位向右移动指定位数，带符号移动（正数补0，负数补1） |



```rust
fn main() {
    // 无符号8位整数，二进制为00000010
    let a: u8 = 2; // 也可以写 let a: u8 = 0b_0000_0010;

    // 二进制为00000011
    let b: u8 = 3;

    // {:08b}：左高右低输出二进制01，不足8位则高位补0
    println!("a value is        {:08b}", a);

    println!("b value is        {:08b}", b);

    println!("(a & b) value is  {:08b}", a & b);

    println!("(a | b) value is  {:08b}", a | b);

    println!("(a ^ b) value is  {:08b}", a ^ b);

    println!("(!b) value is     {:08b}", !b);

    println!("(a << b) value is {:08b}", a << b);

    println!("(a >> b) value is {:08b}", a >> b);

    let mut a = a;
    // 注意这些计算符除了!之外都可以加上=进行赋值 (因为!=要用来判断不等于)
    a <<= b;
    println!("(a << b) value is {:08b}", a);
}
```


对于移位运算，Rust 会检查它是否超出该整型的位数范围，如果超出，则会报错 overflow。比如，一个 8 位的整型，如果试图移位 8 位，就会报错，但如果移位 7 位就不会。Rust 这样做的理由也很简单，如果移位太多，那么这个移位后的数字就是全 0 或者全 1，所以移位操作不如直接写 0 或者 -1，这很可能意味着这里的代码是有问题的。需要注意的是，不论 debug 模式还是 release 模式，Rust 都会检查溢出。

```rust
fn main() {
   let a: u8 = 255;
   let b = a>>7; // ok
   let b = a<<7; // ok
   let b = a>>8; // overflow
   let b = a<<8; // overflow
}
```

## 序列(Range)

Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 `1..5`，生成从 1 到 4 的连续数字，不包含 5 ；`1..=5`，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：

```rust
for i in 1..=5 {
    println!("{}",i);
}
```

最终程序输出:

```console
1
2
3
4
5
```

序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。如下是一个使用字符类型序列的例子：

```rust
for i in 'a'..='z' {
    println!("{}",i);
}
```

## 使用 As 完成类型转换
Rust 中可以使用 As 来完成一个类型到另一个类型的转换，其最常用于将原始类型转换为其他原始类型，但是它也可以完成诸如将指针转换为地址、地址转换为指针以及将指针转换为其他指针等功能。你可以在[这里](../../advance/into-types/converse.md)了解更多相关的知识。

## 有理数和复数

Rust 的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：

- 有理数和复数
- 任意大小的整数和任意精度的浮点数
- 固定精度的十进制小数，常用于货币相关的场景

好在社区已经开发出高质量的 Rust 数值库：[num](https://crates.io/crates/num)。

按照以下步骤来引入 `num` 库：

1. 创建新工程 `cargo new complex-num && cd complex-num`
2. 在 `Cargo.toml` 中的 `[dependencies]` 下添加一行 `num = "0.4.0"`
3. 将 `src/main.rs` 文件中的 `main` 函数替换为下面的代码
4. 运行 `cargo run`

```rust
use num::complex::Complex;

 fn main() {
   let a = Complex { re: 2.1, im: -1.2 };
   let b = Complex::new(11.1, 22.2);
   let result = a + b;

   println!("{} + {}i", result.re, result.im)
 }
```

## 总结

之前提到过 Rust 的数值类型和运算跟其他语言相似，事实上还是存在一些差异，例如语法差异，再比如：

- **Rust 拥有相当多的数值类型**. 因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数
- **类型转换必须是显式的**. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数
- **Rust 的数值上可以使用方法**. 例如你可以用以下方法来将 `13.14` 取整：`13.14_f32.round()`，在这里我们使用了类型后缀，因为编译器需要知道 `13.14` 的具体类型

数值类型的讲解已经基本结束，接下来，来看看字符和布尔类型。


## 课后练习

> [Rust By Practice](https://practice-zh.course.rs/basic-types/numbers.html)，支持代码在线编辑和运行，并提供详细的[习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/basic-types/numbers.md)。






================================================
FILE: src/basic/base-type/statement-expression.md
================================================
# 语句和表达式 

Rust 的函数体是由一系列语句组成，最后由一个表达式来返回值，例如：

```rust
fn add_with_extra(x: i32, y: i32) -> i32 {
    let x = x + 1; // 语句
    let y = y + 5; // 语句
    x + y // 表达式
}
```

语句会执行一些操作但是不会返回一个值，而表达式会在求值后返回一个值，因此在上述函数体的三行代码中，前两行是语句，最后一行是表达式。



对于 Rust 语言而言，**这种基于语句（statement）和表达式（expression）的方式是非常重要的，你需要能明确的区分这两个概念**，但是对于很多其它语言而言，这两个往往无需区分。基于表达式是函数式语言的重要特征，**表达式总要返回值**。


其实，在此之前，我们已经多次使用过语句和表达式。

## 语句

```rust
let a = 8;
let b: Vec<f64> = Vec::new();
let (a, c) = ("hi", false);
```

以上都是语句，它们完成了一个具体的操作，但是并没有返回值，因此是语句。

由于 `let` 是语句，因此不能将 `let` 语句赋值给其它值，如下形式是错误的：

```rust
let b = (let a = 8);
```

错误如下:

```console
error: expected expression, found statement (`let`) // 期望表达式，却发现`let`语句
 --> src/main.rs:2:13
  |
2 |     let b = let a = 8;
  |             ^^^^^^^^^
  |
  = note: variable declaration using `let` is a statement `let`是一条语句

error[E0658]: `let` expressions in this position are experimental
          // 下面的 `let` 用法目前是试验性的，在稳定版中尚不能使用
 --> src/main.rs:2:13
  |
2 |     let b = let a = 8;
  |             ^^^^^^^^^
  |
  = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information
  = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`

```

以上的错误告诉我们 `let` 是语句，不是表达式，因此它不返回值，也就不能给其它变量赋值。但是该错误还透漏了一个重要的信息， `let` 作为表达式已经是试验功能了，也许不久的将来，我们在 [`stable rust`](https://course.rs/appendix/rust-version.html) 下可以这样使用。

## 表达式

表达式会进行求值，然后返回一个值。例如 `5 + 6`，在求值后，返回值 `11`，因此它就是一条表达式。

表达式可以成为语句的一部分，例如 `let y = 6` 中，`6` 就是一个表达式，它在求值后返回一个值 `6`（有些反直觉，但是确实是表达式）。

调用一个函数是表达式，因为会返回一个值，调用宏也是表达式，用花括号包裹最终返回一个值的语句块也是表达式，总之，能返回值，它就是表达式:

```rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
```

上面使用一个语句块表达式将值赋给 `y` 变量，语句块长这样：

```rust
{
    let x = 3;
    x + 1
}
```

该语句块是表达式的原因是：它的最后一行是表达式，返回了 `x + 1` 的值，注意 `x + 1` 不能以分号结尾，否则就会从表达式变成语句， **表达式不能包含分号**。这一点非常重要，一旦你在表达式后加上分号，它就会变成一条语句，再也**不会**返回一个值，请牢记！

最后，表达式如果不返回任何值，会隐式地返回一个 [`()`](https://course.rs/basic/base-type/char-bool.html#单元类型) 。

```rust
fn main() {
    assert_eq!(ret_unit_type(), ())
}

fn ret_unit_type() {
    let x = 1;
    // if 语句块也是一个表达式，因此可以用于赋值，也可以直接返回
    // 类似三元运算符，在Rust里我们可以这样写
    let y = if x % 2 == 1 {
        "odd"
    } else {
        "even"
    };
    // 或者写成一行
    let z = if x % 2 == 1 { "odd" } else { "even" };
}
```

## 课后练习

> [Rust By Practice](https://practice-zh.course.rs/basic-types/statements-expressions.html)，支持代码在线编辑和运行，并提供详细的[习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/basic-types/statements.md)。




================================================
FILE: src/basic/collections/hashmap.md
================================================
[Binary file]


================================================
FILE: src/basic/collections/intro.md
================================================
[Binary file]


================================================
FILE: src/basic/collections/vector.md
================================================
[Binary file]


================================================
FILE: src/basic/compound-type/array.md
================================================
# 数组

在日常开发中，使用最广的数据结构之一就是数组，在 Rust 中，最常用的数组有两种，第一种是速度很快但是长度固定的 `array`，第二种是可动态增长的但是有性能损耗的 `Vector`，在本书中，我们称 `array` 为数组，`Vector` 为动态数组。

不知道你们发现没，这两个数组的关系跟 `&str` 与 `String` 的关系很像，前者是长度固定的字符串切片，后者是可动态增长的字符串。其实，在 Rust 中无论是 `String` 还是 `Vector`，它们都是 Rust 的高级类型：集合类型，在后面章节会有详细介绍。

对于本章节，我们的重点还是放在数组 `array` 上。数组的具体定义很简单：将多个类型相同的元素依次组合在一起，就是一个数组。结合上面的内容，可以得出数组的三要素：

- 长度固定
- 元素必须有相同的类型
- 依次线性排列

这里再啰嗦一句，**我们这里说的数组是 Rust 的基本类型，是固定长度的，这点与其他编程语言不同，其它编程语言的数组往往是可变长度的，与 Rust 中的动态数组 `Vector` 类似**，希望读者大大牢记此点。

### 创建数组

在 Rust 中，数组是这样定义的：

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

数组语法跟 JavaScript 很像，也跟大多数编程语言很像。由于它的元素类型大小固定，且长度也是固定，因此**数组 `array` 是存储在栈上**，性能也会非常优秀。与此对应，**动态数组 `Vector` 是存储在堆上**，因此长度可以动态改变。当你不确定是使用数组还是动态数组时，那就应该使用后者，具体见[动态数组 Vector](https://course.rs/basic/collections/vector.html)。

举个例子，在需要知道一年中各个月份名称的程序中，你很可能希望使用的是数组而不是动态数组。因为月份是固定的，它总是只包含 12 个元素：

```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```

在一些时候，还需要为**数组声明类型**，如下所示：

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

这里，数组类型是通过方括号语法声明，`i32` 是元素类型，分号后面的数字 `5` 是数组长度，数组类型也从侧面说明了**数组的元素类型要统一，长度要固定**。

还可以使用下面的语法初始化一个**某个值重复出现 N 次的数组**：

```rust
let a = [3; 5];
```

`a` 数组包含 `5` 个元素，这些元素的初始化值为 `3`，聪明的读者已经发现，这种语法跟数组类型的声明语法其实是保持一致的：`[3; 5]` 和 `[类型; 长度]`。

在元素重复的场景，这种写法要简单的多，否则你就得疯狂敲击键盘：`let a = [3, 3, 3, 3, 3];`，不过老板可能很喜欢你的这种疯狂编程的状态。

### 访问数组元素

因为数组是连续存放元素的，因此可以通过索引的方式来访问存放其中的元素：

```rust
fn main() {
    let a = [9, 8, 7, 6, 5];

    let first = a[0]; // 获取a数组第一个元素
    let second = a[1]; // 获取第二个元素
}
```

与许多语言类似，数组的索引下标是从 0 开始的。此处，`first` 获取到的值是 `9`，`second` 是 `8`。

#### 越界访问

如果使用超出数组范围的索引访问数组元素，会怎么样？下面是一个接收用户的控制台输入，然后将其作为索引访问数组元素的例子：

```rust
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();
    // 读取控制台的输出
    io::stdin()
        .read_line(&mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!(
        "The value of the element at index {} is: {}",
        index, element
    );
}
```

使用 `cargo run` 来运行代码，因为数组只有 5 个元素，如果我们试图输入 `5` 去访问第 6 个元素，则会访问到不存在的数组元素，最终程序会崩溃退出：

```console
Please enter an array index.
5
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 5', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

这就是数组访问越界，访问了数组中不存在的元素，导致 Rust 运行时错误。程序因此退出并显示错误消息，未执行最后的 `println!` 语句。

当你尝试使用索引访问元素时，Rust 将检查你指定的索引是否小于数组长度。如果索引大于或等于数组长度，Rust 会出现 **_panic_**。这种检查只能在运行时进行，比如在上面这种情况下，编译器无法在编译期知道用户运行代码时将输入什么值。

这种就是 Rust 的安全特性之一。在很多系统编程语言中，并不会检查数组越界问题，你会访问到无效的内存地址获取到一个风马牛不相及的值，最终导致在程序逻辑上出现大问题，而且这种问题会非常难以检查。

#### 数组元素为非基础类型

学习了上面的知识，很多朋友肯定觉得已经学会了 Rust 的数组类型，但现实会给我们一记重锤，实际开发中还会碰到一种情况，就是**数组元素是非基本类型**的，这时候大家一定会这样写。

```rust
let array = [String::from("rust is good!"); 8];

println!("{:#?}", array);
```

然后你会惊喜的得到编译错误。

```console
error[E0277]: the trait bound `String: std::marker::Copy` is not satisfied
 --> src/main.rs:7:18
  |
7 |     let array = [String::from("rust is good!"); 8];
  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `String`
  |
  = note: the `Copy` trait is required because this value will be copied for each element of the array
```

有些还没有看过特征的小伙伴，有可能不太明白这个报错，不过这个目前可以不提，我们就拿之前所学的[所有权](https://course.rs/basic/ownership/ownership.html)知识，就可以思考明白，前面几个例子都是 Rust 的基本类型，而**基本类型在 Rust 中赋值是以 Copy 的形式**，这时候你就懂了吧，`let array=[3;5]`底层就是不断的Copy出来的，但很可惜复杂类型都没有深拷贝，只能一个个创建。

接着就有小伙伴会这样写。

```rust
let array = [String::from("rust is good!"),String::from("rust is good!"),String::from("rust is good!")];

println!("{:#?}", array);
```

作为一个追求极致完美的Rust开发者，怎么能容忍上面这么难看的代码存在！

**正确的写法**，应该调用`std::array::from_fn`

```rust
let array: [String; 8] = std::array::from_fn(|_i| String::from("rust is good!"));

println!("{:#?}", array);
```

## 数组切片

在之前的[章节](https://course.rs/basic/compound-type/string-slice.html#切片slice)，我们有讲到 `切片` 这个概念，它允许你引用集合中的部分连续片段，而不是整个集合，对于数组也是，数组切片允许我们引用数组的一部分：

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];

let slice: &[i32] = &a[1..3];

assert_eq!(slice, &[2, 3]);
```

上面的数组切片 `slice` 的类型是`&[i32]`，与之对比，数组的类型是`[i32;5]`，简单总结下切片的特点：

- 切片的长度可以与数组不同，并不是固定的，而是取决于你使用时指定的起始和结束位置
- 创建切片的代价非常小，因为切片只是针对底层数组的一个引用
- 切片类型 [T] 拥有不固定的大小，而切片引用类型 &[T] 则具有固定的大小，因为 Rust 很多时候都需要固定大小数据类型，因此 &[T] 更有用，`&str` 字符串切片也同理

## 总结

最后，让我们以一个综合性使用数组的例子，来结束本章节的学习：

```rust
fn main() {
  // 编译器自动推导出one的类型
  let one             = [1, 2, 3];
  // 显式类型标注
  let two: [u8; 3]    = [1, 2, 3];
  let blank1          = [0; 3];
  let blank2: [u8; 3] = [0; 3];

  // arrays是一个二维数组，其中每一个元素都是一个数组，元素类型是[u8; 3]
  let arrays: [[u8; 3]; 4]  = [one, two, blank1, blank2];

  // 借用arrays的元素用作循环中
  for a in &arrays {
    print!("{:?}: ", a);
    // 将a变成一个迭代器，用于循环
    // 你也可以直接用for n in a {}来进行循环
    for n in a.iter() {
      print!("\t{} + 10 = {}", n, n+10);
    }

    let mut sum = 0;
    // 0..a.len,是一个 Rust 的语法糖，其实就等于一个数组，元素是从0,1,2一直增加到到a.len-1
    for i in 0..a.len() {
      sum += a[i];
    }
    println!("\t({:?} = {})", a, sum);
  }
}
```

做个总结，数组虽然很简单，但是其实还是存在几个要注意的点：

- **数组类型容易跟数组切片混淆**，[T;n] 描述了一个数组的类型，而 [T] 描述了切片的类型， 因为切片是运行期的数据结构，它的长度无法在编译期得知，因此不能用 [T;n] 的形式去描述
- `[u8; 3]`和`[u8; 4]`是不同的类型，数组的长度也是类型的一部分
- **在实际开发中，使用最多的是数组切片[T]**，我们往往通过引用的方式去使用`&[T]`，因为后者有固定的类型大小

至此，关于数据类型部分，我们已经全部学完了，对于 Rust 学习而言，我们也迈出了坚定的第一步，后面将开始更高级特性的学习。未来如果大家有疑惑需要检索知识，一样可以继续回顾过往的章节，因为本书不仅仅是一门 Rust 的教程，还是一本厚重的 Rust 工具书。

## 课后练习

> [Rust By Practice](https://practice-zh.course.rs/compound-types/array.html)，支持代码在线编辑和运行，并提供详细的[习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/array.md)。



================================================
FILE: src/basic/compound-type/enum.md
================================================
[Binary file]


================================================
FILE: src/basic/compound-type/intro.md
================================================
# 复合类型

行百里者半九十，欢迎大家来到这里，虽然还不到中点，但是已经不远了。如果说之前学的基础数据类型是原子，那么本章将讲的数据类型可以认为是分子。

本章的重点在复合类型上，顾名思义，复合类型是由其它类型组合而成的，最典型的就是结构体 `struct` 和枚举 `enum`。例如平面上的一个点 `point(x, y)`，它由两个数值类型的值 `x` 和 `y` 组合而来。我们无法单独去维护这两个数值，因为单独一个 `x` 或者 `y` 是含义不完整的，无法标识平面上的一个点，应该把它们看作一个整体去理解和处理。

来看一段代码，它使用我们之前学过的内容来构建文件操作：

```rust
#![allow(unused_variables)]
type File = String;

fn open(f: &mut File) -> bool {
    true
}
fn close(f: &mut File) -> bool {
    true
}

#[allow(dead_code)]
fn read(f: &mut File, save_to: &mut Vec<u8>) -> ! {
    unimplemented!()
}

fn main() {
    let mut f1 = File::from("f1.txt");
    open(&mut f1);
    //read(&mut f1, &mut vec![]);
    close(&mut f1);
}
```

接下来我们的学习非常类似原型设计：有的方法只提供 API 接口，但是不提供具体实现。此外，有的变量在声明之后并未使用，因此在这个阶段我们需要排除一些编译器噪音（Rust 在编译的时候会扫描代码，变量声明后未使用会以 `warning` 警告的形式进行提示），引入 `#![allow(unused_variables)]` 属性标记，该标记会告诉编译器忽略未使用的变量，不要抛出 `warning` 警告，具体的常见编译器属性你可以在这里查阅：[编译器属性标记](https://course.rs/profiling/compiler/attributes.html)。

`read` 函数也非常有趣，它返回一个 `!` 类型，这个表明该函数是一个发散函数，不会返回任何值，包括 `()`。`unimplemented!()` 告诉编译器该函数尚未实现，`unimplemented!()` 标记通常意味着我们期望快速完成主要代码，回头再通过搜索这些标记来完成次要代码，类似的标记还有 `todo!()`，当代码执行到这种未实现的地方时，程序会直接报错。你可以反注释 `read(&mut f1, &mut vec![]);` 这行，然后再观察下结果。

同时，从代码设计角度来看，关于文件操作的类型和函数应该组织在一起，散落得到处都是，是难以管理和使用的。而且通过 `open(&mut f1)` 进行调用，也远没有使用 `f1.open()` 来调用好，这就体现出了只使用基本类型的局限性：**无法从更高的抽象层次去简化代码**。

接下来，我们将引入一个高级数据结构 —— 结构体 `struct`，来看看复合类型是怎样更好的解决这类问题。 开始之前，先来看看 Rust 的重点也是难点：字符串 `String` 和 `&str`。



================================================
FILE: src/basic/compound-type/string-slice.md
================================================
[Binary file]


================================================
FILE: src/basic/compound-type/struct.md
================================================
# 结构体

上一节中提到需要一个更高级的数据结构来帮助我们更好的抽象问题，结构体 `struct` 恰恰就是这样的复合数据结构，它是由其它数据类型组合而来。 其它语言也有类似的数据结构，不过可能有不同的名称，例如 `object`、 `record` 等。

结构体跟之前讲过的[元组](https://course.rs/basic/compound-type/tuple.html)有些相像：都是由多种类型组合而成。但是与元组不同的是，结构体可以为内部的每个字段起一个富有含义的名称。因此结构体更加灵活更加强大，你无需依赖这些字段的顺序来访问和解析它们。

## 结构体语法

天下无敌的剑士往往也因为他有一柄无双之剑，既然结构体这么强大，那么我们就需要给它配套一套强大的语法，让用户能更好的驾驭。

#### 定义结构体

一个结构体由几部分组成：

- 通过关键字 `struct` 定义
- 一个清晰明确的结构体 `名称`
- 几个有名字的结构体 `字段`

例如, 以下结构体定义了某网站的用户：

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```

该结构体名称是 `User`，拥有 4 个字段，且每个字段都有对应的字段名及类型声明，例如 `username` 代表了用户名，是一个可变的 `String` 类型。

#### 创建结构体实例

为了使用上述结构体，我们需要创建 `User` 结构体的**实例**：

```rust
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
```

有几点值得注意:

1. 初始化实例时，**每个字段**都需要进行初始化
2. 初始化时的字段顺序**不需要**和结构体定义时的顺序一致

#### 访问结构体字段

通过 `.` 操作符即可访问结构体实例内部的字段值，也可以修改它们：

```rust
    let mut user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
```

需要注意的是，必须要将结构体实例声明为可变的，才能修改其中的字段，Rust 不支持将某个结构体某个字段标记为可变。

#### 简化结构体创建

下面的函数类似一个构建函数，返回了 `User` 结构体的实例：

```rust
fn build_user(email: String, username: String) -> User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
```

它接收两个字符串参数： `email` 和 `username`，然后使用它们来创建一个 `User` 结构体，并且返回。可以注意到这两行： `email: email` 和 `username: username`，非常的扎眼，因为实在有些啰嗦，如果你从 TypeScript 过来，肯定会鄙视 Rust 一番，不过好在，它也不是无可救药：

```rust
fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
```

如上所示，当函数参数和结构体字段同名时，可以直接使用缩略的方式进行初始化，跟 TypeScript 中一模一样。

#### 结构体更新语法

在实际场景中，有一种情况很常见：根据已有的结构体实例，创建新的结构体实例，例如根据已有的 `user1` 实例来构建 `user2`：

```rust
  let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
```

老话重提，如果你从 TypeScript 过来，肯定觉得啰嗦爆了：竟然手动把 `user1` 的三个字段逐个赋值给 `user2`，好在 Rust 为我们提供了 `结构体更新语法`：

```rust
  let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
```

因为 `user2` 仅仅在 `email` 上与 `user1` 不同，因此我们只需要对 `email` 进行赋值，剩下的通过结构体更新语法 `..user1` 即可完成。

`..` 语法表明凡是我们没有显式声明的字段，全部从 `user1` 中自动获取。需要注意的是 `..user1` 必须在结构体的尾部使用。

> 结构体更新语法跟赋值语句 `=` 非常相像，因此在上面代码中，`user1` 的部分字段所有权被转移到 `user2` 中：`username` 字段发生了所有权转移，作为结果，`user1` 无法再被使用。
>
> 聪明的读者肯定要发问了：明明有三个字段进行了自动赋值，为何只有 `username` 发生了所有权转移？
>
> 仔细回想一下[所有权](https://course.rs/basic/ownership/ownership.html#拷贝浅拷贝)那一节的内容，我们提到了 `Copy` 特征：实现了 `Copy` 特征的类型无需所有权转移，可以直接在赋值时进行
>数据拷贝，其中 `bool` 和 `u64` 类型就实现了 `Copy` 特征，因此 `active` 和 `sign_in_count` 字段在赋值给 `user2` 时，仅仅发生了拷贝，而不是所有权转移。
>
> 值得注意的是：`username` 所有权被转移给了 `user2`，导致了 `user1` 无法再被使用，但是并不代表 `user1` 内部的其它字段不能被继续使用，例如：

```rust
# #[derive(Debug)]
# struct User {
#     active: bool,
#     username: String,
#     email: String,
#     sign_in_count: u64,
# }
# fn main() {
let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};
let user2 = User {
    active: user1.active,
    username: user1.username,
    email: String::from("another@example.com"),
    sign_in_count: user1.sign_in_count,
};
println!("{}", user1.active);
// 下面这行会报错
println!("{:?}", user1);
# }
```

## 结构体的内存排列

先来看以下代码：

```rust
#[derive(Debug)]
 struct File {
   name: String,
   data: Vec<u8>,
 }

 fn main() {
   let f1 = File {
     name: String::from("f1.txt"),
     data: Vec::new(),
   };

   let f1_name = &f1.name;
   let f1_length = &f1.data.len();

   println!("{:?}", f1);
   println!("{} is {} bytes long", f1_name, f1_length);
 }
```

上面定义的 `File` 结构体在内存中的排列如下图所示：
<img alt="" src="https://pic3.zhimg.com/80/v2-8cc4ed8cd06d60f974d06ca2199b8df5_1440w.png" class="center"  />

从图中可以清晰地看出 `File` 结构体两个字段 `name` 和 `data` 分别拥有底层两个 `[u8]` 数组的所有权（`String` 类型的底层也是 `[u8]` 数组），通过 `ptr` 指针指向底层数组的内存地址，这里你可以把 `ptr` 指针理解为 Rust 中的引用类型。

该图片也侧面印证了：**把结构体中具有所有权的字段转移出去后，将无法再访问该字段，但是可以正常访问其它的字段**。

## 元组结构体(Tuple Struct)

结构体必须要有名称，但是结构体的字段可以没有名称，这种结构体长得很像元组，因此被称为元组结构体，例如：

```rust
    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);

    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
```

元组结构体在你希望有一个整体名称，但是又不关心里面字段的名称时将非常有用。例如上面的 `Point` 元组结构体，众所周知 3D 点是 `(x, y, z)` 形式的坐标点，因此我们无需再为内部的字段逐一命名为：`x`, `y`, `z`。

## 单元结构体(Unit-like Struct)

还记得之前讲过的基本没啥用的[单元类型](https://course.rs/basic/base-type/char-bool.html#单元类型)吧？单元结构体就跟它很像，没有任何字段和属性，但是好在，它还挺有用。

如果你定义一个类型，但是不关心该类型的内容，只关心它的行为时，就可以使用 `单元结构体`：

```rust
struct AlwaysEqual;

let subject = AlwaysEqual;

// 我们不关心 AlwaysEqual 的字段数据，只关心它的行为，因此将它声明为单元结构体，然后再为它实现某个特征
impl SomeTrait for AlwaysEqual {

}
```

## 结构体数据的所有权

在之前的 `User` 结构体的定义中，有一处细节：我们使用了自身拥有所有权的 `String` 类型而不是基于引用的 `&str` 字符串切片类型。这是一个有意而为之的选择：因为我们想要这个结构体拥有它所有的数据，而不是从其它地方借用数据。

你也可以让 `User` 结构体从其它对象借用数据，不过这么做，就需要引入[生命周期(lifetimes)](https://course.rs/basic/lifetime.html)这个新概念（也是一个复杂的概念），简而言之，生命周期能确保结构体的作用范围要比它所借用的数据的作用范围要小。

总之，如果你想在结构体中使用一个引用，就必须加上生命周期，否则就会报错：

```rust
struct User {
    username: &str,
    email: &str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: "someone@example.com",
        username: "someusername123",
        active: true,
        sign_in_count: 1,
    };
}
```

编译器会抱怨它需要生命周期标识符：

```console
error[E0106]: missing lifetime specifier
 --> src/main.rs:2:15
  |
2 |     username: &str,
  |               ^ expected named lifetime parameter // 需要一个生命周期
  |
help: consider introducing a named lifetime parameter // 考虑像下面的代码这样引入一个生命周期
  |
1 ~ struct User<'a> {
2 ~     username: &'a str,
  |

error[E0106]: missing lifetime specifier
 --> src/main.rs:3:12
  |
3 |     email: &str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User<'a> {
2 |     username: &str,
3 ~     email: &'a str,
  |
```

未来在[生命周期](https://course.rs/basic/lifetime.html)中会讲到如何修复这个问题以便在结构体中存储引用，不过在那之前，我们会避免在结构体中使用引用类型。

## 使用 `#[derive(Debug)]` 来打印结构体的信息

在前面的代码中我们使用 `#[derive(Debug)]` 对结构体进行了标记，这样才能使用 `println!("{:?}", s);` 的方式对其进行打印输出，如果不加，看看会发生什么:

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {}", rect1);
}
```

首先可以观察到，上面使用了 `{}` 而不是之前的 `{:?}`，运行后报错：

```shell
error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
```

提示我们结构体 `Rectangle` 没有实现 `Display` 特征，这是因为如果我们使用 `{}` 来格式化输出，那对应的类型就必须实现 `Display` 特征，以前学习的基本类型，都默认实现了该特征:

```rust
fn main() {
    let v = 1;
    let b = true;

    println!("{}, {}", v, b);
}
```

上面代码不会报错，那么结构体为什么不默认实现 `Display` 特征呢？原因在于结构体较为复杂，例如考虑以下问题：你想要逗号对字段进行分割吗？需要括号吗？加在什么地方？所有的字段都应该显示？类似的还有很多，由于这种复杂性，Rust 不希望猜测我们想要的是什么，而是把选择权交给我们自己来实现：如果要用 `{}` 的方式打印结构体，那就自己实现 `Display` 特征。

接下来继续阅读报错：

```shell
= help: the trait `std::fmt::Display` is not implemented for `Rectangle`
= note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
```

上面提示我们使用 `{:?}` 来试试，这个方式我们在本文的前面也见过，下面来试试:

```rust
println!("rect1 is {:?}", rect1);
```

可是依然无情报错了:

```shell
error[E0277]: `Rectangle` doesn't implement `Debug`
```

好在，聪明的编译器又一次给出了提示:

```shell
= help: the trait `Debug` is not implemented for `Rectangle`
= note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
```

让我们实现 `Debug` 特征，Oh No，就是不想实现 `Display` 特征，才用的 `{:?}`，怎么又要实现 `Debug`，但是仔细看，提示中有一行： `add #[derive(Debug)] to Rectangle`， 哦？这不就是我们前文一直在使用的吗？

首先，Rust 默认不会为我们实现 `Debug`，为了实现，有两种方式可以选择：

- 手动实现
- 使用 `derive` 派生实现

后者简单的多，但是也有限制，具体见[附录 D](https://course.rs/appendix/derive.html)，这里我们就不再深入讲解，来看看该如何使用:

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {:?}", rect1);
}
```

此时运行程序，就不再有错误，输出如下:

```shell
$ cargo run
rect1 is Rectangle { width: 30, height: 50 }
```

这个输出格式看上去也不赖嘛，虽然未必是最好的。这种格式是 Rust 自动为我们提供的实现，看上基本就跟结构体的定义形式一样。

当结构体较大时，我们可能希望能够有更好的输出表现，此时可以使用 `{:#?}` 来替代 `{:?}`，输出如下:

```shell
rect1 is Rectangle {
    width: 30,
    height: 50,
}
```

此时结构体的输出跟我们创建时候的代码几乎一模一样了！当然，如果大家还是不满足，那最好还是自己实现 `Display` 特征，以向用户更美的展示你的私藏结构体。关于格式化输出的更多内容，我们强烈推荐看看这个[章节](https://course.rs/basic/formatted-output.html#debug-特征)。

还有一个简单的输出 debug 信息的方法，那就是使用 [`dbg!` 宏](https://doc.rust-lang.org/std/macro.dbg.html)，它会拿走表达式的所有权，然后打印出相应的文件名、行号等 debug 信息，当然还有我们需要的表达式的求值结果。**除此之外，它最终还会把表达式值的所有权返回！**

> `dbg!` 输出到标准错误输出 `stderr`，而 `println!` 输出到标准输出 `stdout`。

下面的例子中清晰的展示了 `dbg!` 如何在打印出信息的同时，还把表达式的值赋给了 `width`:

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&rect1);
}
```

最终的 debug 输出如下:

```shell
$ cargo run
[src/main.rs:10] 30 * scale = 60
[src/main.rs:14] &rect1 = Rectangle {
    width: 60,
    height: 50,
}
```

可以看到，我们想要的 debug 信息几乎都有了：代码所在的文件名、行号、表达式以及表达式的值，简直完美！

## 课后练习

> [Rust By Practice](https://practice-zh.course.rs/compound-types/struct.html)，支持代码在线编辑和运行，并提供详细的[习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/struct.md)。




================================================
FILE: src/basic/compound-type/tuple.md
================================================
[Binary file]


================================================
FILE: src/basic/crate-module/crate.md
================================================
# 包和 Package

当读者按照章节顺序读到本章时，意味着你已经几乎具备了参与真实项目开发的能力。但是真实项目远比我们之前的 `cargo new` 的默认目录结构要复杂，好在，Rust 为我们提供了强大的包管理工具：

- **项目(Package)**：可以用来构建、测试和分享包
- **工作空间(WorkSpace)**：对于大型项目，可以进一步将多个包联合在一起，组织成工作空间
- **包(Crate)**：一个由多个模块组成的树形结构，可以作为三方库进行分发，也可以生成可执行文件进行运行
- **模块(Module)**：可以一个文件多个模块，也可以一个文件一个模块，模块可以被认为是真实项目中的代码组织单元

## 定义

其实项目 `Package` 和包 `Crate` 很容易被搞混，甚至在很多书中，这两者都是不分的，但是由于官方对此做了明确的区分，因此我们会在本章节中试图（挣扎着）理清这个概念。

#### 包 Crate

对于 Rust 而言，包是一个独立的可编译单元，它编译后会生成一个可执行文件或者一个库。

一个包会将相关联的功能打包在一起，使得该功能可以很方便的在多个项目中分享。例如标准库中没有提供但是在三方库中提供的 `rand` 包，它提供了随机数生成的功能，我们只需要将该包通过 `use rand;` 引入到当前项目的作用域中，就可以在项目中使用 `rand` 的功能：`rand::XXX`。

同一个包中不能有同名的类型，但是在不同包中就可以。例如，虽然 `rand` 包中，有一个 `Rng` 特征，可是我们依然可以在自己的项目中定义一个 `Rng`，前者通过 `rand::Rng` 访问，后者通过 `Rng` 访问，对于编译器而言，这两者的边界非常清晰，不会存在引用歧义。

## 项目 Package

鉴于 Rust 团队标新立异的起名传统，以及包的名称被 `crate` 占用，库的名称被 `library` 占用，经过斟酌， 我们决定将 `Package` 翻译成项目，你也可以理解为工程、软件包。

由于 `Package` 就是一个项目，因此它包含有独立的 `Cargo.toml` 文件，以及因为功能性被组织在一起的一个或多个包。一个 `Package` 只能包含**一个**库(library)类型的包，但是可以包含**多个**二进制可执行类型的包。

#### 二进制 Package

让我们来创建一个二进制 `Package`：

```console
$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
```

这里，Cargo 为我们创建了一个名称是 `my-project` 的 `Package`，同时在其中创建了 `Cargo.toml` 文件，可以看一下该文件，里面并没有提到 `src/main.rs` 作为程序的入口，原因是 Cargo 有一个惯例：**`src/main.rs` 是二进制包的根文件，该二进制包的包名跟所属 `Package` 相同，在这里都是 `my-project`**，所有的代码执行都从该文件中的 `fn main()` 函数开始。

使用 `cargo run` 可以运行该项目，输出：`Hello, world!`。

#### 库 Package

再来创建一个库类型的 `Package`：

```console
$ cargo new my-lib --lib
     Created library `my-lib` package
$ ls my-lib
Cargo.toml
src
$ ls my-lib/src
lib.rs
```

首先，如果你试图运行 `my-lib`，会报错：

```console
$ cargo run
error: a bin target must be available for `cargo run`
```

原因是库类型的 `Package` 只能作为三方库被其它项目引用，而不能独立运行，只有之前的二进制 `Package` 才可以运行。

与 `src/main.rs` 一样，Cargo 知道，如果一个 `Package` 包含有 `src/lib.rs`，意味它包含有一个库类型的同名包 `my-lib`，该包的根文件是 `src/lib.rs`。

#### 易混淆的 Package 和包

看完上面，相信大家看出来为何 `Package` 和包容易被混淆了吧？因为你用 `cargo new` 创建的 `Package` 和它其中包含的包是同名的！

不过，只要你牢记 `Package` 是一个项目工程，而包只是一个编译单元，也就不会再混淆这两个概念：`src/main.rs` 和 `src/lib.rs` 都是编译单元，因此它们都是包。

#### 典型的 `Package` 结构

上面创建的 `Package` 中仅包含 `src/main.rs` 文件，意味着它仅包含一个二进制同名包 `my-project`。如果一个 `Package` 同时拥有 `src/main.rs` 和 `src/lib.rs`，那就意味着它包含两个包：库包和二进制包，这两个包名也都是 `my-project` —— 都与 `Package` 同名。

一个真实项目中典型的 `Package`，会包含多个二进制包，这些包文件被放在 `src/bin` 目录下，每一个文件都是独立的二进制包，同时也会包含一个库包，该包只能存在一个 `src/lib.rs`：

```css
.
├── Cargo.toml
├── Cargo.lock
├── src
│   ├── main.rs
│   ├── lib.rs
│   └── bin
│       └── main1.rs
│       └── main2.rs
├── tests
│   └── some_integration_tests.rs
├── benches
│   └── simple_bench.rs
└── examples
    └── simple_example.rs
```

- 唯一库包：`src/lib.rs`
- 默认二进制包：`src/main.rs`，编译后生成的可执行文件与 `Package` 同名
- 其余二进制包：`src/bin/main1.rs` 和 `src/bin/main2.rs`，它们会分别生成一个文件同名的二进制可执行文件
- 集成测试文件：`tests` 目录下
- 基准性能测试 `benchmark` 文件：`benches` 目录下
- 项目示例：`examples` 目录下

这种目录结构基本上是 Rust 的标准目录结构，在 `GitHub` 的大多数项目上，你都将看到它的身影。

理解了包的概念，我们再来看看构成包的基本单元：模块。

## 课后练习

> [Rust By Practice](https://practice-zh.course.rs/crate-module/crate.html)，支持代码在线编辑和运行，并提供详细的[习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/crate-module/crate.md)。


================================================
FILE: src/basic/crate-module/intro.md
================================================
[Binary file]


================================================
FILE: src/basic/crate-module/module.md
================================================
[Binary file]


================================================
FILE: src/basic/crate-module/use.md
================================================
# 使用 use 及受限可见性

如果代码中，通篇都是 `crate::front_of_house::hosting::add_to_waitlist` 这样的函数调用形式，我不知道有谁会喜欢，也许靠代码行数赚工资的人会很喜欢，但是强迫症肯定受不了，悲伤的是程序员大多都有强迫症。。。

因此我们需要一个办法来简化这种使用方式，在 Rust 中，可以使用 `use` 关键字把路径提前引入到当前作用域中，随后的调用就可以省略该路径，极大地简化了代码。

## 基本引入方式

在 Rust 中，引入模块中的项有两种方式：[绝对路径和相对路径](https://course.rs/basic/crate-module/module.html#用路径引用模块)，这两者在前面章节都有讲过，就不再赘述，先来看看使用绝对路径的引入方式。

#### 绝对路径引入模块

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
```

这里，我们使用 `use` 和绝对路径的方式，将 `hosting` 模块引入到当前作用域中，然后只需通过 `hosting::add_to_waitlist` 的方式，即可调用目标模块中的函数，相比 `crate::front_of_house::hosting::add_to_waitlist()` 的方式要简单的多，那么还能更简单吗？

#### 相对路径引入模块中的函数

在下面代码中，我们不仅要使用相对路径进行引入，而且与上面引入 `hosting` 模块不同，直接引入该模块中的 `add_to_waitlist` 函数：

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
    add_to_waitlist();
    add_to_waitlist();
}
```

很明显，三兄弟又变得更短了，不过，怎么觉得这句话怪怪的。。

#### 引入模块还是函数

从使用简洁性来说，引入函数自然是更甚一筹，但是在某些时候，引入模块会更好：

- 需要引入同一个模块的多个函数
- 作用域中存在同名函数

在以上两种情况中，使用 `use front_of_house::hosting;` 引入模块要比 `use front_of_house::hosting::add_to_waitlist;` 引入函数更好。

例如，如果想使用 `HashMap`，那么直接引入该结构体是比引入模块更好的选择，因为在 `collections` 模块中，我们只需要使用一个 `HashMap` 结构体：

```rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
```

其实严格来说，对于引用方式并没有需要遵守的惯例，主要还是取决于你的喜好，不过我们建议：**优先使用最细粒度（引入函数、结构体等）的引用方式，如果引起了某种麻烦（例如前面两种情况），再使用引入模块的方式**。

## 避免同名引用

根据上一章节的内容，我们只要保证同一个模块中不存在同名项就行，模块之间、包之间的同名，谁管得着谁啊，话虽如此，一起看看，如果遇到同名的情况该如何处理。

#### 模块::函数

```rust
use std::fmt;
use std::io;

fn function1() -> fmt::Result {
    // --snip--
}

fn function2() -> io::Result<()> {
    // --snip--
}
```

上面的例子给出了很好的解决方案，使用模块引入的方式，具体的 `Result` 通过 `模块::Result` 的方式进行调用。

可以看出，避免同名冲突的关键，就是使用**父模块的方式来调用**，除此之外，还可以给予引入的项起一个别名。

#### `as` 别名引用

对于同名冲突问题，还可以使用 `as` 关键字来解决，它可以赋予引入项一个全新的名称：

```rust
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
    // --snip--
}

fn function2() -> IoResult<()> {
    // --snip--
}
```

如上所示，首先通过 `use std::io::Result` 将 `Result` 引入到作用域，然后使用 `as` 给予它一个全新的名称 `IoResult`，这样就不会再产生冲突：

- `Result` 代表 `std::fmt::Result`
- `IoResult` 代表 `std:io::Result`

## 引入项再导出

当外部的模块项 `A` 被引入到当前模块中时，它的可见性自动被设置为私有的，如果你希望允许其它外部代码引用我们的模块项 `A`，那么可以对它进行再导出：

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
```

如上，使用 `pub use` 即可实现。这里 `use` 代表引入 `hosting` 模块到当前作用域，`pub` 表示将该引入的内容再度设置为可见。

当你希望将内部的实现细节隐藏起来或者按照某个目的组织代码时，可以使用 `pub use` 再导出，例如统一使用一个模块来提供对外的 API，那该模块就可以引入其它模块中的 API，然后进行再导出，最终对于用户来说，所有的 API 都是由一个模块统一提供的。

## 使用第三方包

之前我们一直在引入标准库模块或者自定义模块，现在来引入下第三方包中的模块，关于如何引入外部依赖，我们在 [Cargo 入门](https://course.rs/first-try/cargo.html#package-配置段落)中就有讲，这里直接给出操作步骤：

1. 修改 `Cargo.toml` 文件，在 `[dependencies]` 区域添加一行：`rand = "0.8.3"`
2. 此时，如果你用的是 `VSCode` 和 `rust-analyzer` 插件，该插件会自动拉取该库，你可能需要等它完成后，再进行下一步（VSCode 左下角有提示）

好了，此时，`rand` 包已经被我们添加到依赖中，下一步就是在代码中使用：

```rust
use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..101);
}
```

这里使用 `use` 引入了第三方包 `rand` 中的 `Rng` 特征，因为我们需要调用的 `gen_range` 方法定义在该特征中。

#### crates.io，lib.rs

Rust 社区已经为我们贡献了大量高质量的第三方包，你可以在 `crates.io` 或者 `lib.rs` 中检索和使用，从目前来说查找包更推荐 `lib.rs`，搜索功能更强大，内容展示也更加合理，但是下载依赖包还是得用`crates.io`。

你可以在网站上搜索 `rand` 包，看看它的文档使用方式是否和我们之前引入方式相一致：在网上找到想要的包，然后将你想要的包和版本信息写入到 `Cargo.toml` 中。

## 使用 `{}` 简化引入方式

对于以下一行一行的引入方式：

```rust
use std::collections::HashMap;
use std::collections::BTreeMap;
use std::collections::HashSet;

use std::cmp::Ordering;
use std::io;
```

可以使用 `{}` 来一起引入进来，在大型项目中，使用这种方式来引入，可以减少大量 `use` 的使用：

```rust
use std::collections::{HashMap,BTreeMap,HashSet};
use std::{cmp::Ordering, io};
```

对于下面的同时引入模块和模块中的项：

```rust
use std::io;
use std::io::Write;
```

可以使用 `{}` 的方式进行简化:

```rust
use std::io::{self, Write};
```

#### self

上面使用到了模块章节提到的 `self` 关键字，用来替代模块自身，结合上一节中的 `self`，可以得出它在模块中的两个用途：

- `use self::xxx`，表示加载当前模块中的 `xxx`。此时 `self` 可省略
- `use xxx::{self, yyy}`，表示，加载当前路径下模块 `xxx` 本身，以及模块 `xxx` 下的 `yyy`

## 使用 `*` 引入模块下的所有项

对于之前一行一行引入 `std::collections` 的方式，我们还可以使用

```rust
use std::collections::*;
```

以上这种方式来引入 `std::collections` 模块下的所有公共项，这些公共项自然包含了 `HashMap`，`HashSet` 等想手动引入的集合类型。

当使用 `*` 来引入的时候要格外小心，因为你很难知道到底哪些被引入到了当前作用域中，有哪些会和你自己程序中的名称相冲突：

```rust
use std::collections::*;

struct HashMap;
fn main() {
   let mut v =  HashMap::new();
   v.insert("a", 1);
}
```

以上代码中，`std::collections::HashMap` 被 `*` 引入到当前作用域，但是由于存在另一个同名的结构体，因此 `HashMap::new` 根本不存在，因为对于编译器来说，本地同名类型的优先级更高。

在实际项目中，这种引用方式往往用于快速写测试代码，它可以把所有东西一次性引入到 `tests` 模块中。

## 受限的可见性

在上一节中，我们学习了[可见性](https://course.rs/basic/crate-module/module.html#代码可见性)这个概念，这也是模块体系中最为核心的概念，控制了模块中哪些内容可以被外部看见，但是在实际使用时，光被外面看到还不行，我们还想控制哪些人能看，这就是 Rust 提供的受限可见性。

例如，在 Rust 中，包是一个模块树，我们可以通过 `pub(crate) item;` 这种方式来实现：`item` 虽然是对外可见的，但是只在当前包内可见，外部包无法引用到该 `item`。

所以，如果我们想要让某一项可以在整个包中都可以被使用，那么有两种办法：

- 在包根中定义一个非 `pub` 类型的 `X`(父模块的项对子模块都是可见的，因此包根中的项对模块树上的所有模块都可见)
- 在子模块中定义一个 `pub` 类型的 `Y`，同时通过 `use` 将其引入到包根

```rust
mod a {
    pub mod b {
        pub fn c() {
            println!("{:?}",crate::X);
        }

        #[derive(Debug)]
        pub struct Y;
    }
}

#[derive(Debug)]
struct X;
use a::b::Y;
fn d() {
    println!("{:?}",Y);
}
```

以上代码充分说明了之前两种办法的使用方式，但是有时我们会遇到这两种方法都不太好用的时候。例如希望对于某些特定的模块可见，但是对于其他模块又不可见：

```rust
// 目标：`a` 导出 `I`、`bar` and `foo`，其他的不导出
pub mod a {
    pub const I: i32 = 3;

    fn semisecret(x: i32) -> i32 {
        use self::b::c::J;
        x + J
    }

    pub fn bar(z: i32) -> i32 {
        semisecret(I) * z
    }
    pub fn foo(y: i32) -> i32 {
        semisecret(I) + y
    }

    mod b {
        mod c {
            const J: i32 = 4;
        }
    }
}
```

这段代码会报错，因为与父模块中的项对子模块可见相反，子模块中的项对父模块是不可见的。这里 `semisecret` 方法中，`a` -> `b` -> `c` 形成了父子模块链，那 `c` 中的 `J` 自然对 `a` 模块不可见。

如果使用之前的可见性方式，那么想保持 `J` 私有，同时让 `a` 继续使用 `semisecret` 函数的办法是将该函数移动到 `c` 模块中，然后用 `pub use` 将 `semisecret` 函数进行再导出：

```rust
pub mod a {
    pub const I: i32 = 3;

    use self::b::semisecret;

    pub fn bar(z: i32) -> i32 {
        semisecret(I) * z
    }
    pub fn foo(y: i32) -> i32 {
        semisecret(I) + y
    }

    mod b {
        pub use self::c::semisecret;
        mod c {
            const J: i32 = 4;
            pub fn semisecret(x: i32) -> i32 {
                x + J
            }
        }
    }
}
```

这段代码说实话问题不大，但是有些破坏了我们之前的逻辑，如果想保持代码逻辑，同时又只让 `J` 在 `a` 内可见该怎么办？

```rust
pub mod a {
    pub const I: i32 = 3;

    fn semisecret(x: i32) -> i32 {
        use self::b::c::J;
        x + J
    }

    pub fn bar(z: i32) -> i32 {
        semisecret(I) * z
    }
    pub fn foo(y: i32) -> i32 {
        semisecret(I) + y
    }

    mod b {
        pub(in crate::a) mod c {
            pub(in crate::a) const J: i32 = 4;
        }
    }
}
```

通过 `pub(in crate::a)` 的方式，我们指定了模块 `c` 和常量 `J` 的可见范围都只是 `a` 模块中，`a` 之外的模块是完全访问不到它们的。

#### 限制可见性语法

`pub(crate)` 或 `pub(in crate::a)` 就是限制可见性语法，前者是限制在整个包内可见，后者是通过绝对路径，限制在包内的某个模块内可见，总结一下：

- `pub` 意味着可见性无任何限制
- `pub(crate)` 表示在当前包可见
- `pub(self)` 在当前模块可见
- `pub(super)` 在父模块可见
- `pub(in <path>)` 表示在某个路径代表的模块中可见，其中 `path` 必须是父模块或者祖先模块

#### 一个综合例子

```rust
// 一个名为 `my_mod` 的模块
mod my_mod {
    // 模块中的项默认具有私有的可见性
    fn private_function() {
        println!("called `my_mod::private_function()`");
    }

    // 使用 `pub` 修饰语来改变默认可见性。
    pub fn function() {
        println!("called `my_mod::function()`");
    }

    // 在同一模块中，项可以访问其它项，即使它是私有的。
    pub fn indirect_access() {
        print!("called `my_mod::indirect_access()`, that\n> ");
        private_function();
    }

    // 模块也可以嵌套
    pub mod nested {
        pub fn function() {
            println!("called `my_mod::nested::function()`");
        }

        #[allow(dead_code)]
        fn private_function() {
            println!("called `my_mod::nested::private_function()`");
        }

        // 使用 `pub(in path)` 语法定义的函数只在给定的路径中可见。
        // `path` 必须是父模块（parent module）或祖先模块（ancestor module）
        pub(in crate::my_mod) fn public_function_in_my_mod() {
            print!("called `my_mod::nested::public_function_in_my_mod()`, that\n > ");
            public_function_in_nested()
        }

        // 使用 `pub(self)` 语法定义的函数则只在当前模块中可见。
        pub(self) fn public_function_in_nested() {
            println!("called `my_mod::nested::public_function_in_nested");
        }

        // 使用 `pub(super)` 语法定义的函数只在父模块中可见。
        pub(super) fn public_function_in_super_mod() {
            println!("called my_mod::nested::public_function_in_super_mod");
        }
    }

    pub fn call_public_function_in_my_mod() {
        print!("called `my_mod::call_public_funcion_in_my_mod()`, that\n> ");
        nested::public_function_in_my_mod();
        print!("> ");
        nested::public_function_in_super_mod();
    }

    // `pub(crate)` 使得函数只在当前包中可见
    pub(crate) fn public_function_in_crate() {
        println!("called `my_mod::public_function_in_crate()");
    }

    // 嵌套模块的可见性遵循相同的规则
    mod private_nested {
        #[allow(dead_code)]
        pub fn function() {
            println!("called `my_mod::private_nested::function()`");
        }
    }
}

fn function() {
    println!("called `function()`");
}

fn main() {
    // 模块机制消除了相同名字的项之间的歧义。
    function();
    my_mod::function();

    // 公有项，包括嵌套模块内的，都可以在父模块外部访问。
    my_mod::indirect_access();
    my_mod::nested::function();
    my_mod::call_public_function_in_my_mod();

    // pub(crate) 项可以在同一个 crate 中的任何地方访问
    my_mod::public_function_in_crate();

    // pub(in path) 项只能在指定的模块中访问
    // 报错！函数 `public_function_in_my_mod` 是私有的
    //my_mod::nested::public_function_in_my_mod();
    // 试一试 ^ 取消该行的注释

    // 模块的私有项不能直接访问，即便它是嵌套在公有模块内部的

    // 报错！`private_function` 是私有的
    //my_mod::private_function();
    // 试一试 ^ 取消此行注释

    // 报错！`private_function` 是私有的
    //my_mod::nested::private_function();
    // 试一试 ^ 取消此行的注释

    // 报错！ `private_nested` 是私有的
    //my_mod::private_nested::function();
    // 试一试 ^ 取消此行的注释
}
```

## 课后练习

> [Rust By Practice](https://practice-zh.course.rs/crate-module/use-pub.html)，支持代码在线编辑和运行，并提供详细的[习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/crate-module/use-pub.md)。


================================================
FILE: src/basic/match-pattern/all-patterns.md
================================================
# 全模式列表

在本书中我们已领略过许多不同类型模式的例子，本节的目标就是把这些模式语法都罗列出来，方便大家检索查阅（模式匹配在我们的开发中会经常用到）。

### 匹配字面值

```rust
let x = 1;

match x {
    1 => println!("one"),
    2 => println!("two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

这段代码会打印 `one` 因为 `x` 的值是 1，如果希望代码获得特定的具体值，那么这种语法很有用。

### 匹配命名变量

在 [match](https://course.rs/basic/match-pattern/match-if-let.html#%E5%8F%98%E9%87%8F%E9%81%AE%E8%94%BD) 中，我们有讲过变量遮蔽的问题，这个在**匹配命名变量**时会遇到：

```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(y) => println!("Matched, y = {:?}", y),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {:?}", x, y);
}
```

让我们看看当 `match` 语句运行的时候发生了什么。第一个匹配分支的模式并不匹配 `x` 中定义的值，所以代码继续执行。

第二个匹配分支中的模式引入了一个新变量 `y`，它会匹配任何 `Some` 中的值。因为这里的 `y` 在 `match` 表达式的作用域中，而不是之前 `main` 作用域中，所以这是一个新变量，不是开头声明为值 10 的那个 `y`。这个新的 `y` 绑定会匹配任何 `Some` 中的值，在这里是 `x` 中的值。因此这个 `y` 绑定了 `x` 中 `Some` 内部的值。这个值是 5，所以这个分支的表达式将会执行并打印出 `Matched，y = 5`。

如果 `x` 的值是 `None` 而不是 `Some(5)`，头两个分支的模式不会匹配，所以会匹配模式 `_`。这个分支的模式中没有引入变量 `x`，所以此时表达式中的 `x` 会是外部没有被遮蔽的 `x`，也就是 `None`。

一旦 `match` 表达式执行完毕，其作用域也就结束了，同理内部 `y` 的作用域也结束了。最后的 `println!` 会打印 `at the end: x = Some(5), y = 10`。

如果你不想引入变量遮蔽，可以使用另一个变量名而非 `y`，或者使用匹配守卫(match guard)的方式，稍后在[匹配守卫提供的额外条件](#匹配守卫提供的额外条件)中会讲解。

### 单分支多模式

在 `match` 表达式中，可以使用 `|` 语法匹配多个模式，它代表 **或**的意思。例如，如下代码将 `x` 的值与匹配分支相比较，第一个分支有 **或** 选项，意味着如果 `x` 的值匹配此分支的任何一个模式，它就会运行：

```rust
let x = 1;

match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

上面的代码会打印 `one or two`。

### 通过序列 `..=` 匹配值的范围

在[数值类型](https://course.rs/basic/base-type/numbers.html#序列range)中我们有讲到一个序列语法，该语法不仅可以用于循环中，还能用于匹配模式。

`..=` 语法允许你匹配一个闭区间序列内的值。在如下代码中，当模式匹配任何在此序列内的值时，该分支会执行：

```rust
let x = 5;

match x {
    1..=5 => println!("one through five"),
    _ => println!("something else"),
}
```

如果 `x` 是 1、2、3、4 或 5，第一个分支就会匹配。这相比使用 `|` 运算符表达相同的意思更为方便；相比 `1..=5`，使用 `|` 则不得不指定 `1 | 2 | 3 | 4 | 5` 这五个值，而使用 `..=` 指定序列就简短的多，比如希望匹配从 1 到 1000 的数字的时候！

序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。

如下是一个使用字符类型序列的例子：

```rust
let x = 'c';

match x {
    'a'..='j' => println!("early ASCII letter"),
    'k'..='z' => println!("late ASCII letter"),
    _ => println!("something else"),
}
```

Rust 知道 `'c'` 位于第一个模式的序列内，所以会打印出 `early ASCII letter`。

### 解构并分解值

也可以使用模式来解构结构体、枚举、元组、数组和引用。

#### 解构结构体

下面代码展示了如何用 `let` 解构一个带有两个字段 `x` 和 `y` 的结构体 `Point`：

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
```

这段代码创建了变量 `a` 和 `b` 来匹配结构体 `p` 中的 `x` 和 `y` 字段，这个例子展示了**模式中的变量名不必与结构体中的字段名一致**。不过通常希望变量名与字段名一致以便于理解变量来自于哪些字段。

因为变量名匹配字段名是常见的，同时因为 `let Point { x: x, y: y } = p;` 中 `x` 和 `y` 重复了，所以对于匹配结构体字段的模式存在简写：只需列出结构体字段的名称，则模式创建的变量会有相同的名称。下例与上例有着相同行为的代码，不过 `let` 模式创建的变量为 `x` 和 `y` 而不是 `a` 和 `b`：

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
```

这段代码创建了变量 `x` 和 `y`，与结构体 `p` 中的 `x` 和 `y` 字段相匹配。其结果是变量 `x` 和 `y` 包含结构体 `p` 中的值。

也可以使用字面值作为结构体模式的一部分进行解构，而不是为所有的字段创建变量。这允许我们测试一些字段为特定值的同时创建其他字段的变量。

下文展示了固定某个字段的匹配方式：

```rust
# struct Point {
#     x: i32,
#     y: i32,
# }
#
fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } => println!("On the x axis at {}", x),
        Point { x: 0, y } => println!("On the y axis at {}", y),
        Point { x, y } => println!("On neither axis: ({}, {})", x, y),
    }
}
```

首先是 `match` 第一个分支，指定匹配 `y` 为 `0` 的 `Point`；
然后第二个分支在第一个分支之后，匹配 `y` 不为 `0`，`x` 为 `0` 的 `Point`;
最后一个分支匹配 `x` 不为 `0`，`y` 也不为 `0` 的 `Point`。

在这个例子中，值 `p` 因为其 `x` 包含 0 而匹配第二个分支，因此会打印出 `On the y axis at 7`。

#### 解构枚举

下面代码以 `Message` 枚举为例，编写一个 `match` 使用模式解构每一个内部值：

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit => {
            println!("The Quit variant has no data to destructure.")
        }
        Message::Move { x, y } => {
            println!(
                "Move in the x direction {} and in the y direction {}",
                x,
                y
            );
        }
        Message::Write(text) => println!("Text message: {}", text),
        Message::ChangeColor(r, g, b) => {
            println!(
                "Change the color to red {}, green {}, and blue {}",
                r,
                g,
                b
            )
        }
    }
}
```

这里老生常谈一句话，模式匹配一样要类型相同，因此匹配 `Message::Move{1,2}` 这样的枚举值，就必须要用 `Message::Move{x,y}` 这样的同类型模式才行。

这段代码会打印出 `Change the color to red 0, green 160, and blue 255`。尝试改变 `msg` 的值来观察其他分支代码的运行。

对于像 `Message::Quit` 这样没有任何数据的枚举成员，不能进一步解构其值。只能匹配其字面值 `Message::Quit`，因此模式中没有任何变量。

对于另外两个枚举成员，就用相同类型的模式去匹配出对应的值即可。

#### 解构嵌套的结构体和枚举

目前为止，所有的例子都只匹配了深度为一级的结构体或枚举。 `match` 也可以匹配嵌套的项！

例如使用下面的代码来同时支持 RGB 和 HSV 色彩模式：

```rust
enum Color {
   Rgb(i32, i32, i32),
   Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => {
            println!(
                "Change the color to red {}, green {}, and blue {}",
                r,
                g,
                b
            )
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) => {
            println!(
                "Change the color to hue {}, saturation {}, and value {}",
                h,
                s,
                v
            )
        }
        _ => ()
    }
}
```

`match` 第一个分支的模式匹配一个 `Message::ChangeColor` 枚举成员，该枚举成员又包含了一个 `Color::Rgb` 的枚举成员，最终绑定了 3 个内部的 `i32` 值。第二个，就交给亲爱的读者来思考完成。

#### 解构结构体和元组

我们甚至可以用复杂的方式来混合、匹配和嵌套解构模式。如下是一个复杂结构体的例子，其中结构体和元组嵌套在元组中，并将所有的原始类型解构出来：

```rust
struct Point {
     x: i32,
     y: i32,
 }

let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
```

这种将复杂类型分解匹配的方式，可以让我们单独得到感兴趣的某个值。

#### 解构数组

对于数组，我们可以用类似元组的方式解构，分为两种情况：

定长数组
```rust
let arr: [u16; 2] = [114, 514];
let [x, y] = arr;

assert_eq!(x, 114);
assert_eq!(y, 514);
```

不定长数组
```rust
let arr: &[u16] = &[114, 514];

if let [x, ..] = arr {
    assert_eq!(x, &114);
}

if let &[.., y] = arr {
    assert_eq!(y, 514);
}

let arr: &[u16] = &[];

assert!(matches!(arr, [..]));
assert!(!matches!(arr, [x, ..]));
```

### 忽略模式中的值

有时忽略模式中的一些值是很有用的，比如在 `match` 中的最后一个分支使用 `_` 模式匹配所有剩余的值。 你也可以在另一个模式中使用 `_` 模式，使用一个以下划线开始的名称，或者使用 `..` 忽略所剩部分的值。

#### 使用 `_` 忽略整个值

虽然 `_` 模式作为 `match` 表达式最后的分支特别有用，但是它的作用还不限于此。例如可以将其用于函数参数中：

```rust
fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {}", y);
}

fn main() {
    foo(3, 4);
}
```

这段代码会完全忽略作为第一个参数传递的值 `3`，并会打印出 `This code only uses the y parameter: 4`。

大部分情况当你不再需要特定函数参数时，最好修改签名不再包含无用的参数。在一些情况下忽略函数参数会变得特别有用，比如实现特征时，当你需要特定类型签名但是函数实现并不需要某个参数时。此时编译器就**不会警告说存在未使用的函数参数**，就跟使用命名参数一样。

#### 使用嵌套的 `_` 忽略部分值

可以在一个模式内部使用 `_` 忽略部分值：

```rust
let mut setting_value = Some(5);
let new_setting_value = Some(10);

match (setting_value, new_setting_value) {
    (Some(_), Some(_)) => {
        println!("Can't overwrite an existing customized value");
    }
    _ => {
        setting_value = new_setting_value;
    }
}

println!("setting is {:?}", setting_value);
```

这段代码会打印出 `Can't overwrite an existing customized value` 接着是 `setting is Some(5)`。

第一个匹配分支，我们不关心里面的值，只关心元组中两个元素的类型，因此对于 `Some` 中的值，直接进行忽略。
剩下的形如 `(Some(_),None)`，`(None, Some(_))`, `(None,None)` 形式，都由第二个分支 `_` 进行分配。

还可以在一个模式中的多处使用下划线来忽略特定值，如下所示，这里忽略了一个五元元组中的第二和第四个值：

```rust
let numbers = (2, 4, 8, 16, 32);

match numbers {
    (first, _, third, _, fifth) => {
        println!("Some numbers: {}, {}, {}", first, third, fifth)
    },
}
```

老生常谈：模式匹配一定要类型相同，因此匹配 `numbers` 元组的模式，也必须有五个值（元组中元素的数量也属于元组类型的一部分）。

这会打印出 `Some numbers: 2, 8, 32`, 值 4 和 16 会被忽略。

#### 使用下划线开头忽略未使用的变量

如果你创建了一个变量却不在任何地方使用它，Rust 通常会给你一个警告，因为这可能会是个 BUG。但是有时创建一个不会被使用的变量是有用的，比如你正在设计原型或刚刚开始一个项目。这时你希望告诉 Rust 不要警告未使用的变量，为此可以用下划线作为变量名的开头：

```rust
fn main() {
    let _x = 5;
    let y = 10;
}
```

这里得到了警告说未使用变量 `y`，至于 `x` 则没有警告。

注意, 只使用 `_` 和使用以下划线开头的名称有些微妙的不同：比如 **`_x` 仍会将值绑定到变量，而 `_` 则完全不会绑定**。

```rust
let s = Some(String::from("Hello!"));

if let Some(_s) = s {
    println!("found a string");
}

println!("{:?}", s);
```

`s` 是一个拥有所有权的动态字符串，在上面代码中，我们会得到一个错误，因为 `s` 的值会被转移给 `_s`，在 `println!` 中再次使用 `s` 会报错：

```console
error[E0382]: borrow of partially moved value: `s`
 --> src/main.rs:8:22
  |
4 |     if let Some(_s) = s {
  |                 -- value partially moved here
...
8 |     println!("{:?}", s);
  |                      ^ value borrowed here after partial move
```

只使用下划线本身，则并不会绑定值，因为 `s` 没有被移动进 `_`：

```rust
let s = Some(String::from("Hello!"));

if let Some(_) = s {
    println!("found a string");
}

println!("{:?}", s);
```

#### 用 `..` 忽略剩余值

对于有多个部分的值，可以使用 `..` 语法来只使用部分值而忽略其它值，这样也不用再为每一个被忽略的值都单独列出下划线。`..` 模式会忽略模式中剩余的任何没有显式匹配的值部分。

```rust
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } => println!("x is {}", x),
}
```

这里列出了 `x` 值，接着使用了 `..` 模式来忽略其它字段，这样的写法要比一一列出其它字段，然后用 `_` 忽略简洁的多。

还可以用 `..` 来忽略元组中间的某些值：

```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) => {
            println!("Some numbers: {}, {}", first, last);
        },
    }
}
```

这里用 `first` 和 `last` 来匹配第一个和最后一个值。`..` 将匹配并忽略中间的所有值。

然而使用 `..` 必须是无歧义的。如果期望匹配和忽略的值是不明确的，Rust 会报错。下面代码展示了一个带有歧义的 `..` 例子，因此不能编译：

```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) => {
            println!("Some numbers: {}", second)
        },
    }
}
```

如果编译上面的例子，会得到下面的错误：

```text
error: `..` can only be used once per tuple pattern // 每个元组模式只能使用一个 `..`
 --> src/main.rs:5:22
  |
5 |         (.., second, ..) => {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here // 上一次使用在这里

error: could not compile `world_hello` due to previous error              ^^
```

Rust 无法判断，`second` 应该匹配 `numbers` 中的第几个元素，因此这里使用两个 `..` 模式，是有很大歧义的！

### 匹配守卫提供的额外条件

**匹配守卫**（_match guard_）是一个位于 `match` 分支模式之后的额外 `if` 条件，它能为分支模式提供更进一步的匹配条件。

这个条件可以使用模式中创建的变量：

```rust
let num = Some(4);

match num {
    Some(x) if x < 5 => println!("less than five: {}", x),
    Some(x) => println!("{}", x),
    None => (),
}
```

这个例子会打印出 `less than five: 4`。当 `num` 与模式中第一个分支匹配时，`Some(4)` 可以与 `Some(x)` 匹配，接着匹配守卫检查 `x` 值是否小于 5，因为 4 小于 5，所以第一个分支被选择。

相反如果 `num` 为 `Some(10)`，因为 10 不小于 5 ，所以第一个分支的匹配守卫为假。接着 Rust 会前往第二个分支，因为这里没有匹配守卫所以会匹配任何 `Some` 成员。

模式中无法提供类如 `if x < 5` 的表达能力，我们可以通过匹配守卫的方式来实现。

在[之前](#匹配命名变量)，我们提到可以使用匹配守卫来解决模式中变量覆盖的问题，那里 `match` 表达式的模式中新建了一个变量而不是使用 `match` 之外的同名变量。内部变量覆盖了外部变量，意味着此时不能够使用外部变量的值，下面代码展示了如何使用匹配守卫修复这个问题。

```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(n) if n == y => println!("Matched, n = {}", n),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {}", x, y);
}
```

上面代码会打印 `Default case, x = Some(5)`。其中，第二个匹配分支由于没有新建局部变量 `y`，因此在匹配守卫中使用的是外部的 `y`。

匹配守卫 `if n == y` 并不是一个模式所以没有引入新变量。这个 `y` **正是** 外部的 `y` 而不是新的覆盖变量 `y`，这样就可以通过比较 `n` 和 `y` 来表达寻找一个与外部 `y` 相同的值的概念了。

也可以在匹配守卫中使用 **或** 运算符 `|` 来指定多个模式，**同时匹配守卫的条件会作用于所有的模式**。下面代码展示了匹配守卫与 `|` 的优先级。这个例子中看起来好像 `if y` 只作用于 `6`，但实际上匹配守卫 `if y` 作用于 `4`、`5` **和** `6` ，在满足 `x` 属于 `4 | 5 | 6` 后才会判断 `y` 是否为 `true`：

```rust
let x = 4;
let y = false;

match x {
    4 | 5 | 6 if y => println!("yes"),
    _ => println!("no"),
}
```

这个匹配条件表明此分支只匹配 `x` 值为 `4`、`5` 或 `6` **同时** `y` 为 `true` 的情况。

虽然在第一个分支中，`x` 匹配了模式 `4` ，但是对于匹配守卫 `if y` 来说，因为 `y` 是 `false`，因此该守卫条件的值永远是 `false`，也意味着第一个分支永远无法被匹配。

下面的文字图解释了匹配守卫作用于多个模式时的优先级规则，第一张是正确的：

```text
(4 | 5 | 6) if y => ...
```

而第二张图是错误的

```text
4 | 5 | (6 if y) => ...
```

可以通过运行代码时的情况看出这一点：如果匹配守卫只作用于由 `|` 运算符指定的值列表的最后一个值，这个分支就会匹配且程序会打印出 `yes`。

## @绑定

`@`（读作 at）运算符允许为一个字段绑定另外一个变量。下面例子中，我们希望测试 `Message::Hello` 的 `id` 字段是否位于 `3..=7` 范围内，同时也希望能将其值绑定到 `id_variable` 变量中以便此分支中相关的代码可以使用它。我们可以将 `id_variable` 命名为 `id`，与字段同名，不过出于示例的目的这里选择了不同的名称。

```rust
enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello { id: id_variable @ 3..=7 } => {
        println!("Found an id in range: {}", id_variable)
    },
    Message::Hello { id: 10..=12 } => {
        println!("Found an id in another range")
    },
    Message::Hello { id } => {
        println!("Found some other id: {}", id)
    },
}
```

上例会打印出 `Found an id in range: 5`。通过在 `3..=7` 之前指定 `id_variable @`，我们捕获了任何匹配此范围的值并同时将该值绑定到变量 `id_variable` 上。

第二个分支只在模式中指定了一个范围，`id` 字段的值可以是 `10、11 或 12`，不过这个模式的代码并不知情也不能使用 `id` 字段中的值，因为没有将 `id` 值保存进一个变量。

最后一个分支指定了一个没有范围的变量，此时确实拥有可以用于分支代码的变量 `id`，因为这里使用了结构体字段简写语法。不过此分支中没有像头两个分支那样对 `id` 字段的值进行测试：任何值都会匹配此分支。

当你既想要限定分支范围，又想要使用分支的变量时，就可以用 `@` 来绑定到一个新的变量上，实现想要的功能。

#### @前绑定后解构(Rust 1.56 新增)

使用 `@` 还可以在绑定新变量的同时，对目标进行解构：

```rust
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    // 绑定新变量 `p`，同时对 `Point` 进行解构
    let p @ Point {x: px, y: py } = Point {x: 10, y: 23};
    println!("x: {}, y: {}", px, py);
    println!("{:?}", p);


    let point = Point {x: 10, y: 5};
    if let p @ Point {x: 10, y} = point {
        println!("x is 10 and y is {} in {:?}", y, p);
    } else {
        println!("x was not 10 :(");
    }
}
```

#### @新特性(Rust 1.53 新增)

考虑下面一段代码:

```rust
fn main() {
    match 1 {
        num @ 1 | 2 => {
            println!("{}", num);
        }
        _ => {}
    }
}
```

编译不通过，是因为 `num` 没有绑定到所有的模式上，只绑定了模式 `1`，你可能会试图通过这个方式来解决：

```rust
num @ (1 | 2)
```

但是，如果你用的是 Rust 1.53 之前的版本，那这种写法会报错，因为编译器不支持。

至此，模式匹配的内容已经全部完结，复杂但是详尽，想要一次性全部记住属实不易，因此读者可以先留一个印象，等未来需要时，再来翻阅寻找具体的模式实现方式。


## 课后练习

> [Rust By Practice](https://practice-zh.course.rs/pattern-match/patterns.html)，支持代码在线编辑和运行，并提供详细的[习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/pattern-match/patterns.md)。



================================================
FILE: src/basic/match-pattern/intro.md
================================================
# 模式匹配

模式匹配，这个词，对于非函数语言编程来说，真的还蛮少听到，因为它经常出现在函数式编程里，用于为复杂的类型系统提供一个轻松的解构能力。

曾记否？在枚举和流程控制那章，我们遗留了两个问题，都是关于 `match` 的，第一个是如何对 `Option` 枚举进行进一步处理，另外一个是如何用 `match` 来替代 `else if` 这种丑陋的多重分支使用方式。那么让我们先一起来揭开 `match` 的神秘面纱。



================================================
FILE: src/basic/match-pattern/match-if-let.md
================================================
# match 和 if let

在 Rust 中，模式匹配最常用的就是 `match` 和 `if let`，本章节将对两者及相关的概念进行详尽介绍。

先来看一个关于 `match` 的简单例子：

```rust
enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    let dire = Direction::South;
    match dire {
        Direction::East => println!("East"),
        Direction::North | Direction::South => {
            println!("South or North");
        },
        _ => println!("West"),
    };
}
```

这里我们想去匹配 `dire` 对应的枚举类型，因此在 `match` 中用三个匹配分支来完全覆盖枚举变量 `Direction` 的所有成员类型，有以下几点值得注意：

- `match` 的匹配必须要穷举出所有可能，因此这里用 `_` 来代表未列出的所有可能性
- `match` 的每一个分支都必须是一个表达式，且所有分支的表达式最终返回值的类型必须相同
- **X | Y**，类似逻辑运算符 `或`，代表该分支可以匹配 `X` 也可以匹配 `Y`，只要满足一个即可

其实 `match` 跟其他语言中的 `switch` 非常像，`_` 类似于 `switch` 中的 `default`。

## `match` 匹配

首先来看看 `match` 的通用形式：

```rust
match target {
    模式1 => 表达式1,
    模式2 => {
        语句1;
        语句2;
        表达式2
    },
    _ => 表达式3
}
```

该形式清晰的说明了何为模式，何为模式匹配：将模式与 `target` 进行匹配，即为模式匹配，而模式匹配不仅仅局限于 `match`，后面我们会详细阐述。

`match` 允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行对应的代码，下面让我们来一一详解，先看一个例子：

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny =>  {
            println!("Lucky penny!");
            1
        },
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

`value_in_cents` 函数根据匹配到的硬币，返回对应的美分数值。`match` 后紧跟着的是一个表达式，跟 `if` 很像，但是 `if` 后的表达式必须是一个布尔值，而 `match` 后的表达式返回值可以是任意类型，只要能跟后面的分支中的模式匹配起来即可，这里的 `coin` 是枚举 `Coin` 类型。

接下来是 `match` 的分支。一个分支有两个部分：**一个模式和针对该模式的处理代码**。第一个分支的模式是 `Coin::Penny`，其后的 `=>` 运算符将模式和将要运行的代码分开。这里的代码就仅仅是表达式 `1`，不同分支之间使用逗号分隔。

当 `match` 表达式执行时，它将目标值 `coin` 按顺序依次与每一个分支的模式相比较，如果模式匹配了这个值，那么模式之后的代码将被执行。如果模式并不匹配这个值，将继续执行下一个分支。

每个分支相关联的代码是一个表达式，而表达式的结果值将作为整个 `match` 表达式的返回值。如果分支有多行代码，那么需要用 `{}` 包裹，同时最后一行代码需要是一个表达式。

#### 使用 `match` 表达式赋值

还有一点很重要，`match` 本身也是一个表达式，因此可以用它来赋值：

```rust
enum IpAddr {
   Ipv4,
   Ipv6
}

fn main() {
    let ip1 = IpAddr::Ipv6;
    let ip_str = match ip1 {
        IpAddr::Ipv4 => "127.0.0.1",
        _ => "::1",
    };

    println!("{}", ip_str);
}
```

因为这里匹配到 `_` 分支，所以将 `"::1"` 赋值给了 `ip_str`。

#### 模式绑定

模式匹配的另外一个重要功能是从模式中取出绑定的值，例如：

```rust
#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState), // 25美分硬币
}
```

其中 `Coin::Quarter` 成员还存放了一个值：美国的某个州（因为在 1999 年到 2008 年间，美国在 25 美分(Quarter)硬币的背后为 50 个州印刷了不同的标记，其它硬币都没有这样的设计）。

接下来，我们希望在模式匹配中，获取到 25 美分硬币上刻印的州的名称：

```rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        },
    }
}
```

上面代码中，在匹配 `Coin::Quarter(state)` 模式时，我们把它内部存储的值绑定到了 `state` 变量上，因此 `state` 变量就是对应的 `UsState` 枚举类型。

例如有一个印了阿拉斯加州标记的 25 分硬币：`Coin::Quarter(UsState::Alaska)`，它在匹配时，`state` 变量将被绑定 `UsState::Alaska` 的枚举值。

再来看一个更复杂的例子：

```rust
enum Action {
    Say(String),
    MoveTo(i32, i32),
    ChangeColorRGB(u16, u16, u16),
}

fn main() {
    let actions = [
        Action::Say("Hello Rust".to_string()),
        Action::MoveTo(1,2),
        Action::ChangeColorRGB(255,255,0),
    ];
    for action in actions {
        match action {
            Action::Say(s) => {
                println!("{}", s);
            },
            Action::MoveTo(x, y) => {
                println!("point from (0, 0) move to ({}, {})", x, y);
            },
            Action::ChangeColorRGB(r, g, _) => {
                println!("change color into '(r:{}, g:{}, b:0)', 'b' has been ignored",
                    r, g,
                );
            }
        }
    }
}
```

运行后输出：

```console
$ cargo run
   Compiling world_hello v0.1.0 (/Users/sunfei/development/rust/world_hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.16s
     Running `target/debug/world_hello`
Hello Rust
point from (0, 0) move to (1, 2)
change color into '(r:255, g:255, b:0)', 'b' has been ignored
```

#### 穷尽匹配

在文章的开头，我们简单总结过 `match` 的匹配必须穷尽所有情况，下面来举例说明，例如：

```rust
enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    let dire = Direction::South;
    match dire {
        Direction::East => println!("East"),
        Direction::North | Direction::South => {
            println!("South or North");
        },
    };
}
```

我们没有处理 `Direction::West` 的情况，因此会报错：

```console
error[E0004]: non-exhaustive patterns: `West` not covered // 非穷尽匹配，`West` 没有被覆盖
  --> src/main.rs:10:11
   |
1  | / enum Direction {
2  | |     East,
3  | |     West,
   | |     ---- not covered
4  | |     North,
5  | |     South,
6  | | }
   | |_- `Direction` defined here
...
10 |       match dire {
   |             ^^^^ pattern `West` not covered // 模式 `West` 没有被覆盖
   |
   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
   = note: the matched value is of type `Direction`
```

不禁想感叹，Rust 的编译器**真强大**，忍不住想爆粗口了，sorry，如果你以后进一步深入使用 Rust 也会像我这样感叹的。Rust 编译器清晰地知道 `match` 中有哪些分支没有被覆盖，这种行为能强制我们处理所有的可能性，有效避免传说中价值**十亿美金**的 `null` 陷阱。

#### `_` 通配符

当我们不想在匹配时列出所有值的时候，可以使用 Rust 提供的一个特殊**模式**，例如，`u8` 可以拥有 0 到 255 的有效的值，但是我们只关心 `1、3、5 和 7` 这几个值，不想列出其它的 `0、2、4、6、8、9 一直到 255` 的值。那么, 我们不必一个一个列出所有值, 因为可以使用特殊的模式 `_` 替代：

```rust
let some_u8_value = 0u8;
match some_u8_value {
    1 => println!("one"),
    3 => println!("three"),
    5 => println!("five"),
    7 => println!("seven"),
    _ => (),
}
```

通过将 `_` 其放置于其他分支后，`_` 将会匹配所有遗漏的值。`()` 表示返回**单元类型**与所有分支返回值的类型相同，所以当匹配到 `_` 后，什么也不会发生。

除了`_`通配符，用一个变量来承载其他情况也是可以的。

```rust
#[derive(Debug)]
enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    let dire = Direction::South;
    match dire {
        Direction::East => println!("East"),
        other => println!("other direction: {:?}", other),
    };
}
```

然而，在某些场景下，我们其实只关心**某一个值是否存在**，此时 `match` 就显得过于啰嗦。

## `if let` 匹配

有时会遇到只有一个模式的值需要被处理，其它值直接忽略的场景，如果用 `match` 来处理就要写成下面这样：

```rust
    let v = Some(3u8);
    match v {
        Some(3) => println!("three"),
        _ => (),
    }
```

我们只想要对 `Some(3)` 模式进行匹配, 不想处理任何其他 `Some<u8>` 值或 `None` 值。但是为了满足 `match` 表达式（穷尽性）的要求，写代码时必须在处理完这唯一的成员后加上 `_ => ()`，这样会增加不少无用的代码。

俗话说“杀鸡焉用牛刀”，我们完全可以用 `if let` 的方式来实现：

```rust
if let Some(3) = v {
    println!("three");
}
```

这两种匹配对于新手来说，可能有些难以抉择，但是只要记住一点就好：**当你只要匹配一个条件，且忽略其他条件时就用 `if let` ，否则都用 `match`**。

## matches!宏

Rust 标准库中提供了一个非常实用的宏：`matches!`，它可以将一个表达式跟模式进行匹配，然后返回匹配的结果 `true` or `false`。

例如，有一个动态数组，里面存有以下枚举：

```rust
enum MyEnum {
    Foo,
    Bar
}

fn main() {
    let v = vec![MyEnum::Foo,MyEnum::Bar,MyEnum::Foo];
}
```

现在如果想对 `v` 进行过滤，只保留类型是 `MyEnum::Foo` 的元素，你可能想这么写：

```rust
v.iter().filter(|x| x == MyEnum::Foo);
```

但是，实际上这行代码会报错，因为你无法将 `x` 直接跟一个枚举成员进行比较。好在，你可以使用 `match` 来完成，但是会导致代码更为啰嗦，是否有更简洁的方式？答案是使用 `matches!`：

```rust
v.iter().filter(|x| matches!(x, MyEnum::Foo));
```

很简单也很简洁，再来看看更多的例子：

```rust
let foo = 'f';
assert!(matches!(foo, 'A'..='Z' | 'a'..='z'));

let bar = Some(4);
assert!(matches!(bar, Some(x) if x > 2));
```

## 变量遮蔽

无论是 `match` 还是 `if let`，这里都是一个新的代码块，而且这里的绑定相当于新变量，如果你使用同名变量，会发生变量遮蔽：

```rust
fn main() {
   let age = Some(30);
   println!("在匹配前，age是{:?}",age);
   if let Some(age) = age {
       println!("匹配出来的age是{}",age);
   }

   println!("在匹配后，age是{:?}",age);
}
```

`cargo run `运行后输出如下：

```console
在匹配前，age是Some(30)
匹配出来的age是30
在匹配后，age是Some(30)
```

可以看出在 `if let` 中，`=` 右边 `Some(i32)` 类型的 `age` 被左边 `i32` 类型的新 `age` 遮蔽了，该遮蔽一直持续到 `if let` 语句块的结束。因此第三个 `println!` 输出的 `age` 依然是 `Some(i32)` 类型。

对于 `match` 类型也是如此:

```rust
fn main() {
   let age = Some(30);
   println!("在匹配前，age是{:?}",age);
   match age {
       Some(age) =>  println!("匹配出来的age是{}",age),
       _ => ()
   }
   println!("在匹配后，age是{:?}",age);
}
```

需要注意的是，**`match` 中的变量遮蔽其实不是那么的容易看出**，因此要小心！其实这里最好不要使用同名，避免难以理解，如下。

```rust
fn main() {
   let age = Some(30);
   println!("在匹配前，age是{:?}", age);
   match age {
       Some(x) =>  println!("匹配出来的age是{}", x),
       _ => ()
   }
   println!("在匹配后，age是{:?}", age);
}
```


## 课后练习

> [Rust By Practice](https://practice-zh.course.rs/pattern-match/match-iflet.html)，支持代码在线编辑和运行，并提供详细的[习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/pattern-match/match.md)。



================================================
FILE: src/basic/match-pattern/option.md
================================================
# 解构 Option

在枚举那章，提到过 `Option` 枚举，它用来解决 Rust 中变量是否有值的问题，定义如下：

```rust
enum Option<T> {
    None,
    Some(T),
}
```

简单解释就是：**一个变量要么有值：`Some(T)`, 要么为空：`None`**。

那么现在的问题就是该如何去使用这个 `Option` 枚举类型，根据我们上一节的经验，可以通过 `match` 来实现。

> 因为 `Option`，`Some`，`None` 都包含在 `prelude` 中，因此你可以直接通过名称来使用它们，而无需以 `Option::Some` 这种形式去使用，总之，千万不要因为调用路径变短了，就忘记 `Some` 和 `None` 也是 `Option` 底下的枚举成员！

## 匹配 `Option<T>`

使用 `Option<T>`，是为了从 `Some` 中取出其内部的 `T` 值以及处理没有值的情况，为了演示这一点，下面一起来编写一个函数，它获取一个 `Option<i32>`，如果其中含有一个值，将其加一；如果其中没有值，则函数返回 `None` 值：

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```

`plus_one` 接受一个 `Option<i32>` 类型的参数，同时返回一个 `Option<i32>` 类型的值（这种形式的函数在标准库内随处所见），在该函数的内部处理中，如果传入的是一个 `None` ，则返回一个 `None` 且不做任何处理；如果传入的是一个 `Some(i32)`，则通过模式绑定，把其中的值绑定到变量 `i` 上，然后返回 `i+1` 的值，同时用 `Some` 进行包裹。

为了进一步说明，假设 `plus_one` 函数接受的参数值 x 是 `Some(5)`，来看看具体的分支匹配情况：

#### 传入参数 `Some(5)`

```rust,ignore
None => None,
```

首先是匹配 `None` 分支，因为值 `Some(5)` 并不匹配模式 `None`，所以继续匹配下一个分支。

```rust,ignore
Some(i) => Some(i + 1),
```

`Some(5)` 与 `Some(i)` 匹配吗？当然匹配！它们是相同的成员。`i` 绑定了 `Some` 中包含的值，因此 `i` 的值是 `5`。接着匹配分支的代码被执行，最后将 `i` 的值加一并返回一个含有值 `6` 的新 `Some`。

#### 传入参数 None

接着考虑下 `plus_one` 的第二个调用，这次传入的 `x` 是 `None`， 我们进入 `match` 并与第一个分支相比较。

```rust,ignore
None => None,
```

匹配上了！接着程序继续执行该分支后的代码：返回表达式 `None` 的值，也就是返回一个 `None`，因为第一个分支就匹配到了，其他的分支将不再比较。



================================================
FILE: src/basic/match-pattern/pattern-match.md
================================================
# 模式适用场景

## 模式

模式是 Rust 中的特殊语法，它用来匹配类型中的结构和数据，它往往和 `match` 表达式联用，以实现强大的模式匹配能力。模式一般由以下内容组合而成：

- 字面值
- 解构的数组、枚举、结构体或者元组
- 变量
- 通配符
- 占位符

### 所有可能用到模式的地方

#### match 分支

```rust
match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
}
```

如上所示，`match` 的每个分支就是一个**模式**，因为 `match` 匹配是穷尽式的，因此我们往往需要一个特殊的模式 `_`，来匹配剩余的所有情况：

```rust
match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    _ => EXPRESSION,
}
```

#### if let 分支

`if let` 往往用于匹配一个模式，而忽略剩下的所有模式的场景：

```rust
if let PATTERN = SOME_VALUE {

}
```

#### while let 条件循环

一个与 `if let` 类似的结构是 `while let` 条件循环，它允许只要模式匹配就一直进行 `while` 循环。下面展示了一个使用 `while let` 的例子：

```rust
// Vec是动态数组
let mut stack = Vec::new();

// 向数组尾部插入元素
stack.push(1);
stack.push(2);
stack.push(3);

// stack.pop从数组尾部弹出元素
while let Some(top) = stack.pop() {
    println!("{}", top);
}
```

这个例子会打印出 `3`、`2` 接着是 `1`。`pop` 方法取出动态数组的最后一个元素并返回 `Some(value)`，如果动态数组是空的，将返回 `None`，对于 `while` 来说，只要 `pop` 返回 `Some` 就会一直不停的循环。一旦其返回 `None`，`while` 循环停止。我们可以使用 `while let` 来弹出栈中的每一个元素。

你也可以用 `loop` + `if let` 或者 `match` 来实现这个功能，但是会更加啰嗦。

#### for 循环

```rust
let v = vec!['a', 'b', 'c'];

for (index, value) in v.iter().enumerate() {
    println!("{} is at index {}", value, index);
}
```

这里使用 `enumerate` 方法产生一个迭代器，该迭代器每次迭代会返回一个 `(索引，值)` 形式的元组，然后用 `(index,value)` 来匹配。

#### let 语句

```rust
let PATTERN = EXPRESSION;
```

是的， 该语句我们已经用了无数次了，它也是一种模式匹配：

```rust
let x = 5;
```

这其中，`x` 也是一种模式绑定，代表将**匹配的值绑定到变量 x 上**。因此，在 Rust 中，**变量名也是一种模式**，只不过它比较朴素很不起眼罢了。

```rust
let (x, y, z) = (1, 2, 3);
```

上面将一个元组与模式进行匹配（**模式和值的类型必需相同！**），然后把 `1, 2, 3` 分别绑定到 `x, y, z` 上。

模式匹配要求两边的类型必须相同，否则就会导致下面的报错：

```rust
let (x, y) = (1, 2, 3);
```

```rust
error[E0308]: mismatched types
 --> src/main.rs:4:5
  |
4 | let (x, y) = (1, 2, 3);
  |     ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`
  |     |
  |     expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`
For more information about this error, try `rustc --explain E0308`.
error: could not compile `playground` due to previous error
```

对于元组来说，元素个数也是类型的一部分！

#### 函数参数

函数参数也是模式：

```rust
fn foo(x: i32) {
    // 代码
}
```

其中 `x` 就是一个模式，你还可以在参数中匹配元组：

```rust
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Current location: ({}, {})", x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&point);
}
```

`&(3, 5)` 会匹配模式 `&(x, y)`，因此 `x` 得到了 `3`，`y` 得到了 `5`。

#### let 和 if let

对于以下代码，编译器会报错：

```rust
let Some(x) = some_option_value;
```

因为右边的值可能不为 `Some`，而是 `None`，这种时候就不能进行匹配，也就是上面的代码遗漏了 `None` 的匹配。

类似 `let` , `for`和`match` 都必须要求完全覆盖匹配，才能通过编译( 不可驳模式匹配 )。

但是对于 `if let`，就可以这样使用：

```rust
if let Some(x) = some_option_value {
    println!("{}", x);
}
```

因为 `if let` 允许匹配一种模式，而忽略其余的模式( 可驳模式匹配 )。

#### let-else(Rust 1.65 新增)

使用 `let-else` 匹配，即可使 `let` 变为可驳模式。它可以使用 `else` 分支来处理模式不匹配的情况，但是 `else` 分支中必须用发散的代码块处理（例如：`break`、`return`、`panic`）。请看下面的代码：

```rust
use std::str::FromStr;

fn get_count_item(s: &str) -> (u64, &str) {
    let mut it = s.split(' ');
    let (Some(count_str), Some(item)) = (it.next(), it.next()) else {
        panic!("Can't segment count item pair: '{s}'");
    };
    let Ok(count) = u64::from_str(count_str) else {
        panic!("Can't parse integer: '{count_str}'");
    };
    // error: `else` clause of `let...else` does not diverge
    // let Ok(count) = u64::from_str(count_str) else { 0 };
    (count, item)
}

fn main() {
    assert_eq!(get_count_item("3 chairs"), (3, "chairs"));
}
```

与 `match` 和 `if let` 相比，`let-else` 的一个显著特点在于其解包成功时所创建的变量具有更广的作用域。在 `let-else` 语句中，成功匹配后的变量不再仅限于特定分支内使用：

```rust
// if let
if let Some(x) = some_option_value {
    println!("{}", x);
}

// let-else
let Some(x) = some_option_value else { return; }
println!("{}", x);
```

在上面的例子中，`if let` 写法里的 `x` 只能在 `if` 分支内使用，而 `let-else` 写法里的 `x` 则可以在 `let` 之外使用。




================================================
FILE: src/basic/ownership/borrowing.md
================================================
[Binary file]


================================================
FILE: src/basic/ownership/index.md
================================================
# 所有权和借用

Rust 之所以能成为万众瞩目的语言，就是因为其内存安全性。在以往，内存安全几乎都是通过 GC 的方式实现，但是 GC 会引来性能、内存占用以及 Stop the world 等问题，在高性能场景和系统编程上是不可接受的，因此 Rust 采用了与 ( 不 ) 众 ( 咋 ) 不 ( 好 ) 同 ( 学 )的方式：**所有权系统**。

理解**所有权**和**借用**，对于 Rust 学习是至关重要的，因此我们把本章提到了非常靠前的位置，So，在座的各位，有一个算一个，准备好了嘛？

从现在开始，鉴于大家已经掌握了非常基本的语法，有些时候，在示例代码中，将省略 `fn main() {}` 的模版代码，只要将相应的示例放在 `fn main() {}` 中，即可运行。



================================================
FILE: src/basic/ownership/ownership.md
================================================
[Binary file]


================================================
FILE: src/basic/result-error/intro.md
================================================
[Binary file]


================================================
FILE: src/basic/result-error/panic.md
================================================
# panic 深入剖析

在正式开始之前，先来思考一个问题：假设我们想要从文件读取数据，如果失败，你有没有好的办法通知调用者为何失败？如果成功，你有没有好的办法把读取的结果返还给调用者？

## panic! 与不可恢复错误

上面的问题在真实场景会经常遇到，其实处理起来挺复杂的，让我们先做一个假设：文件读取操作发生在系统启动阶段。那么可以轻易得出一个结论，一旦文件读取失败，那么系统启动也将失败，这意味着该失败是不可恢复的错误，无论是因为文件不存在还是操作系统硬盘的问题，这些只是错误的原因不同，但是归根到底都是不可恢复的错误（梳理清楚当前场景的错误类型非常重要）。

对于这些严重到影响程序运行的错误，触发 `panic` 是很好的解决方式。在 Rust 中触发 `panic` 有两种方式：被动触发和主动调用，下面依次来看看。


### 被动触发
先来看一段简单又熟悉的代码:
```rust
fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
```

心明眼亮的同学立马就能看出这里发生了严重的错误 —— 数组访问越界，在其它编程语言中无一例外，都会报出严重的异常，甚至导致程序直接崩溃关闭。

而 Rust 也不例外，运行后将看到如下报错：
```shell
$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

上面给出了非常详细的报错信息，包含了具体的异常描述以及发生的位置，甚至你还可以加入额外的命令来看到异常发生时的堆栈信息，这个会在后面详细展开。

总之，类似的 `panic` 还有很多，而被动触发的 `panic` 是我们日常开发中最常遇到的，这也是 Rust 给我们的一种保护，毕竟错误只有抛出来，才有可能被处理，否则只会偷偷隐藏起来，寻觅时机给你致命一击。


### 主动调用

在某些特殊场景中，开发者想要主动抛出一个异常，例如开头提到的在系统启动阶段读取文件失败。

对此，Rust 为我们提供了 `panic!` 宏，当调用执行该宏时，**程序会打印出一个错误信息，展开报错点往前的函数调用堆栈，最后退出程序**。

> 切记，一定是不可恢复的错误，才调用 `panic!` 处理，你总不想系统仅仅因为用户随便传入一个非法参数就崩溃吧？所以，**只有当你不知道该如何处理时，再去调用 panic!**.

首先，来调用一下 `panic!`，这里使用了最简单的代码实现，实际上你在程序的任何地方都可以这样调用：

```rust
fn main() {
    panic!("crash and burn");
}
```

运行后输出:

```console
thread 'main' panicked at 'crash and burn', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

以上信息包含了两条重要信息：

- `main` 函数所在的线程崩溃了，发生的代码位置是 `src/main.rs` 中的第 2 行第 5 个字符（包含该行前面的空字符）
- 在使用时加上一个环境变量可以获取更详细的栈展开信息：
  - Linux/macOS 等 UNIX 系统： `RUST_BACKTRACE=1 cargo run`
  - Windows 系统（PowerShell）： `$env:RUST_BACKTRACE=1 ; cargo run`

下面让我们针对第二点进行详细展开讲解。

## backtrace 栈展开

在真实场景中，错误往往涉及到很长的调用链甚至会深入第三方库，如果没有栈展开技术，错误将难以跟踪处理，下面我们来看一个真实的崩溃例子：

```rust
fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
```

上面的代码很简单，数组只有 `3` 个元素，我们却尝试去访问它的第 `100` 号元素（数组索引从 `0` 开始），那自然会崩溃。

我们的读者里不乏正义之士，此时肯定要质疑，一个简单的数组越界访问，为何要直接让程序崩溃？是不是有些小题大作了？

如果有过 C 语言的经验，即使你越界了，问题不大，我依然尝试去访问，至于这个值是不是你想要的（`100` 号内存地址也有可能有值，只不过是其它变量或者程序的！），抱歉，不归我管，我只负责取，你要负责管理好自己的索引访问范围。上面这种情况被称为**缓冲区溢出**，并可能会导致安全漏洞，例如攻击者可以通过索引来访问到数组后面不被允许的数据。

说实话，我宁愿程序崩溃，为什么？当你取到了一个不属于你的值，这在很多时候会导致程序上的逻辑 BUG！ 有编程经验的人都知道这种逻辑上的 BUG 是多么难被发现和修复！因此程序直接崩溃，然后告诉我们问题发生的位置，最后我们对此进行修复，这才是最合理的软件开发流程，而不是把问题藏着掖着：

```console
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

好的，现在成功知道问题发生的位置，但是如果我们想知道该问题之前经过了哪些调用环节，该怎么办？那就按照提示使用 `RUST_BACKTRACE=1 cargo run` 或 `$env:RUST_BACKTRACE=1 ; cargo run` 来再一次运行程序：

```console
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/std/src/panicking.rs:517:5
   1: core::panicking::panic_fmt
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:101:14
   2: core::panicking::panic_bounds_check
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:77:5
   3: <usize as core::slice::index::SliceIndex<[T]>>::index
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:184:10
   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:15:9
   5: <alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/alloc/src/vec/mod.rs:2465:9
   6: world_hello::main
             at ./src/main.rs:4:5
   7: core::ops::function::FnOnce::call_once
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/ops/function.rs:227:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
```

上面的代码就是一次栈展开（也称栈回溯），它包含了函数调用的顺序，当然按照逆序排列：最近调用的函数排在列表的最上方。因为咱们的 `main` 函数基本是最先调用的函数了，所以排在了倒数第二位，还有一个关注点，排在最顶部最后一个调用的函数是 `rust_begin_unwind`，该函数的目的就是进行栈展开，呈现这些列表信息给我们。

要获取到栈回溯信息，你还需要开启 `debug` 标志，该标志在使用 `cargo run` 或者 `cargo build` 时自动开启（这两个操作默认是 `Debug` 运行方式）。同时，栈展开信息在不同操作系统或者 Rust 版本上也有所不同。

## panic 时的两种终止方式

当出现 `panic!` 时，程序提供了两种方式来处理终止流程：**栈展开**和**直接终止**。

其中，默认的方式就是 `栈展开`，这意味着 Rust 会回溯栈上数据和函数调用，因此也意味着更多的善后工作，好处是可以给出充分的报错信息和栈调用信息，便于事后的问题复盘。`直接终止`，顾名思义，不清理数据就直接退出程序，善后工作交与操作系统来负责。

对于绝大多数用户，使用默认选择是最好的，但是当你关心最终编译出的二进制可执行文件大小时，那么可以尝试去使用直接终止的方式，例如下面的配置修改 `Cargo.toml` 文件，实现在 [`release`](https://course.rs/first-try/cargo.html#手动编译和运行项目) 模式下遇到 `panic` 直接终止：

```rust
[profile.release]
panic = 'abort'
```

## 线程 `panic` 后，程序是否会终止？

长话短说，如果是 `main` 线程，则程序会终止，如果是其它子线程，该线程会终止，但是不会影响 `main` 线程。因此，尽量不要在 `main` 线程中做太多任务，将这些任务交由子线程去做，就算子线程 `panic` 也不会导致整个程序的结束。

具体解析见 [panic 原理剖析](#panic-原理剖析)。

## 何时该使用 panic!

下面让我们大概罗列下何时适合使用 `panic`，也许经过之前的学习，你已经能够对 `panic` 的使用有了自己的看法，但是我们还是会罗列一些常见的用法来加深你的理解。

先来一点背景知识，在前面章节我们粗略讲过 `Result<T, E>` 这个枚举类型，它是用来表示函数的返回结果：

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

当没有错误发生时，函数返回一个用 `Result` 类型包裹的值 `Ok(T)`，当错误时，返回一个 `Err(E)`。对于 `Result` 返回我们有很多处理方法，最简单粗暴的就是 `unwrap` 和 `expect`，这两个函数非常类似，我们以 `unwrap` 举例：

```rust
use std::net::IpAddr;
let home: IpAddr = "127.0.0.1".parse().unwrap();
```

上面的 `parse` 方法试图将字符串 `"127.0.0.1" `解析为一个 IP 地址类型 `IpAddr`，它返回一个 `Result<IpAddr, E>` 类型，如果解析成功，则把 `Ok(IpAddr)` 中的值赋给 `home`，如果失败，则不处理 `Err(E)`，而是直接 `panic`。

因此 `unwrap` 简而言之：成功则返回值，失败则 `panic`，总之不进行任何错误处理。

#### 示例、原型、测试

这几个场景下，需要快速地搭建代码，错误处理会拖慢编码的速度，也不是特别有必要，因此通过 `unwrap`、`expect` 等方法来处理是最快的。

同时，当我们回头准备做错误处理时，可以全局搜索这些方法，不遗漏地进行替换。

#### 你确切的知道你的程序是正确时，可以使用 panic

因为 `panic` 的触发方式比错误处理要简单，因此可以让代码更清晰，可读性也更加好，当我们的代码注定是正确时，你可以用 `unwrap` 等方法直接进行处理，反正也不可能 `panic` ：

```rust
use std::net::IpAddr;
let home: IpAddr = "127.0.0.1".parse().unwrap();
```

例如上面的例子，`"127.0.0.1"` 就是 `ip` 地址，因此我们知道 `parse` 方法一定会成功，那么就可以直接用 `unwrap` 方法进行处理。

当然，如果该字符串是来自于用户输入，那在实际项目中，就必须用错误处理的方式，而不是 `unwrap`，否则你的程序一天要崩溃几十万次吧！

#### 可能导致全局有害状态时

有害状态大概分为几类：

- 非预期的错误
- 后续代码的运行会受到显著影响
- 内存安全的问题

当错误预期会出现时，返回一个错误较为合适，例如解析器接收到格式错误的数据，HTTP 请求接收到错误的参数甚至该请求内的任何错误（不会导致整个程序有问题，只影响该次请求）。**因为错误是可预期的，因此也是可以处理的**。

当启动时某个流程发生了错误，对后续代码的运行造成了影响，那么就应该使用 `panic`，而不是处理错误后继续运行，当然你可以通过重试的方式来继续。

上面提到过，数组访问越界，就要 `panic` 的原因，这个就是属于内存安全的范畴，一旦内存访问不安全，那么我们就无法保证自己的程序会怎么运行下去，也无法保证逻辑和数据的正确性。

## panic 原理剖析

本来不想写这块儿内容，因为真的难写，但是转念一想，既然号称圣经，那么本书就得与众不同，避重就轻显然不是该有的态度。

当调用 `panic!` 宏时，它会

1. 格式化 `panic` 信息，然后使用该信息作为参数，调用 `std::panic::panic_any()` 函数
2. `panic_any` 会检查应用是否使用了 [`panic hook`](https://doc.rust-lang.org/std/panic/fn.set_hook.html)，如果使用了，该 `hook` 函数就会被调用（`hook` 是一个钩子函数，是外部代码设置的，用于在 `panic` 触发时，执行外部代码所需的功能）
3. 当 `hook` 函数返回后，当前的线程就开始进行栈展开：从 `panic_any` 开始，如果寄存器或者栈因为某些原因信息错乱了，那很可能该展开会发生异常，最终线程会直接停止，展开也无法继续进行
4. 展开的过程是一帧一帧的去回溯整个栈，每个帧的数据都会随之被丢弃，但是在展开过程中，你可能会遇到被用户标记为 `catching` 的帧（通过 `std::panic::catch_unwind()` 函数标记），此时用户提供的 `catch` 函数会被调用，展开也随之停止：当然，如果 `catch` 选择在内部调用 `std::panic::resume_unwind()` 函数，则展开还会继续。

还有一种情况，在展开过程中，如果展开本身 `panic` 了，那展开线程会终止，展开也随之停止。

一旦线程展开被终止或者完成，最终的输出结果是取决于哪个线程 `panic`：对于 `main` 线程，操作系统提供的终止功能 `core::intrinsics::abort()` 会被调用，最终结束当前的 `panic` 进程；如果是其它子线程，那么子线程就会简单的终止，同时信息会在稍后通过 `std::thread::join()` 进行收集。

## 课后练习

> [Rust By Practice](https://practice-zh.course.rs/result-panic/panic.html)，支持代码在线编辑和运行，并提供详细的[习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/result-panic/panic.md)。



================================================
FILE: src/basic/result-error/result.md
================================================
# 可恢复的错误 Result

还记得上一节中，提到的关于文件读取的思考题吧？当时我们解决了读取文件时遇到不可恢复错误该怎么处理的问题，现在来看看，读取过程中，正常返回和遇到可以恢复的错误时该如何处理。

假设，我们有一台消息服务器，每个用户都通过 websocket 连接到该服务器来接收和发送消息，该过程就涉及到 socket 文件的读写，那么此时，如果一个用户的读写发生了错误，显然不能直接 `panic`，否则服务器会直接崩溃，所有用户都会断开连接，因此我们需要一种更温和的错误处理方式：`Result<T, E>`。

之前章节有提到过，`Result<T, E>` 是一个枚举类型，定义如下：

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

泛型参数 `T` 代表成功时存入的正确值的类型，存放方式是 `Ok(T)`，`E` 代表错误时存入的错误值，存放方式是 `Err(E)`，枯燥的讲解永远不及代码生动准确，因此先来看下打开文件的例子：

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");
}
```

以上 `File::open` 返回一个 `Result` 类型，那么问题来了：

> #### 如何获知变量类型或者函数的返回类型
>
> 有几种常用的方式，此处更推荐第二种方法：
>
> - 第一种是查询标准库或者三方库文档，搜索 `File`，然后找到它的 `open` 方法
> - 在 [Rust IDE](https://course.rs/first-try/editor.html) 章节，我们推荐了 `VSCode` IDE 和 `rust-analyzer` 插件，如果你成功安装的话，那么就可以在 `VSCode` 中很方便的通过代码跳转的方式查看代码，同时 `rust-analyzer` 插件还会对代码中的类型进行标注，非常方便好用！
> - 你还可以尝试故意标记一个错误的类型，然后让编译器告诉你：

```rust
let f: u32 = File::open("hello.txt");
```

错误提示如下：

```console
error[E0308]: mismatched types
 --> src/main.rs:4:18
  |
4 |     let f: u32 = File::open("hello.txt");
  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum
`std::result::Result`
  |
  = note: expected type `u32`
             found type `std::result::Result<std::fs::File, std::io::Error>`
```

上面代码，故意将 `f` 类型标记成整形，编译器立刻不乐意了，你是在忽悠我吗？打开文件操作返回一个整形？来，大哥来告诉你返回什么：`std::result::Result<std::fs::File, std::io::Error>`，我的天呐，怎么这么长的类型！

别慌，其实很简单，首先 `Result` 本身是定义在 `std::result` 中的，但是因为 `Result` 很常用，所以就被包含在了 [`prelude`](https://course.rs/appendix/prelude.html) 中（将常用的东东提前引入到当前作用域内），因此无需手动引入 `std::result::Result`，那么返回类型可以简化为 `Result<std::fs::File,std::io::Error>`，你看看是不是很像标准的 `Result<T, E>` 枚举定义？只不过 `T` 被替换成了具体的类型 `std::fs::File`，是一个文件句柄类型，`E` 被替换成 `std::io::Error`，是一个 IO 错误类型。

这个返回值类型说明 `File::open` 调用如果成功则返回一个可以进行读写的文件句柄，如果失败，则返回一个 IO 错误：文件不存在或者没有访问文件的权限等。总之 `File::open` 需要一个方式告知调用者是成功还是失败，并同时返回具体的文件句柄（成功）或错误信息（失败），万幸的是，这些信息可以通过 `Result` 枚举提供：

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => {
            panic!("Problem opening the file: {:?}", error)
        },
    };
}
```

代码很清晰，对打开文件后的 `Result<T, E>` 类型进行匹配取值，如果是成功，则将 `Ok(file)` 中存放的的文件句柄 `file` 赋值给 `f`，如果失败，则将 `Err(error)` 中存放的错误信息 `error` 使用 `panic` 抛出来，进而结束程序，这非常符合上文提到过的 `panic` 使用场景。

好吧，也没有那么合理 :)

## 对返回的错误进行处理

直接 `panic` 还是过于粗暴，因为实际上 IO 的错误有很多种，我们需要对部分错误进行特殊处理，而不是所有错误都直接崩溃：

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => panic!("Problem opening the file: {:?}", other_error),
        },
    };
}
```

上面代码在匹配出 `error` 后，又对 `error` 进行了详细的匹配解析，最终结果：

- 如果是文件不存在错误 `ErrorKind::NotFound`，就创建文件，这里创建文件`File::create` 也是返回 `Result`，因此继续用 `match` 对其结果进行处理：创建成功，将新的文件句柄赋值给 `f`，如果失败，则 `panic`
- 剩下的错误，一律 `panic`

虽然很清晰，但是代码还是有些啰嗦，我们会在[简化错误处理](https://course.rs/advance/errors.html)一章重点讲述如何写出更优雅的错误。

## 失败就 panic: unwrap 和 expect

上一节中，已经看到过这两兄弟的简单介绍，这里再来回顾下。

在不需要处理错误的场景，例如写原型、示例时，我们不想使用 `match` 去匹配 `Result<T, E> ` 以获取其中的 `T` 值，因为 `match` 的穷尽匹配特性，你总要去处理下 `Err` 分支。那么有没有办法简化这个过程？有，答案就是 `unwrap` 和 `expect`。

它们的作用就是，如果返回成功，就将 `Ok(T)` 中的值取出来，如果失败，就直接 `panic`，真的勇士绝不多 BB，直接崩溃。

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt").unwrap();
}
```

如果调用这段代码时 _hello.txt_ 文件不存在，那么 `unwrap` 就将直接 `panic`：

```console
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: "No such file or directory" }', src/main.rs:4:37
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

`expect` 跟 `unwrap` 很像，也是遇到错误直接 `panic`, 但是会带上自定义的错误提示信息，相当于重载了错误打印的函数：

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt").expect("Failed to open hello.txt");
}
```

报错如下：

```console
thread 'main' panicked at 'Failed to open hello.txt: Os { code: 2, kind: NotFound, message: "No such file or directory" }', src/main.rs:4:37
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

可以看出，`expect` 相比 `unwrap` 能提供更精确的错误信息，在有些场景也会更加实用。

## 传播错误

咱们的程序几乎不太可能只有 `A->B` 形式的函数调用，一个设计良好的程序，一个功能涉及十几层的函数调用都有可能。而错误处理也往往不是哪里调用出错，就在哪里处理，实际应用中，大概率会把错误层层上传然后交给调用链的上游函数进行处理，错误传播将极为常见。

例如以下函数从文件中读取用户名，然后将结果进行返回：

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    // 打开文件，f是`Result<文件句柄,io::Error>`
    let f = File::open("hello.txt");

    let mut f = match f {
        // 打开文件成功，将file句柄赋值给f
        Ok(file) => file,
        // 打开文件失败，将错误返回(向上传播)
        Err(e) => return Err(e),
    };
    // 创建动态字符串s
    let mut s = String::new();
    // 从f文件句柄读取数据并写入s中
    match f.read_to_string(&mut s) {
        // 读取成功，返回Ok封装的字符串
        Ok(_) => Ok(s),
        // 将错误向上传播
        Err(e) => Err(e),
    }
}
```

有几点值得注意：

- 该函数返回一个 `Result<String, io::Error>` 类型，当读取用户名成功时，返回 `Ok(String)`，失败时，返回 `Err(io:Error)`
- `File::open` 和 `f.read_to_string` 返回的 `Result<T, E>` 中的 `E` 就是 `io::Error`

由此可见，该函数将 `io::Error` 的错误往上进行传播，该函数的调用者最终会对 `Result<String,io::Error>` 进行再处理，至于怎么处理就是调用者的事，如果是错误，它可以选择继续向上传播错误，也可以直接 `panic`，亦或将具体的错误原因包装后写入 socket 中呈现给终端用户。

但是上面的代码也有自己的问题，那就是太长了（优秀的程序员身上的优点极多，其中最大的优点就是*懒*），我自认为也有那么一点点优秀，因此见不得这么啰嗦的代码，下面咱们来讲讲如何简化它。

### 传播界的大明星: ?

大明星出场，必须得有排面，来看看 `?` 的排面：

```rust
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut f = File::open("hello.txt")?;
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}
```

看到没，这就是排面，相比前面的 `match` 处理错误的函数，代码直接减少了一半不止，但是，一山更比一山难，看不懂啊！

其实 `?` 就是一个宏，它的作用跟上面的 `match` 几乎一模一样：

```rust
let mut f = match f {
    // 打开文件成功，将file句柄赋值给f
    Ok(file) => file,
    // 打开文件失败，将错误返回(向上传播)
    Err(e) => return Err(e),
};
```

如果结果是 `Ok(T)`，则把 `T` 赋值给 `f`，如果结果是 `Err(E)`，则返回该错误，所以 `?` 特别适合用来传播错误。

虽然 `?` 和 `match` 功能一致，但是事实上 `?` 会更胜一筹。何解？

想象一下，一个设计良好的系统中，肯定有自定义的错误特征，错误之间很可能会存在上下级关系，例如标准库中的 `std::io::Error `和 `std::error::Error`，前者是 IO 相关的错误结构体，后者是一个最最通用的标准错误特征，同时前者实现了后者，因此 `std::io::Error` 可以转换为 `std:error::Error`。

明白了以上的错误转换，`?` 的更胜一筹就很好理解了，它可以自动进行类型提升（转换）：

```rust
fn open_file() -> Result<File, Box<dyn std::error::Error>> {
    let mut f = File::open("hello.txt")?;
    Ok(f)
}
```

上面代码中 `File::open` 报错时返回的错误是 `std::io::Error` 类型，但是 `open_file` 函数返回的错误类型是 `std::error::Error` 的特征对象，可以看到一个错误类型通过 `?` 返回后，变成了另一个错误类型，这就是 `?` 的神奇之处。

根本原因是在于标准库中定义的 `From` 特征，该特征有一个方法 `from`，用于把一个类型转成另外一个类型，`?` 可以自动调用该方法，然后进行隐式类型转换。因此只要函数返回的错误 `ReturnError` 实现了 `From<OtherError>` 特征，那么 `?` 就会自动把 `OtherError` 转换为 `ReturnError`。

这种转换非常好用，意味着你可以用一个大而全的 `ReturnError` 来覆盖所有错误类型，只需要为各种子错误类型实现这种转换即可。

强中自有强中手，一码更比一码短：

```rust
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut s = String::new();

    File::open("hello.txt")?.read_to_string(&mut s)?;

    Ok(s)
}
```

瞧见没？ `?` 还能实现链式调用，`File::open` 遇到错误就返回，没有错误就将 `Ok` 中的值取出来用于下一个方法调用，简直太精妙了，从 Go 语言过来的我，内心狂喜（其实学 Rust 的苦和痛我才不会告诉你们）。

不仅有更强，还要有最强，我不信还有人比我更短(不要误解)：

```rust
use std::fs;
use std::io;

fn read_username_from_file() -> Result<String, io::Error> {
    // read_to_string是定义在std::io中的方法，因此需要在上面进行引用
    fs::read_to_string("hello.txt")
}
```

从文件读取数据到字符串中，是比较常见的操作，因此 Rust 标准库为我们提供了 `fs::read_to_string` 函数，该函数内部会打开一个文件、创建 `String`、读取文件内容最后写入字符串并返回，因为该函数其实与本章讲的内容关系不大，因此放在最后来讲，其实只是我想震你们一下 :)

#### ? 用于 Option 的返回

`?` 不仅仅可以用于 `Result` 的传播，还能用于 `Option` 的传播，再来回忆下 `Option` 的定义：

```rust
pub enum Option<T> {
    Some(T),
    None
}
```

`Result` 通过 `?` 返回错误，那么 `Option` 就通过 `?` 返回 `None`：

```rust
fn first(arr: &[i32]) -> Option<&i32> {
   let v = arr.get(0)?;
   Some(v)
}
```

上面的函数中，`arr.get` 返回一个 `Option<&i32>` 类型，因为 `?` 的使用，如果 `get` 的结果是 `None`，则直接返回 `None`，如果是 `Some(&i32)`，则把里面的值赋给 `v`。

其实这个函数有些画蛇添足，我们完全可以写出更简单的版本：

```rust
fn first(arr: &[i32]) -> Option<&i32> {
   arr.get(0)
}
```

有一句话怎么说？没有需求，制造需求也要上……大家别跟我学习，这是软件开发大忌。只能用代码洗洗眼了：

```rust
fn last_char_of_first_line(text: &str) -> Option<char> {
    text.lines().next()?.chars().last()
}
```

上面代码展示了在链式调用中使用 `?` 提前返回 `None` 的用法， `.next` 方法返回的是 `Option` 类型：如果返回 `Some(&str)`，那么继续调用 `chars` 方法，如果返回 `None`，则直接从整个函数中返回 `None`，不再继续进行链式调用。

#### 新手用 ? 常会犯的错误

初学者在用 `?` 时，老是会犯错，例如写出这样的代码：

```rust
fn first(arr: &[i32]) -> Option<&i32> {
   arr.get(0)?
}
```

这段代码无法通过编译，切记：`?` 操作符需要一个变量来承载正确的值，这个函数只会返回 `Some(&i32)` 或者 `None`，只有错误值能直接返回，正确的值不行，所以如果数组中存在 0 号元素，那么函数第二行使用 `?` 后的返回类型为 `&i32` 而不是 `Some(&i32)`。因此 `?` 只能用于以下形式：

- `let v = xxx()?;`
- `xxx()?.yyy()?;`

#### 带返回值的 main 函数

在了解了 `?` 的使用限制后，这段代码你很容易看出它无法编译：

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt")?;
}
```

运行后会报错:
```shell
$ cargo run
   ...
   the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --> src/main.rs:4:48
  |
3 | fn main() {
  | --------- this function should return `Result` or `Option` to accept `?`
4 |     let greeting_file = File::open("hello.txt")?;
  |                                                ^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `FromResidual<Result<Infallible, std::io::Error>>` is not implemented for `()`
```

因为 `?` 要求 `Result<T, E>` 形式的返回值，而 `main` 函数的返回是 `()`，因此无法满足，那是不是就无解了呢？

实际上 Rust 还支持另外一种形式的 `main` 函数：

```rust
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let f = File::open("hello.txt")?;

    Ok(())
}
```

这样就能使用 `?` 提前返回了，同时我们又一次看到了`Box<dyn Error>` 特征对象，因为 `std::error:Error` 是 Rust 中抽象层次最高的错误，其它标准库中的错误都实现了该特征，因此我们可以用该特征对象代表一切错误，就算 `main` 函数中调用任何标准库函数发生错误，都可以通过 `Box<dyn Error>` 这个特征对象进行返回。

至于 `main` 函数可以有多种返回值，那是因为实现了 [std::process::Termination](https://doc.rust-lang.org/std/process/trait.Termination.html) 特征，目前为止该特征还没进入稳定版 Rust 中，也许未来你可以为自己的类型实现该特征！

#### try!

在 `?` 横空出世之前( Rust 1.13 )，Rust 开发者还可以使用 `try!` 来处理错误，该宏的大致定义如下：

```rust
macro_rules! try {
    ($e:expr) => (match $e {
        Ok(val) => val,
        Err(err) => return Err(::std::convert::From::from(err)),
    });
}
```

简单看一下与 `?` 的对比:

```rust
//  `?`
let x = function_with_error()?; // 若返回 Err, 则立刻返回；若返回 Ok(255)，则将 x 的值设置为 255

// `try!()`
let x = try!(function_with_error());
```

可以看出 `?` 的优势非常明显，何况 `?` 还能做链式调用。

总之，`try!` 作为前浪已经死在了沙滩上，**在当前版本中，我们要尽量避免使用 try!**。

## 课后练习

> [Rust By Practice](https://practice-zh.course.rs/result-panic/result.html)，支持代码在线编辑和运行，并提供详细的[习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/result-panic/result.md)。



================================================
FILE: src/basic/trait/advance-trait.md
================================================
[Binary file]


================================================
FILE: src/basic/trait/generic.md
================================================
[Binary file]


================================================
FILE: src/basic/trait/intro.md
================================================
# 泛型和特征

泛型和特征是 Rust 中最最重要的抽象类型，也是你在学习 Rust 路上的拦路虎，但是挑战往往与乐趣并存，一旦学会，在后面学习 Rust 的路上，你将一往无前。



================================================
FILE: src/basic/trait/trait-object.md
================================================
# 特征对象

在上一节中有一段代码无法通过编译：

```rust
fn returns_summarizable(switch: bool) -> impl Summary {
    if switch {
        Post {
           // ...
        }
    } else {
        Weibo {
            // ...
        }
    }
}
```

其中 `Post` 和 `Weibo` 都实现了 `Summary` 特征，因此上面的函数试图通过返回 `impl Summary` 来返回这两个类型，但是编译器却无情地报错了，原因是 `impl Trait` 的返回值类型并不支持多种不同的类型返回，那如果我们想返回多种类型，该怎么办？

再来考虑一个问题：现在在做一款游戏，需要将多个对象渲染在屏幕上，这些对象属于不同的类型，存储在列表中，渲染的时候，需要循环该列表并顺序渲染每个对象，在 Rust 中该怎么实现？

聪明的同学可能已经能想到一个办法，利用枚举：

```rust
#[derive(Debug)]
enum UiObject {
    Button,
    SelectBox,
}

fn main() {
    let objects = [
        UiObject::Button,
        UiObject::SelectBox
    ];

    for o in objects {
        draw(o)
    }
}

fn draw(o: UiObject) {
    println!("{:?}",o);
}
```

Bingo，这个确实是一个办法，但是问题来了，如果你的对象集合并不能事先明确地知道呢？或者别人想要实现一个 UI 组件呢？此时枚举中的类型是有些缺少的，是不是还要修改你的代码增加一个枚举成员？

总之，在编写这个 UI 库时，我们无法知道所有的 UI 对象类型，只知道的是：

- UI 对象的类型不同
- 需要一个统一的类型来处理这些对象，无论是作为函数参数还是作为列表中的一员
- 需要对每一个对象调用 `draw` 方法

在拥有继承的语言中，可以定义一个名为 `Component` 的类，该类上有一个 `draw` 方法。其他的类比如 `Button`、`Image` 和 `SelectBox` 会从 `Component` 派生并因此继承 `draw` 方法。它们各自都可以覆盖 `draw` 方法来定义自己的行为，但是框架会把所有这些类型当作是 `Component` 的实例，并在其上调用 `draw`。不过 Rust 并没有继承，我们得另寻出路。

## 特征对象定义

为了解决上面的所有问题，Rust 引入了一个概念 —— **特征对象**。

在介绍特征对象之前，先来为之前的 UI 组件定义一个特征：

```rust
pub trait Draw {
    fn draw(&self);
}
```

只要组件实现了 `Draw` 特征，就可以调用 `draw` 方法来进行渲染。假设有一个 `Button` 和 `SelectBox` 组件实现了 `Draw` 特征：

```rust
pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&self) {
        // 绘制按钮的代码
    }
}

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec<String>,
}

impl Draw for SelectBox {
    fn draw(&self) {
        // 绘制SelectBox的代码
    }
}

```

此时，还需要一个动态数组来存储这些 UI 对象：

```rust
pub struct Screen {
    pub components: Vec<?>,
}
```

注意到上面代码中的 `?` 吗？它的意思是：我们应该填入什么类型，可以说就之前学过的内容里，你找不到哪个类型可以填入这里，但是因为 `Button` 和 `SelectBox` 都实现了 `Draw` 特征，那我们是不是可以把 `Draw` 特征的对象作为类型，填入到数组中呢？答案是肯定的。

**特征对象**指向实现了 `Draw` 特征的类型的实例，也就是指向了 `Button` 或者 `SelectBox` 的实例，这种映射关系是存储在一张表中，可以在运行时通过特征对象找到具体调用的类型方法。

可以通过 `&` 引用或者 `Box<T>` 智能指针的方式来创建特征对象。

> `Box<T>` 在后面章节会[详细讲解](https://course.rs/advance/smart-pointer/box.html)，大家现在把它当成一个引用即可，只不过它包裹的值会被强制分配在堆上。


```rust
trait Draw {
    fn draw(&self) -> String;
}

impl Draw for u8 {
    fn draw(&self) -> String {
        format!("u8: {}", *self)
    }
}

impl Draw for f64 {
    fn draw(&self) -> String {
        format!("f64: {}", *self)
    }
}

// 若 T 实现了 Draw 特征， 则调用该函数时传入的 Box<T> 可以被隐式转换成函数参数签名中的 Box<dyn Draw>
fn draw1(x: Box<dyn Draw>) {
    // 由于实现了 Deref 特征，Box 智能指针会自动解引用为它所包裹的值，然后调用该值对应的类型上定义的 `draw` 方法
    x.draw();
}

fn draw2(x: &dyn Draw) {
    x.draw();
}

fn main() {
    let x = 1.1f64;
    // do_something(&x);
    let y = 8u8;

    // x 和 y 的类型 T 都实现了 `Draw` 特征，因为 Box<T> 可以在函数调用时隐式地被转换为特征对象 Box<dyn Draw> 
    // 基于 x 的值创建一个 Box<f64> 类型的智能指针，指针指向的数据被放置在了堆上
    draw1(Box::new(x));
    // 基于 y 的值创建一个 Box<u8> 类型的智能指针
    draw1(Box::new(y));
    draw2(&x);
    draw2(&y);
}
```

上面代码，有几个非常重要的点：

- `draw1` 函数的参数是 `Box<dyn Draw>` 形式的特征对象，该特征对象是通过 `Box::new(x)` 的方式创建的
- `draw2` 函数的参数是 `&dyn Draw` 形式的特征对象，该特征对象是通过 `&x` 的方式创建的
- `dyn` 关键字只用在特征对象的类型声明上，在创建时无需使用 `dyn`

因此，可以使用特征对象来代表泛型或具体的类型。

继续来完善之前的 UI 组件代码，首先来实现 `Screen`：

```rust
pub struct Screen {
    pub components: Vec<Box<dyn Draw>>,
}
```

其中存储了一个动态数组，里面元素的类型是 `Draw` 特征对象：`Box<dyn Draw>`，任何实现了 `Draw` 特征的类型，都可以存放其中。

再来为 `Screen` 定义 `run` 方法，用于将列表中的 UI 组件渲染在屏幕上：

```rust
impl Screen {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```

至此，我们就完成了之前的目标：在列表中存储多种不同类型的实例，然后将它们使用同一个方法逐一渲染在屏幕上！

再来看看，如果通过泛型实现，会如何：

```rust
pub struct Screen<T: Draw> {
    pub components: Vec<T>,
}

impl<T> Screen<T>
    where T: Draw {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```

上面的 `Screen` 的列表中，存储了类型为 `T` 的元素，然后在 `Screen` 中使用特征约束让 `T` 实现了 `Draw` 特征，进而可以调用 `draw` 方法。

但是这种写法限制了 `Screen` 实例的 `Vec<T>` 中的每个元素必须是 `Button` 类型或者全是 `SelectBox` 类型。如果只需要同质（相同类型）集合，更倾向于采用泛型+特征约束这种写法，因其实现更清晰，且性能更好(特征对象，需要在运行时从 `vtable` 动态查找需要调用的方法)。

现在来运行渲染下咱们精心设计的 UI 组件列表：

```rust
fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from("Yes"),
                    String::from("Maybe"),
                    String::from("No")
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from("OK"),
            }),
        ],
    };

    screen.run();
}
```

上面使用 `Box::new(T)` 的方式来创建了两个 `Box<dyn Draw>` 特征对象，如果以后还需要增加一个 UI 组件，那么让该组件实现 `Draw` 特征，则可以很轻松的将其渲染在屏幕上，甚至用户可以引入我们的库作为三方库，然后在自己的库中为自己的类型实现 `Draw` 特征，然后进行渲染。

在动态类型语言中，有一个很重要的概念：**鸭子类型**(_duck typing_)，简单来说，就是只关心值长啥样，而不关心它实际是什么。当一个东西走起来像鸭子，叫起来像鸭子，那么它就是一只鸭子，就算它实际上是一个奥特曼，也不重要，我们就当它是鸭子。

在上例中，`Screen` 在 `run` 的时候，我们并不需要知道各个组件的具体类型是什么。它也不检查组件到底是 `Button` 还是 `SelectBox` 的实例，只要它实现了 `Draw` 特征，就能通过 `Box::new` 包装成 `Box<dyn Draw>` 特征对象，然后被渲染在屏幕上。

使用特征对象和 Rust 类型系统来进行类似鸭子类型操作的优势是，无需在运行时检查一个值是否实现了特定方法或者担心在调用时因为值没有实现方法而产生错误。如果值没有实现特征对象所需的特征， 那么 Rust 根本就不会编译这些代码：

```rust
fn main() {
    let screen = Screen {
        components: vec![
            Box::new(String::from("Hi")),
        ],
    };

    screen.run();
}
```

因为 `String` 类型没有实现 `Draw` 特征，编译器直接就会报错，不会让上述代码运行。如果想要 `String` 类型被渲染在屏幕上，那么只需要为其实现 `Draw` 特征即可，非常容易。

<!-- #### &dyn 和 Box\<dyn\>的区别

前文提到， `&dyn` 和 `Box<dyn>` 都可以用于特征对象，因此在功能上 `&dyn` 和 `Box<dyn>` 几乎没有区别，唯一的区别就是：`&dyn` 减少了一次指针调用。

因为 `Box<dyn>` 是一个宽指针（`fat pointer`），它需要一次额外的解引用后，才能获取到指向 `vtable` 的指针，然后再通过该指针访问 `vtable` 查询到具体的函数指针，最后进行调用。

所以，如果你在乎性能，又想使用特征对象简化代码，可以优先考虑 `&dyn`。 -->

注意 `dyn` 不能单独作为特征对象的定义，例如下面的代码编译器会报错，原因是特征对象可以是任意实现了某个特征的类型，编译器在编译期不知道该类型的大小，不同的类型大小是不同的。

而 `&dyn` 和 `Box<dyn>` 在编译期都是已知大小，所以可以用作特征对象的定义。

```rust
fn draw2(x: dyn Draw) {
    x.draw();
}
```

```
10 | fn draw2(x: dyn Draw) {
   |          ^ doesn't have a size known at compile-time
   |
   = help: the trait `Sized` is not implemented for `(dyn Draw + 'static)`
help: function arguments must have a statically known size, borrowed types always have a known size
```

## 特征对象的动态分发

回忆一下泛型章节我们提到过的，泛型是在编译期完成处理的：编译器会为每一个泛型参数对应的具体类型生成一份代码，这种方式是**静态分发(static dispatch)**，因为是在编译期完成的，对于运行期性能完全没有任何影响。

与静态分发相对应的是**动态分发(dynamic dispatch)**，在这种情况下，直到运行时，才能确定需要调用什么方法。之前代码中的关键字 `dyn` 正是在强调这一“动态”的特点。

当使用特征对象时，Rust 必须使用动态分发。编译器无法知晓所有可能用于特征对象代码的类型，所以它也不知道应该调用哪个类型的哪个方法实现。为此，Rust 在运行时使用特征对象中的指针来知晓需要调用哪个方法。动态分发也阻止编译器有选择的内联方法代码，这会相应的禁用一些优化。

下面这张图很好的解释了静态分发 `Box<T>` 和动态分发 `Box<dyn Trait>` 的区别：

<img alt="" src="https://pic1.zhimg.com/80/v2-b771fe4cfc6ebd63d9aff42840eb8e67_1440w.jpg" class="center"  />

结合上文的内容和这张图可以了解：

- **特征对象大小不固定**：这是因为，对于特征 `Draw`，类型 `Button` 可以实现特征 `Draw`，类型 `SelectBox` 也可以实现特征 `Draw`，因此特征没有固定大小
- **几乎总是使用特征对象的引用方式**，如 `&dyn Draw`、`Box<dyn Draw>`
  - 虽然特征对象没有固定大小，但它的引用类型的大小是固定的，它由两个指针组成（`ptr` 和 `vptr`），因此占用两个指针大小
  - 一个指针 `ptr` 指向实现了特征 `Draw` 的具体类型的实例，也就是当作特征 `Draw` 来用的类型的实例，比如类型 `Button` 的实例、类型 `SelectBox` 的实例
  - 另一个指针 `vptr` 指向一个虚表 `vtable`，`vtable` 中保存了类型 `Button` 或类型 `SelectBox` 的实例对于可以调用的实现于特征 `Draw` 的方法。当调用方法时，直接从 `vtable` 中找到方法并调用。之所以要使用一个 `vtable` 来保存各实例的方法，是因为实现了特征 `Draw` 的类型有多种，这些类型拥有的方法各不相同，当将这些类型的实例都当作特征 `Draw` 来使用时(此时，它们全都看作是特征 `Draw` 类型的实例)，有必要区分这些实例各自有哪些方法可调用

简而言之，当类型 `Button` 实现了特征 `Draw` 时，类型 `Button` 的实例对象 `btn` 可以当作特征 `Draw` 的特征对象类型来使用，`btn` 中保存了作为特征对象的数据指针（指向类型 `Button` 的实例数据）和行为指针（指向 `vtable`）。

一定要注意，此时的 `btn` 是 `Draw` 的特征对象的实例，而不再是具体类型 `Button` 的实例，而且 `btn` 的 `vtable` 只包含了实现自特征 `Draw` 的那些方法（比如 `draw`），因此 `btn` 只能调用实现于特征 `Draw` 的 `draw` 方法，而不能调用类型 `Button` 本身实现的方法和类型 `Button` 实现于其他特征的方法。**也就是说，`btn` 是哪个特征对象的实例，它的 `vtable` 中就包含了该特征的方法。**

## Self 与 self

在 Rust 中，有两个`self`，一个指代当前的实例对象，一个指代特征或者方法类型的别名：

```rust
trait Draw {
    fn draw(&self) -> Self;
}

#[derive(Clone)]
struct Button;
impl Draw for Button {
    fn draw(&self) -> Self {
        return self.clone()
    }
}

fn main() {
    let button = Button;
    let newb = button.draw();
}
```

上述代码中，`self`指代的就是当前的实例对象，也就是 `button.draw()` 中的 `button` 实例，`Self` 则指代的是 `Button` 类型。

当理解了 `self` 与 `Self` 的区别后，我们再来看看何为对象安全。

## 特征对象的限制

不是所有特征都能拥有特征对象，只有对象安全的特征才行。当一个特征的所有方法都有如下属性时，它的对象才是安全的：

- 方法的返回类型不能是 `Self`
- 方法没有任何泛型参数

对象安全对于特征对象是必须的，因为一旦有了特征对象，就不再需要知道实现该特征的具体类型是什么了。如果特征方法返回了具体的 `Self` 类型，但是特征对象忘记了其真正的类型，那这个 `Self` 就非常尴尬，因为没人知道它是谁了。但是对于泛型类型参数来说，当使用特征时其会放入具体的类型参数：此具体类型变成了实现该特征的类型的一部分。而当使用特征对象时其具体类型被抹去了，故而无从得知放入泛型参数类型到底是什么。

标准库中的 `Clone` 特征就不符合对象安全的要求：

```rust
pub trait Clone {
    fn clone(&self) -> Self;
}
```

因为它的其中一个方法，返回了 `Self` 类型，因此它是对象不安全的。

`String` 类型实现了 `Clone` 特征， `String` 实例上调用 `clone` 方法时会得到一个 `String` 实例。类似的，当调用 `Vec<T>` 实例的 `clone` 方法会得到一个 `Vec<T>` 实例。`clone` 的签名需要知道什么类型会代替 `Self`，因为这是它的返回值。

如果违反了对象安全的规则，编译器会提示你。例如，如果尝试使用之前的 `Screen` 结构体来存放实现了 `Clone` 特征的类型：

```rust
pub struct Screen {
    pub components: Vec<Box<dyn Clone>>,
}
```

将会得到如下错误：

```text
error[E0038]: the trait `std::clone::Clone` cannot be made into an object
 --> src/lib.rs:2:5
  |
2 |     pub components: Vec<Box<dyn Clone>>,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone`
  cannot be made into an object
  |
  = note: the trait cannot require that `Self : Sized`
```

这意味着不能以这种方式使用此特征作为特征对象。


## 课后练习

> [Rust By Practice](https://practice-zh.course.rs/generics-traits/trait-object.html)，支持代码在线编辑和运行，并提供详细的[习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/generics-traits/trait-object.md)。



================================================
FILE: src/basic/trait/trait.md
================================================
# 特征 Trait

如果我们想定义一个文件系统，那么把该系统跟底层存储解耦是很重要的。文件操作主要包含四个：`open` 、`write`、`read`、`close`，这些操作可以发生在硬盘，可以发生在内存，还可以发生在网络 IO 甚至（...我实在编不下去了，大家来帮帮我）。总之如果你要为每一种情况都单独实现一套代码，那这种实现将过于繁杂，而且也没那个必要。

要解决上述问题，需要把这些行为抽象出来，就要使用 Rust 中的特征 `trait` 概念。可能你是第一次听说这个名词，但是不要怕，如果学过其他语言，那么大概率你听说过接口，没错，特征跟接口很类似。

在之前的代码中，我们也多次见过特征的使用，例如 `#[derive(Debug)]`，它在我们定义的类型(`struct`)上自动派生 `Debug` 特征，接着可以使用 `println!("{:?}", x)` 打印这个类型；再例如：

```rust
fn add<T: std::ops::Add<Output = T>>(a:T, b:T) -> T {
    a + b
}
```

通过 `std::ops::Add` 特征来限制 `T`，只有 `T` 实现了 `std::ops::Add` 才能进行合法的加法操作，毕竟不是所有的类型都能进行相加。

这些都说明一个道理，特征定义了**一组可以被共享的行为，只要实现了特征，你就能使用这组行为**。

## 定义特征

如果不同的类型具有相同的行为，那么我们就可以定义一个特征，然后为这些类型实现该特征。**定义特征**是把一些方法组合在一起，目的是定义一个实现某些目标所必需的行为的集合。

例如，我们现在有文章 `Post` 和微博 `Weibo` 两种内容载体，而我们想对相应的内容进行总结，也就是无论是文章内容，还是微博内容，都可以在某个时间点进行总结，那么总结这个行为就是共享的，因此可以用特征来定义：

```rust
pub trait Summary {
    fn summarize(&self) -> String;
}
```

这里使用 `trait` 关键字来声明一个特征，`Summary` 是特征名。在大括号中定义了该特征的所有方法，在这个例子中是： `fn summarize(&self) -> String`。

特征只定义行为看起来是什么样的，而不定义行为具体是怎么样的。因此，我们只定义特征方法的签名，而不进行实现，此时方法签名结尾是 `;`，而不是一个 `{}`。

接下来，每一个实现这个特征的类型都需要具体实现该特征的相应方法，编译器也会确保任何实现 `Summary` 特征的类型都拥有与这个签名的定义完全一致的 `summarize` 方法。

## 为类型实现特征

因为特征只定义行为看起来是什么样的，因此我们需要为类型实现具体的特征，定义行为具体是怎么样的。

首先来为 `Post` 和 `Weibo` 实现 `Summary` 特征：

```rust
pub trait Summary {
    fn summarize(&self) -> String;
}
pub struct Post {
    pub title: String, // 标题
    pub author: String, // 作者
    pub content: String, // 内容
}

impl Summary for Post {
    fn summarize(&self) -> String {
        format!("文章{}, 作者是{}", self.title, self.author)
    }
}

pub struct Weibo {
    pub username: String,
    pub content: String
}

impl Summary for Weibo {
    fn summarize(&self) -> String {
        format!("{}发表了微博{}", self.username, self.content)
    }
}
```

实现特征的语法与为结构体、枚举实现方法很像：`impl Summary for Post`，读作“为 `Post` 类型实现 `Summary` 特征”，然后在 `impl` 的花括号中实现该特征的具体方法。

接下来就可以在这个类型上调用特征的方法：

```rust
fn main() {
    let post = Post{title: "Rust语言简介".to_string(),author: "Sunface".to_string(), content: "Rust棒极了!".to_string()};
    let weibo = Weibo{username: "sunface".to_string(),content: "好像微博没Tweet好用".to_string()};

    println!("{}",post.summarize());
    println!("{}",weibo.summarize());
}
```

运行输出：

```console
文章 Rust 语言简介, 作者是Sunface
sunface发表了微博好像微博没Tweet好用
```

说实话，如果特征仅仅如此，你可能会觉得花里胡哨没啥用，接下来就让你见识下 `trait` 真正的威力。

#### 特征定义与实现的位置(孤儿规则)

上面我们将 `Summary` 定义成了 `pub` 公开的。这样，如果他人想要使用我们的 `Summary` 特征，则可以引入到他们的包中，然后再进行实现。

关于特征实现与定义的位置，有一条非常重要的原则：**如果你想要为类型** `A` **实现特征** `T`**，那么** `A` **或者** `T` **至少有一个是在当前作用域中定义的！** 例如我们可以为上面的 `Post` 类型实现标准库中的 `Display` 特征，这是因为 `Post` 类型定义在当前的作用域中。同时，我们也可以在当前包中为 `String` 类型实现 `Summary` 特征，因为 `Summary` 定义在当前作用域中。

但是你无法在当前作用域中，为 `String` 类型实现 `Display` 特征，因为它们俩都定义在标准库中，其定义所在的位置都不在当前作用域，跟你半毛钱关系都没有，看看就行了。

该规则被称为**孤儿规则**，可以确保其它人编写的代码不会破坏你的代码，也确保了你不会莫名其妙就破坏了风马牛不相及的代码。

#### 默认实现

你可以在特征中定义具有**默认实现**的方法，这样其它类型无需再实现该方法，或者也可以选择重写该方法：

```rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
```

上面为 `Summary` 定义了一个默认实现，下面我们编写段代码来测试下：

```rust
impl Summary for Post {}

impl Summary for Weibo {
    fn summarize(&self) -> String {
        format!("{}发表了微博{}", self.username, self.content)
    }
}
```

可以看到，`Post` 选择了默认实现，而 `Weibo` 重写了该方法，调用和输出如下：

```rust
    println!("{}",post.summarize());
    println!("{}",weibo.summarize());
```

```console
(Read more...)
sunface发表了微博好像微博没Tweet好用
```

默认实现允许调用相同特征中的其他方法，哪怕这些方法没有默认实现。如此，特征可以提供很多有用的功能而只需要实现指定的一小部分内容。例如，我们可以定义 `Summary` 特征，使其具有一个需要实现的 `summarize_author` 方法，然后定义一个 `summarize` 方法，此方法的默认实现调用 `summarize_author` 方法：

```rust
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
```

为了使用 `Summary`，只需要实现 `summarize_author` 方法即可：

```rust
impl Summary for Weibo {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}
println!("1 new weibo: {}", weibo.summarize());

```

`weibo.summarize()` 会先调用 `Summary` 特征默认实现的 `summarize` 方法，通过该方法进而调用 `Weibo` 为 `Summary` 实现的 `summarize_author` 方法，最终输出：`1 new weibo: (Read more from @horse_ebooks...)`。

## 使用特征作为函数参数

之前提到过，特征如果仅仅是用来实现方法，那真的有些大材小用，现在我们来讲下，真正可以让特征大放光彩的地方。

现在，先定义一个函数，使用特征作为函数参数：

```rust
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```

`impl Summary`，只能说想出这个类型的人真的是起名鬼才，简直太贴切了，顾名思义，它的意思是 **实现了`Summary`特征** 的 `item` 参数。

你可以使用任何实现了 `Summary` 特征的类型作为该函数的参数，同时在函数体内，还可以调用该特征的方法，例如 `summarize` 方法。具体的说，可以传递 `Post` 或 `Weibo` 的实例来作为参数，而其它类如 `String` 或者 `i32` 的类型则不能用做该函数的参数，因为它们没有实现 `Summary` 特征。

## 特征约束(trait bound)

虽然 `impl Trait` 这种语法非常好理解，但是实际上它只是一个语法糖：

```rust
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```

真正的完整书写形式如上所述，形如 `T: Summary` 被称为**特征约束**。

在简单的场景下 `impl Trait` 这种语法糖就足够使用，但是对于复杂的场景，特征约束可以让我们拥有更大的灵活性和语法表现能力，例如一个函数接受两个 `impl Summary` 的参数：

```rust
pub fn notify(item1: &impl Summary, item2: &impl Summary) {}
```

如果函数两个参数是不同的类型，那么上面的方法很好，只要这两个类型都实现了 `Summary` 特征即可。但是如果我们想要强制函数的两个参数是同一类型呢？上面的语法就无法做到这种限制，此时我们只能使特征约束来实现：

```rust
pub fn notify<T: Summary>(item1: &T, item2: &T) {}
```

泛型类型 `T` 说明了 `item1` 和 `item2` 必须拥有同样的类型，同时 `T: Summary` 说明了 `T` 必须实现 `Summary` 特征。

#### 多重约束

除了单个约束条件，我们还可以指定多个约束条件，例如除了让参数实现 `Summary` 特征外，还可以让参数实现 `Display` 特征以控制它的格式化输出：

```rust
pub fn notify(item: &(impl Summary + Display)) {}
```

除了上述的语法糖形式，还能使用特征约束的形式：

```rust
pub fn notify<T: Summary + Display>(item: &T) {}
```

通过这两个特征，就可以使用 `item.summarize` 方法，以及通过 `println!("{}", item)` 来格式化输出 `item`。

#### Where 约束

当特征约束变得很多时，函数的签名将变得很复杂：

```rust
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {}
```

严格来说，上面的例子还是不够复杂，但是我们还是能对其做一些形式上的改进，通过 `where`：

```rust
fn some_function<T, U>(t: &T, u: &U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{}
```

#### 使用特征约束有条件地实现方法或特征

特征约束，可以让我们在指定类型 + 指定特征的条件下去实现方法，例如：

```rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self {
            x,
            y,
        }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```

`cmp_display` 方法，并不是所有的 `Pair<T>` 结构体对象都可以拥有，只有 `T` 同时实现了 `Display + PartialOrd` 的 `Pair<T>` 才可以拥有此方法。
该函数可读性会更好，因为泛型参数、参数、返回值都在一起，可以快速的阅读，同时每个泛型参数的特征也在新的代码行中通过**特征约束**进行了约束。

**也可以有条件地实现特征**，例如，标准库为任何实现了 `Display` 特征的类型实现了 `ToString` 特征：

```rust
impl<T: Display> ToString for T {
    // --snip--
}
```

我们可以对任何实现了 `Display` 特征的类型调用由 `ToString` 定义的 `to_string` 方法。例如，可以将整型转换为对应的 `String` 值，因为整型实现了 `Display`：

```rust
let s = 3.to_string();
```

## 函数返回中的 `impl Trait`

可以通过 `impl Trait` 来说明一个函数返回了一个类型，该类型实现了某个特征：

```rust
fn returns_summarizable() -> impl Summary {
    Weibo {
        username: String::from("sunface"),
        content: String::from(
            "m1 max太厉害了，电脑再也不会卡",
        )
    }
}
```

因为 `Weibo` 实现了 `Summary`，因此这里可以用它来作为返回值。要注意的是，虽然我们知道这里是一个 `Weibo` 类型，但是对于 `returns_summarizable` 的调用者而言，他只知道返回了一个实现了 `Summary` 特征的对象，但是并不知道返回了一个 `Weibo` 类型。

这种 `impl Trait` 形式的返回值，在一种场景下非常非常有用，那就是返回的真实类型非常复杂，你不知道该怎么声明时（毕竟 Rust 要求你必须标出所有的类型），此时就可以用 `impl Trait` 的方式简单返回。例如，闭包和迭代器就是很复杂，只有编译器才知道那玩意的真实类型，如果让你写出来它们的具体类型，估计内心有一万只草泥马奔腾，好在你可以用 `impl Iterator` 来告诉调用者，返回了一个迭代器，因为所有迭代器都会实现 `Iterator` 特征。

但是这种返回值方式有一个很大的限制：只能有一个具体的类型，例如：

```rust
fn returns_summarizable(switch: bool) -> impl Summary {
    if switch {
        Post {
            title: String::from(
                "Penguins win the Stanley Cup Championship!",
            ),
            author: String::from("Iceburgh"),
            content: String::from(
                "The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.",
            ),
        }
    } else {
        Weibo {
            username: String::from("horse_ebooks"),
            content: String::from(
                "of course, as you probably already know, people",
            ),
        }
    }
}
```

以上的代码就无法通过编译，因为它返回了两个不同的类型 `Post` 和 `Weibo`。

```console
`if` and `else` have incompatible types
expected struct `Post`, found struct `Weibo`
```

报错提示我们 `if` 和 `else` 返回了不同的类型。如果想要实现返回不同的类型，需要使用下一章节中的[特征对象](https://course.rs/basic/trait/trait-object.html)。

## 修复上一节中的 `largest` 函数

还记得上一节中的[例子](https://course.rs/basic/trait/generic.html#泛型详解)吧，当时留下一个疑问，该如何解决编译报错：

```rust
error[E0369]: binary operation `>` cannot be applied to type `T` // 无法在 `T` 类型上应用`>`运算符
 --> src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T` // 考虑使用以下的特征来约束 `T`
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> T {
  |             ^^^^^^^^^^^^^^^^^^^^^^
```

在 `largest` 函数体中我们想要使用大于运算符（`>`）比较两个 `T` 类型的值。这个运算符是标准库中特征 `std::cmp::PartialOrd` 的一个默认方法。所以需要在 `T` 的特征约束中指定 `PartialOrd`，这样 `largest` 函数可以用于内部元素类型可比较大小的数组切片。

由于 `PartialOrd` 位于 `prelude` 中所以并不需要通过 `std::cmp` 手动将其引入作用域。所以可以将 `largest` 的签名修改为如下：

```rust
fn largest<T: PartialOrd>(list: &[T]) -> T {}
```

但是此时编译，又会出现新的错误：

```rust
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --> src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       help: consider using a reference instead: `&list[0]`

error[E0507]: cannot move out of borrowed content
 --> src/main.rs:4:9
  |
4 |     for &item in list.iter() {
  |         ^----
  |         ||
  |         |hint: to prevent move, use `ref item` or `ref mut item`
  |         cannot move out of borrowed content
```

错误的核心是 `cannot move out of type [T], a non-copy slice`，原因是 `T` 没有[实现 `Copy` 特性](https://course.rs/basic/ownership/ownership.html#拷贝浅拷贝)，因此我们只能把所有权进行转移，毕竟只有 `i32` 等基础类型才实现了 `Copy` 特性，可以存储在栈上，而 `T` 可以指代任何类型（严格来说是实现了 `PartialOrd` 特征的所有类型）。

因此，为了让 `T` 拥有 `Copy` 特性，我们可以增加特征约束：

```rust
fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
```

如果并不希望限制 `largest` 函数只能用于实现了 `Copy` 特征的类型，我们可以在 `T` 的特征约束中指定 [`Clone` 特征](https://course.rs/basic/ownership/ownership.html#克隆深拷贝) 而不是 `Copy` 特征。并克隆 `list` 中的每一个值使得 `largest` 函数拥有其所有权。使用 `clone` 函数意味着对于类似 `String` 这样拥有堆上数据的类型，会潜在地分配更多堆上空间，而堆分配在涉及大量数据时可能会相当缓慢。

另一种 `largest` 的实现方式是返回在 `list` 中 `T` 值的引用。如果我们将函数返回值从 `T` 改为 `&T` 并改变函数体使其能够返回一个引用，我们将不需要任何 `Clone` 或 `Copy` 的特征约束而且也不会有任何的堆分配。尝试自己实现这种替代解决方式吧！

## 通过 `derive` 派生特征

在本书中，形如 `#[derive(Debug)]` 的代码已经出现了很多次，这种是一种特征派生语法，被 `derive` 标记的对象会自动实现对应的默认特征代码，继承相应的功能。

例如 `Debug` 特征，它有一套自动实现的默认代码，当你给一个结构体标记后，就可以使用 `println!("{:?}", s)` 的形式打印该结构体的对象。

再如 `Copy` 特征，它也有一套自动实现的默认代码，当标记到一个类型上时，可以让这个类型自动实现 `Copy` 特征，进而可以调用 `copy` 方法，进行自我复制。

总之，`derive` 派生出来的是 Rust 默认给我们提供的特征，在开发过程中极大的简化了自己手动实现相应特征的需求，当然，如果你有特殊的需求，还可以自己手动重写该实现。

详细的 `derive` 列表参见[附录-派生特征](https://course.rs/appendix/derive.html)。

## 调用方法需要引入特征

在一些场景中，使用 `as` 关键字做类型转换会有比较大的限制，因为你想要在类型转换上拥有完全的控制，例如处理转换错误，那么你将需要 `TryInto`：

```rust
use std::convert::TryInto;

fn main() {
  let a: i32 = 10;
  let b: u16 = 100;

  let b_ = b.try_into()
            .unwrap();

  if a < b_ {
    println!("Ten is less than one hundred.");
  }
}
```

上面代码中引入了 `std::convert::TryInto` 特征，但是却没有使用它，可能有些同学会为此困惑，主要原因在于**如果你要使用一个特征的方法，那么你需要将该特征引入当前的作用域中**，我们在上面用到了 `try_into` 方法，因此需要引入对应的特征。

但是 Rust 又提供了一个非常便利的办法，即把最常用的标准库中的特征通过 [`std::prelude`](https://course.rs/appendix/prelude.html) 模块提前引入到当前作用域中，其中包括了 `std::convert::TryInto`，你可以尝试删除第一行的代码 `use ...`，看看是否会报错。

## 几个综合例子

#### 为自定义类型实现 `+` 操作

在 Rust 中除了数值类型的加法，`String` 也可以做[加法](https://course.rs/basic/compound-type/string-slice.html#操作字符串)，因为 Rust 为该类型实现了 `std::ops::Add` 特征，同理，如果我们为自定义类型实现了该特征，那就可以自己实现 `Point1 + Point2` 的操作:

```rust
use std::ops::Add;

// 为Point结构体派生Debug特征，用于格式化输出
#[derive(Debug)]
struct Point<T: Add<T, Output = T>> { //限制类型T必须实现了Add特征，否则无法进行+操作。
    x: T,
    y: T,
}

impl<T: Add<T, Output = T>> Add for Point<T> {
    type Output = Point<T>;

    fn add(self, p: Point<T>) -> Point<T> {
        Point{
            x: self.x + p.x,
            y: self.y + p.y,
        }
    }
}

fn add<T: Add<T, Output=T>>(a:T, b:T) -> T {
    a + b
}

fn main() {
    let p1 = Point{x: 1.1f32, y: 1.1f32};
    let p2 = Point{x: 2.1f32, y: 2.1f32};
    println!("{:?}", add(p1, p2));

    let p3 = Point{x: 1i32, y: 1i32};
    let p4 = Point{x: 2i32, y: 2i32};
    println!("{:?}", add(p3, p4));
}
```

#### 自定义类型的打印输出

在开发过程中，往往只要使用 `#[derive(Debug)]` 对我们的自定义类型进行标注，即可实现打印输出的功能：

```rust
#[derive(Debug)]
struct Point{
    x: i32,
    y: i32
}
fn main() {
    let p = Point{x:3,y:3};
    println!("{:?}",p);
}
```

但是在实际项目中，往往需要对我们的自定义类型进行自定义的格式化输出，以让用户更好的阅读理解我们的类型，此时就要为自定义类型实现 `std::fmt::Display` 特征：

```rust
#![allow(dead_code)]

use std::fmt;
use std::fmt::{Display};

#[derive(Debug,PartialEq)]
enum FileState {
  Open,
  Closed,
}

#[derive(Debug)]
struct File {
  name: String,
  data: Vec<u8>,
  state: FileState,
}

impl Display for FileState {
   fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
     match *self {
         FileState::Open => write!(f, "OPEN"),
         FileState::Closed => write!(f, "CLOSED"),
     }
   }
}

impl Display for File {
   fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
      write!(f, "<{} ({})>",
             self.name, self.state)
   }
}

impl File {
  fn new(name: &str) -> File {
    File {
        name: String::from(name),
        data: Vec::new(),
        state: FileState::Closed,
    }
  }
}

fn main() {
  let f6 = File::new("f6.txt");
  //...
  println!("{:?}", f6);
  println!("{}", f6);
}
```

以上两个例子较为复杂，目的是为读者展示下真实的使用场景长什么样，因此需要读者细细阅读，最终消化这些知识对于你的 Rust 之路会有莫大的帮助。

最后，特征和特征约束，是 Rust 中极其重要的概念，如果你还是没搞懂，强烈建议回头再看一遍，或者寻找相关的资料进行补充学习。如果已经觉得掌握了，那么就可以进入下一节的学习。


## 课后练习

> [Rust By Practice](https://practice-zh.course.rs/generics-traits/traits.html)，支持代码在线编辑和运行，并提供详细的[习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/generics-traits/traits.md)。



================================================
FILE: src/basic-practice/base-features.md
================================================
# 实现基本功能

无论功能设计的再怎么花里胡哨，对于一个文件查找命令而言，首先得指定文件和待查找的字符串，它们需要用户从命令行给予输入，然后我们在程序内进行读取。

## 接收命令行参数

国际惯例，先创建一个新的项目 `minigrep` ，该名字充分体现了我们的自信：就是不如 `grep`。

```shell
cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
```

首先来思考下，如果要传入文件路径和待搜索的字符串，那这个命令该长啥样，我觉得大概率是这样:

```shell
cargo run -- searchstring example-filename.txt
```

`--` 告诉 `cargo` 后面的参数是给我们的程序使用的，而不是给 `cargo` 自己使用，例如 `--` 前的 `run` 就是给它用的。

接下来就是在程序中读取传入的参数，这个很简单，下面代码就可以:
```rust
// in main.rs
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    dbg!(args);
}
```
首先通过 `use` 引入标准库中的 `env` 模块，然后 `env::args` 方法会读取并分析传入的命令行参数，最终通过 `collect` 方法输出一个集合类型 `Vector`。

可能有同学疑惑，为啥不直接引入 `args` ，例如 `use std::env::args` ，这样就无需 `env::args` 来繁琐调用，直接`args().collect()` 即可。原因很简单，`args` 方法只会使用一次，啰嗦就啰嗦点吧，把相同的好名字让给 `let args..` 这位大哥不好吗？毕竟人家要出场多次的。

> ### 不可信的输入
> 所有的用户输入都不可信！不可信！不可信！
>
> 重要的话说三遍，我们的命令行程序也是，用户会输入什么你根本就不知道，例如他输入了一个非 Unicode 字符，你能阻止吗？显然不能，但是这种输入会直接让我们的程序崩溃！
>
> 原因是当传入的命令行参数包含非 Unicode 字符时， `std::env::args` 会直接崩溃，如果有这种特殊需求，建议大家使用 `std::env::args_os`，该方法产生的数组将包含 `OsString` 类型，而不是之前的 `String` 类型，前者对于非 Unicode 字符会有更好的处理。
>
> 至于为啥我们不用，两个理由，你信哪个：1. 用户爱输入啥输入啥，反正崩溃了，他就知道自己错了 2. `args_os` 会引入额外的跨平台复杂性 



`collect` 方法其实并不是`std::env`模块提供的，而是迭代器自带的方法(`env::args()` 会返回一个迭代器)，它会将迭代器消费后转换成我们想要的集合类型，关于迭代器和 `collect` 的具体介绍，请参考[这里](https://course.rs/advance/functional-programing/iterator.html)。

最后，代码中使用 `dbg!` 宏来输出读取到的数组内容，来看看长啥样：
```shell
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[src/main.rs:5] args = [
    "target/debug/minigrep",
]
```

```shell
$ cargo run -- needle haystack
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep needle haystack`
[src/main.rs:5] args = [
    "target/debug/minigrep",
    "needle",
    "haystack",
]
```

上面两个版本分别是无参数和两个参数，其中无参数版本实际上也会读取到一个字符串，仔细看，是不是长得很像我们的程序名，Bingo! `env::args` 读取到的参数中第一个就是程序的可执行路径名。

## 存储读取到的参数

在编程中，给予清晰合理的变量名是一项基本功，咱总不能到处都是 `args[1]` 、`args[2]` 这样的糟糕代码吧。

因此我们需要两个变量来存储文件路径和待搜索的字符串:
```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    let query = &args[1];
    let file_path = &args[2];

    println!("Searching for {}", query);
    println!("In file {}", file_path);
}
```

很简单的代码，来运行下:
```shell
$ cargo run -- test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
```

输出结果很清晰的说明了我们的目标：在文件 `sample.txt` 中搜索包含 `test` 字符串的内容。

事实上，就算作为一个简单的程序，它也太过于简单了，例如用户不提供任何参数怎么办？因此，错误处理显然是不可少的，但是在添加之前，先来看看如何读取文件内容。

## 文件读取

既然读取文件，那么首先我们需要创建一个文件并给予一些内容，来首诗歌如何？"我啥也不是，你呢?"

```text
I'm nobody! Who are you?
我啥也不是，你呢？
Are you nobody, too?
牛逼如你也是无名之辈吗？
Then there's a pair of us - don't tell!
那我们就是天生一对，嘘！别说话！
They'd banish us, you know.
你知道，我们不属于这里。
How dreary to be somebody!
因为这里属于没劲的大人物！
How public, like a frog
他们就像青蛙一样呱噪，
To tell your name the livelong day
成天将自己的大名
To an admiring bog!
传遍整个无聊的沼泽！
```

在项目根目录创建 `poem.txt` 文件，并写入如上的优美诗歌(可能翻译的很烂，别打我，哈哈，事实上大家写入英文内容就够了)。

接下来修改 `main.rs` 来读取文件内容：
```rust
use std::env;
use std::fs;

fn main() {
    // --省略之前的内容--
    println!("In file {}", file_path);

    let contents = fs::read_to_string(file_path)
        .expect("Should have been able to read the file");

    println!("With text:\n{contents}");
}
```

首先，通过 `use std::fs` 引入文件操作模块，然后通过 `fs::read_to_string` 读取指定的文件内容，最后返回的 `contents` 是 `std::io::Result<String>` 类型。

运行下试试，这里无需输入第二个参数，因为我们还没有实现查询功能:
```shell
$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
```

完美，虽然代码还有很多瑕疵，例如所有内容都在 `main` 函数，这个不符合软件工程，没有错误处理，功能不完善等。不过没关系，万事开头难，好歹我们成功迈开了第一步。

好了，是时候重构赚波 KPI 了，读者：are you serious? 这就开始重构了？



================================================
FILE: src/basic-practice/envs.md
================================================
# 使用环境变量来增强程序

在上一章节中，留下了一个悬念，该如何实现用户控制的大小写敏感，其实答案很简单，你在其它程序中肯定也遇到过不少，例如如何控制 `panic` 后的栈展开？ Rust 提供的解决方案是通过命令行参数来控制: 

```shell
RUST_BACKTRACE=1 cargo run
```

与之类似，我们也可以使用环境变量来控制大小写敏感，例如: 

```shell
IGNORE_CASE=1 cargo run -- to poem.txt
```

既然有了目标，那么一起来看看该如何实现吧。


## 编写大小写不敏感的测试用例

还是遵循之前的规则：测试驱动，这次是对一个新的大小写不敏感函数进行测试 `search_case_insensitive`。

还记得 TDD 的测试步骤嘛？首先编写一个注定失败的用例:

```rust
// in src/lib.rs
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Duct tape.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }

    #[test]
    fn case_insensitive() {
        let query = "rUsT";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Trust me.";

        assert_eq!(
            vec!["Rust:", "Trust me."],
            search_case_insensitive(query, contents)
        );
    }
}
```

可以看到，这里新增了一个 `case_insensitive` 测试用例，并对 `search_case_insensitive` 进行了测试，结果显而易见，函数都没有实现，自然会失败。

接着来实现这个大小写不敏感的搜索函数:

```rust
pub fn search_case_insensitive<'a>(
    query: &str,
    contents: &'a str,
) -> Vec<&'a str> {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&query) {
            results.push(line);
        }
    }

    results
}
```

跟之前一样，但是引入了一个新的方法 `to_lowercase`，它会将 `line` 转换成全小写的字符串，类似的方法在其它语言中也差不多，就不再赘述。

还要注意的是 `query` 现在是 `String` 类型，而不是之前的 `&str`，因为 `to_lowercase` 返回的是 `String`。

修改后，再来跑一次测试，看能否通过。

```shell
$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.33s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

Ok，TDD的第二步也完成了，测试通过，接下来就是最后一步，在 `run` 中调用新的搜索函数。但是在此之前，要新增一个配置项，用于控制是否开启大小写敏感。

```rust
// in lib.rs
pub struct Config {
    pub query: String,
    pub file_path: String,
    pub ignore_case: bool,
}
```

接下来就是检查该字段，来判断是否启动大小写敏感：

```rust
pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.file_path)?;

    let results = if config.ignore_case {
        search_case_insensitive(&config.query, &contents)
    } else {
        search(&config.query, &contents)
    };

    for line in results {
        println!("{line}");
    }

    Ok(())
}
```

现在的问题来了，该如何控制这个配置项呢。这个就要借助于章节开头提到的环境变量，好在 Rust 的 `env` 包提供了相应的方法。

```rust
use std::env;
// --snip--

impl Config {
    pub fn build(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
```

`env::var` 没啥好说的，倒是 `is_ok` 值得说道下。该方法是 `Result` 提供的，用于检查是否有值，有就返回 `true`，没有则返回 `false`，刚好完美符合我们的使用场景，因为我们并不关心 `Ok<T>` 中具体的值。

运行下试试：
```shell
$ cargo run -- to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
```

看起来没有问题，接下来测试下大小写不敏感: 

```shell
$ IGNORE_CASE=1 cargo run -- to poem.txt
```

```shell
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
```

大小写不敏感后，查询到的内容明显多了很多，也很符合我们的预期。

最后，给大家留一个小作业：同时使用命令行参数和环境变量的方式来控制大小写不敏感，其中环境变量的优先级更高，也就是两个都设置的情况下，优先使用环境变量的设置。






================================================
FILE: src/basic-practice/intro.md
================================================
# 构建一个简单命令行程序

在前往更高的山峰前，我们应该驻足欣赏下身后的风景，虽然是半览众山不咋小，但总比身在此山中无法窥全貌要强一丢丢。

在本章中，我们将一起构建一个命令行程序，目标是尽可能帮大家融会贯通之前的学到的知识。

linux 系统中的 `grep` 命令很强大，可以完成各种文件搜索任务，我们肯定做不了那么强大，但是假冒一个伪劣的版本还是可以的，它将从命令行参数中读取指定的文件名和字符串，然后在相应的文件中找到包含该字符串的内容，最终打印出来。

> 这里推荐一位大神写的知名 Rust 项目 [ripgrep](https://github.com/BurntSushi/ripgrep) ，绝对是 `grep` 真正的高替品，值得学习和使用


================================================
FILE: src/basic-practice/iterators.md
================================================
[Binary file]


================================================
FILE: src/basic-practice/refactoring.md
================================================
[Binary file]


================================================
FILE: src/basic-practice/stderr.md
================================================
# 重定向错误信息的输出

迄今为止，所有的输出信息，无论 debug 还是 error 类型，都是通过 `println!` 宏输出到终端的标准输出( `stdout` )，但是对于程序来说，错误信息更适合输出到标准错误输出(stderr)。

这样修改后，用户就可以选择将普通的日志类信息输出到日志文件 1，然后将错误信息输出到日志文件 2，甚至还可以输出到终端命令行。

## 目前的错误输出位置

我们先来观察下，目前的输出信息包括错误，是否是如上面所说，都写到标准错误输出。

测试方式很简单，将标准错误输出的内容重定向到文件中，看看是否包含故意生成的错误信息即可。

```shell
$ cargo run > output.txt
```

首先，这里的运行没有带任何参数，因此会报出类如文件不存在的错误，其次，通过 `>` 操作符，标准输出上的内容被重定向到文件 `output.txt` 中，不再打印到控制上。

大家先观察下控制台，然后再看看 `output.txt`，是否发现如下的错误信息已经如期被写入到文件中？

```shell
Problem parsing arguments: not enough arguments
```

所以，可以得出一个结论，如果错误信息输出到标准输出，那么它们将跟普通的日志信息混在一起，难以分辨，因此我们需要将错误信息进行单独输出。


## 标准错误输出 stderr

将错误信息重定向到 `stderr` 很简单，只需在打印错误的地方，将 `println!` 宏替换为 `eprintln!`即可。

```rust
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::build(&args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!("Application error: {e}");
        process::exit(1);
    }
}
```

接下来，还是同样的运行命令：
```shell
$ cargo run > output.txt
Problem parsing arguments: not enough arguments
```

可以看到，日志信息成功的重定向到 `output.txt` 文件中，而错误信息由于 `eprintln!` 的使用，被写入到标准错误输出中，默认还是输出在控制台中。

再来试试没有错误的情况:

```shell
$ cargo run -- to poem.txt > output.txt
```

这次运行参数很正确，因此也没有任何错误信息产生，同时由于我们重定向了标准输出，因此相应的输出日志会写入到 `output.txt` 中，打开可以看到如下内容：

```shell
Are you nobody, too?
How dreary to be somebody!
```

至此，简易搜索程序 `minigrep` 已经基本完成，下一章节将使用迭代器进行部分改进，请大家在看完[迭代器章节](https://course.rs/advance/functional-programing/iterator.html)后，再回头阅读。


================================================
FILE: src/basic-practice/tests.md
================================================
# 测试驱动开发

> 开始之前，推荐大家先了解下[如何在 Rust 中编写测试代码](https://course.rs/test/intro.html)，这块儿内容不复杂，先了解下有利于本章的继续阅读

在之前的章节中，我们完成了对项目结构的重构，并将进入逻辑代码编程的环节，但在此之前，我们需要先编写一些测试代码，也是最近颇为流行的测试驱动开发模式(TDD, Test Driven Development)：

1. 编写一个注定失败的测试，并且失败的原因和你指定的一样
2. 编写一个成功的测试
3. 编写你的逻辑代码，直到通过测试

这三个步骤将在我们的开发过程中不断循环，直到所有的代码都开发完成并成功通过所有测试。

## 注定失败的测试用例

既然要添加测试，那之前的 `println!` 语句将没有大的用处，毕竟 `println!` 存在的目的就是为了让我们看到结果是否正确，而现在测试用例将取而代之。

接下来，在 `lib.rs` 文件中，添加 `tests` 模块和 `test` 函数: 

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }
}
```

测试用例将在指定的内容中搜索 `duct` 字符串，目测可得：其中有一行内容是包含有目标字符串的。

但目前为止，还无法运行该测试用例，更何况还想幸灾乐祸的看其失败，原因是 `search` 函数还没有实现！毕竟是测试驱动、测试先行。

```rust
// in lib.rs
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    vec![]
}
```

先添加一个简单的 `search` 函数实现，非常简单粗暴的返回一个空的数组，显而易见测试用例将成功通过，真是一个居心叵测的测试用例！

注意这里生命周期 `'a` 的使用，之前的章节有[详细介绍](https://course.rs/basic/lifetime.html#函数签名中的生命周期标注)，不太明白的同学可以回头看看。

喔，这么复杂的代码，都用上生命周期了！嘚瑟两下试试：

```shell
$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 0.97s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `["safe, fast, productive."]`,
 right: `[]`', src/lib.rs:44:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
```

太棒了！它失败了...

## 务必成功的测试用例

接着就是测试驱动的第二步：编写注定成功的测试。当然，前提条件是实现我们的 `search` 函数。它包含以下步骤：

- 遍历迭代 `contents` 的每一行
- 检查该行内容是否包含我们的目标字符串
- 若包含，则放入返回值列表中，否则忽略
- 返回匹配到的返回值列表

### 遍历迭代每一行

Rust 提供了一个很便利的 `lines` 方法将目标字符串进行按行分割:

```rust
// in lib.rs
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    for line in contents.lines() {
        // do something with line
    }
}
```

这里的 `lines` 返回一个[迭代器](https://course.rs/advance/functional-programing/iterator.html)，关于迭代器在后续章节会详细讲解，现在只要知道 `for` 可以遍历取出迭代器中的值即可。

### 在每一行中查询目标字符串

```rust
// in lib.rs
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
```

与之前的 `lines` 函数类似，Rust 的字符串还提供了 `contains` 方法，用于检查 `line` 是否包含待查询的 `query`。

接下来，只要返回合适的值，就可以完成 `search` 函数的编写。


### 存储匹配到的结果

简单，创建一个 `Vec` 动态数组，然后将查询到的每一个 `line` 推进数组中即可：

```rust
// in lib.rs
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
```

至此，`search` 函数已经完成了既定目标，为了检查功能是否正确，运行下我们之前编写的测试用例:

```shell
$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

测试通过，意味着我们的代码也完美运行，接下来就是在 `run` 函数中大显身手了。

### 在 run 函数中调用 search 函数

```rust
// in src/lib.rs
pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.file_path)?;

    for line in search(&config.query, &contents) {
        println!("{line}");
    }

    Ok(())
}
```

好，再运行下看看结果，看起来我们距离成功从未如此之近！

```shell
$ cargo run -- frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
```

酷！成功查询到包含 `frog` 的行，再来试试 `body` :

```shell
$ cargo run -- body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
```

完美，三行，一行不少，为了确保万无一失，再来试试查询一个不存在的单词:

```shell
cargo run -- monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
```

至此，章节开头的目标已经全部完成，接下来思考一个小问题：如果要为程序加上大小写不敏感的控制命令，由用户进行输入，该怎么实现比较好呢？毕竟在实际搜索查询中，同时支持大小写敏感和不敏感还是很重要的。

答案留待下一章节揭晓。



================================================
FILE: src/cargo/getting-started.md
================================================
[Binary file]


================================================
FILE: src/cargo/git-auth.md
================================================
# 附录：Git鉴权



================================================
FILE: src/cargo/intro.md
================================================
# Cargo 使用指南

Rust 语言的名气之所以这么大，保守估计 `Cargo` 的贡献就占了三分之一。

`Cargo` 是包管理工具，可以用于依赖包的下载、编译、更新、分发等，与 `Cargo` 一样有名的还有 [`crates.io`](https://crates.io)，它是社区提供的包注册中心：用户可以将自己的包发布到该注册中心，然后其它用户通过注册中心引入该包。

> 本章内容是基于 [Cargo Book](https://doc.rust-lang.org/stable/cargo/index.html) 翻译，并做了一些内容优化和目录组织上的调整

<img src="https://doc.rust-lang.org/stable/cargo/images/Cargo-Logo-Small.png" />




================================================
FILE: src/cargo/guide/build-cache.md
================================================
# 构建( Build )缓存

`cargo build` 的结果会被放入项目根目录下的 `target` 文件夹中，当然，这个位置可以三种方式更改：设置 `CARGO_TARGET_DIR` [环境变量](https://doc.rust-lang.org/stable/cargo/reference/environment-variables.html)、[`build.target-dir`](https://course.rs/cargo/reference/configuration.html#配置文件概览) 配置项以及 `--target-dir` 命令行参数。

## target 目录结构

`target` 目录的结构取决于是否使用 `--target` 标志为特定的平台构建。

#### 不使用 --target

若 `--target` 标志没有指定，`Cargo` 会根据宿主机架构进行构建，构建结果会放入项目根目录下的 `target` 目录中，`target` 下每个子目录中包含了相应的 [`发布配置profile`](https://course.rs/cargo/reference/profiles.html) 的构建结果，例如 `release`、`debug` 是自带的`profile`，前者往往用于生产环境，因为会做大量的性能优化，而后者则用于开发环境，此时的编译效率和报错信息是最好的。

除此之外我们还可以定义自己想要的 `profile` ，例如用于测试环境的 `profile`： `test`，用于预发环境的 `profile` ：`pre-prod` 等。

| 目录             | 描述                                                                    |
| ---------------- | ----------------------------------------------------------------------- |
| `target/debug/`  | 包含了 `dev` profile 的构建输出(`cargo build` 或 `cargo build --debug`) |
| `target/release/` | `release` profile 的构建输出，`cargo build --release`                   |
| `target/foo/`    | 自定义 `foo` profile 的构建输出，`cargo build --profile=foo`            |

出于历史原因:

- `dev` 和 `test` profile 的构建结果都存放在 `debug` 目录下
- `release` 和 `bench` profile 则存放在 `release` 目录下
- 用户定义的 profile 存在同名的目录下

#### 使用 --target

当使用 `--target XXX` 为特定的平台编译后，输出会放在 `target/XXX/` 目录下:

| 目录                       | 示例                                    |
| -------------------------- | --------------------------------------- |
| `target/<triple>/debug/`    | `target/thumbv7em-none-eabihf/debug/`   |
| `target/<triple>/release/` | `target/thumbv7em-none-eabihf/release/` |

> **注意：**，当没有使用 `--target` 时，`Cargo` 会与构建脚本和过程宏一起共享你的依赖包，对于每个 `rustc` 命令调用而言，[`RUSTFLAGS`](https://course.rs/cargo/reference/configuration.html#配置文件概览) 也将被共享。
>
> 而使用 `--target` 后，构建脚本、过程宏会针对宿主机的 CPU 架构进行各自构建，且不会共享 `RUSTFLAGS`。

#### target 子目录说明

在 profile 文件夹中(例如 `debug` 或 `release`)，包含编译后的最终成果:

| 目录                     | 描述                                                                                                                                  |
| ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------- |
| `target/debug/`          | 包含编译后的输出，例如二进制可执行文件、[库对象( library target )](https://course.rs/cargo/reference/cargo-target.html#库对象library) |
| `target/debug/examples/` | 包含[示例对象( example target )](https://course.rs/cargo/reference/cargo-target.html#示例对象examples)                                |

还有一些命令会在 `target` 下生成自己的独立目录:

| 目录              | 描述                                               |
| ----------------- | -------------------------------------------------- |
| `target/doc/`     | 包含通过 `cargo doc` 生成的文档                    |
| `target/package/` | 包含 `cargo package` 或 `cargo publish` 生成的输出 |

Cargo 还会创建几个用于构建过程的其它类型目录，它们的目录结构只应该被 Cargo 自身使用，因此可能会在未来发生变化:

| 目录                       | 描述                                                                                                                    |
| -------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| `target/debug/deps`        | 依赖和其它输出成果                                                                                                      |
| `target/debug/incremental` | `rustc` [增量编译](https://course.rs/cargo/reference/profiles.html#incremental)的输出，该缓存可以用于提升后续的编译速度 |
| `target/debug/build/`      | [构建脚本](https://course.rs/cargo/reference/build-script/intro.html)的输出                                             |

## 依赖信息文件

在每一个编译成果的旁边，都有一个依赖信息文件，文件后缀是 `.d`。该文件的语法类似于 `Makefile`，用于说明构建编译成果所需的所有依赖包。

该文件往往用于提供给外部的构建系统，这样它们就可以判断 `Cargo` 命令是否需要再次被执行。

文件中的路径默认是绝对路径，你可以通过 [`build.dep-info-basedir`](https://course.rs/cargo/reference/configuration.html#配置文件概览) 配置项来修改为相对路径。

```shell
# 关于 `.d` 文件的一个示例 : target/debug/foo.d
/path/to/myproj/target/debug/foo: /path/to/myproj/src/lib.rs /path/to/myproj/src/main.rs
```

## 共享缓存

[sccache](https://github.com/mozilla/sccache) 是一个三方工具，可以用于在不同的工作空间中共享已经构建好的依赖包。

为了设置 `sccache`，首先需要使用 `cargo install sccache` 进行安装，然后在调用 `Cargo` 之前将 `RUSTC_WRAPPER` 环境变量设置为 `sccache`。

- 如果用的 `bash`，可以将 `export RUSTC_WRAPPER=sccache` 添加到 `.bashrc` 中
- 也可以使用 [`build.rustc-wrapper`](https://course.rs/cargo/reference/configuration.html#配置文件概览) 配置项



================================================
FILE: src/cargo/guide/cargo-cache.md
================================================
# Cargo 缓存

Cargo 使用了缓存的方式提升构建效率，当构建时，Cargo 会将已下载的依赖包放在 `CARGO_HOME` 目录下，下面一起来看看。

## Cargo Home

默认情况下，Cargo Home 所在的目录是 `$HOME/.cargo/`，例如在 `macos` ，对应的目录是:

```shell
$ echo $HOME/.cargo/
/Users/sunfei/.cargo/
```

我们也可以通过修改 `CARGO_HOME` 环境变量的方式来重新设定该目录的位置。若你需要在项目中通过代码的方式来获取 `CARGO_HOME` ，[`home`](https://crates.io/crates/home) 包提供了相应的 API。

> 注意！ Cargo Home 目录的内部结构并没有稳定化，在未来可能会发生变化

## 文件

- `config.toml` 是 Cargo 的全局配置文件，具体请查看[这里](https://course.rs/cargo/reference/configuration.html)
- `credentials.toml` 为 `cargo login` 提供私有化登录证书，用于登录 `package` 注册中心，例如 `crates.io`
- `.crates.toml`, `.crates2.json` 这两个是隐藏文件，包含了通过 `cargo install` 安装的包的 `package` 信息，**请不要手动修改！**

## 目录

- `bin` 目录包含了通过 `cargo install` 或 `rustup` 下载的包编译出的可执行文件。你可以将该目录加入到 `$PATH` 环境变量中，以实现对这些可执行文件的直接访问
- `git` 中存储了 `Git` 的资源文件:
  - `git/db`，当一个包依赖某个 `git` 仓库时，`Cargo` 会将该仓库克隆到 `git/db` 目录下，如果未来需要还会对其进行更新
  - `git/checkouts`，若指定了 `git` 源和 `commit`，那相应的仓库就会从 `git/db` 中 `checkout` 到该目录下，因此同一个仓库的不同 `checkout` 共存成为了可能性
- `registry` 包含了注册中心( 例如 `crates.io` )的元数据 和 `packages`
  - `registry/index` 是一个 git 仓库，包含了注册中心中所有可用包的元数据( 版本、依赖等 )
  - `registry/cache` 中保存了已下载的依赖，这些依赖包以 `gzip` 的压缩档案形式保存，后缀名为 `.crate`
  - `registry/src`，若一个已下载的 `.crate` 档案被一个 `package` 所需要，该档案会被解压缩到 `registry/src` 文件夹下，最终 `rustc` 可以在其中找到所需的 `.rs` 文件

## 在 CI 时缓存 Cargo Home

为了避免持续集成时重复下载所有的包依赖，我们可以将 `$CARGO_HOME` 目录进行缓存，但缓存整个目录是效率低下的，原因是源文件可能会被缓存两次。

例如我们依赖一个包 `serde 1.0.92`，如果将整个 `$CACHE_HOME` 目录缓存，那么`serde` 的源文件就会被缓存两次：在 `registry/cache` 中的 `serde-1.0.92.crate` 以及 `registry/src` 下被解压缩的 `.rs` 文件。

因此，在 CI 构建时，出于效率的考虑，我们仅应该缓存以下目录:

- `bin/`
- `registry/index/`
- `registry/cache/`
- `git/db/`

## 清除缓存

理论上，我们可以手动移除缓存中的任何一部分，当后续有包需要时 `Cargo` 会尽可能去恢复这些资源：

- 解压缩 `registry/cache` 下的 `.crate` 档案
- 从 `.git` 中 `checkout` 缓存的仓库
- 如果以上都没了，会从网络上重新下载

你也可以使用 [cargo-cache](https://crates.io/crates/cargo-cache) 包来选择性的清除 `cache` 中指定的部分，当然，它还可以用来查看缓存中的组件大小。

## 构建时卡住：Blocking waiting for file lock ..

在开发过程中，或多或少我们都会碰到这种问题，例如你同时打开了 VSCode IDE 和终端，然后在 `Cargo.toml` 中刚添加了一个新的依赖。

此时 IDE 会捕捉到这个修改然后自动去重新下载依赖(这个过程可能还会更新 `crates.io` 使用的索引列表)，在此过程中， Cargo 会将相关信息写入到 `$HOME/.cargo/.package_cache` 下，并将其锁住。

如果你试图在另一个地方(例如终端)对同一个项目进行构建，就会报错: `Blocking waiting for file lock on package cache`。

解决办法很简单：

- 既然下载慢，那就使用[国内的注册服务](https://course.rs/cargo/reference/specify-deps.html#从其它注册服务引入依赖包)，不再使用 crates.io
- 耐心等待持有锁的用户构建完成
- 强行停止正在构建的进程，例如杀掉 IDE 使用的 rust-analyer 插件进程，然后删除 `$HOME/.cargo/.package_cache` 目录




================================================
FILE: src/cargo/guide/cargo-toml-lock.md
================================================
# Cargo.toml vs Cargo.lock

`Cargo.toml` 和 `Cargo.lock` 是 `Cargo` 的两个元配置文件，但是它们拥有不同的目的:

- 前者从用户的角度出发来描述项目信息和依赖管理，因此它是由用户来编写
- 后者包含了依赖的精确描述信息，它是由 `Cargo` 自行维护，因此不要去手动修改

它们的关系跟 `package.json` 和 `package-lock.json` 非常相似，从 JavaScript 过来的同学应该会比较好理解。

## 是否上传本地的 `Cargo.lock`

当本地开发时，`Cargo.lock` 自然是非常重要的，但是当你要把项目上传到 `Git` 时，例如 `GitHub`，那是否上传 `Cargo.lock` 就成了一个问题。

关于是否上传，有如下经验准则:

- 从实践角度出发，如果你构建的是三方库类型的服务，请把 `Cargo.lock` 加入到 `.gitignore` 中。
- 若构建的是一个面向用户终端的产品，例如可以像命令行工具、应用程序一样执行，那就把 `Cargo.lock` 上传到源代码目录中。

例如 [`axum`](https://github.com/tokio-rs/axum) 是 web 开发框架，它属于三方库类型的服务，因此源码目录中不应该出现 `Cargo.lock` 的身影，它的归宿是 `.gitignore`。而 [`ripgrep`](https://github.com/BurntSushi/ripgrep) 则恰恰相反，因为它是一个面向终端的产品，可以直接运行提供服务。

**那么问题来了，为何会有这种选择？**

原因是 `Cargo.lock` 会详尽描述上一次成功构建的各种信息：环境状态、依赖、版本等等，Cargo 可以使用它提供确定性的构建环境和流程，无论何时何地。这种特性对于终端服务是非常重要的：能确定、稳定的在用户环境中运行起来是终端服务最重要的特性之一。

而对于三方库来说，情况就有些不同。它不仅仅被库的开发者所使用，还会间接影响依赖链下游的使用者。用户引入了三方库是不会去看它的 `Cargo.lock` 信息的，也不应该受这个库的确定性运行条件所限制。

还有个原因，在项目中，可能会有几个依赖库引用同一个三方库的同一个版本，那如果该三方库使用了 `Cargo.lock` 文件，那可能三方库的多个版本会被引入使用，这时就会造成版本冲突。换句话说，通过指定版本的方式引用一个依赖库是无法看到该依赖库的完整情况的，而只有终端的产品才会看到这些完整的情况。

## 假设没有 `Cargo.lock`

`Cargo.toml` 是一个清单文件( `manifest` )包含了我们 `package` 的描述元数据。例如，通过以下内容可以说明对另一个 `package` 的依赖 :

```rust
[package]
name = "hello_world"
version = "0.1.0"

[dependencies]
regex = { git = "https://github.com/rust-lang/regex.git" }
```

可以看到，只有一个依赖，且该依赖的来源是 `GitHub` 上一个特定的仓库。由于我们没有指定任何版本信息，`Cargo` 会自动拉取该依赖库的最新版本( `master` 或 `main` 分支上的最新 `commit` )。

这种使用方式，其实就错失了包管理工具的最大的优点：版本管理。例如你在今天构建使用了版本 `A`，然后过了一段时间后，由于依赖包的升级，新的构建却使用了大更新版本 `B`，结果因为版本不兼容，导致了构建失败。

可以看出，确保依赖版本的确定性是非常重要的:

```rust
[dependencies]
regex = { git = "https://github.com/rust-lang/regex.git", rev = "9f9f693" }
```

这次，我们使用了指定 `rev` ( `revision` ) 的方式来构建，那么不管未来何时再次构建，使用的依赖库都会是该 `rev` ，而不是最新的 `commit`。

但是，这里还有一个问题：`rev` 需要手动的管理，你需要在每次更新包的时候都思考下 `SHA-1`，这显然非常麻烦。

## 当有了 `Cargo.lock` 后

当有了 `Cargo.lock` 后，我们无需手动追踪依赖库的 `rev`，`Cargo` 会自动帮我们完成，还是之前的清单:

```rust
[package]
name = "hello_world"
version = "0.1.0"

[dependencies]
regex = { git = "https://github.com/rust-lang/regex.git" }
```

第一次构建时，`Cargo` 依然会拉取最新的 `master commit`，然后将以下信息写到 `Cargo.lock` 文件中:

```rust
[[package]]
name = "hello_world"
version = "0.1.0"
dependencies = [
 "regex 1.5.0 (git+https://github.com/rust-lang/regex.git#9f9f693768c584971a4d53bc3c586c33ed3a6831)",
]

[[package]]
name = "regex"
version = "1.5.0"
source = "git+https://github.com/rust-lang/regex.git#9f9f693768c584971a4d53bc3c586c33ed3a6831"
```

可以看出，其中包含了依赖库的准确 `rev` 信息。当未来再次构建时，只要项目中还有该 `Cargo.lock` 文件，那构建依然会拉取同一个版本的依赖库，并且再也无需我们手动去管理 `rev` 的 `SHA` 信息!

## 更新依赖

由于 `Cargo.lock` 会锁住依赖的版本，你需要通过手动的方式将依赖更新到新的版本：

```rust
$ cargo update            # 更新所有依赖
$ cargo update -p regex   # 只更新 “regex”
```

以上命令将使用新的版本信息重新生成 `Cargo.lock` ，需要注意的是 `cargo update -p regex` 传递的参数实际上是一个 `Package ID`， `regex` 只是一个简写形式。



================================================
FILE: src/cargo/guide/dependencies.md
================================================
# 添加依赖

[`crates.io`](https://crates.io) 是 Rust 社区维护的中心化注册服务，用户可以在其中寻找和下载所需的包。对于 `cargo` 来说，默认就是从这里下载依赖。

下面我们来添加一个 `time` 依赖包，若你的 `Cargo.toml` 文件中没有 `[dependencies]` 部分，就手动添加一个，并添加目标包名和版本号:

```toml
[dependencies]
time = "0.1.12"
```

可以看到我们指定了 `time` 包的版本号 "0.1.12"，关于版本号，实际上还有其它的指定方式，具体参见[指定依赖项](https://course.rs/cargo/reference/specify-deps.html)章节。

如果想继续添加 `regexp` 包，只需在 `time` 包后面添加即可 :

```toml
[package]
name = "hello_world"
version = "0.1.0"
edition = "2021"

[dependencies]
time = "0.1.12"
regex = "0.1.41"
```

此时，再通过运行 `cargo build` 来重新构建，首先 `Cargo` 会获取新的依赖以及依赖的依赖, 接着对它们进行编译并更新 `Cargo.lock`:

```shell
$ cargo build
      Updating crates.io index
   Downloading memchr v0.1.5
   Downloading libc v0.1.10
   Downloading regex-syntax v0.2.1
   Downloading memchr v0.1.5
   Downloading aho-corasick v0.3.0
   Downloading regex v0.1.41
     Compiling memchr v0.1.5
     Compiling libc v0.1.10
     Compiling regex-syntax v0.2.1
     Compiling memchr v0.1.5
     Compiling aho-corasick v0.3.0
     Compiling regex v0.1.41
     Compiling hello_world v0.1.0 (file:///path/to/package/hello_world)
```

在 `Cargo.lock` 中包含了我们项目使用的所有依赖的准确版本信息。这个非常重要，未来就算 `regexp` 的作者升级了该包，我们依然会下载 `Cargo.lock` 中的版本，而不是最新的版本，只有这样，才能保证项目依赖包不会莫名其妙的因为更新升级导致无法编译。 当然，你还可以使用 `cargo update` 来手动更新包的版本。

此时，就可以在 `src/main.rs` 中使用新引入的 `regexp` 包:

```rust
use regex::Regex;

fn main() {
    let re = Regex::new(r"^\d{4}-\d{2}-\d{2}$").unwrap();
    println!("Did our date match? {}", re.is_match("2014-01-01"));
}
```

运行后输出:

```shell
$ cargo run
   Running `target/hello_world`
Did our date match? true
```



================================================
FILE: src/cargo/guide/download-package.md
================================================
# 下载并构建 Package

如果看中 `GitHub` 上的某个开源 Rust 项目，那下载并构建它将是非常简单的。

```shell
$ git clone https://github.com/rust-lang/regex.git
$ cd regex
```

如上所示，直接从 `GitHub` 上克隆下来想要的项目，然后使用 `cargo build` 进行构建即可：

```shell
$ cargo build
   Compiling regex v1.5.0 (file:///path/to/package/regex)
```

该命令将下载相关的依赖库，等下载成功后，再对 `package` 和下载的依赖进行一同的编译构建。

这就是包管理工具的强大之处，`cargo build` 搞定一切，而背后隐藏的复杂配置、参数你都无需关心。




================================================
FILE: src/cargo/guide/intro.md
================================================
# 使用手册

在本章中，我们将学习 `Cargo` 的详细使用方式，例如 `Package` 的创建与管理、依赖拉取、`Package` 结构描述等。




================================================
FILE: src/cargo/guide/package-layout.md
================================================
# 标准的 Package 目录结构

一个典型的 `Package` 目录结构如下：

```shell
.
├── Cargo.lock
├── Cargo.toml
├── src/
│   ├── lib.rs
│   ├── main.rs
│   └── bin/
│       ├── named-executable.rs
│       ├── another-executable.rs
│       └── multi-file-executable/
│           ├── main.rs
│           └── some_module.rs
├── benches/
│   ├── large-input.rs
│   └── multi-file-bench/
│       ├── main.rs
│       └── bench_module.rs
├── examples/
│   ├── simple.rs
│   └── multi-file-example/
│       ├── main.rs
│       └── ex_module.rs
└── tests/
    ├── some-integration-tests.rs
    └── multi-file-test/
        ├── main.rs
        └── test_module.rs
```

这也是 `Cargo` 推荐的目录结构，解释如下：

- `Cargo.toml` 和 `Cargo.lock` 保存在 `package` 根目录下
- 源代码放在 `src` 目录下
- 默认的 `lib` 包根是 `src/lib.rs`
- 默认的二进制包根是 `src/main.rs`
  - 其它二进制包根放在 `src/bin/` 目录下
- 基准测试 benchmark 放在 `benches` 目录下
- 示例代码放在 `examples` 目录下
- 集成测试代码放在 `tests` 目录下

关于 Rust 中的包和模块，[之前的章节](https://course.rs/basic/crate-module/intro.html)有更详细的解释。

此外，`bin`、`tests`、`examples` 等目录路径都可以通过配置文件进行配置，它们被统一称之为 [Cargo Target](https://course.rs/cargo/reference/cargo-target.html)。




================================================
FILE: src/cargo/guide/tests-ci.md
================================================
[Binary file]


================================================
FILE: src/cargo/guide/why-exist.md
================================================
# 为何会有 Cargo

根据之前学习的知识，Rust 有两种类型的包: 库包和二进制包，前者是我们经常使用的依赖包，用于被其它包所引入，而后者是一个应用服务，可以编译成二进制可执行文件进行运行。

包是通过 Rust 编译器 `rustc` 进行编译的:

```rust
$ rustc hello.rs
$ ./hello
Hello, world!
```

上面我们直接使用 `rustc` 对二进制包 `hello.rs` 进行编译，生成二进制可执行文件 `hello`，并对其进行运行。

该方式虽然简单，但有几个问题：

- 必须要指定文件名编译，当项目复杂后，这种编译方式也随之更加复杂
- 如果要指定编译参数，情况将更加复杂

最关键的是，外部依赖库的引入也将是一个大问题。大部分实际的项目都有不少依赖包，而这些依赖包又间接的依赖了新的依赖包，在这种复杂情况下，如何管理依赖包及其版本也成为一个相当棘手的问题。

正是因为这些原因，与其使用 `rustc` ，我们可以使用一个强大的包管理工具来解决问题：欢迎 `Cargo` 闪亮登场。

## Cargo

`Cargo` 解决了之前描述的所有问题，同时它保证了每次重复的构建都不会改变上一次构建的结果，这背后是通过完善且强大的依赖包版本管理来实现的。

总之，`Cargo` 为了实现目标，做了四件事：

- 引入两个元数据文件，包含项目的方方面面信息: `Cargo.toml` 和 `Cargo.lock`
- 获取和构建项目的依赖，例如 `Cargo.toml` 中的依赖包版本描述，以及从 `crates.io` 下载包
- 调用 `rustc` (或其它编译器) 并使用的正确的参数来构建项目，例如 `cargo build`
- 引入一些惯例，让项目的使用更加简单

毫不夸张的说，得益于 `Cargo` 的标准化，只要你使用它构建过一个项目，那构建其它使用 `Cargo` 的项目，也将不存在任何困难。




================================================
FILE: src/cargo/reference/cargo-target.md
================================================
# Cargo Target

**Cargo 项目中包含有一些对象，它们包含的源代码文件可以被编译成相应的包，这些对象被称之为 Cargo Target**。例如[之前章节](https://course.rs/cargo/guide/package-layout.html)提到的库对象 `Library` 、二进制对象 `Binary`、示例对象 `Examples`、测试对象 `Tests` 和 基准性能对象 `Benches` 都是 Cargo Target。

本章节我们一起来看看该如何在 `Cargo.toml` 清单中配置这些对象，当然，大部分时候都无需手动配置，因为默认的配置通常由项目目录的布局自动推断出来。

## 对象介绍

在开始讲解如何配置对象前，我们先来看看这些对象究竟是什么，估计还有些同学对此有些迷糊 :)

#### 库对象(Library)

库对象用于定义一个库，该库可以被其它的库或者可执行文件所链接。**该对象包含的默认文件名是 `src/lib.rs`，且默认情况下，库对象的名称[跟项目名是一致的](https://course.rs/basic/crate-module/crate.html#package)**，

一个工程只能有一个库对象，因此也只能有一个 `src/lib.rs` 文件，以下是一种自定义配置:

```shell
# 一个简单的例子：在 Cargo.toml 中定制化库对象
[lib]
crate-type = ["cdylib"]
bench = false
```

#### 二进制对象(Binaries)

二进制对象在被编译后可以生成可执行的文件，默认的文件名是 `src/main.rs`，二进制对象的名称跟项目名也是相同的。

大家应该还记得，一个项目拥有多个二进制文件，因此一个项目可以拥有多个二进制对象。当拥有多个对象时，对象的文件默认会被放在 `src/bin/` 目录下。

二进制对象可以使用库对象提供的公共 API，也可以通过 `[dependencies]` 来引入外部的依赖库。

我们可以使用 `cargo run --bin <bin-name>` 的方式来运行指定的二进制对象，以下是二进制对象的配置示例：

```toml
# Example of customizing binaries in Cargo.toml.
[[bin]]
name = "cool-tool"
test = false
bench = false

[[bin]]
name = "frobnicator"
required-features = ["frobnicate"]
```

#### 示例对象(Examples)

示例对象的文件在根目录下的 `examples` 目录中。既然是示例，自然是使用项目中的库对象的功能进行演示。示例对象编译后的文件会存储在 `target/debug/examples` 目录下。

如上所示，示例对象可以使用库对象的公共 API，也可以通过 `[dependencies]` 来引入外部的依赖库。

默认情况下，示例对象都是可执行的二进制文件( 带有 `fn main()` 函数入口)，毕竟例子是用来测试和演示我们的库对象，是用来运行的。而你完全可以将示例对象改成库的类型:

```toml
[[example]]
name = "foo"
crate-type = ["staticlib"]
```

如果想要指定运行某个示例对象，可以使用 `cargo run --example <example-name>` 命令。如果是库类型的示例对象，则可以使用 `cargo build --example <example-name>` 进行构建。

与此类似，还可以使用 `cargo install --example <example-name>` 来将示例对象编译出的可执行文件安装到默认的目录中，将该目录添加到 `$PATH` 环境变量中，就可以直接全局运行安装的可执行文件。

最后，`cargo test` 命令默认会对示例对象进行编译，以防止示例代码因为长久没运行，导致严重过期以至于无法运行。

#### 测试对象(Tests)

测试对象的文件位于根目录下的 `tests` 目录中，如果大家还有印象的话，就知道该目录是[集成测试](https://course.rs/test/unit-integration-test.html#集成测试)所使用的。

当运行 `cargo test` 时，里面的每个文件都会被编译成独立的包，然后被执行。

测试对象可以使用库对象提供的公共 API，也可以通过 `[dependencies]` 来引入外部的依赖库。

#### 基准性能对象(Benches)

该对象的文件位于 `benches` 目录下，可以通过 `cargo bench` 命令来运行，关于基准测试，可以通过[这篇文章](https://course.rs/test/benchmark.html)了解更多。

## 配置一个对象

我们可以通过 `Cargo.toml` 中的 `[lib]`、`[[bin]]`、`[[example]]`、`[[test]]` 和 `[[bench]]` 部分对以上对象进行配置。

> 大家可能会疑惑 `[lib]` 和 `[[bin]]` 的写法为何不一致，原因是这种语法是 `TOML` 提供的[数组特性](https://toml.io/en/v1.0.0-rc.3#array-of-tables)， `[[bin]]` 这种写法意味着我们可以在 Cargo.toml 中创建多个 `[[bin]]` ，每一个对应一个二进制文件
>
> 上文提到过，我们只能指定一个库对象，因此这里只能使用 `[lib]` 形式

由于它们的配置内容都是相似的，因此我们以 `[lib]` 为例来说明相应的配置项:

```toml
[lib]
name = "foo"           # 对象名称: 库对象、`src/main.rs` 二进制对象的名称默认是项目名
path = "src/lib.rs"    # 对象的源文件路径
test = true            # 能否被测试，默认是 true
doctest = true         # 文档测试是否开启，默认是 true
bench = true           # 基准测试是否开启
doc = true             # 文档功能是否开启
plugin = false         # 是否可以用于编译器插件(deprecated).
proc-macro = false     # 是否是过程宏类型的库
harness = true         # 是否使用libtest harness : https://doc.rust-lang.org/stable/rustc/tests/index.html
edition = "2015"       # 对象使用的 Rust Edition
crate-type = ["lib"]   # 生成的包类型
required-features = [] # 构建对象所需的 Cargo Features (N/A for lib).
```

#### name

对于库对象和默认的二进制对象( `src/main.rs `)，默认的名称是项目的名称( `package.name` )。

对于其它类型的对象，默认是目录或文件名。

除了 `[lib]` 外，`name` 字段对于其他对象都是必须的。

#### proc-macro

该字段的使用方式在[过程宏章节](https://course.rs/advance/macro.html#定义过程宏)有详细的介绍。

#### edition

对使用的 Rust Edition 版本进行设置。

如果没有设置，则默认使用 `[package]` 中配置的 `package.edition`，通常来说，这个字段不应该被单独设置，只有在一些特殊场景中才可能用到：例如将一个大型项目逐步升级为新的 edition 版本。

#### crate-type

该字段定义了对象生成的[包类型](https://doc.rust-lang.org/stable/reference/linkage.html)。它是一个数组，因此为同一个对象指定多个包类型。

需要注意的是，只有库对象和示例对象可以被指定，因为其他的二进制、测试和基准测试对象只能是 `bin` 这个包类型。

默认的包类型如下:

| 对象           | 包类型       |
| -------------- | ------------ |
| 正常的库对象   | "lib"        |
| 过程宏的库对象 | "proc-macro" |
| 示例对象       | "bin"        |

可用的选项包括 `bin`、`lib`、`rlib`、`dylib`、`cdylib`、`staticlib` 和 `proc-macro` ，如果大家想了解更多，可以看下官方的[参考手册](https://doc.rust-lang.org/stable/reference/linkage.html)。

#### required-features

该字段用于指定在构建对象时所需的 [`features`](https://course.rs/cargo/reference/features.html) 列表。

该字段只对 `[[bin]]`、 `[[bench]]`、 `[[test]]` 和 `[[example]]` 有效，对于 `[lib]` 没有任何效果。

```toml
[features]
# ...
postgres = []
sqlite = []
tools = []

[[bin]]
name = "my-pg-tool"
required-features = ["postgres", "tools"]
```

## 对象自动发现

默认情况下，`Cargo` 会基于项目的[目录文件布局](https://course.rs/cargo/guide/package-layout.html)自动发现和确定对象，而之前的配置项则允许我们对其进行手动的配置修改(若项目布局跟标准的不一样时)。

而这种自动发现对象的设定可以通过以下配置来禁用:

```toml
[package]
# ...
autobins = false
autoexamples = false
autotests = false
autobenches = false
```

只有在特定场景下才应该禁用自动对象发现。例如，你有一个模块想要命名为 `bin`，目录结构如下:

```shell
├── Cargo.toml
└── src
    ├── lib.rs
    └── bin
        └── mod.rs
```

这在默认情况下会导致问题，因为 `Cargo` 会使用 `src/bin` 作为存放二进制对象的地方。

为了阻止这一点，可以设置 `autobins = false` :

```toml
├── Cargo.toml
└── src
    ├── lib.rs
    └── bin
        └── mod.rs
```



================================================
FILE: src/cargo/reference/configuration.md
================================================
# 通过 config.toml 对 Cargo 进行配置

Cargo 相关的配置有两种，第一种是对自身进行配置，第二种是对指定的项目进行配置，关于后者请查看 [Cargo.toml 清单](https://course.rs/cargo/reference/manifest.html)。对于普通用户而言第二种才是我们最常使用的。

本文讲述的是如何对 Cargo 相关的工具进行配置，该配置中的部分内容可能会覆盖掉 `Cargo.toml` 中对应的部分，例如关于 `profile` 的内容。

## 层级结构

在前面我们已经见识过如何为 Cargo 进行全局配置：`$HOME/.cargo/config.toml`，事实上，还支持在一个 `package` 内对它进行配置。

总体原则是：`Cargo` 会顺着当前目录往上查找，直到找到目标配置文件。例如我们在目录 `/projects/foo/bar/baz` 下调用 Cargo 命令，那查找路径如下所示：

- `/projects/foo/bar/baz/.cargo/config.toml`
- `/projects/foo/bar/.cargo/config.toml`
- `/projects/foo/.cargo/config.toml`
- `/projects/.cargo/config.toml`
- `/.cargo/config.toml`
- `$CARGO_HOME/config.toml` 默认是 :
  - Windows: `%USERPROFILE%\.cargo\config.toml`
  - Unix: `$HOME/.cargo/config.toml`

有了这种机制，我们既可以在全局中设置默认的配置，又可以每个包都设定独立的配置，甚至还能做版本控制。

如果一个 `key` 在多个配置中出现，那这些 `key` 只会保留一个：最靠近 Cargo 执行目录的配置文件中的 key 的值将被最终使用(因此， $HOME 下的都是最低优先级)。**需要注意的是，如果 `key` 的值是数组，那相应的值将被合并( join )**。

对于工作空间而言，`Cargo` 的搜索策略是从 root 开始，对于内部成员中包含的 `.cargo.toml` 会自动忽略。例如一个工作空间拥有两个成员，每个成员都有配置文件: `/projects/foo/bar/baz/mylib/.cargo/config.toml` 和 `/projects/foo/bar/baz/mybin/.cargo/config.toml`，但是 `Cargo` 并不会读取它们而是从工作空间的根( `/projects/foo/bar/baz/` )开始往上查找。

> 注意：Cargo 还支持没有 `.toml` 后缀的 `.cargo/config` 文件。对于 `.toml` 的支持是从 Rust 1.39 版本开始，同时也是目前最推荐的方式。**但若同时存在有后缀和无后缀的文件，Cargo 将使用无后缀的!**

## 配置文件概览

下面是一个完整的配置文件，并对**常用的选项**进行了翻译，大家可以参考下:

```toml
paths = ["/path/to/override"] # 覆盖 `Cargo.toml` 中通过 path 引入的本地依赖

[alias]     # 命令别名
b = "build"
c = "check"
t = "test"
r = "run"
rr = "run --release"
space_example = ["run", "--release", "--", "\"command list\""]

[build]
jobs = 1                      # 并行构建任务的数量，默认等于 CPU 的核心数
rustc = "rustc"               # rust 编译器
rustc-wrapper = "…"           # 使用该 wrapper 来替代 rustc
rustc-workspace-wrapper = "…" # 为工作空间的成员使用 该 wrapper 来替代 rustc
rustdoc = "rustdoc"           # 文档生成工具
target = "triple"             # 为 target triple 构建 ( `cargo install` 会忽略该选项)
target-dir = "target"         # 存放编译输出结果的目录
rustflags = ["…", "…"]        # 自定义flags，会传递给所有的编译器命令调用
rustdocflags = ["…", "…"]     # 自定义flags，传递给 rustdoc
incremental = true            # 是否开启增量编译
dep-info-basedir = "…"        # path for the base directory for targets in depfiles
pipelining = true             # rustc pipelining

[doc]
browser = "chromium"          # `cargo doc --open` 使用的浏览器,
                              # 可以通过 `BROWSER` 环境变量进行重写

[env]
# Set ENV_VAR_NAME=value for any process run by Cargo
ENV_VAR_NAME = "value"
# Set even if already present in environment
ENV_VAR_NAME_2 = { value = "value", force = true }
# Value is relative to .cargo directory containing `config.toml`, make absolute
ENV_VAR_NAME_3 = { value = "relative/path", relative = true }

[cargo-new]
vcs = "none"              # 所使用的 VCS  ('git', 'hg', 'pijul', 'fossil', 'none')

[http]
debug = false               # HTTP debugging
proxy = "host:port"         # HTTP 代理，libcurl 格式
ssl-version = "tlsv1.3"     # TLS version to use
ssl-version.max = "tlsv1.3" # 最高支持的 TLS 版本
ssl-version.min = "tlsv1.1" # 最小支持的 TLS 版本
timeout = 30                # HTTP 请求的超时时间，秒
low-speed-limit = 10        # 网络超时阈值 (bytes/sec)
cainfo = "cert.pem"         # path to Certificate Authority (CA) bundle
check-revoke = true         # check for SSL certificate revocation
multiplexing = true         # HTTP/2 multiplexing
user-agent = "…"            # the user-agent header

[install]
root = "/some/path"         # `cargo install` 安装到的目标目录

[net]
retry = 2                   # 网络重试次数
git-fetch-with-cli = true   # 是否使用 `git` 命令来执行 git 操作
offline = true              # 不能访问网络

[patch.<registry>]
# Same keys as for [patch] in Cargo.toml

[profile.<name>]         # profile 配置，详情见"如何在 Cargo.toml 中配置 profile" : https://course.rs/cargo/reference/profiles.html#profile设置
opt-level = 0
debug = true
split-debuginfo = '...'
debug-assertions = true
overflow-checks = true
lto = false
panic = 'unwind'
incremental = true
codegen-units = 16
rpath = false
[profile.<name>.build-override]
[profile.<name>.package.<name>]

[registries.<name>]  # 设置其它的注册服务： https://course.rs/cargo/reference/specify-deps.html#从其它注册服务引入依赖包
index = "…"          # 注册服务索引列表的 URL
token = "…"          # 连接注册服务所需的鉴权 token

[registry]
default = "…"        # 默认的注册服务名称: crates.io
token = "…"

[source.<name>]      # 注册服务源和替换source definition and replacement
replace-with = "…"   # 使用给定的 source 来替换当前的 source，例如使用科大源来替换crates.io源以提升国内的下载速度：[source.crates-io] replace-with = 'ustc'
directory = "…"      # path to a directory source
registry = "…"       # 注册源的 URL ，例如科大源: [source.ustc] registry = "git://mirrors.ustc.edu.cn/crates.io-index"
local-registry = "…" # path to a local registry source
git = "…"            # URL of a git repository source
branch = "…"         # branch name for the git repository
tag = "…"            # tag name for the git repository
rev = "…"            # revision for the git repository

[target.<triple>]
linker = "…"            # linker to use
runner = "…"            # wrapper to run executables
rustflags = ["…", "…"]  # custom flags for `rustc`

[target.<cfg>]
runner = "…"            # wrapper to run executables
rustflags = ["…", "…"]  # custom flags for `rustc`

[target.<triple>.<links>] # `links` build script override
rustc-link-lib = ["foo"]
rustc-link-search = ["/path/to/foo"]
rustc-flags = ["-L", "/some/path"]
rustc-cfg = ['key="value"']
rustc-env = {key = "value"}
rustc-cdylib-link-arg = ["…"]
metadata_key1 = "value"
metadata_key2 = "value"

[term]
verbose = false        # whether cargo provides verbose output
color = 'auto'         # whether cargo colorizes output
progress.when = 'auto' # whether cargo shows progress bar
progress.width = 80    # width of progress bar
```

## 环境变量

除了 `config.toml` 配置文件，我们还可以使用环境变量的方式对 Cargo 进行配置。

配置文件的中的 key `foo.bar` 对应的环境变量形式为 `CARGO_FOO_BAR`，其中的`.`、`-` 被转换成 `_`，且字母都变成大写的。例如，`target.x86_64-unknown-linux-gnu.runner` key 转换成环境变量后变成 `CARGO_TARGET_X86_64_UNKNOWN_LINUX_GNU_RUNNER`。

就优先级而言，环境变量是比配置文件更高的。除了上面的机制，Cargo 还支持一些[预定义的环境变量](https://doc.rust-lang.org/stable/cargo/reference/environment-variables.html)。

> 官方 Cargo Book 中本文的内容还有[很多](https://doc.rust-lang.org/stable/cargo/reference/config.html#configuration-keys)，但是剩余内容对于绝大多数用户都用不到，因此我们并没有涵盖其中。



================================================
FILE: src/cargo/reference/deps-overriding.md
================================================
# 依赖覆盖

依赖覆盖对于本地开发来说，是很常见的，大部分原因都是我们希望在某个包发布到 `crates.io` 之前使用它，例如：

- 你正在同时开发一个包和一个项目，而后者依赖于前者，你希望能在该项目中对正在开发的包进行测试
- 你引入的一个依赖包在 `master` 分支发布了新的代码，恰好修复了某个 bug，因此你希望能单独对该分支进行下测试
- 你即将发布一个包的新版本，为了确保新版本正常工作，你需要对其进行集成测试
- 你为项目的某个依赖包提了一个 PR 并解决了一个重要 bug，在等待合并到 `master` 分支，但是时间不等人，因此你决定先使用自己修改的版本，等未来合并后，再继续使用官方版本

下面我们来具体看看类似的问题该如何解决。

> 上一章节中我们讲了如果通过[多种引用方式](https://course.rs/cargo/reference/specify-deps/intro.html#多引用方式混合)来引入一个包，其实这也是一种依赖覆盖。

## 测试 bugfix 版本

假设我们有一个项目正在使用 [`uuid`](https://crates.io/crates/uuid) 依赖包，但是却不幸地发现了一个 bug，由于这个 bug 影响了使用，没办法等到官方提交新版本，因此还是自己修复为好。

我们项目的 `Cargo.toml` 内容如下：

```toml
[package]
name = "my-library"
version = "0.1.0"

[dependencies]
uuid = "0.8.2"
```

为了修复 `bug`，首先需要将 `uuid` 的源码克隆到本地，笔者是克隆到和项目同级的目录下:

```shell
git clone https://github.com/uuid-rs/uuid
```

下面，修改项目的 `Cargo.toml` 添加以下内容以引入本地克隆的版本:

```toml
[patch.crates-io]
uuid = { path = "../uuid" }
```

这里我们使用自己修改过的 `patch` 来覆盖来自 `crates.io` 的版本，由于克隆下来的 `uuid` 目录和我们的项目同级，因此通过相对路径 "../uuid" 即可定位到。

在成功为 `uuid` 打了本地补丁后，现在尝试在项目下运行 `cargo build`，但是却报错了，而且报错内容有一些看不太懂：

```shell
$ cargo build
    Updating crates.io index
warning: Patch `uuid v1.0.0-alpha.1 (/Users/sunfei/development/rust/demos/uuid)` was not used in the crate graph.
Check that the patched package version and available features are compatible
with the dependency requirements. If the patch has a different version from
what is locked in the Cargo.lock file, run `cargo update` to use the new
version. This may also occur with an optional dependency that is not enabled.
```

具体原因比较复杂，但是仔细观察，会发现克隆下来的 `uuid` 的版本是 `v1.0.0-alpha.1` (在 `"../uuid/Cargo.toml"` 中可以查看)，然后我们本地引入的 `uuid` 版本是 `0.8.2`，根据之前讲过的 `crates.io` 的[版本规则](https://course.rs/cargo/reference/specify-deps/intro.html#从-cratesio-引入依赖包)，这两者是不兼容的，`0.8.2` 只能升级到 `0.8.z`，例如 `0.8.3`。

既然如此，我们先将 "../uuid/Cargo.toml" 中的 `version = "1.0.0-alpha.1"` 修改为 `version = "0.8.3"` ，然后看看结果先:

```shell
$ cargo build
    Updating crates.io index
   Compiling uuid v0.8.3 (/Users/sunfei/development/rust/demos/uuid)
```

大家注意到最后一行了吗？我们成功使用本地的 `0.8.3` 版本的 `uuid` 作为最新的依赖，因此也侧面证明了，补丁 `patch` 的版本也必须遵循相应的版本兼容规则！

如果修改后还是有问题，大家可以试试以下命令，指定版本进行更新:

```shell
% cargo update -p uuid --precise 0.8.3
    Updating crates.io index
    Updating uuid v0.8.3 (/Users/sunfei/development/rust/demos/uuid) -> v0.8.3
```

修复 bug 后，我们可以提交 pr 给 `uuid`，一旦 pr 被合并到了 `master` 分支，你可以直接通过以下方式来使用补丁:

```toml
[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid' }
```

等未来新的内容更新到 `crates.io` 后，大家就可以移除这个补丁，直接更新 `[dependencies]` 中的 `uuid` 版本即可！

## 使用未发布的小版本

还是 `uuid` 包，这次假设我们要为它新增一个特性，同时我们已经修改完毕，在本地测试过，并提交了相应的 pr，下面一起来看看该如何在它发布到 `crates.io` 之前继续使用。

再做一个假设，对于 `uuid` 来说，目前 `crates.io` 上的版本是 `1.0.0`，在我们提交了 pr 并合并到 `master` 分支后，`master` 上的版本变成了 `1.0.1`，这意味着未来 `crates.io` 上的版本也将变成 `1.0.1`。

为了使用新加的特性，同时当该包在未来发布到 `crates.io` 后，我们可以自动使用 `crates.io` 上的新版本，而无需再使用 `patch` 补丁，可以这样修改 `Cargo.toml`：

```toml
[package]
name = "my-library"
version = "0.1.0"

[dependencies]
uuid = "1.0.1"

[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid' }
```

注意，我们将 `[dependencies]` 中的 `uuid` 版本提前修改为 `1.0.1`，由于该版本在 `crates.io` 尚未发布，因此 `patch` 版本会被使用。

现在，我们的项目是基于 `patch` 版本的 `uuid` 来构建，也就是从 `gihtub` 的 `master` 分支中拉取最新的 `commit` 来构建。一旦未来 `crates.io` 上有了 `1.0.1` 版本，那项目就会继续基于 `crates.io` 来构建，此时，`patch` 就可以删除了。

#### 间接使用 `patch`

现在假设项目 `A` 的依赖是 `B` 和 `uuid`，而 `B` 的依赖也是 `uuid`，此时我们可以让 `A` 和 `B` 都使用来自 `GitHub` 的 `patch` 版本，配置如下:

```toml
[package]
name = "my-binary"
version = "0.1.0"

[dependencies]
my-library = { git = 'https://example.com/git/my-library' }
uuid = "1.0.1"

[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid' }
```

如上所示，`patch` 不仅仅对于 `my-binary` 项目有用，对于 `my-binary` 的依赖 `my-library` 来说，一样可以间接生效。

#### 非 crates.io 的 patch

若我们想要覆盖的依赖并不是来自 `crates.io` ，就需要对 `[patch]` 做一些修改。例如依赖是 `git` 仓库，然后使用本地路径来覆盖它:

```toml
[patch."https://github.com/your/repository"]
my-library = { path = "../my-library/path" }
```

easy，轻松搞定!

## 使用未发布的大版本

现在假设我们要发布一个大版本 `2.0.0`，与之前类似，可以将 `Cargo.toml` 修改如下:

```toml
[dependencies]
uuid = "2.0"

[patch.crates-io]
uuid = { git = "https://github.com/uuid-rs/uuid", branch = "2.0.0" }
```

此时 `2.0` 版本在 `crates.io` 上还不存在，因此我们使用了 `patch` 版本且指定了 `branch = "2.0.0"`。

#### 间接使用 `patch`

这里需要注意，**与之前的小版本不同，大版本的 `patch` 不会发生间接的传递！**，例如：

```toml
[package]
name = "my-binary"
version = "0.1.0"

[dependencies]
my-library = { git = 'https://example.com/git/my-library' }
uuid = "1.0"

[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid', branch = '2.0.0' }
```

以上配置中, `my-binary` 将继续使用 `1.x.y` 系列的版本，而 `my-library` 将使用最新的 `2.0.0` patch。

原因是，大版本更新往往会带来破坏性的功能，Rust 为了让我们平稳的升级，采用了滚动的方式：在依赖图中逐步推进更新，而不是一次性全部更新。

## 多版本[patch]

在之前章节，我们介绍过如何使用 `package key` 来[重命名依赖包](https://course.rs/cargo/reference/specify-deps/intro.html#在-cargotoml-中重命名依赖)，现在来看看如何使用它同时引入多个 `patch`。

假设，我们对 `serde` 有两个新的 `patch` 需求:

- `serde` 官方解决了一个 `bug` 但是还没发布到 `crates.io`，我们想直接从 `git` 仓库的最新 `commit` 拉取版本 `1.*`
- 我们自己为 `serde` 添加了新的功能，命名为 `2.0.0` 版本，并将该版本上传到自己的 `git` 仓库中

为了满足这两个 `patch`，可以使用如下内容的 `Cargo.toml`：

```toml
[patch.crates-io]
serde = { git = 'https://github.com/serde-rs/serde' }
serde2 = { git = 'https://github.com/example/serde', package = 'serde', branch = 'v2' }
```

第一行说明，第一个 `patch` 从官方仓库 `main` 分支的最新 `commit` 拉取，而第二个则从我们自己的仓库拉取 `v2` 分支，同时将其重命名为 `serde2`。

这样，在代码中就可以分别通过 `serde` 和 `serde2` 引用不同版本的依赖库了。

## 通过[path]来覆盖依赖

有时我们只是临时性地对一个项目进行处理，因此并不想去修改它的 `Cargo.toml`。此时可以使用 `Cargo` 提供的路径覆盖方法: **注意，这个方法限制较多，如果可以，还是要使用 [patch]**。

与 `[patch]` 修改 `Cargo.toml` 不同，路径覆盖修改的是 `Cargo` 自身的[配置文件](https://course.rs/cargo/guide/cargo-cache.html#cargo-home) `$Home/.cargo/config.toml`:

```toml
paths = ["/path/to/uuid"]
```

`paths` 数组中的元素是一个包含 `Cargo.toml` 的目录(依赖包)，在当前例子中，由于我们只有一个 `uuid`，因此只需要覆盖它即可。目标路径可以是相对的，也是绝对的，需要注意，如果是相对路径，那是相对包含 `.cargo` 的 `$Home` 来说的。

## 不推荐的[replace]

> `[replace]` 已经被标记为 `deprecated`，并将在未来被移除，请使用 `[patch]` 替代

虽然不建议使用，但是如果大家阅读其它项目时依然可能会碰到这种用法:

```toml
[replace]
"foo:0.1.0" = { git = 'https://github.com/example/foo' }
"bar:1.0.2" = { path = 'my/local/bar' }
```

语法看上去还是很清晰的，`[replace]` 中的每一个 `key` 都是 `Package ID` 格式，通过这种写法可以在依赖图中任意挑选一个节点进行覆盖。



================================================
FILE: src/cargo/reference/env.md
================================================
# 环境变量



================================================
FILE: src/cargo/reference/intro.md
================================================
# 进阶指南

进阶指南包含了 Cargo 的参考级内容，大家可以先看一遍了解下大概有什么，然后在后面需要时，再回来查询如何使用。




================================================
FILE: src/cargo/reference/manifest.md
================================================
# Cargo.toml 格式讲解

`Cargo.toml` 又被称为清单( `manifest` )，文件格式是 `TOML`，每一个清单文件都由以下部分组成：

- [`cargo-features`](unstable.md) — 只能用于 `nightly`版本的 `feature`
- [`[package]`](#package) — 定义项目( `package` )的元信息
  - [`name`](#name) — 名称
  - [`version`](#version) — 版本
  - [`authors`](#authors) — 开发作者
  - [`edition`](#edition) — Rust edition.
  - [`rust-version`](#rust-version) — 支持的最小化 Rust 版本
  - [`description`](#description) — 描述
  - [`documentation`](#documentation) — 文档 URL
  - [`readme`](#readme) — README 文件的路径
  - [`homepage`](#homepage) - 主页 URL
  - [`repository`](#repository) — 源代码仓库的 URL
  - [`license`](#license和license-file) — 开源协议 License.
  - [`license-file`](#license和license-file) — License 文件的路径.
  - [`keywords`](#keywords) — 项目的关键词
  - [`categories`](#categories) — 项目分类
  - [`workspace`](#workspace) — 工作空间 workspace 的路径
  - [`build`](#build) — 构建脚本的路径
  - [`links`](#links) — 本地链接库的名称
  - [`exclude`](#exclude和include) — 发布时排除的文件
  - [`include`](#exclude和include) — 发布时包含的文件
  - [`publish`](#the-publish-field) — 用于阻止项目的发布
  - [`metadata`](#metadata) — 额外的配置信息，用于提供给外部工具
  - [`default-run`](#default-run) — [`cargo run`] 所使用的默认可执行文件( binary )
  - [`autobins`](https://course.rs/cargo/reference/cargo-target.html#对象自动发现) — 禁止可执行文件的自动发现
  - [`autoexamples`](https://course.rs/cargo/reference/cargo-target.html#对象自动发现) — 禁止示例文件的自动发现
  - [`autotests`](https://course.rs/cargo/reference/cargo-target.html#对象自动发现) — 禁止测试文件的自动发现
  - [`autobenches`](https://course.rs/cargo/reference/cargo-target.html#对象自动发现) — 禁止 bench 文件的自动发现
  - [`resolver`](resolver.md#resolver-versions) — 设置依赖解析器( dependency resolver)
- Cargo Target 列表: (查看 [Target 配置](https://course.rs/cargo/reference/cargo-target.html#Target配置) 获取详细设置)
  - [`[lib]`](https://course.rs/cargo/reference/cargo-target.html#库对象library) — Library target 设置.
  - [`[[bin]]`](https://course.rs/cargo/reference/cargo-target.html#二进制对象binaries) — Binary target 设置.
  - [`[[example]]`](https://course.rs/cargo/reference/cargo-target.html#示例对象examples) — Example target 设置.
  - [`[[test]]`](https://course.rs/cargo/reference/cargo-target.html#测试对象tests) — Test target 设置.
  - [`[[bench]]`](https://course.rs/cargo/reference/cargo-target.html#基准性能对象benches) — Benchmark target 设置.
- Dependency tables:
  - [`[dependencies]`](https://course.rs/cargo/reference/specify-deps.html) — 项目依赖包
  - [`[dev-dependencies]`](https://course.rs/cargo/reference/specify-deps.html#dev-dependencies) — 用于 examples、tests 和 benchmarks 的依赖包
  - [`[build-dependencies]`](https://course.rs/cargo/reference/specify-deps.html#build-dependencies) — 用于构建脚本的依赖包
  - [`[target]`](https://course.rs/cargo/reference/specify-deps.html#根据平台引入依赖) — 平台特定的依赖包
- [`[badges]`](#badges) — 用于在注册服务(例如 crates.io ) 上显示项目的一些状态信息，例如当前的维护状态：活跃中、寻找维护者、deprecated
- [`[features]`](https://course.rs/cargo/reference/features/intro.html) — `features` 可以用于条件编译
- [`[patch]`](https://course.rs/cargo/reference/deps-overriding.html) — 推荐使用的依赖覆盖方式
- [`[replace]`](https://course.rs/cargo/reference/deps-overriding.html#不推荐的replace) — 不推荐使用的依赖覆盖方式 (deprecated).
- [`[profile]`](https://course.rs/cargo/reference/profiles.html) — 编译器设置和优化
- [`[workspace]`](https://course.rs/cargo/reference/workspaces.html) — 工作空间的定义

下面，我们将对其中一些部分进行详细讲解。

## [package]

`Cargo.toml` 中第一个部分就是 `package`，用于设置项目的相关信息：

```toml
[package]
name = "hello_world" # the name of the package
version = "0.1.0"    # the current version, obeying semver
authors = ["Alice <a@example.com>", "Bob <b@example.com>"]
```

其中，只有 `name` 和 `version` 字段是**必须填写的**。当发布到注册服务时，可能会有额外的字段要求，具体参见[发布到 crates.io](publishing-on-crates.io.md)。

#### name

项目名用于引用一个项目( `package` )，它有几个用途：

- 其它项目引用我们的 `package` 时，会使用该 `name`
- 编译出的可执行文件(bin target)的默认名称

`name` 只能使用 [`alphanumeric`](https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_alphanumeric) 字符、 `-` 和 `_`，并且不能为空。

事实上，`name` 的限制不止如此，例如:

- **当使用 `cargo new` 或 `cargo init` 创建时**，`name` 还会被施加额外的限制，例如不能使用 Rust 关键字名称作为 `name`
- **如果要发布到 `crates.io` ，那还有更多的限制**: `name` 使用 `ASCII` 码，不能使用已经被使用的名称，例如 `uuid` 已经在 `crates.io` 上被使用，因此我们只能使用类如 `uuid_v1` 的名称，才能将项目发布到 `crates.io` 上

#### version

Cargo 使用了[语义化版本控制](https://semver.org)的概念，例如字符串 `"0.1.12"` 是一个 `semver` 格式的版本号，符合 `"x.y.z"` 的形式，其中 `x` 被称为主版本`major`, `y` 被称为小版本 `minor` ，而 `z` 被称为补丁 `patch`，可以看出从左到右，版本的影响范围逐步降低，补丁的更新是无关痛痒的，并不会造成 API 的兼容性被破坏。

使用该规则，你还需要遵循一些基本规则:

- 使用标准的 `x.y.z` 形式的版本号，例如 `1.0.0` 而不是 `1.0`
- 在版本到达 `1.0.0` 之前，怎么都行，但是如果有破坏性变更( breaking changes )，需要增加 `minor` 版本号。例如，为结构体新增字段或为枚举新增成员就是一种破坏性变更
- 在 `1.0.0` 之后，如果发生破坏性变更，需要增加 `major` 版本号
- 在 `1.0.0` 之后不要去破坏构建流程
- 在 `1.0.0` 之后，不要在 `patch` 更新中添加新的 `api` ( `pub` 声明)，如果要添加新的 `pub` 结构体、特征、类型、函数、方法等对象时，增加 `minor` 版本号

如果大家想知道 Rust 如何使用版本号来解析依赖，可以查看[这里](https://doc.rust-lang.org/stable/cargo/reference/resolver.html)。同时 [SemVer 兼容性](https://doc.rust-lang.org/stable/cargo/reference/semver.html) 提供了更为详尽的破坏性变更列表。

#### authors

```toml
[package]
authors = ["Sunfei <contact@im.dev>"]
```

该字段仅用于项目的元信息描述和 `build.rs` 用到的 `CARGO_PKG_AUTHORS` 环境变量，它并不会显示在 `crates.io` 界面上。

> 警告：清单中的 `[package]` 部分一旦发布到 `crates.io` 就无法进行更改，因此对于已发布的包来说，`authors` 字段是无法修改的

#### edition

可选字段，用于指定项目所使用的 [Rust Edition](https://course.rs/appendix/rust-version.html)。

该配置将影响项目中的所有 `Cargo Target` 和包，前者包含测试用例、benchmark、可执行文件、示例等。

```toml
[package]
# ...
edition = '2021'
```

大多数时候，我们都无需手动指定，因为 `cargo new` 的时候，会自动帮我们添加。若 `edition` 配置不存在，那 `2015 Edition` 会被默认使用。

#### rust-version

可选字段，用于说明你的项目支持的最低 Rust 版本(编译器能顺利完成编译)。一旦你使用的 Rust 版本比这个字段设置的要低，`Cargo` 就会报错，然后告诉用户所需的最低版本。

该字段是在 Rust 1.56 引入的，若大家使用的 Rust 版本低于该版本，则该字段会被自动忽略时。

```toml
[package]
# ...
edition = '2021'
rust-version = "1.56"
```

还有一点，`rust-version` 必须比第一个引入 `edition` 的 Rust 版本要新。例如 Rust Edition 2021 是在 Rust 1.56 版本引入的，若你使用了 `edition = '2021'` 的 `[package]` 配置，则指定的 `rust version` 字段必须要要大于等于 `1.56` 版本。

还可以使用 `--ignore-rust-version` 命令行参数来忽略 `rust-version`。

该字段将影响项目中的所有 `Cargo Target` 和包，前者包含测试用例、benchmark、可执行文件、示例等。

## description

该字段是项目的简介，`crates.io` 会在项目首页使用该字段包含的内容，**不支持 `Markdown` 格式**。

```toml
[package]
# ...
description = "A short description of my package"
```

> 注意: 若发布 `crates.io` ，则该字段是必须的

## documentation

该字段用于说明项目文档的地址，若没有设置，`crates.io` 会自动链接到 `docs.rs` 上的相应页面。

```toml
[package]
# ...
documentation = "https://docs.rs/bitflags"
```

#### readme

`readme` 字段指向项目的 `README.md` 文件，该文件应该存在项目的根目录下(跟 `Cargo.toml` 同级)，用于向用户描述项目的详细信息，支持 `Markdown` 格式。大家看到的 `crates.io` 上的项目首页就是基于该文件的内容进行渲染的。

```toml
[package]
# ...
readme = "README.md"
```

若该字段未设置且项目根目录下存在 `README.md`、`README.txt` 或 `README` 文件，则该文件的名称将被默认使用。

你也可以通过将 `readme` 设置为 `false` 来禁止该功能，若设置为 `true` ，则默认值 `README.md` 将被使用。

#### homepage

该字段用于设置项目主页的 URL:

```toml
[package]
# ...
homepage = "https://serde.rs/"
```

#### repository

设置项目的源代码仓库地址，例如 `GitHub` 链接:

```toml
[package]
# ...
repository = "https://github.com/rust-lang/cargo/"
```

#### license 和 license-file

`license` 字段用于描述项目所遵循的开源协议。而 `license-file` 则用于指定包含开源协议的文件所在的路径(相对于 `Cargo.toml`)。

如果要发布到 `crates.io` ，则该协议必须是 [SPDX2.1 协议表达式](https://spdx.dev/spdx-specification-21-web-version/#h.jxpfx0ykyb60)。同时 `license` 名称必须是来自于 [SPDX 协议列表 3.11](https://github.com/spdx/license-list-data/tree/v3.11)。

SPDX 只支持使用 `AND` 、`OR` 来组合多个开源协议:

```toml
[package]
# ...
license = "MIT OR Apache-2.0"
```

`OR` 代表用户可以任选一个协议进行遵循，而 `AND` 表示用户必须要同时遵循两个协议。还可以通过 `WITH` 来在指定协议之外添加额外的要求:

- `MIT OR Apache-2.0`
- `LGPL-2.1-only AND MIT AND BSD-2-Clause`
- `GPL-2.0-or-later WITH Bison-exception-2.2`

**若项目使用了非标准的协议**，你可以通过指定 `license-file` 字段来替代 `license` 的使用:

```toml
[package]
# ...
license-file = "LICENSE.txt"
```

> 注意：crates.io 要求必须设置 `license` 或 `license-file`

#### keywords

该字段使用字符串数组的方式来指定项目的关键字列表，当用户在 `crates.io` 上搜索时，这些关键字可以提供索引的功能。

```toml
[package]
# ...
keywords = ["gamedev", "graphics"]
```

> 注意：`crates.io` 最多只支持 5 个关键字，每个关键字都必须是合法的 `ASCII` 文本，且需要使用字母作为开头，只能包含字母、数字、`_` 和 `-`，最多支持 20 个字符长度

#### categories

`categories` 用于描述项目所属的类别:

```toml
categories = ["command-line-utilities", "development-tools::cargo-plugins"]
```

> 注意：`crates.io` 最多只支持 5 个类别，目前不支持用户随意自定义类别，你所使用的类别需要跟 [https://crates.io/category_slugs](https://crates.io/category_slugs) 上的类别**精准匹配**。

#### workspace

该字段用于配置当前项目所属的工作空间。

若没有设置，则将沿着文件目录向上寻找，直至找到第一个 设置了 `[workspace]` 的`Cargo.toml`。因此，当一个成员不在工作空间的子目录时，设置该字段将非常有用。

```toml
[package]
# ...
workspace = "path/to/workspace/root"
```

需要注意的是 `Cargo.toml` 清单还有一个 `[workspace]` 部分专门用于设置工作空间，若它被设置了，则 `package` 中的 `workspace` 字段将无法被指定。这是因为一个包无法同时满足两个角色：

- 该包是工作空间的根包(root crate)，通过 `[workspace]` 指定)
- 该包是另一个工作空间的成员，通过 `package.workspace` 指定

若要了解工作空间的更多信息，请参见[这里](https://course.rs/cargo/reference/workspaces.html)。

#### build

`build` 用于指定位于项目根目录中的构建脚本，关于构建脚本的更多信息，可以阅读 [构建脚本](https://course.rs/cargo/reference/build-script/intro.html) 一章。

```toml
[package]
# ...
build = "build.rs"
```

还可以使用 `build = false` 来禁止构建脚本的自动检测。

#### links

用于指定项目链接的本地库的名称，更多的信息请看构建脚本章节的 [links](https://course.rs/cargo/reference/build-script/intro.html#links)

```toml
[package]
# ...
links = "foo"
```

#### exclude 和 include

这两个字段可以用于显式地指定想要包含在外或在内的文件列表，往往用于发布到注册服务时。你可以使用 `cargo package --list` 来检查哪些文件被包含在项目中。

```toml
[package]
# ...
exclude = ["/ci", "images/", ".*"]
```

```toml
[package]
# ...
include = ["/src", "COPYRIGHT", "/examples", "!/examples/big_example"]
```

尽管大家可能没有指定 `include` 或 `exclude`，但是任然会有些规则自动被应用，一起来看看。

若 `include` 没有被指定，则以下文件将被排除在外:

- 项目不是 git 仓库，则所有以 `.` 开头的隐藏文件会被排除
- 项目是 git 仓库，通过 `.gitignore` 配置的文件会被排除

无论 `include` 或 `exclude` 是否被指定，以下文件都会被排除在外:

- 任何包含 `Cargo.toml` 的子目录会被排除
- 根目录下的 `target` 目录会被排除

以下文件会永远被 `include` ，你无需显式地指定：

- `Cargo.toml`
- 若项目包含可执行文件或示例代码，则最小化的 `Cargo.lock` 会自动被包含
- `license-file` 指定的协议文件

> 这两个字段很强大，但是对于生产实践而言，我们还是推荐通过 `.gitignore` 来控制，因为这样协作者更容易看懂。如果大家希望更深入的了解 `include/exclude`，可以参考下官方的 `Cargo` [文档](https://doc.rust-lang.org/stable/cargo/reference/manifest.html?search=#the-exclude-and-include-fields)

#### publish

该字段常常用于防止项目因为失误被发布到 `crates.io` 等注册服务上，例如如果希望项目在公司内部私有化，你应该设置：

```toml
[package]
# ...
publish = false
```

也可以通过字符串数组的方式来指定允许发布到的注册服务名称:

```toml
[package]
# ...
publish = ["some-registry-name"]
```

若 `publish` 数组中包含了一个注册服务名称，则 `cargo publish` 命令会使用该注册服务，除非你通过 `--registry` 来设定额外的规则。

#### metadata

Cargo 默认情况下会对 `Cargo.toml` 中未使用的 `key` 进行警告，以帮助大家提前发现风险。但是 `package.metadata` 并不在其中，因为它是由用户自定义的提供给外部工具的配置文件。例如：

```toml
[package]
name = "..."
# ...

# 以下配置元数据可以在生成安卓 APK 时使用
[package.metadata.android]
package-name = "my-awesome-android-app"
assets = "path/to/static"
```

与其相似的还有 `[workspace.metadata]`，都可以作为外部工具的配置信息来使用。

#### default-run

当大家使用 `cargo run` 来运行项目时，该命令会使用默认的二进制可执行文件作为程序启动入口。

我们可以通过 `default-run` 来修改默认的入口，例如现在有两个二进制文件 `src/bin/a.rs` 和 `src/bin/b.rs`，通过以下配置可以将入口设置为前者:

```toml
[package]
default-run = "a"
```

## [badges]

该部分用于指定项目当前的状态，该状态会展示在 `crates.io` 的项目主页中，例如以下配置可以设置项目的维护状态:

```toml
[badges]
# `maintenance` 是项目的当前维护状态，它可能会被其它注册服务所使用，但是目前还没有被 `crates.io` 使用:  https://github.com/rust-lang/crates.io/issues/2437
#
# `status` 字段时必须的，以下是可用的选项:
# - `actively-developed`: 新特性正在积极添加中，bug 在持续修复中
# - `passively-maintained`: 目前没有计划去支持新的特性，但是项目维护者可能会回答你提出的 issue
# - `as-is`: 该项目的功能已经完结，维护者不准备继续开发和提供支持了，但是它的功能已经达到了预期
# - `experimental`: 作者希望同大家分享，但是还不准备满足任何人的特殊要求
# - `looking-for-maintainer`: 当前维护者希望将项目转移给新的维护者
# - `deprecated`: 不再推荐使用该项目，需要说明原因以及推荐的替代项目
# - `none`:  不显示任何 badge ，因此维护者没有说明他们的状态，用户需要自己去调查发生了什么
maintenance = { status = "..." }
```

## [dependencies]

在[之前章节](https://course.rs/cargo/reference/specify-deps.html)中，我们已经详细介绍过 `[dependencies]` 、 `[dev-dependencies]` 和 `[build-dependencies]`，这里就不再赘述。

## [profile.*]

该部分可以对编译器进行配置，例如 debug 和优化，在后续的[编译器优化](https://course.rs/cargo/reference/profiles.html)章节有详细介绍。




================================================
FILE: src/cargo/reference/package-id.md
================================================
# Package ID 说明



================================================
FILE: src/cargo/reference/profile.md
================================================
# 发布配置 profile todo



================================================
FILE: src/cargo/reference/profiles.md
================================================
[Binary file]


================================================
FILE: src/cargo/reference/publishing-on-crates.io.md
================================================
[Binary file]


================================================
FILE: src/cargo/reference/specify-deps.md
================================================
# 指定依赖项

我们的项目可以引用在 `crates.io` 或 `GitHub` 上的依赖包，也可以引用存放在本地文件系统中的依赖包。

大家可能会想，直接从前两个引用即可，为何还提供了本地方式？可以设想下，如果你要有一个正处于开发中的包，然后需要在本地的另一个项目中引用测试，那是将该包先传到网上，然后再引用简单，还是直接从本地路径的方式引用简单呢？答案显然不言而喻。

本章节，我们一起来看看有哪些方式可以指定和引用三方依赖包。

## 从 `crates.io` 引入依赖包

默认设置下，`Cargo` 就从 [crates.io](https://crates.io) 上下载依赖包，只需要一个包名和版本号即可：

```toml
[dependencies]
time = "0.1.12"
```

字符串 `"0.1.12"` 是一个 [`semver`](https://semver.org) 格式的版本号，符合 `"x.y.z"` 的形式，其中 `x` 被称为主版本`major`, `y` 被称为小版本 `minor` ，而 `z` 被称为补丁 `patch`，可以看出从左到右，版本的影响范围逐步降低，补丁的更新是无关痛痒的，并不会造成 API 的兼容性被破坏。

`"0.1.12"` 中并没有任何额外的符号，在版本语义上，它跟使用了 `^` 的 `"^0.1.12"` 是相同的，都是指定非常具体的版本进行引入。

但是 `^` 能做的更多。

> npm 使用的就是 `semver` 版本号，从 `JavaScript` 过来的同学应该非常熟悉。

#### `^` 指定版本

与之前的 `"0.1.12"` 不同， `^` 可以指定一个版本号范围，**然后会使用该范围内的最大版本号来引用对应的包**。

只要新的版本号没有修改最左边的非零数字，那该版本号就在允许的版本号范围中。例如 `"^0.1.12"` 最左边的非零数字是 `1`，因此，只要新的版本号是 `"0.1.z"` 就可以落在范围内，而`0.2.0` 显然就没有落在范围内，因此通过 `"^0.1.12"` 引入的依赖包是无法被升级到 `0.2.0` 版本的。

同理，若是 `"^1.0"`，则 `1.1` 在范围中，`2.0` 则不在。 大家思考下，`"^0.0.1"` 与哪些版本兼容？答案是：无，因为它最左边的数字是 `1` ，而该数字已经退无可退，我们又不能修改 `1`，因此没有版本落在范围中。

```shell
^1.2.3  :=  >=1.2.3, <2.0.0
^1.2    :=  >=1.2.0, <2.0.0
^1      :=  >=1.0.0, <2.0.0
^0.2.3  :=  >=0.2.3, <0.3.0
^0.2    :=  >=0.2.0, <0.3.0
^0.0.3  :=  >=0.0.3, <0.0.4
^0.0    :=  >=0.0.0, <0.1.0
^0      :=  >=0.0.0, <1.0.0
```

以上是更多的例子，**事实上，这个规则跟 `SemVer` 还有所不同**，因为对于 `SemVer` 而言，`0.x.y` 的版本是没有其它版本与其兼容的，而对于 Rust，只要版本号 `0.x.y` 满足 ： `z>=y` 且 `x>0` 的条件，那它就能更新到 `0.x.z` 版本。

#### `~` 指定版本

`~` 指定了最小化版本 :

```rust
~1.2.3  := >=1.2.3, <1.3.0
~1.2    := >=1.2.0, <1.3.0
~1      := >=1.0.0, <2.0.0
```

#### `*` 通配符

这种方式允许将 `*` 所在的位置替换成任何数字:

```rust
*     := >=0.0.0
1.*   := >=1.0.0, <2.0.0
1.2.* := >=1.2.0, <1.3.0
```

不过 `crates.io` 并不允许我们只使用孤零零一个 `*` 来指定版本号 : `*`。

#### 比较符

可以使用比较符的方式来指定一个版本号范围或一个精确的版本号:

```rust
>= 1.2.0
> 1
< 2
= 1.2.3
```

同时还能使用比较符进行组合，并通过逗号分隔：

```rust
>= 1.2, < 1.5
```

需要注意，以上的版本号规则仅仅针对 `crate.io` 和基于它搭建的注册服务(例如科大服务源) ，其它注册服务(例如 GitHub )有自己相应的规则。

## 从其它注册服务引入依赖包

为了使用 `crates.io` 之外的注册服务，我们需要对 `$HOME/.cargo/config.toml` ($CARGO_HOME 下) 文件进行配置，添加新的服务提供商，有两种方式可以实现。

> 由于国内访问国外注册服务的不稳定性，我们可以使用[科大的注册服务](http://mirrors.ustc.edu.cn/help/crates.io-index.html)来提升下载速度，以下注册服务的链接都是科大的

**首先是在 `crates.io` 之外添加新的注册服务**，修改 `.cargo/config.toml` 添加以下内容：

```toml
[registries]
ustc = { index = "https://mirrors.ustc.edu.cn/crates.io-index/" }
```

对于这种方式，我们的项目的 `Cargo.toml` 中的依赖包引入方式也有所不同：

```toml
[dependencies]
time = {  registry = "ustc" }
```

在重新配置后，初次构建可能要较久的时间，因为要下载更新 `ustc` 注册服务的索引文件，还挺大的...

注意，这一种使用方式最大的缺点就是在引用依赖包时要指定注册服务: `time = { registry = "ustc" }`。

**而第二种方式就不需要，因为它是直接使用新注册服务来替代默认的 `crates.io`**。

```toml
[source.crates-io]
replace-with = 'ustc'

[source.ustc]
registry = "git://mirrors.ustc.edu.cn/crates.io-index"
```

上面配置中的第一个部分，首先将源 `source.crates-io` 替换为 `ustc`，然后在第二部分指定了 `ustc` 源的地址。

> 注意，如果你要发布包到 `crates.io` 上，那该包的依赖也必须在 `crates.io` 上

#### 引入 git 仓库作为依赖包

若要引入 git 仓库中的库作为依赖包，你至少需要提供一个仓库的地址:

```toml
[dependencies]
regex = { git = "https://github.com/rust-lang/regex" }
```

由于没有指定版本，Cargo 会假定我们使用 `master` 或 `main` 分支的最新 `commit` 。你可以使用 `rev`、`tag` 或 `branch` 来指定想要拉取的版本。例如下面代码拉取了 `next` 分支上的最新 `commit`：

```toml
[dependencies]
regex = { git = "https://github.com/rust-lang/regex", branch = "next" }
```

任何非 `tag` 和 `branch` 的类型都可以通过 `rev` 来引入，例如通过最近一次 `commit` 的哈希值引入: `rev = "4c59b707"`，再比如远程仓库提供的的具名引用: `rev = "refs/pull/493/head"`。

一旦 `git` 依赖被拉取下来，该版本就会被记录到 `Cargo.lock` 中进行锁定。因此 `git` 仓库中后续新的提交不再会被自动拉取，除非你通过 `cargo update` 来升级。需要注意的是锁定一旦被删除，那 Cargo 依然会按照 `Cargo.toml` 中配置的地址和版本去拉取新的版本，如果你配置的版本不正确，那可能会拉取下来一个不兼容的新版本！

**因此不要依赖锁定来完成版本的控制，而应该老老实实的在 `Cargo.toml` 小心配置你希望使用的版本。**

如果访问的是私有仓库，你可能需要授权来访问该仓库，可以查看[这里](https://course.rs/cargo/git-auth.html)了解授权的方式。

#### 通过路径引入本地依赖包

Cargo 支持通过路径的方式来引入本地的依赖包：一般来说，本地依赖包都是同一个项目内的内部包，例如假设我们有一个 `hello_world` 项目( package )，现在在其根目录下新建一个包:

```shell
#  在 hello_world/ 目录下
$ cargo new hello_utils
```

新建的 `hello_utils` 文件夹跟 `src`、`Cargo.toml` 同级，现在修改 `Cargo.toml` 让 `hello_world` 项目引入新建的包:

```toml
[dependencies]
hello_utils = { path = "hello_utils" }
# 以下路径也可以
# hello_utils = { path = "./hello_utils" }
# hello_utils = { path = "../hello_world/hello_utils" }
```

但是，此时的 `hello_world` 是无法发布到 `crates.io` 上的。想要发布，需要先将 `hello_utils` 先发布到 `crates.io` 上，然后再通过 `crates.io` 的方式来引入:

```toml
[dependencies]
hello_utils = { path = "hello_utils", version = "0.1.0" }
```

> 注意！使用 `path` 指定依赖的 package 将无法发布到 `crates.io`，除非 `path` 存在于 [[dev-dependencies]](#dev-dependencies) 中。当然，你还可以使用多种引用混合的方式来解决这个问题，下面将进行介绍

## 多引用方式混合

实际上，我们可以同时使用多种方式来引入同一个包，例如本地引入和 `crates.io` :

```toml
[dependencies]
# 本地使用时，通过 path 引入,
# 发布到 `crates.io` 时，通过 `crates.io` 的方式引入：  version = "1.0"
bitflags = { path = "my-bitflags", version = "1.0" }

# 本地使用时，通过 git 仓库引入
# 当发布时，通过 `crates.io` 引入： version = "1.0"
smallvec = { git = "https://github.com/servo/rust-smallvec", version = "1.0" }

# N.B. 若 version 无法匹配，Cargo 将无法编译
```

这种方式跟下章节将要讲述的依赖覆盖类似，但是前者只会应用到当前声明的依赖包上。

## 根据平台引入依赖

我们还可以根据特定的平台来引入依赖:

```toml
[target.'cfg(windows)'.dependencies]
winhttp = "0.4.0"

[target.'cfg(unix)'.dependencies]
openssl = "1.0.1"

[target.'cfg(target_arch = "x86")'.dependencies]
native = { path = "native/i686" }

[target.'cfg(target_arch = "x86_64")'.dependencies]
native = { path = "native/x86_64" }
```

此处的语法跟 Rust 的 [`#[cfg]`](https://doc.rust-lang.org/stable/reference/conditional-compilation.html) 语法非常相像，因此我们还能使用逻辑操作符进行控制:

```toml
[target.'cfg(not(unix))'.dependencies]
openssl = "1.0.1"
```

这里的意思是，当不是 `unix` 操作系统时，才对 `openssl` 进行引入。

如果你想要知道 `cfg` 能够作用的目标，可以在终端中运行 `rustc --print=cfg` 进行查询。当然，你可以指定平台查询: `rustc --print=cfg --target=x86_64-pc-windows-msvc`，该命令将对 `64bit` 的 Windows 进行查询。

聪明的同学已经发现，这非常类似于条件依赖引入，那我们是不是可以根据自定义的条件来决定是否引入某个依赖呢？具体答案参见后续的 [feature](https://course.rs/cargo/reference/features.html) 章节。这里是一个简单的示例:

```toml
[dependencies]
foo = { version = "1.0", optional = true }
bar = { version = "1.0", optional = true }

[features]
fancy-feature = ["foo", "bar"]
```

但是需要注意的是，你如果妄图通过 `cfg(feature)`、`cfg(debug_assertions)`, `cfg(test)` 和 `cfg(proc_macro)` 的方式来条件引入依赖，那是不可行的。

`Cargo` 还允许通过下面的方式来引入平台特定的依赖:

```toml
[target.x86_64-pc-windows-gnu.dependencies]
winhttp = "0.4.0"

[target.i686-unknown-linux-gnu.dependencies]
openssl = "1.0.1"
```

## 自定义 target 引入

如果你在使用自定义的 `target` ：例如 `--target bar.json`，那么可以通过下面方式来引入依赖:

```toml
[target.bar.dependencies]
winhttp = "0.4.0"

[target.my-special-i686-platform.dependencies]
openssl = "1.0.1"
native = { path = "native/i686" }
```

> 需要注意，这种使用方式在 `stable` 版本的 Rust 中无法被使用，建议大家如果没有特别的需求，还是使用之前提到的 feature 方式

## [dev-dependencies]

你还可以为项目添加只在测试时需要的依赖库，类似于 `package.json`( Nodejs )文件中的 `devDependencies`，可以在 `Cargo.toml` 中添加 `[dev-dependencies]` 来实现:

```toml
[dev-dependencies]
tempdir = "0.3"
```

这里的依赖只会在运行测试、示例和 benchmark 时才会被引入。并且，假设`A` 包引用了 `B`，而 `B` 通过 `[dev-dependencies]` 的方式引用了 `C` 包， 那 `A` 是不会引用 `C` 包的。

当然，我们还可以指定平台特定的测试依赖包:

```toml
[target.'cfg(unix)'.dev-dependencies]
mio = "0.0.1"
```

> 注意，当发布包到 crates.io 时，`[dev-dependencies]` 中的依赖只有指定了 `version` 的才会被包含在发布包中。况且，再加上测试稳定性的考虑，我们建议为 `[dev-dependencies]` 中的包指定相应的版本号

## [build-dependencies]

我们还可以指定某些依赖仅用于构建脚本:

```toml
[build-dependencies]
cc = "1.0.3"
```

当然，平台特定的依然可以使用：

```toml
[target.'cfg(unix)'.build-dependencies]
cc = "1.0.3"
```

有一点需要注意：构建脚本(` build.rs` )和项目的正常代码是彼此独立，因此它们的依赖不能互通： 构建脚本无法使用 `[dependencies]` 或 `[dev-dependencies]` 中的依赖，而 `[build-dependencies]` 中的依赖也无法被构建脚本之外的代码所使用。

## 选择 features

如果你依赖的包提供了条件性的 `features`，你可以指定使用哪一个:

```toml
[dependencies.awesome]
version = "1.3.5"
default-features = false # 不要包含默认的 features，而是通过下面的方式来指定
features = ["secure-password", "civet"]
```

更多的信息参见 [Features 章节](https://course.rs/cargo/reference/features.html)

## 在 Cargo.toml 中重命名依赖

如果你想要实现以下目标：

- 避免在 Rust 代码中使用 `use foo as bar`
- 依赖某个包的多个版本
- 依赖来自于不同注册服务的同名包

那可以使用 Cargo 提供的 `package key` :

```toml
[package]
name = "mypackage"
version = "0.0.1"

[dependencies]
foo = "0.1"
bar = { git = "https://github.com/example/project", package = "foo" }
baz = { version = "0.1", registry = "custom", package = "foo" }
```

此时，你的代码中可以使用三个包：

```rust
extern crate foo; // 来自 crates.io
extern crate bar; // 来自 git repository
extern crate baz; // 来自 registry `custom`
```

有趣的是，由于这三个 `package` 的名称都是 `foo`(在各自的 `Cargo.toml` 中定义)，因此我们显式的通过 `package = "foo"` 的方式告诉 Cargo：我们需要的就是这个 `foo package`，虽然它被重命名为 `bar` 或 `baz`。

有一点需要注意，当使用可选依赖时，如果你将 `foo` 包重命名为 `bar` 包，那引用前者的 feature 时的路径名也要做相应的修改:

```toml
[dependencies]
bar = { version = "0.1", package = 'foo', optional = true }

[features]
log-debug = ['bar/log-debug'] # 若使用 'foo/log-debug' 会导致报错
```




================================================
FILE: src/cargo/reference/workspaces.md
================================================
# 工作空间 Workspace

一个工作空间是由多个 `package` 组成的集合，它们共享同一个 `Cargo.lock` 文件、输出目录和一些设置(例如 profiles : 编译器设置和优化)。组成工作空间的 `packages` 被称之为工作空间的成员。

## 工作空间的两种类型

工作空间有两种类型：`root package` 和虚拟清单( virtual manifest )。

#### 根 package

**若一个 `package` 的 `Cargo.toml` 包含了`[package]` 的同时又包含了 `[workspace]` 部分，则该 `package` 被称为工作空间的根 `package`**。

换而言之，一个工作空间的根( root )是该工作空间的 `Cargo.toml` 文件所在的目录。

举个例子，我们现在有多个 `package`，它们的目录是嵌套关系，然后我们在最外层的 `package`，也就是最外层目录中的 `Cargo.toml` 中定义一个 `[workspace]`，此时这个最外层的 `package` 就是工作空间的根。

再举个例子，大名鼎鼎的 [ripgrep](https://github.com/BurntSushi/ripgrep/blob/master/Cargo.toml) 就在最外层的 `package` 中定义了 `[workspace]` :

```toml
[workspace]
members = [
  "crates/globset",
  "crates/grep",
  "crates/cli",
  "crates/matcher",
  "crates/pcre2",
  "crates/printer",
  "crates/regex",
  "crates/searcher",
  "crates/ignore",
]
```

那么[最外层的目录](https://github.com/BurntSushi/ripgrep)就是 `ripgrep` 的工作空间的根。

#### 虚拟清单

若一个 `Cargo.toml` 有 `[workspace]` 但是没有 `[package]` 部分，则它是虚拟清单类型的工作空间。

**对于没有主 `package` 的场景或你希望将所有的 `package` 组织在单独的目录中时，这种方式就非常适合。**

例如 [rust-analyzer](https://github.com/rust-analyzer/rust-analyzer) 就是这样的项目，它的根目录中的 `Cargo.toml` 中并没有 `[package]`，说明该根目录不是一个 `package`，但是却有 `[workspace]` :

```toml
[workspace]
members = ["xtask/", "lib/*", "crates/*"]
exclude = ["crates/proc_macro_test/imp"]
```

结合 rust-analyzer 的目录布局可以看出，**该工作空间的所有成员 `package` 都在单独的目录中，因此这种方式很适合虚拟清单的工作空间。**

## 关键特性

工作空间的几个关键点在于:

- 所有的 `package` 共享同一个 `Cargo.lock` 文件，该文件位于工作空间的根目录中
- 所有的 `package` 共享同一个[输出目录](https://course.rs/cargo/guide/build-cache.html)，该目录默认的名称是 `target` ，位于工作空间根目录下
- 只有工作空间根目录的 `Cargo.toml` 才能包含 `[patch]`, `[replace]` 和 `[profile.*]`，而成员的 `Cargo.toml` 中的相应部分将被自动忽略

## [workspace]

`Cargo.toml` 中的 `[workspace]` 部分用于定义哪些 `packages` 属于工作空间的成员:

```toml
[workspace]
members = ["member1", "path/to/member2", "crates/*"]
exclude = ["crates/foo", "path/to/other"]
```

若某个本地依赖包是通过 [`path`](https://course.rs/cargo/reference/specify-deps.html#通过路径引入本地依赖包) 引入，且该包位于工作空间的目录中，则该包自动成为工作空间的成员。

剩余的成员需要通过 `workspace.members` 来指定，里面包含了各个成员所在的目录(成员目录中包含了 Cargo.toml )。

`members` 还支持使用 [`glob`](https://docs.rs/glob/0.3.0/glob/struct.Pattern.html) 来匹配多个路径，例如上面的例子中使用 `crates/*` 匹配 `crates` 目录下的所有包。

`exclude` 可以将指定的目录排除在工作空间之外，例如还是上面的例子，`crates/*` 在包含了 `crates` 目录下的所有包后，又通过 `exclude` 中 `crates/foo` 将 `crates` 下的 `foo` 目录排除在外。

你也可以将一个空的 `[workspace]` 直接联合 `[package]` 使用，例如：

```toml
[package]
name = "hello"
version = "0.1.0"

[workspace]
```

此时的工作空间的成员包含:

- 根 `package` : "hello"
- 所有通过 `path` 引入的本地依赖(位于工作空间目录下)

## 选择工作空间

选择工作空间有两种方式：`Cargo` 自动查找、手动指定 `package.workspace` 字段。

当位于工作空间的子目录中时，`Cargo` 会自动在该目录的父目录中寻找带有 `[workspace]` 定义的 `Cargo.toml`，然后再决定使用哪个工作空间。

我们还可以使用下面的方法来覆盖 `Cargo` 自动查找功能：将成员包中的 `package.workspace` 字段修改为工作区间根目录的位置，这样就能显式地让一个成员使用指定的工作空间。

当成员不在工作空间的子目录下时，这种手动选择工作空间的方法就非常适用。毕竟 `Cargo` 的自动搜索是沿着父目录往上查找，而成员并不在工作空间的子目录下，这意味着顺着成员的父目录往上找是无法找到该工作空间的 `Cargo.toml` 的，此时就只能手动指定了。

## 选择 package

在工作空间中，`package` 相关的 `Cargo` 命令(例如 `cargo build` )可以使用 `-p` 、 `--package` 或 `--workspace` 命令行参数来指定想要操作的 `package`。

若没有指定任何参数，则 `Cargo` 将使用当前工作目录的中的 `package` 。若工作目录是虚拟清单类型的工作空间，则该命令将作用在所有成员上(就好像是使用了 `--workspace` 命令行参数)。而 `default-members` 可以在命令行参数没有被提供时，手动指定操作的成员:

```toml
[workspace]
members = ["path/to/member1", "path/to/member2", "path/to/member3/*"]
default-members = ["path/to/member2", "path/to/member3/foo"]
```

这样一来， `cargo build` 就不会应用到虚拟清单工作空间的所有成员，而是指定的成员上。

## workspace.metadata

与 [package.metadata](https://course.rs/cargo/reference/manifest.html#metadata) 非常类似，`workspace.metadata` 会被 `Cargo` 自动忽略，就算没有被使用也不会发出警告。

这个部分可以用于让工具在 `Cargo.toml` 中存储一些工作空间的配置元信息。例如:

```toml
[workspace]
members = ["member1", "member2"]

[workspace.metadata.webcontents]
root = "path/to/webproject"
tool = ["npm", "run", "build"]
# ...
```



================================================
FILE: src/cargo/reference/build-script/examples.md
================================================
[Binary file]


================================================
FILE: src/cargo/reference/build-script/intro.md
================================================
[Binary file]


================================================
FILE: src/cargo/reference/features/examples.md
================================================
# Features 示例

以下我们一起来看看一些来自真实世界的示例。

### 最小化构建时间和文件大小

如果一些包的部分特性不再启用，就可以减少该包占用的大小以及编译时间:

- [`syn`](https://crates.io/crates/syn) 包可以用来解析 Rust 代码，由于它很受欢迎，大量的项目都在引用，因此它给出了[非常清晰的文档](https://docs.rs/syn/1.0.54/syn/#optional-features)关于如何最小化使用它包含的 `features`
- [`regex`](https://crates.io/crates/regex) 也有关于 features 的[描述文档](https://docs.rs/regex/1.4.2/regex/#crate-features)，例如移除 Unicode 支持的 feature 可以降低最终生成可执行文件的大小
- [`winapi`](https://crates.io/crates/winapi) 拥有[众多 features](https://github.com/retep998/winapi-rs/blob/0.3.9/Cargo.toml#L25-L431)，这些 `feature` 对用了各种 Windows API，你可以只引入代码中用到的 API 所对应的 feature.

### 行为扩展

[`serde_json`](https://crates.io/crates/serde_json) 拥有一个 [`preserve_order` feature](https://github.com/serde-rs/json/blob/v1.0.60/Cargo.toml#L53-L56)，可以用于在序列化时保留 JSON 键值对的顺序。同时，该 feature 还会启用一个可选依赖 [indexmap](https://crates.io/crates/indexmap)。

当这么做时，一定要小心不要破坏了 SemVer 的版本兼容性，也就是说：启用 feature 后，代码依然要能正常工作。

### no_std 支持

一些包希望能同时支持 [`no_std`](https://doc.rust-lang.org/stable/reference/names/preludes.html#the-no_std-attribute) 和 `std` 环境，例如该包希望支持嵌入式系统或资源紧张的系统，且又希望能支持其它的平台，此时这种做法是非常有用的，因为标准库 `std` 会大幅增加编译出来的文件的大小，对于资源紧张的系统来说，`no_std` 才是最合适的。

[wasm-bindgen](https://crates.io/crates/wasm-bindgen) 定义了一个 [std feature](https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/Cargo.toml#L25)，它是[默认启用的](https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/Cargo.toml#L25)。首先，在库的顶部，它[无条件的启用了 `no_std` 属性](https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L8)，它可以确保 `std` 和 [`std prelude`](https://doc.rust-lang.org/stable/std/prelude/index.html) 不会自动引入到作用域中来。其次，在不同的地方([示例 1](https://doc.rust-lang.org/stable/std/prelude/index.html)，[示例 2](https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L67-L75))，它通过 `#[cfg(feature = "std")]` 启用 `std` feature 来添加 `std` 标准库支持。

## 对依赖库的 features 进行再导出

从依赖库再导出 features 在有些场景中会相当有用，这样用户就可以通过依赖包的 features 来控制功能而不是自己去手动定义。

例如 [`regex`](https://crates.io/crates/regex) 将 [`regex_syntax`](https://github.com/rust-lang/regex/blob/1.4.2/regex-syntax/Cargo.toml#L17-L32) 包的 features 进行了[再导出](https://github.com/rust-lang/regex/blob/1.4.2/Cargo.toml#L65-L89)，这样 `regex` 的用户无需知道 `regex_syntax` 包，但是依然可以访问后者包含的 features。

## feature 优先级

一些包可能会拥有彼此互斥的 features(无法共存，上一章节中有讲到)，其中一个办法就是为 feature 定义优先级，这样其中一个就会优于另一个被启用。

例如 [`log`](https://crates.io/crates/log) 包，它有[几个 features](https://github.com/rust-lang/log/blob/0.4.11/Cargo.toml#L29-L42) 可以用于在编译期选择最大的[日志级别](https://docs.rs/log/0.4.11/log/#compile-time-filters)，这里，它就使用了 [`cfg-if`](https://crates.io/crates/cfg-if) 的方式来[设置优先级](https://github.com/rust-lang/log/blob/0.4.11/src/lib.rs#L1422-L1448)。一旦多个 `features` 被启用，那更高优先级的就会优先被启用。

## 过程宏包

一些包拥有过程宏，这些宏必须定义在一个独立的包中。但是不是所有的用户都需要过程宏的，因此也无需引入该包。

在这种情况下，将过程宏所在的包定义为可选依赖，是很不错的选择。这样做还有一个好处：有时过程宏的版本必须要跟父包进行同步，但是我们又不希望所有的用户都进行同步。

其中一个例子就是 [serde](https://crates.io/crates/serde) ，它有一个 [derive](https://github.com/serde-rs/serde/blob/v1.0.118/serde/Cargo.toml#L34-L35) feature 可以启用 [serde_derive](https://crates.io/crates/serde_derive) 过程宏。由于 `serde_derive` 包跟 `serde` 的关系非常紧密，因此它使用了[版本相同的需求](https://github.com/serde-rs/serde/blob/v1.0.118/serde/Cargo.toml#L17)来保证两者的版本同步性。

## 只能用于 nightly 的 feature

Rust 有些实验性的 API 或语言特性只能在 nightly 版本下使用，但某些使用了这些 API 的包并不想强制他们的用户也使用 `nightly` 版本，因此他们会通过 feature 的方式来控制。

若用户希望使用这些 API 时，需要启用相应的 feature ，而这些 feature 只能在 nightly 下使用。若用户不需要使用这些 API，就无需开启 相应的 feature，自然也不需要使用 nightly 版本。

例如 [`rand`](https://crates.io/crates/rand) 包有一个 [simd_support](https://github.com/rust-random/rand/blob/0.7.3/Cargo.toml#L40) feature 就只能在 nightly 下使用，若我们不使用该 feature，则在 stable 下依然可以使用 `rand`。

## 实验性 feature

有一些包会提前将一些实验性的 API 放出去，既然是实验性的，自然无法保证其稳定性。在这种情况下，通常会在文档中将相应的 features 标记为实验性，意味着它们在未来可能会发生大的改变(甚至 minor 版本都可能发生)。

其中一个例子是 [async-std](https://crates.io/crates/async-std) 包，它拥有一个 [unstable feature](https://github.com/async-rs/async-std/blob/v1.8.0/Cargo.toml#L38-L42)，用来[标记一些新的 API](https://github.com/async-rs/async-std/blob/v1.8.0/src/macros.rs#L46)，表示人们已经可以选择性的使用但是还没有准备好去依赖它。




================================================
FILE: src/cargo/reference/features/intro.md
================================================
# 条件编译 Features

`Cargo Feature` 是非常强大的机制，可以为大家提供[条件编译](https://doc.rust-lang.org/stable/reference/conditional-compilation.html)和可选依赖的高级特性。

## [features]

`Feature` 可以通过 `Cargo.toml` 中的 `[features]` 部分来定义：其中每个 `feature` 通过列表的方式指定了它所能启用的其他 `feature` 或可选依赖。

假设我们有一个 2D 图像处理库，然后该库所支持的图片格式可以通过以下方式启用：

```toml
[features]
# 定义一个 feature : webp, 但它并没有启用其它 feature
webp = []
```

当定义了 `webp` 后，我们就可以在代码中通过 [`cfg` 表达式](https://doc.rust-lang.org/stable/reference/conditional-compilation.html)来进行条件编译。例如项目中的 `lib.rs` 可以使用以下代码对 `webp` 模块进行条件引入:

```toml
#[cfg(feature = "webp")]
pub mod webp;
```

`#[cfg(feature = "webp")]` 的含义是：只有在 `webp` feature 被定义后，以下的 `webp` 模块才能被引入进来。由于我们之前在 `[features]` 里定义了 `webp`，因此以上代码的 `webp` 模块会被成功引入。

在 `Cargo.toml` 中定义的 `feature` 会被 `Cargo` 通过命令行参数 `--cfg` 传给 `rustc`，最终由后者完成编译：例如，定义 "hello" 和 "hi" 两个 `feature`，等价于 `rustc --cfg 'feature="hello"' --cfg 'feature="hi" ...'`。若项目中的代码想要测试 `feature` 是否存在，可以使用 [`cfg` 属性](https://doc.rust-lang.org/stable/reference/conditional-compilation.html#the-cfg-attribute)或 [`cfg` 宏](https://doc.rust-lang.org/stable/std/macro.cfg.html)。

之前我们提到了一个 `feature` 还可以开启其他 `feature`，举个例子，例如 ICO 图片格式包含 BMP 和 PNG 格式，因此当 `ico` 被启用后，它还得确保启用 `bmp` 和 `png` ：

```toml
[features]
bmp = []
png = []
ico = ["bmp", "png"]
webp = []
```

对此，我们可以理解为： **`bmp` 和 `png` 是开启 `ico` 的先决条件**（注：开启 `ico`，会自动开启 `bmp`, `png`）。

Feature 名称可以包含来自 [Unicode XID standard]() 定义的字母，允许使用 `_` 或 `0-9` 的数字作为起始字符，在起始字符后，还可以使用 `-`、`+` 或 `.` 。

但是我们**还是推荐按照 crates.io 的方式来设置 Feature 名称** : `crate.io` 要求名称只能由 ASCII 字母数字、`_`、`-` 或 `+` 组成。

## default feature

默认情况下，所有的 `feature` 都会被自动禁用，可以通过 `default` 来启用它们：

```toml
[features]
default = ["ico", "webp"]
bmp = []
png = []
ico = ["bmp", "png"]
webp = []
```

使用如上配置的项目被构建时，`default` feature 首先会被启用，然后它接着启用了 `ico` 和 `webp` feature，当然我们还可以关闭 `default`：

- `--no-default-features` 命令行参数可以禁用 `default` feature
- `default-features = false` 选项可以在依赖声明中指定

> 当你要去改变某个依赖库的 `default` 启用的 feature 列表时(例如觉得该库引入的 feature 过多，导致最终编译出的文件过大)，需要格外的小心，因为这可能会导致某些功能的缺失

## 可选依赖

当依赖被标记为 "可选 optional" 时，意味着它默认不会被编译。假设我们的 2D 图片处理库需要用到一个外部的包来处理 GIF 图片：

```toml
[dependencies]
gif = { version = "0.11.1", optional = true }
```

**这种可选依赖的写法会自动定义一个与依赖同名的 feature，也就是 `gif` feature**，这样一来，当我们启用 `gif` feature 时，该依赖库也会被自动引入并启用：例如通过 `--features gif` 的方式启用 feature 。

> 注意：目前来说，`[feature]` 中定义的 feature 还不能与已引入的依赖库同名。但是在 `nightly` 中已经提供了实验性的功能用于改变这一点: [namespaced features](https://doc.rust-lang.org/stable/cargo/reference/unstable.html#namespaced-features)

当然，**我们还可以通过显式定义 feature 的方式来启用这些可选依赖库**，例如为了支持 AVIF 图片格式，我们需要引入两个依赖包，由于 `avif` 是通过 feature 引入的可选格式，因此它依赖的两个包也必须声明为可选的:

```toml
[dependencies]
ravif = { version = "0.6.3", optional = true }
rgb = { version = "0.8.25", optional = true }

[features]
avif = ["ravif", "rgb"]
```

之后，`avif` feature 一旦被启用，那这两个依赖库也将自动被引入。

> 注意：我们之前也讲过条件引入依赖的方法，那就是使用[平台相关的依赖](https://course.rs/cargo/reference/specify-deps.html#根据平台引入依赖)，与基于 feature 的可选依赖不同，它们是基于特定平台的可选依赖

## 依赖库自身的 feature

就像我们的项目可以定义 `feature` 一样，依赖库也可以定义它自己的 `feature`，也有需要启用的 `feature` 列表，当引入该依赖库时，我们可以通过以下方式为其启用相关的 `features` :

```toml
[dependencies]
serde = { version = "1.0.118", features = ["derive"] }
```

以上配置为 `serde` 依赖开启了 `derive` feature，还可以通过 `default-features = false` 来禁用依赖库的 `default` feature :

```toml
[dependencies]
flate2 = { version = "1.0.3", default-features = false, features = ["zlib"] }
```

这里我们禁用了 `flate2` 的 `default` feature，但又手动为它启用了 `zlib` feature。

> 注意：这种方式未必能成功禁用 `default`，原因是可能会有其它依赖也引入了 `flate2`，并且没有对 `default` 进行禁用，那此时 `default` 依然会被启用。
>
> 查看下文的 [feature 同一化](#feature-同一化) 获取更多信息

除此之外，还能通过下面的方式来间接开启依赖库的 feature :

```toml
[dependencies]
jpeg-decoder = { version = "0.1.20", default-features = false }

[features]
# Enables parallel processing support by enabling the "rayon" feature of jpeg-decoder.
parallel = ["jpeg-decoder/rayon"]
```

如上所示，我们定义了一个 `parallel` feature，同时为其启用了 `jpeg-decoder` 依赖的 `rayon` feature。

> 注意: 上面的 "package-name/feature-name" 语法形式不仅会开启指定依赖的指定 feature，若该依赖是可选依赖，那还会自动将其引入
>
> 在 `nightly` 版本中，可以对这种行为进行禁用：[weak dependency features]("package-name/feature-name")

## 通过命令行参数启用 feature

以下的命令行参数可以启用指定的 `feature` :

- `--features FEATURES`: 启用给出的 feature 列表，可以使用逗号或空格进行分隔，若你是在终端中使用，还需要加上双引号，例如 `--features "foo bar"`。 若在工作空间中构建多个 `package`，可以使用 `package-name/feature-name` 为特定的成员启用 features
- `--all-features`: 启用命令行上所选择的所有包的所有 features
- `--no-default-features`: 对选择的包禁用 `default` feature

## feature 同一化

`feature` 只有在定义的包中才是唯一的，不同包之间的 `feature` 允许同名。因此，在一个包上启用 `feature` 不会导致另一个包的同名 `feature` 被误启用。

**当一个依赖被多个包所使用时，这些包对该依赖所设置的 `feature` 将被进行合并，这样才能确保该依赖只有一个拷贝存在，这个过程就被称之为同一化**。大家可以查看[这里](https://doc.rust-lang.org/stable/cargo/reference/resolver.html#features)了解下解析器如何对 feature 进行解析处理。

这里，我们使用 `winapi` 为例来说明这个过程。首先，`winapi` 使用了大量的 `features`；然后我们有两个包 `foo` 和 `bar` 分别使用了它的两个 features，那么在合并后，最终 `winapi` 将同时启四个 features :

<img src="https://pic2.zhimg.com/80/v2-251973b0cc83f35cd6858bf21dd00ed6_1440w.png" />

由于这种不可控性，我们需要让 `启用feature = 添加特性` 这个等式成立，换而言之，**启用一个 feature 不应该导致某个功能被禁止**。这样才能让多个包启用同一个依赖的不同 features。

例如，如果我们想可选的支持 `no_std` 环境(不使用标准库)，那么有两种做法：

- 默认代码使用标准库的，当 `no_std` feature 启用时，禁用相关的标准库代码
- 默认代码使用非标准库的，当 `std` feature 启用时，才使用标准库的代码

前者就是功能削减，与之相对，后者是功能添加，根据之前的内容，我们应该选择后者的做法：

```rust
#![no_std]

#[cfg(feature = "std")]
extern crate std;

#[cfg(feature = "std")]
pub fn function_that_requires_std() {
    // ...
}
```

#### 彼此互斥的 feature

某极少数情况下，features 之间可能会互相不兼容。我们应该避免这种设计，因为如果一旦这么设计了，那你可能需要修改依赖图的很多地方才能避免两个不兼容 feature 的同时启用。

如果实在没有办法，可以考虑增加一个编译错误来让报错更清晰:

```toml
#[cfg(all(feature = "foo", feature = "bar"))]
compile_error!("feature \"foo\" and feature \"bar\" cannot be enabled at the same time");
```

当同时启用 `foo` 和 `bar` 时，编译器就会爆出一个更清晰的错误：feature `foo` 和 `bar` 无法同时启用。

总之，我们还是应该在设计上避免这种情况的发生，例如：

- 将某个功能分割到多个包中
- 当冲突时，设置 feature 优先级，[cfg-if](https://crates.io/crates/cfg-if) 包可以帮助我们写出更复杂的 `cfg` 表达式

#### 检视已解析的 features

在复杂的依赖图中，如果想要了解不同的 features 是如何被多个包多启用的，这是相当困难的。好在 `cargo tree` 命令提供了几个选项可以帮组我们更好的检视哪些 features 被启用了:

`cargo tree -e features` ，该命令以依赖图的方式来展示已启用的 features，包含了每个依赖包所启用的特性：

```shell
$ cargo tree -e features
test_cargo v0.1.0 (/Users/sunfei/development/rust/demos/test_cargo)
└── uuid feature "default"
    ├── uuid v0.8.2
    └── uuid feature "std"
        └── uuid v0.8.2
```

`cargo tree -f "{p} {f}"` 命令会提供一个更加紧凑的视图：

```shell
$ cargo tree -f "{p} {f}"
test_cargo v0.1.0 (/Users/sunfei/development/rust/demos/test_cargo)
└── uuid v0.8.2 default,std
```

`cargo tree -e features -i foo`，该命令会显示 `features` 会如何"流入"指定的包 `foo` 中:

```shell
$ cargo tree -e features -i uuid
uuid v0.8.2
├── uuid feature "default"
│   └── test_cargo v0.1.0 (/Users/sunfei/development/rust/demos/test_cargo)
│       └── test_cargo feature "default" (command-line)
└── uuid feature "std"
    └── uuid feature "default" (*)
```

该命令在依赖图较为复杂时非常有用，使用它可以让你了解某个依赖包上开启了哪些 `features` 以及其中的原因。

大家可以查看官方的 `cargo tree` [文档](https://doc.rust-lang.org/stable/cargo/commands/cargo-tree.html)获取更加详细的使用信息。

## Feature 解析器 V2 版本

我们还能通过以下配置指定使用 V2 版本的解析器( [resolver](https://doc.rust-lang.org/stable/cargo/reference/resolver.html#resolver-versions) ):

```toml
[package]
name = "my-package"
version = "1.0.0"
resolver = "2"
```

V2 版本的解析器可以在某些情况下避免 feature 同一化的发生，具体的情况在[这里](https://doc.rust-lang.org/stable/cargo/reference/resolver.html#feature-resolver-version-2)有描述，下面做下简单的总结:

- 为特定平台开启的 `features` 且此时并没有被构建，会被忽略
- `build-dependencies` 和 `proc-macros` 不再跟普通的依赖共享 `features`
- `dev-dependencies` 的 `features` 不会被启用，除非正在构建的对象需要它们(例如测试对象、示例对象等)

对于部分场景而言，feature 同一化确实是需要避免的，例如，一个构建依赖开启了 `std` feature，而同一个依赖又被用于 `no_std` 环境，很明显，开启 `std` 将导致错误的发生。

说完优点，我们再来看看 V2 的缺点，其中增加编译构建时间就是其中之一，原因是同一个依赖会被构建多次(每个都拥有不同的 feature 列表)。

> 由于此部分内容可能只有极少数的用户需要，因此我们并没有对其进行扩展，如果大家希望了解更多关于 V2 的内容，可以查看[官方文档](https://doc.rust-lang.org/stable/cargo/reference/features.html#feature-resolver-version-2)

## 构建脚本

[构建脚本](https://course.rs/cargo/reference/build-script/intro.html)可以通过 `CARGO_FEATURE_<name>` 环境变量获取启用的 `feature` 列表，其中 `<name>` 是 feature 的名称，该名称被转换成大全写字母，且 `-` 被转换为 `_`。

## required-features

该字段可以用于禁用特定的 Cargo Target：当某个 feature 没有被启用时，查看[这里](https://course.rs/cargo/reference/cargo-target.html#required-features)获取更多信息。

## SemVer 兼容性

启用一个 feature 不应该引入一个不兼容 SemVer 的改变。例如，启用的 feature 不应该改变现有的 API，因为这会给用户造成不兼容的破坏性变更。 如果大家想知道哪些变化是兼容的，可以参见[官方文档](https://doc.rust-lang.org/stable/cargo/reference/semver.html)。

总之，在新增/移除 feature 或可选依赖时，你需要小心，因此这些可能会造成向后不兼容性。更多信息参见[这里](https://doc.rust-lang.org/stable/cargo/reference/semver.html#cargo)，简单总结如下：

- 在发布 `minor` 版本时，以下通常是安全的:
  - [新增 feature](https://doc.rust-lang.org/stable/cargo/reference/semver.html#cargo-feature-add) 或[可选依赖](https://doc.rust-lang.org/stable/cargo/reference/semver.html#cargo-dep-add)
  - [修改某个依赖的 features](https://doc.rust-lang.org/stable/cargo/reference/semver.html#cargo-change-dep-feature)
- 在发布 `minor` 版本时，以下操作应该避免：
  - [移除 feature](https://doc.rust-lang.org/stable/cargo/reference/semver.html#cargo-feature-remove) 或[可选依赖](https://doc.rust-lang.org/stable/cargo/reference/semver.html#cargo-remove-opt-dep)
  - [将现有的公有代码放在某个 feature 之后](https://doc.rust-lang.org/stable/cargo/reference/semver.html#cargo-remove-opt-dep)
  - [从 feature 列表中移除一个 feature](https://doc.rust-lang.org/stable/cargo/reference/semver.html#cargo-feature-remove-another)

## feature 文档和发现

将你的项目支持的 feature 信息写入到文档中是非常好的选择:

- 我们可以通过在 `lib.rs` 的顶部添加[文档注释](https://course.rs/basic/comment.html#文档注释)的方式来实现。例如 `regex` 就是[这么做的](https://github.com/rust-lang/regex/blob/1.4.2/src/lib.rs#L488-L583)。
- 若项目拥有一个用户手册，那也可以在那里添加说明，例如 [serde.rs](https://github.com/rust-lang/regex/blob/1.4.2/src/lib.rs#L488-L583)。
- 若项目是二进制类型(可运行的应用服务，包含 `fn main` 入口)，可以将说明放在 `README` 文件或其他文档中，例如 [sccache](https://github.com/mozilla/sccache/blob/0.2.13/README.md#build-requirements)。

特别是对于不稳定的或者不该再被使用的 feature 而言，它们更应该被放在文档中进行清晰的说明。

当构建发布到 `docs.rs` 上的文档时，会使用 `Cargo.toml` 中的元数据来控制哪些 features 会被启用。查看 [docs.rs 文档](https://docs.rs/about/metadata)获取更多信息。

#### 如何发现 features

若依赖库的文档中对其使用的 `features` 做了详细描述，那你会更容易知道他们使用了哪些 `features` 以及该如何使用。

当依赖库的文档没有相关信息时，你也可以通过源码仓库的 `Cargo.toml` 文件来获取，但是有些时候，使用这种方式来跟踪并获取全部相关的信息是相当困难的。



================================================
FILE: src/compiler/intro.md
================================================
# 征服编译错误



================================================
FILE: src/compiler/fight-with-compiler/intro.md
================================================
# 对抗编译检查



================================================
FILE: src/compiler/fight-with-compiler/phantom-data.md
================================================
# 幽灵数据



================================================
FILE: src/compiler/fight-with-compiler/unconstrained.md
================================================
# 类型未限制



================================================
FILE: src/compiler/fight-with-compiler/borrowing/borrow-distinct-fields-of-struct.md
================================================
[Binary file]


================================================
FILE: src/compiler/fight-with-compiler/borrowing/intro.md
================================================
# 重复借用

本章讲述如何解决类似`cannot borrow *self as mutable because it is also borrowed as immutable`这种重复借用的错误。




================================================
FILE: src/compiler/fight-with-compiler/borrowing/ref-exist-in-out-fn.md
================================================
[Binary file]


================================================
FILE: src/compiler/fight-with-compiler/lifetime/closure-with-static.md
================================================
# 当闭包碰到特征对象 1

特征对象是一个好东西，闭包也是一个好东西，但是如果两者你都想要时，可能就会火星撞地球，boom! 至于这两者为何会勾搭到一起？考虑一个常用场景：使用闭包作为回调函数.

## 学习目标

如何使用闭包作为特征对象，并解决以下错误：`the parameter type ` \`impl Fn(&str) -> Res\` ` may not live long enough`

## 报错的代码

在下面代码中，我们通过闭包实现了一个简单的回调函数(错误代码已经标注)：

```rust
pub struct Res<'a> {
    value: &'a str,
}

impl<'a> Res<'a> {
    pub fn new(value: &str) -> Res {
        Res { value }
    }
}

pub struct Container<'a> {
    name: &'a str,
    callback: Option<Box<dyn Fn(&str) -> Res>>,
}

impl<'a> Container<'a> {
    pub fn new(name: &str) -> Container {
        Container {
            name,
            callback: None,
        }
    }

    pub fn set(&mut self, cb: impl Fn(&str) -> Res) {
        self.callback = Some(Box::new(cb));
    }
}

fn main() {
    let mut inl = Container::new("Inline");

    inl.set(|val| {
        println!("Inline: {}", val);
        Res::new("inline")
    });

    if let Some(cb) = inl.callback {
        cb("hello, world");
    }
}
```

```
error[E0310]: the parameter type `impl Fn(&str) -> Res` may not live long enough
  --> src/main.rs:25:30
   |
24 |     pub fn set(&mut self, cb: impl Fn(&str) -> Res) {
   |                               -------------------- help: consider adding an explicit lifetime bound...: `impl Fn(&str) -> Res + 'static`
25 |         self.callback = Some(Box::new(cb));
   |                              ^^^^^^^^^^^^ ...so that the type `impl Fn(&str) -> Res` will meet its required lifetime bounds
```

从第一感觉来说，报错属实不应该，因为我们连引用都没有用，生命周期都不涉及，怎么就报错了？在继续深入之前，先来观察下该闭包是如何被使用的：

```rust
callback: Option<Box<dyn Fn(&str) -> Res>>,
```

众所周知，闭包跟哈姆雷特一样，每一个都有[自己的类型](https://course.rs/advance/functional-programing/closure.html#闭包作为函数返回值)，因此我们无法通过类型标注的方式来声明一个闭包，那么只有一个办法，就是使用特征对象，因此上面代码中，通过`Box<dyn Trait>`的方式把闭包特征封装成一个特征对象。

## 深入挖掘报错原因

事出诡异必有妖，那接下来我们一起去会会这只妖。

#### 特征对象的生命周期

首先编译器报错提示我们闭包活得不够久，那可以大胆推测，正因为使用了闭包作为特征对象，所以才活得不够久。因此首先需要调查下特征对象的生命周期。

首先给出结论：**特征对象隐式的具有`'static`生命周期**。

其实在 Rust 中，`'static`生命周期很常见，例如一个没有引用字段的结构体它其实也是`'static`。当`'static`用于一个类型时，该类型不能包含任何非`'static`引用字段，例如以下结构体：

```rust
struct Foo<'a> {
    x : &'a [u8]
};
```

除非`x`字段借用了`'static`的引用，否则`'a`肯定比`'static`要小，那么该结构体实例的生命周期肯定不是`'static`: `'a: 'static`的限制不会被满足([HRTB](https://course.rs/advance/lifetime/advance.html#生命周期约束HRTB))。

对于特征对象来说，它没有包含非`'static`的引用，因此它隐式的具有`'static`生命周期, `Box<dyn Trait>`就跟`Box<dyn Trait + 'static>`是等价的。

#### 'static 闭包的限制

其实以上代码的错误很好解决，甚至编译器也提示了我们：

```console
help: consider adding an explicit lifetime bound...: `impl Fn(&str) -> Res + 'static`
```

但是解决问题不是本文的目标，我们还是要继续深挖一下，如果闭包使用了`'static`会造成什么问题。

##### 1. 无本地变量被捕获

```rust
inl.set(|val| {
    println!("Inline: {}", val);
    Res::new("inline")
});
```

以上代码只使用了闭包中传入的参数，并没有本地变量被捕获，因此`'static`闭包一切 OK。

##### 2. 有本地变量被捕获

```rust
let local = "hello".to_string();

// 编译错误： 闭包不是'static!
inl.set(|val| {
    println!("Inline: {}", val);
    println!("{}", local);
    Res::new("inline")
});
```

这里我们在闭包中捕获了本地环境变量`local`，因为`local`不是`'static`，那么闭包也不再是`'static`。

##### 3. 将本地变量 move 进闭包

```rust
let local = "hello".to_string();

inl.set(move |val| {
    println!("Inline: {}", val);
    println!("{}", local);
    Res::new("inline")
});

// 编译错误: local已经被移动到闭包中，这里无法再被借用
// println!("{}", local);
```

如上所示，你也可以选择将本地变量的所有权`move`进闭包中，此时闭包再次具有`'static`生命周期

##### 4. 非要捕获本地变量的引用？

对于第 2 种情况，如果非要这么干，那`'static`肯定是没办法了，我们只能给予闭包一个新的生命周期:

```rust
pub struct Container<'a, 'b> {
    name: &'a str,
    callback: Option<Box<dyn Fn(&str) -> Res + 'b>>,
}

impl<'a, 'b> Container<'a, 'b> {
    pub fn new(name: &str) -> Container {
        Container {
            name,
            callback: None,
        }
    }

    pub fn set(&mut self, cb: impl Fn(&str) -> Res + 'b) {
        self.callback = Some(Box::new(cb));
    }
}
```

肉眼可见，代码复杂度哐哐哐提升，不得不说`'static`真香！

友情提示：由此修改引发的一系列错误，需要你自行修复: ) (再次友情小提示，可以考虑把`main`中的`local`变量声明位置挪到`inl`声明位置之前)

## 姗姗来迟的正确代码

其实，大家应该都知道该如何修改了，不过出于严谨，我们还是继续给出完整的正确代码:

```rust
pub fn set(&mut self, cb: impl Fn(&str) -> Res + 'static) {
```

可能大家觉得我重新定义了`完整`两个字，其实是我不想水篇幅:)

## 总结

闭包和特征对象的相爱相杀主要原因就在于特征对象默认具备`'static`的生命周期，同时我们还对什么样的类型具备`'static`进行了简单的分析。

同时，如果一个闭包拥有`'static`生命周期，那闭包无法通过引用的方式来捕获本地环境中的变量。如果你想要非要捕获，只能使用非`'static`。



================================================
FILE: src/compiler/fight-with-compiler/lifetime/intro.md
================================================
# 生命周期

本章并不讲太多的概念，主要是用例子来引导大家去思考该如何对抗编译检查。



================================================
FILE: src/compiler/fight-with-compiler/lifetime/loop.md
================================================
[Binary file]


================================================
FILE: src/compiler/fight-with-compiler/lifetime/too-long1.md
================================================
# 生命周期声明的范围过大

在大多时候，Rust 的生命周期你只要标识了，即可以通过编译，但是总是存在一些情况，会导致编译无法通过，本文就讲述这样一种情况：因为生命周期声明的范围过大，导致了编译无法通过，希望大家喜欢

## 例子 1

```rust
struct Interface<'a> {
    manager: &'a mut Manager<'a>
}

impl<'a> Interface<'a> {
    pub fn noop(self) {
        println!("interface consumed");
    }
}

struct Manager<'a> {
    text: &'a str
}

struct List<'a> {
    manager: Manager<'a>,
}

impl<'a> List<'a> {
    pub fn get_interface(&'a mut self) -> Interface {
        Interface {
            manager: &mut self.manager
        }
    }
}

fn main() {
    let mut list = List {
        manager: Manager {
            text: "hello"
        }
    };

    list.get_interface().noop();

    println!("Interface should be dropped here and the borrow released");

    // this fails because inmutable/mutable borrow
    // but Interface should be already dropped here and the borrow released
    use_list(&list);
}

fn use_list(list: &List) {
    println!("{}", list.manager.text);
}
```

运行后报错：

```console
error[E0502]: cannot borrow `list` as immutable because it is also borrowed as mutable // `list`无法被借用，因为已经被可变借用
  --> src/main.rs:40:14
   |
34 |     list.get_interface().noop();
   |     ---- mutable borrow occurs here // 可变借用发生在这里
...
40 |     use_list(&list);
   |              ^^^^^
   |              |
   |              immutable borrow occurs here // 新的不可变借用发生在这
   |              mutable borrow later used here // 可变借用在这里结束
```

这段代码看上去并不复杂，实际上难度挺高的，首先在直觉上，`list.get_interface()`借用的可变引用，按理来说应该在这行代码结束后，就归还了，为何能持续到`use_list(&list)`后面呢？

这是因为我们在`get_interface`方法中声明的`lifetime`有问题，该方法的参数的生明周期是`'a`，而`List`的生命周期也是`'a`，说明该方法至少活得跟`List`一样久，再回到`main`函数中，`list`可以活到`main`函数的结束，因此`list.get_interface()`借用的可变引用也会活到`main`函数的结束，在此期间，自然无法再进行借用了。

要解决这个问题，我们需要为`get_interface`方法的参数给予一个不同于`List<'a>`的生命周期`'b`，最终代码如下：

```rust
struct Interface<'b, 'a: 'b> {
    manager: &'b mut Manager<'a>
}

impl<'b, 'a: 'b> Interface<'b, 'a> {
    pub fn noop(self) {
        println!("interface consumed");
    }
}

struct Manager<'a> {
    text: &'a str
}

struct List<'a> {
    manager: Manager<'a>,
}

impl<'a> List<'a> {
    pub fn get_interface<'b>(&'b mut self) -> Interface<'b, 'a>
    where 'a: 'b {
        Interface {
            manager: &mut self.manager
        }
    }
}

fn main() {

    let mut list = List {
        manager: Manager {
            text: "hello"
        }
    };

    list.get_interface().noop();

    println!("Interface should be dropped here and the borrow released");

    // this fails because inmutable/mutable borrow
    // but Interface should be already dropped here and the borrow released
    use_list(&list);
}

fn use_list(list: &List) {
    println!("{}", list.manager.text);
}
```

当然，咱还可以给生命周期给予更有意义的名称：

```rust
struct Interface<'text, 'manager> {
    manager: &'manager mut Manager<'text>
}

impl<'text, 'manager> Interface<'text, 'manager> {
    pub fn noop(self) {
        println!("interface consumed");
    }
}

struct Manager<'text> {
    text: &'text str
}

struct List<'text> {
    manager: Manager<'text>,
}

impl<'text> List<'text> {
    pub fn get_interface<'manager>(&'manager mut self) -> Interface<'text, 'manager>
    where 'text: 'manager {
        Interface {
            manager: &mut self.manager
        }
    }
}

fn main() {
    let mut list = List {
        manager: Manager {
            text: "hello"
        }
    };

    list.get_interface().noop();

    println!("Interface should be dropped here and the borrow released");

    // this fails because inmutable/mutable borrow
    // but Interface should be already dropped here and the borrow released
    use_list(&list);
}

fn use_list(list: &List) {
    println!("{}", list.manager.text);
}
```



================================================
FILE: src/compiler/fight-with-compiler/lifetime/too-long2.md
================================================
# 生命周期过大-02

继上篇文章后，我们再来看一段**可能**涉及生命周期过大导致的无法编译问题:

```rust
fn bar(writer: &mut Writer) {
    baz(writer.indent());
    writer.write("world");
}

fn baz(writer: &mut Writer) {
    writer.write("hello");
}

pub struct Writer<'a> {
    target: &'a mut String,
    indent: usize,
}

impl<'a> Writer<'a> {
    fn indent(&'a mut self) -> &'a mut Self {
        &mut Self {
            target: self.target,
            indent: self.indent + 1,
        }
    }

    fn write(&mut self, s: &str) {
        for _ in 0..self.indent {
            self.target.push(' ');
        }
        self.target.push_str(s);
        self.target.push('\n');
    }
}

fn main() {}
```

报错如下：

```console
error[E0623]: lifetime mismatch
 --> src/main.rs:2:16
  |
1 | fn bar(writer: &mut Writer) {
  |                -----------
  |                |
  |                these two types are declared with different lifetimes...
2 |     baz(writer.indent());
  |                ^^^^^^ ...but data from `writer` flows into `writer` here
```

WTF，这什么报错，之前都没有见过，而且很难理解，什么叫`writer`滑入了另一个`writer`？

别急，我们先来仔细看下代码，注意这一段：

```rust
impl<'a> Writer<'a> {
    fn indent(&'a mut self) -> &'a mut Self {
        &mut Self {
            target: self.target,
            indent: self.indent + 1,
        }
    }
```

这里的生命周期定义说明`indent`方法使用的。。。等等！你的代码错了，你怎么能在一个函数中返回一个新创建实例的引用？！！最重要的是，编译器不提示这个错误，竟然提示一个莫名其妙看不懂的东东。

行，那我们先解决这个问题，将该方法修改为:

```rust
fn indent(&'a mut self) -> Writer<'a> {
    Writer {
        target: self.target,
        indent: self.indent + 1,
    }
}
```

怀着惴惴这心，再一次运行程序，果不其然，编译器又朝我们扔了一坨错误：

```console
error[E0308]: mismatched types
 --> src/main.rs:2:9
  |
2 |     baz(writer.indent());
  |         ^^^^^^^^^^^^^^^
  |         |
  |         expected `&mut Writer<'_>`, found struct `Writer`
  |         help: consider mutably borrowing here: `&mut writer.indent()`
```

哦，这次错误很明显，因为`baz`需要`&mut Writer`，但是咱们`writer.indent`返回了一个`Writer`，因此修改下即可:

```rust
fn bar(writer: &mut Writer) {
    baz(&mut writer.indent());
    writer.write("world");
}
```

这次总该成功了吧？再次心慌慌的运行编译器，哐：

```console
error[E0623]: lifetime mismatch
 --> src/main.rs:2:21
  |
1 | fn bar(writer: &mut Writer) {
  |                -----------
  |                |
  |                these two types are declared with different lifetimes...
2 |     baz(&mut writer.indent());
  |                     ^^^^^^ ...but data from `writer` flows into `writer` here
```

可恶，还是这个看不懂的错误，仔细检查了下代码，这次真的没有其他错误了，只能硬着头皮上。

大概的意思可以分析，生命周期范围不匹配，说明一个大一个小，然后一个`writer`中流入到另一个`writer`说明，两个`writer`的生命周期定义错了，既然这里提到了`indent`方法调用，那么我们再去仔细看一眼：

```rust
impl<'a> Writer<'a> {
    fn indent(&'a mut self) -> Writer<'a> {
        Writer {
            target: self.target,
            indent: self.indent + 1,
        }
    }
    ...
}
```

好像有点问题，`indent`返回的`Writer`的生命周期和外面调用者的`Writer`的生命周期一模一样，这很不合理，一眼就能看出前者远小于后者。

这里稍微展开以下，为何`indent`方法返回值的生命周期不能与参数中的`self`相同。**首先，我们假设它们可以相同，也就是上面的代码可以编译通过**，由于此时在返回值中借用了`self`的可变引用，意味着**如果你在返回值被使用后，还继续使用`self` 会导致重复借用的错误，因为返回值的生命周期将持续到 `self` 结束**。

既然不能相同，那我们尝试着修改下`indent`:

```rust
 fn indent<'b>(&'b mut self) -> Writer<'b> {
    Writer {
        target: self.target,
        indent: self.indent + 1,
    }
}
```

Bang! 编译成功，不过稍等，回想下生命周期消除的规则，我们还可以实现的更优雅：

```rust
fn bar(writer: &mut Writer) {
    baz(&mut writer.indent());
    writer.write("world");
}

fn baz(writer: &mut Writer) {
    writer.write("hello");
}

pub struct Writer<'a> {
    target: &'a mut String,
    indent: usize,
}

impl<'a> Writer<'a> {
    fn indent(&mut self) -> Writer {
        Writer {
            target: self.target,
            indent: self.indent + 1,
        }
    }

    fn write(&mut self, s: &str) {
        for _ in 0..self.indent {
            self.target.push(' ');
        }
        self.target.push_str(s);
        self.target.push('\n');
    }
}

fn main() {}
```

至此，问题彻底解决，太好了，我感觉我又变强了。可是默默看了眼自己的头发，只能以`哎～`一声叹息结束本章内容。




================================================
FILE: src/compiler/pitfalls/arithmetic-overflow.md
================================================
# 算术溢出导致的 panic

在 Rust 中，溢出后的数值被截断是很正常的:

```rust
let x: u16 = 65535;
let v = x as u8;
println!("{}", v)
```

最终程序会输出`255`, 因此大家可能会下意识地就觉得算数操作在 Rust 中只会导致结果的不正确，并不会导致异常。但是实际上，如果是因为算术操作符导致的溢出，就会让整个程序 panic:

```rust
fn main() {
    let x: u8 = 10;

    let v = x + u8::MAX;
    println!("{}", v)
}
```

输出结果如下:

```console
thread 'main' panicked at 'attempt to add with overflow', src/main.rs:5:13
```

那么当我们确实有这种需求时，该如何做呢？可以使用 Rust 提供的`checked_xxx`系列方法：

```rust
fn main() {
    let x: u8 = 10;

    let v = x.checked_add(u8::MAX).unwrap_or(0);
    println!("{}", v)
}
```

也许你会觉得本章内容其实算不上什么陷阱，但是在实际项目快速迭代中，越是不起眼的地方越是容易出错：

```rust
fn main() {
    let v = production_rate_per_hour(5);
    println!("{}", v);
}

pub fn production_rate_per_hour(speed: u8) -> f64 {
    let cph: u8 = 221;
    match speed {
        1..=4 => (speed * cph) as f64,
        5..=8 => (speed * cph) as f64 * 0.9,
        9..=10 => (speed * cph) as f64 * 0.77,
        _ => 0 as f64,
    }
}

pub fn working_items_per_minute(speed: u8) -> u32 {
    (production_rate_per_hour(speed) / 60 as f64) as u32
}
```

上述代码中，`speed * cph`就会直接 panic:

```console
thread 'main' panicked at 'attempt to multiply with overflow', src/main.rs:10:18
```

是不是还藏的挺隐蔽的？因此大家在 Rust 中做数学运算时，要多留一个心眼，免得上了生产才发现问题所在。或者，你也可以做好单元测试:)




================================================
FILE: src/compiler/pitfalls/closure-with-lifetime.md
================================================
# 闭包上奇怪的生命周期

Rust 一道独特的靓丽风景就是生命周期，也是反复折磨新手的最大黑手，就连老手，可能一不注意就会遇到一些生命周期上的陷阱，例如闭包上使用引用。

## 一段简单的代码

先来看一段简单的代码:

```rust
fn fn_elision(x: &i32) -> &i32 { x }
let closure_slision = |x: &i32| -> &i32 { x };
```

乍一看，这段代码比古天乐还平平无奇，能有什么问题呢？来，走两圈试试：

```console
error: lifetime may not live long enough
  --> src/main.rs:39:39
   |
39 |     let closure = |x: &i32| -> &i32 { x }; // fails
   |                       -        -      ^ returning this value requires that `'1` must outlive `'2`
   |                       |        |
   |                       |        let's call the lifetime of this reference `'2`
   |                       let's call the lifetime of this reference `'1`
```

咦？竟然报错了，明明两个一模一样功能的函数，一个正常编译，一个却报错，错误原因是编译器无法推测返回的引用和传入的引用谁活得更久！

真的是非常奇怪的错误，学过[Rust 生命周期](https://course.rs/basic/lifetime.html#三条消除规则)的读者应该都记得这样一条生命周期消除规则: **如果函数参数中只有一个引用类型，那该引用的生命周期会被自动分配给所有的返回引用**。我们当前的情况完美符合，`fn_elision`函数的顺利编译通过，就充分说明了问题。

那为何闭包就出问题了？

## 一段复杂的代码

为了验证闭包无法应用生命周期消除规则，再来看一个复杂一些的例子:

```rust
use std::marker::PhantomData;

trait Parser<'a>: Sized + Copy {
    fn parse(&self, tail: &'a str) -> &'a str {
        tail
    }
    fn wrap(self) -> Wrapper<'a, Self> {
        Wrapper {
            parser: self,
            marker: PhantomData,
        }
    }
}

#[derive(Copy, Clone)]
struct T<'x> {
    int: &'x i32,
}

impl<'a, 'x> Parser<'a> for T<'x> {}

struct Wrapper<'a, P>
where
    P: Parser<'a>,
{
    parser: P,
    marker: PhantomData<&'a ()>,
}

fn main() {
    // Error.
    let closure_wrap = |parser: T| parser.wrap();

    // No error.
    fn parser_wrap(parser: T<'_>) -> Wrapper<'_, T<'_>> {
        parser.wrap()
    }
}
```

该例子之所以这么复杂，纯粹是为了证明闭包上生命周期会失效，读者大大轻拍:) 编译后，不出所料的报错了：

```console
error: lifetime may not live long enough
  --> src/main.rs:32:36
   |
32 |     let closure_wrap = |parser: T| parser.wrap();
   |                         ------   - ^^^^^^^^^^^^^ returning this value requires that `'1` must outlive `'2`
   |                         |        |
   |                         |        return type of closure is Wrapper<'_, T<'2>>
   |                         has type `T<'1>`
```

## 深入调查

一模一样的报错，说明在这种情况下，生命周期的消除规则也没有生效，看来事情确实不简单，我眉头一皱，决定深入调查，最后还真翻到了一些讨论，经过整理后，大概分享给大家。

首先给出一个结论：**这个问题，可能很难被解决，建议大家遇到后，还是老老实实用正常的函数，不要秀闭包了**。

对于函数的生命周期而言，它的消除规则之所以能生效是因为它的生命周期完全体现在签名的引用类型上，在函数体中无需任何体现:

```rust
fn fn_elision(x: &i32) -> &i32 {..}
```

因此编译器可以做各种编译优化，也很容易根据参数和返回值进行生命周期的分析，最终得出消除规则。

可是闭包，并没有函数那么简单，它的生命周期分散在参数和闭包函数体中(主要是它没有确切的返回值签名)：

```rust
let closure_slision = |x: &i32| -> &i32 { x };
```

编译器就必须深入到闭包函数体中，去分析和推测生命周期，复杂度因此极具提升：试想一下，编译器该如何从复杂的上下文中分析出参数引用的生命周期和闭包体中生命周期的关系？

由于上述原因(当然，实际情况复杂的多)， Rust 语言开发者其实目前是有意为之，针对函数和闭包实现了两种不同的生命周期消除规则。

## 总结

虽然我言之凿凿，闭包的生命周期无法解决，但是未来谁又知道呢。最大的可能性就是之前开头那种简单的场景，可以被自动识别和消除。

总之，如果有这种需求，还是像古天乐一样做一个平平无奇的男人，老老实实使用函数吧。




================================================
FILE: src/compiler/pitfalls/index.md
================================================
# Rust 陷阱系列

本章收录一些 Rust 常见的陷阱，一不小心就会坑你的那种(当然，这不是 Rust 语言的问题，而是一些边边角角的知识点)。




================================================
FILE: src/compiler/pitfalls/iterator-everywhere.md
================================================
# 无处不在的迭代器

Rust 的迭代器无处不在，直至你在它上面栽了跟头，经过深入调查才发现：哦，原来是迭代器的锅。不信的话，看看这个报错你能想到是迭代器的问题吗: `borrow of moved value: words`.

## 报错的代码

以下的代码非常简单，用来统计文本中字词的数量，并打印出来：

```rust
fn main() {
    let s = "hello world";
    let mut words = s.split(" ");
    let n = words.count();
    println!("{:?}",words);
}
```

四行代码，行云流水，一气呵成，且看成效：

```console
error[E0382]: borrow of moved value: `words`
   --> src/main.rs:5:21
    |
3   |     let mut words = s.split(" ");
    |         --------- move occurs because `words` has type `std::str::Split<'_, &str>`, which does not implement the `Copy` trait
4   |     let n = words.count();
    |                   ------- `words` moved due to this method call
5   |     println!("{:?}",words);
    |                     ^^^^^ value borrowed here after move
```

世事难料，我以为只有的生命周期、闭包才容易背叛革命，没想到一个你浓眉大眼的`count`方法也背叛革命。从报错来看，是因为`count`方法拿走了`words`的所有权，来看看签名：

```rust
fn count(self) -> usize
```

从签名来看，编译器的报错是正确的，但是为什么？为什么一个简单的标准库`count`方法就敢拿走所有权？

## 迭代器回顾

在[迭代器](https://course.rs/advance/functional-programing/iterator.html#消费者与适配器)章节中，我们曾经学习过两个概念：迭代器适配器和消费者适配器，前者用于对迭代器中的元素进行操作，最终生成一个新的迭代器，例如`map`、`filter`等方法；而后者用于消费掉迭代器，最终产生一个结果，例如`collect`方法, 一个典型的示例如下：

```rust
let v1: Vec<i32> = vec![1, 2, 3];

let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
```

在其中，我们还提到一个细节，消费者适配器会拿走迭代器的所有权，那么这个是否与我们最开始碰到的问题有关系？

## 深入调查

要解释这个问题，必须要找到`words`是消费者适配器的证据，因此我们需要深入源码进行查看。

其实。。也不需要多深，只要进入`words`的源码，就能看出它属于`Iterator`特征，那说明`split`方法产生了一个迭代器？再来看看：

```rust
pub fn split<'a, P>(&'a self, pat: P) -> Split<'a, P>
where
    P: Pattern<'a>,
//An iterator over substrings of this string slice, separated by characters matched by a pattern.
```

还真是，从代码注释来看，`Split`就是一个迭代器类型，用来迭代被分隔符隔开的子字符串集合。

真相大白了，`split`产生一个迭代器，而`count`方法是一个消费者适配器，用于消耗掉前者产生的迭代器，最终生成字词统计的结果。

本身问题不复杂，但是在**解决方法上，可能还有点在各位客官的意料之外**，且看下文。

## 最 rusty 的解决方法

你可能会想用`collect`来解决这个问题，先收集成一个集合，然后进行统计。当然此方法完全可行，但是很不`rusty`(很符合 rust 规范、潮流的意思)，以下给出最`rusty`的解决方案：

```rust
let words = s.split(",");
let n = words.clone().count();
```

在继续之前，我得先找一个地方藏好，因为俺有一个感觉，烂西红柿正在铺天盖地的呼啸而来，伴随而来的是读者的正义呵斥：
**你管`clone`叫最好、最`rusty`的解决方法？？**

大家且听我慢慢道来，事实上，在 Rust 中`clone`不总是性能低下的代名词，因为`clone`的行为完全取决于它的具体实现。

#### 迭代器的`clone`代价

对于迭代器而言，它其实并不需要持有数据才能进行迭代，事实上它包含一个引用，该引用指向了保存在堆上的数据，而迭代器自身的结构是保存在栈上。

因此对迭代器的`clone`仅仅是复制了一份栈上的简单结构，性能非常高效，例如:

```rust
pub struct Split<'a, T: 'a, P>
where
    P: FnMut(&T) -> bool,
{
    // Used for `SplitWhitespace` and `SplitAsciiWhitespace` `as_str` methods
    pub(crate) v: &'a [T],
    pred: P,
    // Used for `SplitAsciiWhitespace` `as_str` method
    pub(crate) finished: bool,
}

impl<T, P> Clone for Split<'_, T, P>
where
    P: Clone + FnMut(&T) -> bool,
{
    fn clone(&self) -> Self {
        Split { v: self.v, pred: self.pred.clone(), finished: self.finished }
    }
}
```

以上代码实现了对`Split`迭代器的克隆，可以看出，底层的的数组`self.v`并没有被克隆而是简单的复制了一个引用，依然指向了底层的数组`&[T]`，因此这个克隆非常高效。

## 总结

看起来是无效借用导致的错误，实际上是迭代器被消费了导致的问题，这说明 Rust 编译器虽然会告诉你错误原因，但是这个原因不总是根本原因。我们需要一双慧眼和勤劳的手，来挖掘出这个宝藏，最后为己所用。

同时，克隆在 Rust 中也并不总是**bad guy**的代名词，有的时候我们可以大胆去使用，当然前提是了解你的代码场景和具体的`clone`实现，这样你也能像文中那样作出非常`rusty`的选择。




================================================
FILE: src/compiler/pitfalls/lazy-iterators.md
================================================
# 不太勤快的迭代器

迭代器，在 Rust 中是一个非常耀眼的存在，它光鲜亮丽，它让 Rust 大道至简，它备受用户的喜爱。可是，它也是懒惰的，不信？一起来看看。

## for 循环 vs 迭代器

在迭代器学习中，我们提到过迭代器在功能上可以替代循环，性能上略微优于循环(避免边界检查),安全性上优于循环，因此在 Rust 中，迭代器往往都是更优的选择，前提是迭代器得发挥作用。

在下面代码中，分别是使用`for`循环和迭代器去生成一个`HashMap`。

使用循环:

```rust
use std::collections::HashMap;
#[derive(Debug)]
struct Account {
    id: u32,
}

fn main() {
    let accounts = [Account { id: 1 }, Account { id: 2 }, Account { id: 3 }];

    let mut resolvers = HashMap::new();
    for a in accounts {
        resolvers.entry(a.id).or_insert(Vec::new()).push(a);
    }

    println!("{:?}",resolvers);
}
```

使用迭代器:

```rust
let mut resolvers = HashMap::new();
accounts.into_iter().map(|a| {
    resolvers
        .entry(a.id)
        .or_insert(Vec::new())
        .push(a);
});
println!("{:?}",resolvers);
```

#### 预料之外的结果

两端代码乍一看(很多时候我们快速浏览代码的时候，不会去细看)都很正常, 运行下试试:

- `for`循环很正常，输出`{2: [Account { id: 2 }], 1: [Account { id: 1 }], 3: [Account { id: 3 }]}`
- 迭代器很。。。不正常，输出了一个`{}`, 黑人问号`? ?` **?**

在继续深挖之前，我们先来简单回顾下迭代器。

## 回顾下迭代器

在迭代器章节中，我们曾经提到过，迭代器的[适配器](https://course.rs/advance/functional-programing/iterator.html#消费者与适配器)分为两种：消费者适配器和迭代器适配器，前者用来将一个迭代器变为指定的集合类型，往往通过`collect`实现；后者用于生成一个新的迭代器，例如上例中的`map`。

还提到过非常重要的一点: **迭代器适配器都是懒惰的，只有配合消费者适配器使用时，才会进行求值**.

## 懒惰是根因

在我们之前的迭代器示例中，只有一个迭代器适配器`map`:

```rust
accounts.into_iter().map(|a| {
    resolvers
        .entry(a.id)
        .or_insert(Vec::new())
        .push(a);
});
```

首先, `accounts`被拿走所有权后转换成一个迭代器，其次该迭代器通过`map`方法生成一个新的迭代器，最后，在此过程中没有以类如`collect`的消费者适配器收尾。

因此在上述过程中，`map`完全是懒惰的，它没有做任何事情，它在等一个消费者适配器告诉它：赶紧起床，任务可以开始了，它才会开始行动。

自然，我们的插值计划也失败了。

> 事实上，IDE 和编译器都会对这种代码给出警告：iterators are lazy and do nothing unless consumed

## 解决办法

原因非常清晰，如果读者还有疑惑，建议深度了解下上面给出的迭代器链接，我们这里就不再赘述。

下面列出三种合理的解决办法：

1. 不再使用迭代器适配器`map`，改成`for_each`:

```rust
let mut resolvers = HashMap::new();
accounts.into_iter().for_each(|a| {
    resolvers
        .entry(a.id)
        .or_insert(Vec::new())
        .push(a);
});
```

但是，相关的文档也友善的提示了我们，除非作为链式调用的收尾，否则更建议使用`for`循环来处理这种情况。哎，忙忙碌碌，又回到了原点，不禁让人感叹：天道有轮回。

2. 使用消费者适配器`collect`来收尾，将`map`产生的迭代器收集成一个集合类型:

```rust
let resolvers: HashMap<_, _> = accounts
.into_iter()
.map(|a| (a.id, a))
.collect();
```

嗯，还挺简洁，挺`rusty`.

3. 使用`fold`，语义表达更强:

```rust
let resolvers = account.into_iter().fold(HashMap::new(), |mut resolvers, a|{
    resolvers.entry(a.id).or_insert(Vec::new()).push(a);
    resolvers
});
```

## 总结

在使用迭代器时，要清晰的认识到需要用到的方法是迭代型还是消费型适配器，如果一个调用链中没有以消费型适配器结尾，就需要打起精神了，也许，不远处就是一个陷阱在等你跳:)



================================================
FILE: src/compiler/pitfalls/main-with-channel-blocked.md
================================================
# 线程间传递消息导致主线程无法结束

本篇陷阱较短，主要解决新手在多线程间传递消息时可能会遇到的一个问题：主线程会一直阻塞，无法结束。

Rust 标准库中提供了一个消息通道，非常好用，也相当简单明了，但是但是在使用起来还是可能存在坑：

```rust
use std::sync::mpsc;
fn main() {

    use std::thread;

    let (send, recv) = mpsc::channel();
    let num_threads = 3;
    for i in 0..num_threads {
        let thread_send = send.clone();
        thread::spawn(move || {
            thread_send.send(i).unwrap();
            println!("thread {:?} finished", i);
        });
    }

    for x in recv {
        println!("Got: {}", x);
    }
    println!("finished iterating");
}
```

以上代码看起来非常正常，运行下试试:

```console
thread 0 finished
thread 1 finished
Got: 0
Got: 1
thread 2 finished
Got: 2
```

奇怪，主线程竟然卡死了，最后一行` println!("finished iterating");`一直没有被输出。

其实，上面的描述有问题，主线程并不是卡死，而是`for`循环并没有结束，至于`for`循环不结束的原因是消息通道没有被关闭。

回忆一下 Rust 消息通道关闭的两个条件：所有发送者全部被`drop`或接收者被`drop`，由于`for`循环还在使用接收者，因为后者条件无法被满足，那么只能发送者全部被`drop`，才能让例子中的消息通道关闭。

来分析下代码，每一个子线程都从`send`获取了一个拷贝，然后该拷贝在子线程结束时自动被`drop`，看上去没问题啊。等等，好像`send`本身并没有被`drop`，因为`send`要等到`main`函数结束才会被`drop`，那么代码就陷入了一个尴尬的境地：`main`函数要结束需要`for`循环结束，`for`循环结束需要`send`被`drop`，而`send`要被`drop`需要`main`函数结束。。。

破局点只有一个，那就是主动`drop`掉`send`，这个简单，使用`std::mem::drop`函数即可，得益于`prelude`，我们只需要使用`drop`:

```rust
use std::sync::mpsc;
fn main() {

    use std::thread;

    let (send, recv) = mpsc::channel();
    let num_threads = 3;
    for i in 0..num_threads {
        let thread_send = send.clone();
        thread::spawn(move || {

            thread_send.send(i).unwrap();
            println!("thread {:?} finished", i);
        });
    }

    drop(send);
    for x in recv {
        println!("Got: {}", x);
    }
    println!("finished iterating");
}
```

此时再运行，主线程将顺利结束。

## 总结

本文总结了一个新手在使用消息通道时常见的错误，那就是忘记处理创建通道时得到的发送者，最后由于该发送者的存活导致通道无法被关闭，最终主线程阻塞，造成程序错误。



================================================
FILE: src/compiler/pitfalls/multiple-mutable-references.md
================================================
[Binary file]


================================================
FILE: src/compiler/pitfalls/stack-overflow.md
================================================
[Binary file]


================================================
FILE: src/compiler/pitfalls/the-disabled-mutability.md
================================================
[Binary file]


================================================
FILE: src/compiler/pitfalls/use-vec-in-for.md
================================================
# for 循环中使用外部数组

一般来说，`for`循环能做到的，`while`也可以，反之亦然，但是有一种情况，还真不行，先来看代码:

```rust
let mut v = vec![1,2,3];

for i in 0..v.len() {
    v.push(i);
    println!("{:?}",v);
}
```

我们的目的是创建一个无限增长的数组，往里面插入`0..`(看不懂该表达式的同学请查阅[流程控制](https://course.rs/basic/flow-control.html))的数值序列。

看起来上面代码可以完成，因为随着数组不停增长，`v.len()`也会不停变大，但是事实上真的如此吗？

```console
[1, 2, 3, 0]
[1, 2, 3, 0, 1]
[1, 2, 3, 0, 1, 2]
```

输出很清晰的表明，只新插入了三个元素：`0..=2`，刚好是`v`的初始长度。

这是因为：**在 for 循环中,`v.len`只会在循环伊始之时进行求值，之后就一直使用该值**。

行，问题算是清楚了，那该如何解决呢，我们可以使用`while`循环，该循环与`for`相反，每次都会重新求值：

```rust
let mut v = vec![1,2,3];

let mut i = 0;
while i < v.len() {
    v.push(i);
    i+=1;
    println!("{:?}",v);
}
```

友情提示，在你运行上述代码时，千万要及时停止，否则会`Boom` - 炸翻控制台。



================================================
FILE: src/compiler/pitfalls/utf8-performance.md
================================================
[Binary file]


================================================
FILE: src/compiler/pitfalls/weird-ranges.md
================================================
# 奇怪的序列x..y

@todo

https://www.reddit.com/r/rust/comments/rrgxr0/a_critique_of_rusts_range_types/


================================================
FILE: src/difficulties/cow.md
================================================
# 写时拷贝Cow todo



================================================
FILE: src/difficulties/eq.md
================================================
# Eq 和 PartialEq
在 Rust 中，想要重载操作符，你就需要实现对应的特征。

例如 `<`、`<=`、`>` 和 `>=` 需要实现 `PartialOrd` 特征:
```rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```

再比如， `+` 号需要实现 `std::ops::Add` 特征，而本文的主角 `Eq` 和 `PartialEq` 正是 `==` 和 `!=` 所需的特征，那么问题来了，这两个特征有何区别？

我相信很多同学都说不太清楚，包括一些老司机，而且就算是翻文档，可能也找不到特别明确的解释。如果大家看过标准库示例，可能会看过这个例子：
```rust
enum BookFormat { Paperback, Hardback, Ebook }
struct Book {
    isbn: i32,
    format: BookFormat,
}
impl PartialEq for Book {
    fn eq(&self, other: &Self) -> bool {
        self.isbn == other.isbn
    }
}
impl Eq for Book {}
```

这里只实现了 `PartialEq`，并没有实现 `Eq`，而是直接使用了默认实现 `impl Eq for Book {}`，奇了怪了，别急，还有呢：
```rust
impl PartialEq<IpAddr> for Ipv4Addr {
    #[inline]
    fn eq(&self, other: &IpAddr) -> bool {
        match other {
            IpAddr::V4(v4) => self == v4,
            IpAddr::V6(_) => false,
        }
    }
}

impl Eq for Ipv4Addr {}
```

以上代码来自 Rust 标准库，可以看到，依然是这样使用，类似的情况数不胜数。既然如此，是否说明**如果要为我们的类型增加相等性比较，只要实现 `PartialEq` 即可？**

其实，关键点就在于 `partial` 上，**如果我们的类型只在部分情况下具有相等性**，那你就只能实现 `PartialEq`，否则可以实现 `PartialEq` 然后再默认实现 `Eq`。

好的，问题逐步清晰起来，现在我们只需要搞清楚何为部分相等。

### 部分相等性
首先我们需要找到一个类型，它实现了 `PartialEq` 但是没有实现 `Eq`（你可能会想有没有反过来的情况？当然没有啦，部分相等肯定是全部相等的子集！）

在 `HashMap` 章节提到过 `HashMap` 的 key 要求实现 `Eq` 特征，也就是要能完全相等，而浮点数由于没有实现 `Eq` ，因此不能用于 `HashMap` 的 key。

当时由于一些知识点还没有介绍，因此就没有进一步展开，那么让我们考虑浮点数既然没有实现 `Eq` 为何还能进行比较呢？
```rust
fn main() {
   let f1 = 3.14;
   let f2 = 3.14;

   if f1 == f2 {
       println!("hello, world!");
   }
}
```

以上代码是可以看到输出内容的，既然浮点数没有实现 `Eq` 那说明它实现了 `PartialEq`，一起写个简单代码验证下：
```rust
fn main() {
    let f1 = 3.14;
    is_eq(f1);
    is_partial_eq(f1)
}

fn is_eq<T: Eq>(f: T) {}
fn is_partial_eq<T: PartialEq>(f: T) {}
```

上面的代码通过特征约束的方式验证了我们的结论: 
```shell
3 |     is_eq(f1);
  |     ----- ^^ the trait `Eq` is not implemented for `{float}`
```

好的，既然我们成功找到了一个类型实现了 `PartialEq` 但没有实现 `Eq`，那就通过它来看看何为部分相等性。

其实答案很简单，浮点数有一个特殊的值 `NaN`，它是无法进行相等性比较的:
```rust
fn main() {
    let f1 = f32::NAN;
    let f2 = f32::NAN;

    if f1 == f2 {
        println!("NaN 竟然可以比较，这很不数学啊！")
    } else {
        println!("果然，虽然两个都是 NaN ，但是它们其实并不相等")
    }
}
```

大家猜猜哪一行会输出 :) 至于 `NaN` 为何不能比较，这个原因就比较复杂了( 有读者会说，其实就是你不知道，我只能义正严辞的说：咦？你怎么知道 :P )。

既然浮点数有一个值不可以比较相等性，那它自然只能实现 `PartialEq` 而不能实现 `Eq` 了，以此类推，如果我们的类型也有这种特殊要求，那也应该这么做。

### Ord 和 PartialOrd
事实上，还有一对与 `Eq/PartialEq` 非常类似的特征，它们可以用于 `<`、`<=`、`>` 和 `>=` 比较，至于哪个类型实现了 `PartialOrd` 却没有实现 `Ord` 就交给大家自己来思考了：）


> 小提示：Ord 意味着一个类型的所有值都可以进行排序，而 PartialOrd 则不然



================================================
FILE: src/difficulties/intro.md
================================================
# Rust 难点攻关

当大家一路看到这里时，我敢说 90% 的人还是云里雾里的，例如你能说清楚:

- 切片和切片引用的区别吗？
- 各种字符串之间的区别吗？
- 各种指针、引用的区别吗？
- 所有权转移、拷贝、克隆的区别吗？

以及到底该用它们之中哪一个吗？

如果不行，就跟随我一起来看看吧，本章的目标就是帮大家彻底理清这些概念，为后面的进一步学习和实战打好坚实的基础。





================================================
FILE: src/difficulties/lifetime.md
================================================
# 作用域、生命周期和 NLL todo



================================================
FILE: src/difficulties/move-copy.md
================================================
# move、Copy和Clone todo



================================================
FILE: src/difficulties/pointer.md
================================================
# 裸指针、引用和智能指针 todo

<!-- https://blog.csdn.net/kk3909/article/details/106743025 -->


================================================
FILE: src/difficulties/slice.md
================================================
# 切片和切片引用

关于 `str` / `&str`，`[u8]` / `&[u8]` 区别，你能清晰的说出来嘛？如果答案是 No ，那就跟随我一起来看看切片和切片引用到底有何区别吧。

> 在继续之前，查看[这里](https://course.rs/basic/compound-type/string-slice.html#切片slice)了解何为切片

切片允许我们引用集合中部分连续的元素序列，而不是引用整个集合。例如，字符串切片就是一个子字符串，数组切片就是一个子数组。

## 无法被直接使用的切片类型

Rust 语言特性内置的 `str` 和 `[u8]` 类型都是切片，前者是字符串切片，后者是数组切片，下面我们来尝试下使用 `str` ：

```rust
let string: str = "banana";
```

上面代码创建一个 `str` 类型的字符串，看起来很正常，但是编译就会报错：

```shell
error[E0277]: the size for values of type `str` cannot be known at compilation time
 --> src/main.rs:4:9
  |
4 |     let string: str = "banana";
  |         ^^^^^^ doesn't have a size known at compile-time
```

编译器准确的告诉了我们原因：`str` 字符串切片它是 [`DST` 动态大小类型](https://course.rs/advance/into-types/sized.html#动态大小类型-dst)，这意味着编译器无法在编译期知道 `str` 类型的大小，只有到了运行期才能动态获知，这对于强类型、强安全的 Rust 语言来说是不可接受的。

也就是说，我们无法直接使用 `str`，而对于 `[u8]` 也是类似的，大家可以自己动手试试。

总之，我们可以总结出一个结论：**在 Rust 中，所有的切片都是动态大小类型，它们都无法直接被使用**。

#### 为何切片是动态大小类型

原因在于底层的切片长度是可以动态变化的，而编译器无法在编译期得知它的具体的长度，因此该类型无法被分配在栈上，只能分配在堆上。

#### 为何切片只能通过引用来使用

既然切片只能分配到堆上，我们就无法直接使用它，大家可以想想，所有分配在堆上的数据，是不是都是通过一个在栈上的引用来访问的？切片也不例外。

#### 为何切片引用可以存储在栈上

切片引用是一个宽指针，存储在栈上，指向了堆上的切片数据，该引用包含了切片的起始位置和长度，而且最重要的是，类似于指针，引用的大小是固定的(起始位置和长度都是整形)，因此它才可以存储在栈上。

#### 有没有可以存储在栈上的

有，使用固定长度的数组: `let a: [i8;4] = [1,2,3,4];`，注意看，数组的类型与切片是不同的，前者的类型带有长度：`[i8;4]`，而后者仅仅是 `[i8]`。

## 切片引用

那么问题来了，该如何使用切片呢？

何以解忧，唯有引用。由于引用类型的大小在编译期是已知的，因此在 Rust 中，如果要使用切片，就必须要使用它的引用。

`str` 切片的引用类型是 `&str`，而 `[i32]` 的引用类型是 `&[i32]`，相信聪明的读者已经看出来了，`&str` 和 `&[i32]` 都是我们非常常用的类型，例如:

```rust
let s1: &str = "banana";
let s2: &str = &String::from("banana");

let arr = [1, 2, 3, 4, 5];

let s3: &[i32] = &arr[1..3];
```

这段代码就可以正常通过，原因在于这些切片引用的大小在编译器都是已知的。

## 总结

我们常常说使用切片，实际上我们在用的是切片的引用，我们也在频繁说使用字符串，实际上我们在使用的也是字符串切片的引用。

总之，切片在 Rust 中是动态大小类型 DST，是无法被我们直接使用的，而我们在使用的都是切片的引用。

| 切片           | 切片引用              |
| -------------- | --------------------- |
| str 字符串切片 | &str 字符串切片的引用 |
| [u8] 数组切片  | &[u8] 数组切片的引用  |

**但是出于方便，我们往往不会说使用切片引用，而是直接说使用字符串切片或数组切片，实际上，这时指代的都是切片的引用！**




================================================
FILE: src/difficulties/string.md
================================================
[Binary file]


================================================
FILE: src/first-try/cargo.md
================================================
[Binary file]


================================================
FILE: src/first-try/editor.md
================================================
[Binary file]


================================================
FILE: src/first-try/hello-world.md
================================================
# 不仅仅是 Hello world

几乎所有教程中安装的最后一个环节都是 `hello world`，我们也不能免俗。但是，在 `hello world` 之后，还有一个相亲，啊呸，Rust 初印象环节，希望大家喜欢。

## 多国语言的"世界，你好"

还记得大明湖畔等你的 [VSCode IDE](https://course.rs/first-try/editor.html) 和通过 `Cargo` 创建的 [世界，你好](https://course.rs/first-try/cargo.html) 工程吗？

现在使用 VSCode 打开 [上一节](https://course.rs/first-try/cargo.html) 中创建的 `world_hello` 工程，然后进入 `main.rs` 文件。（此文件是当前 Rust 工程的入口文件，和其它语言几无区别。）

接下来，对世界友人给予热切的问候：

```rust
fn greet_world() {
    let southern_germany = "Grüß Gott!";
    let chinese = "世界，你好";
    let english = "World, hello";
    let regions = [southern_germany, chinese, english];
    for region in regions.iter() {
        println!("{}", &region);
    }
}

fn main() {
    greet_world();
}
```

打开终端，进入 `world_hello` 工程根目录，运行该程序。（你也可以在 VSCode 中打开终端，方法是点击 VSCode 上方菜单栏中的终端->新建终端，或者直接使用快捷键打开。）

```console
$ cargo run
   Compiling world_hello v0.1.0 (/Users/sunfei/development/rust/world_hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.21s
     Running `target/debug/world_hello`
Grüß Gott!
世界，你好
World, hello
```

你的热情，就像一把火，燃烧了整个世界~ 花点时间来看看上面的代码：

首先，Rust 原生支持 UTF-8 编码的字符串，这意味着你可以很容易的使用世界各国文字作为字符串内容。

其次，关注下 `println` 后面的 `!`，如果你有 Ruby 编程经验，那么你可能会认为这是解构操作符，但是在 Rust 中，这是 `宏` 操作符，你目前可以认为宏是一种特殊类型函数。

对于 `println` 来说，我们没有使用其它语言惯用的 `%s`、`%d` 来做输出占位符，而是使用 `{}`，因为 Rust 在底层帮我们做了大量工作，会自动识别输出数据的类型，例如当前例子，会识别为 `String` 类型。

最后，和其它语言不同，Rust 的集合类型不能直接进行循环，需要变成迭代器（这里是通过 `.iter()` 方法），才能用于迭代循环。在目前来看，你会觉得这一点好像挺麻烦，不急，以后就知道这么做的好处所在。

> 实际上这段代码可以简写，在 2021 edition 及以后，支持直接写 `for region in regions`，原因会在迭代器章节的开头提到，是因为 for 隐式地将 regions 转换成迭代器。

至于函数声明、调用、数组的使用，和其它语言没什么区别，So Easy！

## Rust 语言初印象

Haskell 和 Java 开发者们可能会觉得Rust 这门语言很熟悉，因为它们在高阶表达方面都很优秀。简而言之，就是可以很简洁的写出原本需要一大堆代码才能表达的含义。但是，Rust 又有所不同：它的性能是底层语言级别的性能，可以跟 C/C++ 相媲美。

上面的 `So Easy` 的余音仍在绕梁，我希望它能继续下去，可是… 人总是要面对现实，因此让我们来点狠活：

```rust
fn main() {
   let penguin_data = "\
   common name,length (cm)
   Little penguin,33
   Yellow-eyed penguin,65
   Fiordland penguin,60
   Invalid,data
   ";

   let records = penguin_data.lines();

   for (i, record) in records.enumerate() {
     if i == 0 || record.trim().len() == 0 {
       continue;
     }

     // 声明一个 fields 变量，类型是 Vec
     // Vec 是 vector 的缩写，是一个可伸缩的集合类型，可以认为是一个动态数组
     // <_>表示 Vec 中的元素类型由编译器自行推断，在很多场景下，都会帮我们省却不少功夫
     let fields: Vec<_> = record
       .split(',')
       .map(|field| field.trim())
       .collect();
     if cfg!(debug_assertions) {
         // 输出到标准错误输出
       eprintln!("debug: {:?} -> {:?}",
              record, fields);
     }

     let name = fields[0];
     // 1. 尝试把 fields[1] 的值转换为 f32 类型的浮点数，如果成功，则把 f32 值赋给 length 变量
     //
     // 2. if let 是一个匹配表达式，用来从=右边的结果中，匹配出 length 的值：
     //   1）当=右边的表达式执行成功，则会返回一个 Ok(f32) 的类型，若失败，则会返回一个 Err(e) 类型，if let 的作用就是仅匹配 Ok 也就是成功的情况，如果是错误，就直接忽略
     //   2）同时 if let 还会做一次解构匹配，通过 Ok(length) 去匹配右边的 Ok(f32)，最终把相应的 f32 值赋给 length
     //
     // 3. 当然你也可以忽略成功的情况，用 if let Err(e) = fields[1].parse::<f32>() {...}匹配出错误，然后打印出来，但是没啥卵用
     if let Ok(length) = fields[1].parse::<f32>() {
         // 输出到标准输出
         println!("{}, {}cm", name, length);
     }
   }
 }
```

看完这段代码，不知道你的余音有没有戛然而止，反正我已经在颤抖了。这就是传说中的下马威吗？😵

上面代码中，值得注意的 Rust 特性有：

- 控制流：`for` 和 `continue` 连在一起使用，实现循环控制。
- 方法语法：由于 Rust 没有继承，因此 Rust 不是传统意义上的面向对象语言，但是它却从 `OO` 语言那里偷师了方法的使用 `record.trim()`，`record.split(',')` 等。
- 高阶函数编程：函数可以作为参数也能作为返回值，例如 `.map(|field| field.trim())`，这里 `map` 方法中使用闭包函数作为参数，也可以称呼为 `匿名函数`、`lambda 函数`。
- 类型标注：`if let Ok(length) = fields[1].parse::<f32>()`，通过 `::<f32>` 的使用，告诉编译器 `length` 是一个 `f32` 类型的浮点数。这种类型标注不是很常用，但是在编译器无法推断出你的数据类型时，就很有用了。
- 条件编译：`if cfg!(debug_assertions)`，说明紧跟其后的输出（打印）只在 `debug` 模式下生效。
- 隐式返回：Rust 提供了 `return` 关键字用于函数返回，但是在很多时候，我们可以省略它。因为 Rust 是 [**基于表达式的语言**](https://course.rs/basic/base-type/statement-expression.html)。

在终端中运行上述代码时，会看到很多 `debug: ...` 的输出，上面有讲，这些都是 `条件编译` 的输出，那么该怎么消除掉这些输出呢？

读者大大普遍冰雪聪明，肯定已经想到：是的，在 [认识 Cargo](https://course.rs/first-try/cargo.html#手动编译和运行项目) 中，曾经介绍过 `--release` 参数，因为 `cargo run` 默认是运行 `debug` 模式。因此想要消灭那些 `debug:` 输出，需要更改为其它模式，其中最常用的模式就是 `--release` 也就是生产发布的模式。

具体运行代码就不给了，留给大家作为一个小练习，建议亲自动手尝试下。

至此，Rust 安装入门就已经结束。相信看到这里，你已经发现了本书与其它书的区别，其中最大的区别就是：**这本书就像优秀的国外课本一样，不太枯燥。也希望这本不太枯燥的书，能伴你长行，犹如一杯奶茶，细细品之，唇齿留香。**



================================================
FILE: src/first-try/installation.md
================================================
# 安装 Rust

`rustup` 是 Rust 的安装程序，也是它的版本管理程序。
强烈建议使用 `rustup` 来安装 Rust，当然如果你有异心，请寻找其它安装方式，然后再从下一节开始阅读。

> haha，开个玩笑。读者乃大大，怎么能弃之不顾。
>
> 注意：如果你不想用或者不能用 rustup，请参见 [Rust 其它安装方法](https://forge.rust-lang.org/infra/other-installation-methods.html#other-rust-installation-methods)。

至于版本，现在 Rust 稳定版特性越来越全了，因此下载最新稳定版本即可。由于你用的 Rust 版本可能跟本书写作时不一样，一些编译错误和警告可能也会有所不同。

## 在 Linux 或 macOS 上安装 `rustup`

打开终端并输入下面命令：

```console
$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
```

这个命令将下载一个脚本并开始安装 `rustup` 工具，此工具将安装 Rust 的最新稳定版本。可能会提示你输入管理员密码。

如果安装成功，将出现下面这行：

```text
Rust is installed now. Great!
```

OK，这样就已经完成 Rust 安装啦。

### 安装 C 语言编译器：（非必需）

Rust 对运行环境的依赖和 Go 语言很像，几乎所有环境都可以无需安装任何依赖直接运行。但是，Rust 会依赖 `libc` 和链接器 `linker`。所以如果遇到了提示链接器无法执行的错误，你需要再手动安装一个 C 语言编译器：

**macOS 下：**

```console
$ xcode-select --install
```

**Linux 下：**

Linux 用户一般应按照相应发行版的文档来安装 `GCC` 或 `Clang`。

例如，如果你使用 Ubuntu，则可安装 `build-essential`。

## 在 FreeBSD 上安装 `rustup`

- 使用 pkg 安装：

```sh
# pkg install rustup-init
```

- 使用 Ports 安装：

```sh
# cd /usr/ports/devel/rustup-init/ 
# make install clean
```

## 在 Windows 上安装 `rustup`

Windows 上安装 Rust 需要有 `C++` 环境，以下为安装的两种方式：

**1. `x86_64-pc-windows-msvc`（官方推荐）**

先安装 [Microsoft C++ Build Tools](https://visualstudio.microsoft.com/zh-hans/visual-cpp-build-tools/)，勾选安装 C++ 环境即可。安装时可自行修改缓存路径与安装路径，避免占用过多 C 盘空间。安装完成后，Rust 所需的 msvc 命令行程序需要手动添加到环境变量中，否则安装 Rust 时 `rustup-init` 会提示未安装 Microsoft C++ Build Tools，其位于：`%Visual Studio 安装位置%\VC\Tools\MSVC\%version%\bin\Hostx64\x64`（请自行替换其中的 %Visual Studio 安装位置%、%version% 字段）下。

如果你不想这么做，可以选择安装 Microsoft C++ Build Tools 新增的“定制”终端 `Developer Command Prompt for %Visual Studio version%` 或 `Developer PowerShell for %Visual Studio version%`，在其中运行 `rustup-init.exe`。

准备好 C++ 环境后开始安装 Rust：

在 [RUSTUP-INIT](https://www.rust-lang.org/learn/get-started) 下载系统相对应的 Rust 安装程序，一路默认即可。

```shell
PS C:\Users\Hehongyuan> rustup-init.exe
......
Current installation options:

   default host triple: x86_64-pc-windows-msvc
     default toolchain: stable (default)
               profile: default
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
```

**2、`x86_64-pc-windows-gnu`**

相比于 MSVC 版本来说，GNU 版本具有更轻量，更靠近 Linux 的优势。

首先，根据 [MSYS2 官网](https://www.msys2.org/) 配置 MSYS。

若您觉得下载太慢，可以试试由 [Caviar-X](https://github.com/Caviar-X) 提供的 [代理](https://github.pigeons.icu/msys2/msys2-installer/releases/download/2021-11-30/msys2-x86_64-20211130.exe)。

在安装 `mingw-toolchain` 后，请将 `%MSYS 安装路径%\mingw64\bin` 添加到系统变量 `PATH` 中。

配置好后，在 MSYS 中输入下面的命令来安装 rustup。

```bash
$ curl https://sh.rustup.rs -sSf | sh
```

之后，根据以下输出进行配置。

```text
Current installation options:

   default host triple: x86_64-pc-windows-msvc
     default toolchain: stable (default)
               profile: default
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
>2

I'm going to ask you the value of each of these installation options.
You may simply press the Enter key to leave unchanged.

Default host triple? [x86_64-pc-windows-msvc]
x86_64-pc-windows-gnu

Default toolchain? (stable/beta/nightly/none) [stable]
stable

Profile (which tools and data to install)? (minimal/default/complete) [default]
complete

Modify PATH variable? (Y/n)
Y

Current installation options:

   default host triple: x86_64-pc-windows-gnu
     default toolchain: stable
               profile: complete
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
>
```

再之后，按下 1，等待。完成后，您就已经安装了 Rust 和 `rustup`。

## 更新
要更新 Rust，在终端执行以下命令即可更新：

```bash
$ rustup update
```

## 卸载

要卸载 Rust 和 `rustup`，在终端执行以下命令即可卸载：

```bash
$ rustup self uninstall
```

## 检查安装是否成功

检查是否正确安装了 Rust，可打开终端并输入下面这行，此时能看到最新发布的稳定版本的版本号、提交哈希值和提交日期：

```bash
$ rustc -V
rustc 1.56.1 (59eed8a2a 2021-11-01)

$ cargo -V
cargo 1.57.0 (b2e52d7ca 2021-10-21)
```

> 注：若发现版本号不同，以您的版本号为准

恭喜，你已成功安装 Rust！

如果没看到此信息：

1. 如果你使用的是 Windows，请检查 Rust 或 `%USERPROFILE%\.cargo\bin` 是否在 `%PATH%` 系统变量中。
2. 如果你使用的是 Windows 下的 Linux 子系统，请关闭并重新打开终端，再次执行以上命令。

如果都正确，但 Rust 仍然无法正常工作，那么你可以在很多地方获得帮助。最简单的是**加入 Rust 编程学院这个大家庭，QQ 群：1009730433**.

## 本地文档

安装 Rust 的同时也会在本地安装一个文档服务，方便我们离线阅读：运行 `rustup doc` 让浏览器打开本地文档。

每当遇到标准库提供的类型或函数不知道怎么用时，都可以在 API 文档中查找到！具体参见 [在标准库寻找你想要的内容](https://course.rs/std/search.html)。



================================================
FILE: src/first-try/intro.md
================================================
# 寻找牛刀，以便小试

其实对于写这种章节，我内心是拒绝的，因为真的很无趣。对于一本书而言，这也更像是一种浪费纸张的行为（好在咱无纸化 :-D）。不过没有办法，如果不安装 Rust 环境，总不能让大家用空气运行吧，so，我恶趣味的起了一个这样的章节名。

在本章中，你将学习以下内容：

1. 在 macOS、Linux、Windows 上安装 Rust 以及相关工具链
2. 搭建 VSCode 所需的环境
3. 简单介绍 Cargo
4. 实现一个酷炫多国语言版本的“世界，你好”的程序，并且谈谈对 Rust 语言的初印象



================================================
FILE: src/first-try/slowly-downloading.md
================================================
[Binary file]


================================================
FILE: src/first-try/sth-you-should-not-do.md
================================================
[Binary file]


================================================
FILE: src/libraries/intro.md
================================================
# 常用三方库



================================================
FILE: src/libraries/command/intro.md
================================================
# 命令行解析



================================================
FILE: src/libraries/command/structopt.md
================================================
# structopt(todo)



================================================
FILE: src/libraries/http/intro.md
================================================
# Http



================================================
FILE: src/libraries/http/reqwest.md
================================================
# reqwest(todo)



================================================
FILE: src/libraries/json/intro.md
================================================
# Json



================================================
FILE: src/libraries/json/serde.md
================================================
# serde(todo)



================================================
FILE: src/logs/about-log.md
================================================
[Binary file]


================================================
FILE: src/logs/intro.md
================================================
# 日志和监控
这几年 AIOps 特别火，但是你要是逮着一个运维问一下，他估计很难说出个所以然来，毕竟概念和现实往往是脱节的，前者的发展速度肯定远快于后者。

好在我大概了解这块儿领域，可以说智能化运维的核心就在于日志和监控，换而言之？何为智能，不就是基于已有的海量数据分析后进行决策吗？当然，你要说以前的知识库类型的运维决策也是智能，我也没办法杠: D

总之，不仅仅是对于开发者，对于整个技术链条的参与者，甚至包括老板，**日志和监控都是开发实践中最最重要的一环**。


================================================
FILE: src/logs/log.md
================================================
# 日志门面 log

就如同 slf4j 是 Java 的日志门面库，[log](https://github.com/rust-lang/log) 也是 Rust 的日志门面库( 这不是我自己编的，官方用语: logging facade )，它目前由官方积极维护，因此大家可以放心使用。

使用方式很简单，只要在 `Cargo.toml` 中引入即可：
```toml
[dependencies]
log = "0.4"
```

> 日志门面不是说排场很大的意思，而是指相应的日志 API 已成为事实上的标准，会被其它日志框架所使用。通过这种统一的门面，开发者就可以不必再拘泥于日志框架的选择，未来大不了再换一个日志框架就是

既然是门面，`log` 自然定义了一套统一的日志特征和 API，将日志的操作进行了抽象。

## Log 特征

例如，它定义了一个 `Log` 特征：
```rust
pub trait Log: Sync + Send {
    fn enabled(&self, metadata: &Metadata<'_>) -> bool;
    fn log(&self, record: &Record<'_>);
    fn flush(&self);
}
```

- `enabled` 用于判断某条带有元数据的日志是否能被记录，它对于 `log_enabled!` 宏特别有用
- `log` 会记录 `record` 所代表的日志
- `flush` 会将缓存中的日志数据刷到输出中，例如标准输出或者文件中

## 日志宏

`log` 还为我们提供了一整套标准的宏，用于方便地记录日志。看到 `trace!`、`debug!`、`info!`、`warn!`、`error!`，大家是否感觉眼熟呢？是的，它们跟上一章节提到的日志级别几乎一模一样，唯一的区别就是这里乱入了一个 `trace!`，它比 `debug!` 的日志级别还要低，记录的信息还要详细。可以说，你如果想巨细无遗地了解某个流程的所有踪迹，它就是不二之选。

```rust
use log::{info, trace, warn};

pub fn shave_the_yak(yak: &mut Yak) {
    trace!("Commencing yak shaving");

    loop {
        match find_a_razor() {
            Ok(razor) => {
                info!("Razor located: {}", razor);
                yak.shave(razor);
                break;
            }
            Err(err) => {
                warn!("Unable to locate a razor: {}, retrying", err);
            }
        }
    }
}
```

上面的例子使用 `trace!` 记录了一条可有可无的信息：准备开始剃须，然后开始寻找剃须刀，找到后就用 `info!` 记录一条可能事后也没人看的信息：找到剃须刀；没找到的话，就记录一条 `warn!` 信息，这条信息就有一定价值了，不仅告诉我们没找到的原因，还记录了发生的次数，有助于事后定位问题。

可以看出，这里使用日志级别的方式和我们上一章节所述基本相符。

除了以上常用的，`log` 还提供了 `log!` 和 `log_enabled!` 宏，后者用于确定一条消息在当前模块中，对于给定的日志级别是否能够被记录

```rust
use log::Level::Debug;
use log::{debug, log_enabled};

// 判断能否记录 Debug 消息
if log_enabled!(Debug) {
    let data = expensive_call();
     // 下面的日志记录较为昂贵，因此我们先在前面判断了是否能够记录，能，才继续这里的逻辑
    debug!("expensive debug data: {} {}", data.x, data.y);
}
if log_enabled!(target: "Global", Debug) {
   let data = expensive_call();
   debug!(target: "Global", "expensive debug data: {} {}", data.x, data.y);
}
```

而 `log!` 宏就简单的多，它是一个通用的日志记录方式，因此需要我们手动指定日志级别：
```rust
use log::{log, Level};

let data = (42, "Forty-two");
let private_data = "private";

log!(Level::Error, "Received errors: {}, {}", data.0, data.1);
log!(target: "app_events", Level::Warn, "App warning: {}, {}, {}",
    data.0, data.1, private_data);
```

## 日志输出在哪里？
我不知道有没有同学尝试运行过上面的代码，但是我知道，就算你们运行了，也看不到任何输出。

为什么？原因很简单，`log` 仅仅是日志门面库，**它并不具备完整的日志库功能！**，因此你无法在控制台中看到任何日志输出，这种情况下，说实话，远不如一个 `println!` 有用！

但是别急，让我们看看该如何让 `log` 有用起来。


## 使用具体的日志库
`log` 包这么设计，其实是有很多好处的。

### Rust 库的开发者
最直接的好处就是，如果你是一个 Rust 库开发者，那你自己或库的用户肯定都不希望这个库绑定任何具体的日志库，否则用户想使用 `log1` 来记录日志，你的库却使用了 `log2`，这就存在很多问题了！

因此，**作为库的开发者，你只要在库中使用门面库即可**，将具体的日志库交给用户去选择和绑定。
```rust
use log::{info, trace, warn};
pub fn deal_with_something() {
    // 开始处理

    // 记录一些日志
    trace!("a trace log");
    info!("a info long: {}", "abc");
    warn!("a warning log: {}, retrying", err);

    // 结束处理
}
```

### 应用开发者
如果是应用开发者，那你的应用运行起来，却看不到任何日志输出，这种场景想想都捉急。此时就需要去选择一个具体的日志库了。

目前来说，已经有了不少日志库实现，官方也[推荐了一些](https://github.com/rust-lang/log#in-executables)
，大家可以根据自己的需求来选择，不过 [env_logger](https://docs.rs/env_logger/*/env_logger/) 是一个相当不错的选择。

`log` 还提供了 [set_logger](https://docs.rs/log/0.4.8/log/fn.set_logger.html) 函数用于设置日志库，[set_max_level](https://docs.rs/log/0.4.8/log/fn.set_max_level.html) 用于设置最大日志级别，但是如果你选了具体的日志库，它往往会提供更高级的 API，无需我们手动调用这两个函数，例如下面的 `env_logger` 就是如此。

#### env_logger

修改 `Cargo.toml` , 添加以下内容:
```toml
# in Cargo.toml

[dependencies]
log = "0.4.0"
env_logger = "0.9"
```

在 `src/main.rs` 中添加如下代码：
```rust
use log::{debug, error, log_enabled, info, Level};

fn main() {
    // 注意，env_logger 必须尽可能早的初始化
    env_logger::init();

    debug!("this is a debug {}", "message");
    error!("this is printed by default");

    if log_enabled!(Level::Info) {
        let x = 3 * 4; // expensive computation
        info!("the answer was: {}", x);
    }
}
```

在运行程序时，可以通过环境变量来设定日志级别:
```shell
$ RUST_LOG=error ./main
[2017-11-09T02:12:24Z ERROR main] this is printed by default
```

我们还可以为单独一个模块指定日志级别:
```shell
$ RUST_LOG=main=info ./main
[2017-11-09T02:12:24Z ERROR main] this is printed by default
[2017-11-09T02:12:24Z INFO main] the answer was: 12
```

还能为某个模块开启所有日志级别：
```shell
$ RUST_LOG=main ./main
[2017-11-09T02:12:24Z DEBUG main] this is a debug message
[2017-11-09T02:12:24Z ERROR main] this is printed by default
[2017-11-09T02:12:24Z INFO main] the answer was: 12
```

需要注意的是，如果文件名包含 `-`，你需要将其替换成下划线来使用，原因是 Rust 的模块和包名不支持使用 `-`。
```shell
$ RUST_LOG=my_app ./my-app
[2017-11-09T02:12:24Z DEBUG my_app] this is a debug message
[2017-11-09T02:12:24Z ERROR my_app] this is printed by default
[2017-11-09T02:12:24Z INFO my_app] the answer was: 12
```

默认情况下，`env_logger` 会输出到标准错误 `stderr`，如果你想要输出到标准输出 `stdout`，可以使用 `Builder` 来改变日志对象( target ):
```rust
use std::env;
use env_logger::{Builder, Target};

let mut builder = Builder::from_default_env();
builder.target(Target::Stdout);

builder.init();
```

默认
```rust
   if cfg!(debug_assertions) {
       eprintln!("debug: {:?} -> {:?}",
              record, fields);
     }
```

### 日志库开发者
对于这类开发者而言，自然要实现自己的 `Log` 特征咯:

```rust
use log::{Record, Level, Metadata};
struct SimpleLogger;
impl log::Log for SimpleLogger {
    fn enabled(&self, metadata: &Metadata) -> bool {
        metadata.level() <= Level::Info
    }
    fn log(&self, record: &Record) {
        if self.enabled(record.metadata()) {
            println!("{} - {}", record.level(), record.args());
        }
    }
    fn flush(&self) {}
}
```

除此之外，我们还需要像 `env_logger` 一样包装下 `set_logger` 和 `set_max_level`:
```rust
use log::{SetLoggerError, LevelFilter};
static LOGGER: SimpleLogger = SimpleLogger;
pub fn init() -> Result<(), SetLoggerError> {
    log::set_logger(&LOGGER)
        .map(|()| log::set_max_level(LevelFilter::Info))
}
```


## 更多示例
关于 `log` 门面库和具体的日志库还有更多的使用方式，详情请参见锈书的[开发者工具](https://rusty.course.rs/devtools/log.html)一章。




================================================
FILE: src/logs/tracing-logger.md
================================================
[Binary file]


================================================
FILE: src/logs/tracing.md
================================================
[Binary file]


================================================
FILE: src/logs/observe/about-observe.md
================================================
[Binary file]


================================================
FILE: src/logs/observe/intro.md
================================================
# 监控

监控是一个很大的领域，大到老板、前端开发、后端开发理解的监控可能都不相同。

- 老板眼中的监控：业务大数据实时展示
- 前端眼中的监控：手机 APP 收集上来的异常、崩溃、用户操作日志等
- 后端眼中的监控：请求链路跟踪、一段时间内的请求错误率、QPS 过高、异常日志等

正是因为这些复杂性，导致很多同学难以准确的说出监控到底是什么。

下面，我们将试图解释清楚监控的概念，并引入一个全新的概念：可观测性。



================================================
FILE: src/logs/observe/trace.md
================================================
# 分布式追踪



================================================
FILE: src/practice/best-pratice.md
================================================
[Binary file]


================================================
FILE: src/practice/interview.md
================================================
# 面试经验 doing

其实这一章节的处境有些尴尬，Rust 虽然在世界范围有点小名气，但是在国内目前还处于开荒阶段，因此至少就公开招聘而言，岗位并不多。

但是既然号称最佳实践，少了面试，总觉得会缺少些什么，由于现在还没有太多的经验可以参考，我们选择先从网上摘选些文章分享给大家，**但仅供参考，具体还要大家自己来辨别**。

> 感谢 [Kasper4649](https://github.com/Kasper4649) 的章节提议和资源分享



- [记一次 Rust 技术面试](https://zhuanlan.zhihu.com/p/411979704)
- [飞书 Rust 实习](https://blog.kuangjux.top/2021/10/22/飞书Rust实习面试/)
- [字节跳动 Rust/C++ 实习](https://www.nowcoder.com/discuss/538078)
- [记一次面试](https://huangjj27.github.io/interview.html)
- [字节跳动面试经历](https://blog.sbw.so/u/byte-dance-rust-cpp-interview-experience.html)


To be continued..


================================================
FILE: src/practice/intro.md
================================================
# Rust最佳实践

对于生产级项目而言，运行稳定性和可维护性是非常重要的，本章就一起来看看 Rust 项目有哪些最佳实践准则。


================================================
FILE: src/practice/naming.md
================================================
# 命名规范

基本的 Rust 命名规范在 [RFC 430] 中有描述。

通常，对于 **type-level** 的构造 Rust 倾向于使用**驼峰命名法**，而对于 **value-level** 的构造使用**蛇形命名法**。详情如下：

| 条目 | 惯例 |
| ---- | ---------- |
| 包 Crates | [unclear](https://github.com/rust-lang/api-guidelines/issues/29) |
| 模块 Modules | `snake_case` |
| 类型 Types | `UpperCamelCase` |
| 特征 Traits | `UpperCamelCase` |
| 枚举 Enumerations | `UpperCamelCase` |
| 结构体 Structs | `UpperCamelCase` |
| 函数 Functions | `snake_case` |
| 方法 Methods | `snake_case` |
| 通用构造器 General constructors | `new` or `with_more_details` |
| 转换构造器 Conversion constructors | `from_some_other_type` |
| 宏 Macros | `snake_case!` |
| 局部变量 Local variables | `snake_case` |
| 静态类型 Statics | `SCREAMING_SNAKE_CASE` |
| 常量 Constants | `SCREAMING_SNAKE_CASE` |
| 类型参数 Type parameters | `UpperCamelCase`，通常使用一个大写字母: `T` |
| 生命周期 Lifetimes | 通常使用小写字母: `'a`，`'de`，`'src` |
| Features | [unclear](https://github.com/rust-lang/api-guidelines/issues/101) but see [C-FEATURE] |

对于**驼峰命名法**，复合词的缩略形式我们认为是一个单独的词语，所以**只对首字母进行大写**：使用 `Uuid` 而不是 ~~`UUID`~~，`Usize` 而不是 ~~`USize`~~，`Stdin` 而不是 ~~`StdIn`~~。

对于**蛇形命名法**，缩略词用全小写：`is_xid_start`。

对于**蛇形命名法**（包括全大写的 `SCREAMING_SNAKE_CASE`），除了最后一部分，其它部分的词语都不能由单个字母组成：
`btree_map` 而不是 ~~`b_tree_map`~~，`PI_2` 而不是 ~~`PI2`~~.

包名**不应该**使用 `-rs` 或者 `-rust` 作为后缀，因为每一个包都是 Rust 写的，因此这种多余的注释其实没有任何意义。

[RFC 430]: https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md
[C-FEATURE]: #c-feature

## 特征命名
特征的名称应该使用动词，而不是形容词或者名词，例如 `Print` 和 `Draw` 明显好于 `Printable` 和 `Drawable`。

## 类型转换要遵守 `as_`，`to_`，`into_` 命名惯例(C-CONV)
类型转换应该通过方法调用的方式实现，其中的前缀规则如下：

| 方法前缀 | 性能开销 | 所有权改变 |
| ------ | ---- | --------- |
| `as_` | Free | borrowed -\> borrowed |
| `to_` | Expensive | borrowed -\> borrowed<br>borrowed -\> owned (non-Copy types)<br>owned -\> owned (Copy types) |
| `into_` | Variable | owned -\> owned (non-Copy types) |

例如：

- [`str::as_bytes()`] 把 `str` 变成 UTF-8 字节数组，性能开销是 0。输入是一个借用的 `&str`，输出也是一个借用的 `&str`
- [`Path::to_str`] 会执行一次昂贵的 UTF-8 字节数组检查，输入和输出都是借用的。对于这种情况，如果把方法命名为 `as_str` 是不正确的，因为这个方法的开销还挺大
- [`str::to_lowercase()`] 在调用过程中会遍历字符串的字符，且可能会分配新的内存对象。输入是一个借用的 `str`，输出是一个有独立所有权的 `String`
- [`String::into_bytes()`] 返回 `String` 底层的 `Vec<u8>` 数组，转换本身是零消耗的。该方法获取 `String` 的所有权，然后返回一个新的有独立所有权的 `Vec<u8>`


[`str::as_bytes()`]: https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes
[`Path::to_str`]: https://doc.rust-lang.org/std/path/struct.Path.html#method.to_str
[`str::to_lowercase()`]: https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase
[`f64::to_radians()`]: https://doc.rust-lang.org/std/primitive.f64.html#method.to_radians
[`String::into_bytes()`]: https://doc.rust-lang.org/std/string/struct.String.html#method.into_bytes
[`BufReader::into_inner()`]: https://doc.rust-lang.org/std/io/struct.BufReader.html#method.into_inner
[`BufWriter::into_inner()`]: https://doc.rust-lang.org/std/io/struct.BufWriter.html#method.into_inner


当一个单独的值被某个类型所包装时，访问该类型的内部值应通过 `into_inner()` 方法来访问。例如将一个缓冲区值包装为 [`BufReader`] 类型，还有 [`GzDecoder`]、[`AtomicBool`] 等，都是这种类型。


[`BufReader`]: https://doc.rust-lang.org/std/io/struct.BufReader.html#method.into_inner
[`GzDecoder`]: https://starry-network.github.io/starry_node/flate2/write/struct.GzDecoder.html#method.into_inner
[`AtomicBool`]: https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.into_inner

如果 `mut` 限定符在返回类型中出现，那么在命名上也**应该**体现出来。例如，[`Vec::as_mut_slice`] 就说明它返回了一个 `mut` 切片，在这种情况下 `as_mut_slice` 比 `as_slice_mut` 更适合。

[`Vec::as_mut_slice`]: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.as_mut_slice

```rust
// 返回类型是一个 `mut` 切片
fn as_mut_slice(&mut self) -> &mut [T];
```

### 标准库中的一些例子

- [`Result::as_ref`](https://doc.rust-lang.org/std/result/enum.Result.html#method.as_ref)
- [`RefCell::as_ptr`](https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.as_ptr)
- [`slice::to_vec`](https://doc.rust-lang.org/std/primitive.slice.html#method.to_vec)
- [`Option::into_iter`](https://doc.rust-lang.org/std/option/enum.Option.html#method.into_iter)


##  读访问器(Getter)的名称遵循 Rust 的命名规范(C-GETTER)

除了少数例外，在 Rust代码中 `get` 前缀不用于 Getter。

```rust
pub struct S {
    first: First,
    second: Second,
}

impl S {
    // 而不是 get_first
    pub fn first(&self) -> &First {
        &self.first
    }

    // 而不是 get_first_mut，get_mut_first，or mut_first
    pub fn first_mut(&mut self) -> &mut First {
        &mut self.first
    }
}
```
至于上文提到的少数例外，如下：**当有且仅有一个值**能被 Getter 所获取时，才使用 `get` 前缀。例如，[`Cell::get`] 能直接访问到 `Cell` 中的内容。

[`Cell::get`]: https://doc.rust-lang.org/std/cell/struct.Cell.html#method.get

有些 Getter 会在过程中执行运行时检查，那么我们就可以考虑添加 `_unchecked` Getter 函数，这个函数虽然不安全，但是往往具有更高的性能。
典型的例子如下：

```rust
fn get(&self, index: K) -> Option<&V>;
fn get_mut(&mut self, index: K) -> Option<&mut V>;
unsafe fn get_unchecked(&self, index: K) -> &V;
unsafe fn get_unchecked_mut(&mut self, index: K) -> &mut V;
```

[`TempDir::path`]: https://docs.rs/tempdir/0.3.5/tempdir/struct.TempDir.html#method.path
[`TempDir::into_path`]: https://docs.rs/tempdir/0.3.5/tempdir/struct.TempDir.html#method.into_path

### 标准库示例

- [`std::io::Cursor::get_mut`](https://doc.rust-lang.org/std/io/struct.Cursor.html#method.get_mut)
- [`std::ptr::Unique::get_mut`](https://doc.rust-lang.org/std/ptr/struct.Unique.html#method.get_mut)
- [`std::sync::PoisonError::get_mut`](https://doc.rust-lang.org/std/sync/struct.PoisonError.html#method.get_mut)
- [`std::sync::atomic::AtomicBool::get_mut`](https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.get_mut)
- [`std::collections::hash_map::OccupiedEntry::get_mut`](https://doc.rust-lang.org/std/collections/hash_map/struct.OccupiedEntry.html#method.get_mut)
- [`<[T]>::get_unchecked`](https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked)

## 一个集合上的方法，如果返回迭代器，需遵循命名规则：`iter`，`iter_mut`，`into_iter` (C-ITER)

```rust
fn iter(&self) -> Iter             // Iter implements Iterator<Item = &U>
fn iter_mut(&mut self) -> IterMut  // IterMut implements Iterator<Item = &mut U>
fn into_iter(self) -> IntoIter     // IntoIter implements Iterator<Item = U>
```
上面的规则适用于同构性的数据集合。与之相反，`str` 类型是一个 UTF-8 字节数组切片，与同构性集合有一点微妙的差别，它可以认为是字节集合，也可以认为是字符集合，因此它提供了 [`str::bytes`] 去遍历字节，还有 [`str::chars`] 去遍历字符，而并没有直接定义 `iter` 等方法。

[`str::bytes`]: https://doc.rust-lang.org/std/primitive.str.html#method.bytes
[`str::chars`]: https://doc.rust-lang.org/std/primitive.str.html#method.chars

上述规则只适用于方法，并不适用于函数。例如 `url` 包的 [`percent_encode`] 函数返回一个迭代器用于遍历百分比编码（[Percent encoding](https://en.wikipedia.org/wiki/Percent-encoding)）的字符串片段. 在这种情况下，使用 `iter`/`iter_mut`/`into_iter` 诸如此类的函数命名无法表达任何具体的含义。

[`percent_encode`]: https://docs.rs/url/1.4.0/url/percent_encoding/fn.percent_encode.html
[RFC 199]: https://github.com/rust-lang/rfcs/blob/master/text/0199-ownership-variants.md

### 标准库示例

- [`Vec::iter`](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter)
- [`Vec::iter_mut`](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut)
- [`Vec::into_iter`](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter)
- [`BTreeMap::iter`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter)
- [`BTreeMap::iter_mut`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter_mut)

## 迭代器的类型应该与产生它的方法名相匹配(C-ITER-TY)
例如形如 `into_iter()` 的方法应该返回一个 `IntoIter` 类型，与之相似，其它任何返回迭代器的方法也应该遵循这种命名惯例。

上述规则主要应用于方法，但是经常对于函数也适用。例如上文提到的 `url` 包中的 [`percent_encode`] 函数，返回了一个 [`PercentEncode`] 类型。

[`PercentEncode`]: https://docs.rs/url/1.4.0/url/percent_encoding/struct.PercentEncode.html

特别是，当这些类型跟包名前缀一起使用时，将具备非常清晰的含义，例如 [`vec::IntoIter`]。

[`vec::IntoIter`]: https://doc.rust-lang.org/std/vec/struct.IntoIter.html

### 标准库示例

* [`Vec::iter`] returns [`Iter`][slice::Iter]
* [`Vec::iter_mut`] returns [`IterMut`][slice::IterMut]
* [`Vec::into_iter`] returns [`IntoIter`][vec::IntoIter]
* [`BTreeMap::keys`] returns [`Keys`][btree_map::Keys]
* [`BTreeMap::values`] returns [`Values`][btree_map::Values]

[`Vec::iter`]: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter
[slice::Iter]: https://doc.rust-lang.org/std/slice/struct.Iter.html
[`Vec::iter_mut`]: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut
[slice::IterMut]: https://doc.rust-lang.org/std/slice/struct.IterMut.html
[`Vec::into_iter`]: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter
[vec::IntoIter]: https://doc.rust-lang.org/std/vec/struct.IntoIter.html
[`BTreeMap::keys`]: https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.keys
[btree_map::Keys]: https://doc.rust-lang.org/std/collections/btree_map/struct.Keys.html
[`BTreeMap::values`]: https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.values
[btree_map::Values]: https://doc.rust-lang.org/std/collections/btree_map/struct.Values.html


<a id="c-feature"></a>
## Cargo Feature 的名称不应该包含占位词(C-FEATURE)

不要在 [Cargo feature] 中包含无法传达任何意义的词，例如 `use-abc` 或 `with-abc`，直接命名为 `abc` 即可。

[Cargo feature]: http://doc.crates.io/manifest.html#the-features-section

一个典型的例子就是：一个包对标准库有可选性的依赖。标准的写法如下：

```toml
# 在 Cargo.toml 中

[features]
default = ["std"]
std = []
```

```rust
// 在我们自定义的 lib.rs 中

#![cfg_attr(not(feature = "std"), no_std)]
```
除了 `std` 之外，不要使用任何 `ust-std` 或者 `with-std` 等自以为很有创造性的名称。

## 命名要使用一致性的词序(C-WORD-ORDER)

这是一些标准库中的错误类型:

- [`JoinPathsError`](https://doc.rust-lang.org/std/env/struct.JoinPathsError.html)
- [`ParseBoolError`](https://doc.rust-lang.org/std/str/struct.ParseBoolError.html)
- [`ParseCharError`](https://doc.rust-lang.org/std/char/struct.ParseCharError.html)
- [`ParseFloatError`](https://doc.rust-lang.org/std/num/struct.ParseFloatError.html)
- [`ParseIntError`](https://doc.rust-lang.org/std/num/struct.ParseIntError.html)
- [`RecvTimeoutError`](https://doc.rust-lang.org/std/sync/mpsc/enum.RecvTimeoutError.html)
- [`StripPrefixError`](https://doc.rust-lang.org/std/path/struct.StripPrefixError.html)

它们都使用了 `谓语-宾语-错误` 的词序，如果我们想要表达一个网络地址无法分析的错误，由于词序一致性的原则，命名应该如下 `ParseAddrError`，而不是 `AddrParseError`。

词序和个人习惯有很大关系，想要注意的是，你可以选择合适的词序，但是要在包的范畴内保持一致性，就如标准库中的包一样。



================================================
FILE: src/practice/third-party-libs.md
================================================
[Binary file]


================================================
FILE: src/profiling/intro.md
================================================
# Rust性能剖析 todo



================================================
FILE: src/profiling/compiler/attributes.md
================================================
# 常见属性标记

## 强制内存对齐

```rust
#[repr(align(64))]
struct CachePadded(AtomicU64);
```

A data of alignment X is stored in memory at address multiple of X

https://doc.rust-lang.org/reference/attributes.html


================================================
FILE: src/profiling/compiler/intro.md
================================================
# 对抗编译检查



================================================
FILE: src/profiling/compiler/llvm.md
================================================
# LLVM todo
https://ttalk.im/2021/12/llvm-infrastructure-and-rust.html


================================================
FILE: src/profiling/compiler/phantom-data.md
================================================
# PhantomData（幽灵数据）

在编写非安全代码时，我们常常遇见这种情况：类型或生命周期逻辑上与一个结构体关联起来了，但是却不属于结构体的任何一个成员。这种情况对于生命周期尤为常见。比如，`&'a [T]`的`Iter`大概是这么定义的：

``` Rust
struct Iter<'a, T: 'a> {
    ptr: *const T,
    end: *const T,
}
```

但是，因为`'a`没有在结构体内被使用，它是无界的。由于一些历史原因，无界生命周期和类型禁止出现在结构体定义中。所以我们必须想办法在结构体内用到这些类型，这也是正确的变性检查和drop检查的必要条件。

我们使用一个特殊的标志类型`PhantomData`做到这一点。`PhantomData`不消耗存储空间，它只是模拟了某种类型的数据，以方便静态分析。这么做比显式地告诉类型系统你需要的变性更不容易出错，而且还能提供drop检查需要的信息。

`Iter`逻辑上包含一系列`&'a T`，所以我们用`PhantomData`这样去模拟它：

``` Rust
use std::marker;

struct Iter<'a, T: 'a> {
    ptr: *const T,
    end: *const T,
    _marker: marker::PhantomData<&'a T>,
}
```

就是这样，生命周期变得有界了，你的迭代器对于`'a`和`T`也可变了。一切尽如人意。

另一个重要的例子是`Vec`，它差不多是这么定义的：

``` Rust
struct Vec<T> {
    data: *const T, // *const是可变的！
    len: usize,
    cap: usize,
}
```

和之前的例子不同，这个定义已经满足我们的各种要求了。`Vec`的每一个泛型参数都被至少一个成员使用过了。非常完美！

你高兴的太早了。

Drop检查器会判断`Vec<T>`并不拥有T类型的值，然后它认为无需担心Vec在析构函数里能不能安全地销毁T，再然后它会允许人们创建不安全的Vec析构函数。

为了让drop检查器知道我们确实拥有T类型的值，也就是需要在销毁Vec的时候同时销毁T，我们需要添加一个额外的PhantomData：

``` Rust
use std::marker:

struct Vec<T> {
    data: *const T, // *const是可变的！
    len: usize,
    cap: usize,
    _marker: marker::PhantomData<T>,
}
```

让裸指针拥有数据是一个很普遍的设计，以至于标准库为它自己创造了一个叫`Unique<T>`的组件，它可以：

- 封装一个`*const T`处理变性
- 包含一个 `PhantomData<T>`
- 自动实现`Send`/`Sync`，模拟和包含T时一样的行为
- 将指针标记为`NonZero`以便空指针优化

## `PhantomData`模式表

下表展示了各种牛X闪闪的`PhantomData`用法：

| Phantom 类型 | `'a` | `'T` |
|----|----|----|
|`PhantomData<T>`|-|协变（可触发drop检查）|
|`PhantomData<&'a T>`|协变|协变|
|`PhantomData<&'a mut T>`|协变|不变|
|`PhantomData<*const T>`|-|协变|
|`PhantomData<*mut T>`|-|不变|
|`PhantomData<fn(T)>`|-|逆变(*)|
|`PhantomData<fn() -> T>`|-|协变|
|`PhantomData<fn(T) -> T>`|-|不变|
|`PhantomData<Cell<&'a ()>>`|不变|-|

(*)如果发生变性的冲突，这个是不变的


================================================
FILE: src/profiling/compiler/speed-up.md
================================================
# 优化编译速度
<!-- 
https://www.reddit.com/r/rust/comments/rnkyc0/why_does_my_code_compile_faster_on_nightly/

https://www.reddit.com/r/rust/comments/rv8126/speedup_compilation_time/

https://www.reddit.com/r/rust/comments/rsfcgb/why_is_my_rust_build_so_slow/

https://www.reddit.com/r/rust/comments/sqi1ba/is_it_just_me_or_rustanalyzer_is_unreliableslow/ -->


================================================
FILE: src/profiling/compiler/optimization/intro.md
================================================
# 编译器优化

在Rust中，一段很不起眼的代码中可能也隐藏着玄机，编译器在细无声的为我们做着各种优化，本章将记录这些优化，帮助大家更好的理解程序的性能。


================================================
FILE: src/profiling/compiler/optimization/option.md
================================================
# Option枚举

https://www.reddit.com/r/learnrust/comments/rz34ht/where_does_the_data_go_if_you_replace_some_with/



================================================
FILE: src/profiling/memory/allocation.md
================================================
# 内存分配(todo)

https://www.reddit.com/r/rust/comments/s4pknf/investigating_memory_allocations_in_rust/


================================================
FILE: src/profiling/memory/intro.md
================================================
# 深入内存

部分内容借鉴了Rust in action和Rust高级编程


https://www.youtube.com/watch?v=rDoqT-a6UFg


================================================
FILE: src/profiling/memory/layout.md
================================================
# 内存布局(todo)

https://www.reddit.com/r/rust/comments/rwta4h/why_arent_rust_structs_laid_out_in_memory_like_c/


================================================
FILE: src/profiling/memory/pointer-ref.md
================================================
# 指针和引用(todo)



================================================
FILE: src/profiling/memory/uninit.md
================================================
# 未初始化内存

https://lucumr.pocoo.org/2022/1/30/unsafe-rust/


================================================
FILE: src/profiling/memory/virtual.md
================================================
# 虚拟内存



================================================
FILE: src/profiling/performance/allocator.md
================================================
# 内存allocator todo

https://www.reddit.com/r/rust/comments/s28g4x/allocating_many_boxes_at_once/

https://www.reddit.com/r/rust/comments/szza43/memory_freed_but_not_immediately/


================================================
FILE: src/profiling/performance/calculate.md
================================================
# 计算性能优化


https://www.reddit.com/r/rust/comments/rn7ozz/find_perfect_number_comparison_go_java_rust/


```go
package main

import (
	"fmt"
	"math"
	"time"
)

func main() {
	n := 320000
	nums := make(map[int][]int)
	start := time.Now()
	calPerfs(n, nums)
	fmt.Printf("runtime: %s\n", time.Since(start))
}

func calPerfs(n int, nums map[int][]int) {
	for i := 1; i <= n; i++ {
		d := divs(i)
		if sum(d) == i {
			nums[i] = all(d)
		}
	}
}

func divs(num int) map[int]struct{} {
	r := make(map[int]struct{})
	r[1] = struct{}{}
	mid := int(math.Sqrt(float64(num)))
	for i := 2; i <= mid; i++ {
		if num%i == 0 {
			r[i] = struct{}{}
			r[num/i] = struct{}{}
		}
	}
	return r
}

func sum(ds map[int]struct{}) int {
	var n int
	for k := range ds {
		n += k
	}
	return n
}

func all(ds map[int]struct{}) []int {
	var a []int
	for k := range ds {
		a = append(a, k)
	}
	return a
}
```

## 120ms

```rust
use std::time::Instant;

const N: usize = 320_000	;

fn is_perfect(n: usize) -> bool {
    //println!("{:?}", n);
    let mut sum = 1;
    let end = (n as f64).sqrt() as usize;
    for i in 2..end  + 1{
        if n % i == 0 {
            if i * i == n {
                sum += i;
            }
            else {
                sum += i + n / i;
            }
        }
    }
    sum == n
}

fn find_perfs(n: usize) -> Vec<usize> {
    let mut perfs:Vec<usize> = vec![];
    for i in 2..n + 1 {
        if is_perfect(i) {
            perfs.push(i)
        }
    }
    perfs
}

fn main() {
    let start = Instant::now();
    let perfects = find_perfs(N);
    println!("{:?}", start.elapsed());
    println!("{:?}, in {:?}", perfects, N);
}
```

## 90ms

```rust
use {
    std::{time::Instant},
};

const N: usize = 320000;

// Optimized, takes about 320ms on an Core i7 6700 @ 3.4GHz
fn cal_perfs2(n: usize) -> Vec<usize> {
    (1..=n)
        .into_iter()
        .filter(|i| cal2(*i) == *i)
        .collect::<Vec<_>>()
}

fn cal2(n: usize) -> usize {
    (2..=(n as f64).sqrt() as usize)
        .into_iter()
        .filter_map(|i| if n % i == 0 { Some([i, n / i]) } else { None })
        .map(|a| a[0] + a[1])
        .sum::<usize>()
        + 1
}


fn main() {
    let start = Instant::now();
    let perf2 = cal_perfs2(N);
    println!("{:?}",perf2);
    println!("Optimized: {:?}", start.elapsed());
}
```


================================================
FILE: src/profiling/performance/clone-copy.md
================================================
# Clone和Copy



================================================
FILE: src/profiling/performance/cpu-cache.md
================================================
# CPU缓存性能优化

https://github.com/TC5027/blog/blob/master/false_sharing.md


# On a use of the "repr" attribute in Rust

Consider we work with the following struct representing a counter,
```rust
struct Counter(u64);
```
and we want to increment it with random ``u8`` values with the help of a for loop : 
```rust
use rand::Rng;
fn main() {
	let mut counter = Counter(0);
	let mut rng = rand::thread_rng();
	
	for _ in 0..1_000_000 {
		counter.0 += rng.gen::<u8>() as u64;
	}
}
```
This takes 1.90ms to run on my laptop using ``cargo run --release``. Remember this timing as it will be our reference value :)
Now suppose we were given this struct, holding not 1 but 2 counters : 
```rust
struct Counters {
	c1 : u64,
	c2 : u64
}
```
Using the same approach, performing the increments for the 2 counters in a single-threaded fashion, we would expect to be twice slower (in fact it takes 3.71ms to execute).
Can we do better ? Well, as our 2 counters are independent, we could spawn 2 threads, assign them one counter and increment concurrently ! Given I have 4 CPUs on my laptop, I would expect to be just as fast as the first scenario. Let's see !

First thing, we could create a local variable in each thread which would be incremented and then we would set the counter value to this incremented one (spoiler : good idea). But we could also save these 2 variables and share the ``Counter`` between the 2 threads with an ``Arc`` (spoiler : definitely not worth). Let's do this second option ! ^^

Doing the following code, 

```rust
fn main() {
	let counters = Arc::new(Counters{c1:0, c2:0});
	let counters_clone = counters.clone();
	
	let handler1 = thread::spawn(move || {
		let mut rng = rand::thread_rng();
		for _ in 0..1_000_000 {
			counters.c1 += rng.gen::<u8>() as u64;
		}
	});
	let handler2 = thread::spawn(move || {
		let mut rng = rand::thread_rng();
		for _ in 0..1_000_000 {
			counters_clone.c2 += rng.gen::<u8>() as u64;
		}
	});
	handler1.join(); handler2.join();
}
```
we end up with an error : 

**cannot assign to data in an `Arc`**
**cannot assign**
**help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::sync::Arc<Counters>`rustc(E0594)**

Unlucky. Maybe we could use **atomic types**. These types provide operations that synchronize updates between threads. In fact, as an equivalent of ``+=`` we could use the ``fetch_add`` method which has the following signature : ``pub fn fetch_add(&self, val: u64, order: Ordering) -> u64``. What should be highlighted is the ``&self``. We could expect a ``&mut self`` given the modification we want to perform using it but thanks to the property that an atomic operation is performed without interruptions we don't need exclusive access to the variable to safely update it.
We can solve the error replacing the counter's type by ``AtomicU64`` as like that we only require ``Arc`` to implement the ``Deref`` trait (given the signature of ``fetch_add``) and it is the case !

We so have to change a bit our struct to : 
```rust
struct Counters {
	c1 : AtomicU64,
	c2 : AtomicU64,
}
```
and our code to :
```rust
fn main() {
    let counters = Arc::new(Counters{
        c1 :  AtomicU64::new(0),
        c2 : AtomicU64::new(0)
    });
    let counters_clone = counters.clone();
    let handler1 = thread::spawn(move || {
        let mut rng = rand::thread_rng();
        for _ in 0..1_000_000 {
            counters.c1.fetch_add(rng.gen::<u8>() as u64,Relaxed);
        }
    });
    let handler2 = thread::spawn(move || {
        let mut rng = rand::thread_rng();
        for _ in 0..1_000_000 {
            counters_clone.c2.fetch_add(rng.gen::<u8>() as u64,Relaxed);
        }
    });
    handler1.join();handler2.join();
}
```
We could naturally expect the operation on Atomics to be a bit slower than the ones on ``u64`` but let's see !
30.22ms .. ok... that's terrible ^^
Do Atomics operations explain all this ?
I ran a benchmark to compare ``+=`` and ``fetch_add( ,Relaxed)`` to figure it out : 

```rust
let mut sum = 0;
let start = Instant::now();
for _ in 0..10_000_000 {
	sum += rng.gen::<u8>() as u64;
}
println!("time spent u64 sum : {:?}", start.elapsed());
let atomic_sum = AtomicU64::new(0);
let start = Instant::now();
for _ in 0..10_000_000 {
	atomic_sum.fetch_add(rng.gen::<u8>() as u64, Relaxed);
}
println!("time spent AtomicU64 sum : {:?}", start.elapsed());
```

The ``u64`` sums takes 20.07ms while the ``AtomicU64`` one takes 70.28ms. So we should only be 3 times slower than 2ms but we are 15 times slower how can it be ???

Hint : CPU cache... but why should we care ?
CPU cache is a data storage, located close to CPU, offering a fast access to data.
In a computer, when the CPU needs to read or write a value, it checks if it is present inside the cache or not. If it is the case then the CPU directly uses the cached data. Otherwise, the cache allocates a new entry and copies data from main memory, an entry being of fixed size and called *cache line*.
CPU cache is relatively small compared to RAM but much faster, and that's why a program should be designed to use as much as possible data lying in cache, based on a locality principle, to avoid expensive access to RAM.

If we represent our current situation it looks like this :
 ![figure](https://github.com/TC5027/blog/blob/master/pngs/false_sharing.png)

The red square corresponds to the first counter and the green one to the second. They can potentially lie in the same cache line !

If data is modified through CPU 0 in its L1 cache we expect our computer to reflect the changes both in memory and in the other L1 cache. To ensure this coherency, there exists coherence protocols which can force the **whole cache line** impacted by the change to be propagated through the whole system, in order to update the copies of the value changed.

With that in mind, what is happening in our code comes from that : we suffer from coherency protocol due to our 2 counters lying on the same cache line. Updating first counter through CPU 0 involves an update in the system of the data stored in the cache line where the second counter (unchanged) potentially lies. During this update, CPU 1 cannot access the second counter whereas it is clearly independent from the change made by CPU 0, and that's why we are slow.
How can we solve then ? well by making sure that the counters lie on different cache lines and that's where we can use the ``repr`` attribute.

In Rust, we can specify the alignment we want for our type with the ``repr(align)`` attribute. We use it like this : 

```rust
#[repr(align(64))]
struct CachePadded(AtomicU64);
```

A data of alignment X is stored in memory at address multiple of X. Knowing this, giving to our counters an alignment equal to the size of a cache line, we ensure that the 2 counters won't be stored in the same cache line !

We can get the size of cache lines with command ``getconf LEVEL1_DCACHE_LINESIZE``. On my laptop the output value is 64.

With those changes we have now a timing of 7.16ms which seems decent given we work with Atomics. Mission succeeded ! 


Finally given my remark at the beginning, I wanted to share a potentially better solution, using local variables in the threads, and channels to communicate these local variables back to the main thread :

```rust
use std::sync::mpsc::channel;
fn main() {
    let (s1,t1) = channel();
    let (s2,t2) = channel();
    let h1 = thread::spawn(move || {
        let mut local_counter = 0;
        let mut rng = rand::thread_rng();
        for _ in 0..1_000_000 {
            local_counter += rng.gen::<u8>() as u64;
        }
        s1.send(local_counter)
    });
    let h2 = thread::spawn(move || {
        let mut local_counter = 0;
        let mut rng = rand::thread_rng();
        for _ in 0..1_000_000 {
            local_counter += rng.gen::<u8>() as u64;
        }
        s2.send(local_counter)
    });
    
    h1.join();
    h2.join();
    let counter = Counters{c1: t1.recv().unwrap(),c2: t2.recv().unwrap()};
}
```
It takes 2.03 ms to execute :)


## 动态和静态分发
https://www.reddit.com/r/rust/comments/ruavjm/is_there_a_difference_in_performance_between/


================================================
FILE: src/profiling/performance/deep-into-move.md
================================================
[Binary file]


================================================
FILE: src/profiling/performance/early-optimise.md
================================================
# 糟糕的提前优化


## 函数调用
由于Rust的编译器和LLVM很强大，因此就算你使用了多层函数调用去完成一件事(嵌套函数调用往往出于设计上的考虑)，依然不会有性能上的影响，因为最终生成的机器码会消除这些多余的函数调用。

总之用Rust时，你不必操心多余的函数调用，只要写合理的代码，然后Rust会帮助你运行的更快!


================================================
FILE: src/profiling/performance/enum.md
================================================
# Enum内存优化 todo

https://blog.zhuangty.com/rust-enum-layout/


================================================
FILE: src/profiling/performance/heap-stack.md
================================================
# 堆和栈

https://www.reddit.com/r/rust/comments/rkddg3/stackheap_question_regarding_performance/


================================================
FILE: src/profiling/performance/intro.md
================================================
# performance

https://nnethercote.github.io/perf-book/profiling.html

##  How do I profile a Rust web application in production?
https://www.reddit.com/r/rust/comments/rupcux/how_do_i_profile_a_rust_web_application_in/

https://zhuanlan.zhihu.com/p/191655266

## 内存对齐
https://www.reddit.com/r/rust/comments/s793x7/force_4byte_memory_alignment/

## riggrep 为啥这么快
https://www.reddit.com/r/rust/comments/sr02aj/what_makes_ripgrep_so_fast/

## 测试堆性能
https://flakm.github.io/posts/heap_allocation/


================================================
FILE: src/profiling/performance/runtime-check.md
================================================
# 减少runtime check

https://www.reddit.com/r/rust/comments/sx8b7m/how_is_rust_able_to_elide_bounds_checks/

## 减少集合访问的边界检查

以下代码，我们实现了两种循环方式：
```rust
// 第一种
let collection = [1, 2, 3, 4, 5];
for i in 0..collection.len() {
  let item = collection[i];
  // ...
}

// 第二种
for item in collection {

}
```

第一种方式是循环索引，然后通过索引下标去访问集合，第二种方式是直接循环迭代集合中的元素，优劣如下：
- **性能**：第一种使用方式中`collection[index]`的索引访问，会因为边界检查(bounds checking)导致运行时的性能损耗 - Rust会检查并确认`index`是落在集合内也就是合法的，但是第二种直接迭代的方式就不会触发这种检查,因为编译器会在编译时就完成分析并证明这种访问是合法的`

## Box::leak
https://www.reddit.com/r/rust/comments/rntx7s/why_use_boxleak/


## bounds check
https://www.reddit.com/r/rust/comments/rnbubh/whats_the_big_deal_with_bounds_checking/

https://www.reddit.com/r/rust/comments/s6u65e/optimization_of_bubble_sort_fails_without_hinting/

## 使用assert 优化检查性能
https://www.reddit.com/r/rust/comments/rui1zz/write_assertions_that_clarify_code_to_both_the/



================================================
FILE: src/profiling/performance/string.md
================================================
https://www.reddit.com/r/rust/comments/t06hk7/string_concatenations_benchmarks_updated/


================================================
FILE: src/profiling/performance/tools.md
================================================
# 常用性能测试工具


https://era.co/blog/unbuffered-io-slows-rust-programs

# profiling
https://www.reddit.com/r/rust/comments/rxj81f/rust_profiling/


================================================
FILE: src/profiling/profiling/performance/benchmark.md
================================================
# Benchmark性能测试(todo)



================================================
FILE: src/std/hashmap.md
================================================
# HashMap



================================================
FILE: src/std/intro.md
================================================
# 标准库解析



================================================
FILE: src/std/iterator.md
================================================
# Iterator常用方法



================================================
FILE: src/std/search.md
================================================
# 标准库使用最佳实践

## 寻找你想要的内容

https://www.reddit.com/r/rust/comments/rk8lf6/how_do_you_find_all_the_functions_available_for_a/

## 如何阅读和使用标准库





================================================
FILE: src/std/vector.md
================================================
# Vector常用方法



================================================
FILE: src/templates/intro.md
================================================
# 场景模版



================================================
FILE: src/templates/files/dir.md
================================================
# 目录



================================================
FILE: src/templates/files/intro.md
================================================
# 文件操作



================================================
FILE: src/templates/http/intro.md
================================================
# Http请求



================================================
FILE: src/test/assertion.md
================================================
[Binary file]


================================================
FILE: src/test/benchmark.md
================================================
# 基准测试 benchmark

几乎所有开发都知道，如果要测量程序的性能，就需要性能测试。

性能测试包含了两种：压力测试和基准测试。前者是针对接口 API，模拟大量用户去访问接口然后生成接口级别的性能数据；而后者是针对代码，可以用来测试某一段代码的运行速度，例如一个排序算法。

而本文将要介绍的就是基准测试 `benchmark`，在 Rust 中，有两种方式可以实现：

- 官方提供的 `benchmark`
- 社区实现，例如 `criterion.rs`

事实上我们更推荐后者，原因在后文会详细介绍，下面先从官方提供的工具开始。

## 官方 benchmark

官方提供的测试工具，目前最大的问题就是只能在非 `stable` 下使用，原因是需要在代码中引入 `test` 特性: `#![feature(test)]`。

#### 设置 Rust 版本

因此在开始之前，我们需要先将当前仓库中的 [`Rust 版本`](https://course.rs/appendix/rust-version.html#不稳定功能)从 `stable` 切换为 `nightly`:

1. 安装 `nightly` 版本：`$ rustup install nightly`
2. 使用以下命令确认版本已经安装成功

```shell
$ rustup toolchain list
stable-aarch64-apple-darwin (default)
nightly-aarch64-apple-darwin (override)
```

3. 进入 `adder` 项目(之前为了学习测试专门创建的项目)的根目录，然后运行 `rustup override set nightly`，将该项目使用的 `rust` 设置为 `nightly`

很简单吧，其实只要一个命令就可以切换指定项目的 Rust 版本，例如你还能在基准测试后再使用 `rustup override set stable` 切换回 `stable` 版本。

#### 使用 benchmark

当完成版本切换后，就可以开始正式编写 `benchmark` 代码了。首先，将 `src/lib.rs` 中的内容替换成如下代码：

```rust
#![feature(test)]

extern crate test;

pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;
    use test::Bencher;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }

    #[bench]
    fn bench_add_two(b: &mut Bencher) {
        b.iter(|| add_two(2));
    }
}
```

可以看出，`benchmark` 跟单元测试区别不大，最大的区别在于它是通过 `#[bench]` 标注，而单元测试是通过 `#[test]` 进行标注，这意味着 `cargo test` 将不会运行 `benchmark` 代码：

```shell
$ cargo test
running 2 tests
test tests::bench_add_two ... ok
test tests::it_works ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

`cargo test` 直接把我们的 `benchmark` 代码当作单元测试处理了，因此没有任何性能测试的结果产生。

对此，需要使用 `cargo bench` 命令：

```shell
$ cargo bench
running 2 tests
test tests::it_works ... ignored
test tests::bench_add_two ... bench:           0 ns/iter (+/- 0)

test result: ok. 0 passed; 0 failed; 1 ignored; 1 measured; 0 filtered out; finished in 0.29s
```

看到没，一个截然不同的结果，除此之外还能看出几点:

- 单元测试 `it_works` 被忽略，并没有执行: `tests::it_works ... ignored`
- benchmark 的结果是 `0 ns/iter`，表示每次迭代( `b.iter` )耗时 `0 ns`，奇怪，怎么是 `0` 纳秒呢？别急，原因后面会讲

#### 一些使用建议

关于 `benchmark`，这里有一些使用建议值得大家关注:

- 将初始化代码移动到 `b.iter` 循环之外，否则每次循环迭代都会初始化一次，这里只应该存放需要精准测试的代码
- 让代码每次都做一样的事情，例如不要去做累加或状态更改的操作
- 最好让 `iter` 之外的代码也具有幂等性，因为它也可能被 `benchmark` 运行多次
- 循环内的代码应该尽量的短小快速，因为这样循环才能被尽可能多的执行，结果也会更加准确

#### 谜一般的性能结果

在写 `benchmark` 时，你可能会遇到一些很纳闷的棘手问题，例如以下代码:

```rust
#![feature(test)]

extern crate test;

fn fibonacci_u64(number: u64) -> u64 {
    let mut last: u64 = 1;
    let mut current: u64 = 0;
    let mut buffer: u64;
    let mut position: u64 = 1;

    return loop {
        if position == number {
            break current;
        }

        buffer = last;
        last = current;
        current = buffer + current;
        position += 1;
    };
}
#[cfg(test)]
mod tests {
    use super::*;
    use test::Bencher;

    #[test]
    fn it_works() {
       assert_eq!(fibonacci_u64(1), 0);
       assert_eq!(fibonacci_u64(2), 1);
       assert_eq!(fibonacci_u64(12), 89);
       assert_eq!(fibonacci_u64(30), 514229);
    }

    #[bench]
    fn bench_u64(b: &mut Bencher) {
        b.iter(|| {
            for i in 100..200 {
                fibonacci_u64(i);
            }
        });
    }
}
```

通过`cargo bench`运行后，得到一个难以置信的结果：`test tests::bench_u64 ... bench: 0 ns/iter (+/- 0)`, 难道 Rust 已经到达量子计算机级别了？

其实，原因藏在`LLVM`中: `LLVM`认为`fibonacci_u64`函数调用的结果没有使用，同时也认为该函数没有任何副作用(造成其它的影响，例如修改外部变量、访问网络等), 因此它有理由把这个函数调用优化掉！

解决很简单，使用 Rust 标准库中的 `black_box` 函数:

```rust
 for i in 100..200 {
    test::black_box(fibonacci_u64(test::black_box(i)));
}
```

通过这个函数，我们告诉编译器，让它尽量少做优化，此时 LLVM 就不会再自作主张了:)

```shell
$ cargo bench
running 2 tests
test tests::it_works ... ignored
test tests::bench_u64 ... bench:       5,626 ns/iter (+/- 267)

test result: ok. 0 passed; 0 failed; 1 ignored; 1 measured; 0 filtered out; finished in 0.67s
```

嗯，这次结果就明显正常了。

## criterion.rs

官方 `benchmark` 有两个问题，首先就是不支持 `stable` 版本的 Rust，其次是结果有些简单，缺少更详细的统计分布。

因此社区 `benchmark` 就应运而生，其中最有名的就是 [`criterion.rs`](https://github.com/bheisler/criterion.rs)，它有几个重要特性:

- 统计分析，例如可以跟上一次运行的结果进行差异比对
- 图表，使用 [`gnuplots`](http://www.gnuplot.info) 展示详细的结果图表

首先，如果你需要图表，需要先安装 `gnuplots`，其次，我们需要引入相关的包，在 `Cargo.toml` 文件中新增 :

```toml
[dev-dependencies]
criterion = "0.3"

[[bench]]
name = "my_benchmark"
harness = false
```

接着，在项目中创建一个测试文件: `$PROJECT/benches/my_benchmark.rs`，然后加入以下内容：

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn fibonacci(n: u64) -> u64 {
    match n {
        0 => 1,
        1 => 1,
        n => fibonacci(n-1) + fibonacci(n-2),
    }
}

fn criterion_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| b.iter(|| fibonacci(black_box(20))));
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
```

最后，使用 `cargo bench` 运行并观察结果：

```shell
     Running target/release/deps/example-423eedc43b2b3a93
Benchmarking fib 20
Benchmarking fib 20: Warming up for 3.0000 s
Benchmarking fib 20: Collecting 100 samples in estimated 5.0658 s (188100 iterations)
Benchmarking fib 20: Analyzing
fib 20                  time:   [26.029 us 26.251 us 26.505 us]
Found 11 outliers among 99 measurements (11.11%)
  6 (6.06%) high mild
  5 (5.05%) high severe
slope  [26.029 us 26.505 us] R^2            [0.8745662 0.8728027]
mean   [26.106 us 26.561 us] std. dev.      [808.98 ns 1.4722 us]
median [25.733 us 25.988 us] med. abs. dev. [234.09 ns 544.07 ns]
```

可以看出，这个结果是明显比官方的更详尽的，如果大家希望更深入的学习它的使用，可以参见[官方文档](https://bheisler.github.io/criterion.rs/book/getting_started.html)。



================================================
FILE: src/test/ci.md
================================================
[Binary file]


================================================
FILE: src/test/intro.md
================================================
[Binary file]


================================================
FILE: src/test/unit-integration-test.md
================================================
# 单元测试、集成测试

在了解了如何在 Rust 中写测试用例后，本章节我们将学习如何实现单元测试、集成测试，其实它们用到的技术还是[上一章节](https://course.rs/test/write-tests.html)中的测试技术，只不过对如何组织测试代码提出了新的要求。

## 单元测试

单元测试目标是测试某一个代码单元(一般都是函数)，验证该单元是否能按照预期进行工作，例如测试一个 `add` 函数，验证当给予两个输入时，最终返回的和是否符合预期。

在 Rust 中，单元测试的惯例是将测试代码的模块跟待测试的正常代码放入同一个文件中，例如 `src/lib.rs` 文件中有如下代码:

```rust
pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(add_two(2), 4);
    }
}
```

`add_two` 是我们的项目代码，为了对它进行测试，我们在同一个文件中编写了测试模块 `tests`，并使用 `#[cfg(test)]` 进行了标注。

#### 条件编译 `#[cfg(test)]`

上面代码中的 `#[cfg(test)]` 标注可以告诉 Rust 只有在 `cargo test` 时才编译和运行模块 `tests`，其它时候当这段代码是空气即可，例如在 `cargo build` 时。这么做有几个好处：

- 节省构建代码时的编译时间
- 减小编译出的可执行文件的体积

其实集成测试就不需要这个标注，因为它们被放入单独的目录文件中，而单元测试是跟正常的逻辑代码在同一个文件，因此必须对其进行特殊的标注，以便 Rust 可以识别。

在 `#[cfg(test)]` 中，`cfg` 是配置 `configuration` 的缩写，它告诉 Rust ：当 `test` 配置项存在时，才运行下面的代码，而 `cargo test` 在运行时，就会将 `test` 这个配置项传入进来，因此后面的 `tests` 模块会被包含进来。

大家看出来了吗？这是典型的条件编译，`Cargo` 会根据指定的配置来选择是否编译指定的代码，事实上关于条件编译 Rust 能做的不仅仅是这些，在 [`Cargo` 专题](https://course.rs/cargo/intro.html)中我们会进行更为详细的介绍。

#### 测试私有函数

关于私有函数能否被直接测试，编程社区里一直争论不休，甚至于部分语言可能都不支持对私有函数进行测试或者难以测试。无论你的立场如何，反正 Rust 是支持对私有函数进行测试的:

```rust
pub fn add_two(a: i32) -> i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
```

`internal_adder` 并没有使用 `pub` 进行声明，因此它是一个私有函数。根据我们之前[学过的内容]()，`tests` 作为另一个模块，是绝对无法对它进行调用的，因为它们根本不在同一个模块中！

但是在上述代码中，我们使用 `use super::*;` 将 `tests` 的父模块中的所有内容引入到当前作用域中，这样就可以非常简单的实现对私有函数的测试。

## 集成测试

与单元测试的同吃同住不同，集成测试的代码是在一个单独的目录下的。由于它们使用跟其它模块一样的方式去调用你想要测试的代码，因此只能调用通过 `pub` 定义的 `API`，这一点与单元测试有很大的不同。

如果说单元测试是对代码单元进行测试，那集成测试则是对某一个功能或者接口进行测试，因此单元测试的通过，并不意味着集成测试就能通过：局部上反映不出的问题，在全局上很可能会暴露出来。

#### _tests_ 目录

一个标准的 Rust 项目，在它的根目录下会有一个 `tests` 目录，大名鼎鼎的 [`ripgrep`](https://github.com/BurntSushi/ripgrep) 也不能免俗。

没错，该目录就是用来存放集成测试的，Cargo 会自动来此目录下寻找集成测试文件。我们可以在该目录下创建任何文件，Cargo 会对每个文件都进行自动编译，但友情提示下，最好按照合适的逻辑来组织你的测试代码。

首先来创建一个集成测试文件 `tests/integration_test.rs` ，注意，`tests` 目录一般来说需要手动创建，该目录在项目的根目录下，跟 `src` 目录同级。然后在文件中填入如下测试代码：

```rust
use adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
```

这段测试代码是对之前**私有函数**中的示例进行测试，该示例代码在 `src/lib.rs` 中。

首先与单元测试有所不同，我们并没有创建测试模块。其次，`tests` 目录下的每个文件都是一个单独的包，我们需要将待测试的包引入到当前包的作用域后: `use adder`，才能进行测试 。大家应该还记得[包和模块章节](https://course.rs/advance/crate-module/crate.html)中讲过的内容吧？在创建项目后，`src/lib.rs` 自动创建一个与项目同名的 `lib` 类型的包，由于我们的项目名是 `adder`，因此包名也是 `adder`。

因为 `tests` 目录本身就说明了它的特殊用途，因此我们无需再使用 `#[cfg(test)]` 来取悦 Cargo。后者会在运行 `cargo test` 时，对 `tests` 目录中的每个文件都进行编译运行。

```shell
$ cargo test
     Running unittests (target/debug/deps/adder-8a400aa2b5212836)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-2d3aeee6f15d1f20)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

运行 `cargo test` ，可以看到上述输出。测试内容有三个部分：单元测试，集成测试和文档测试。

首先是单元测试被运行 `Running unittests` ，其次就是我们的主角集成测试的运行 `Running tests/integration_test.rs`，可以看出，集成测试的输出内容与单元测试并没有大的区别。最后运行的是文档测试 `Doc-tests adder`。

与单元测试类似，我们可以通过[指定名称的方式](https://course.rs/test/write-tests.html#指定运行一部分测试)来运行特定的集成测试用例:

```shell
$ cargo test --test integration_test
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

这次，单元测试、文档测试啥的都没有运行，只有集成测试目录下的 `integration_test` 文件被顺利执行。

大家可以尝试下在同一个测试文件中添加更多的测试用例或者添加更多的测试文件，并观察测试输出会如何变化。

#### 共享模块

在集成测试的 `tests` 目录下，每一个文件都是一个独立的包，这种组织方式可以很好的帮助我们理清测试代码的关系，但是如果大家想要在多个文件中共享同一个功能该怎么做？例如函数 `setup` 可以用于状态初始化，然后多个测试包都需要使用该函数进行状态的初始化。

也许你会想要创建一个 `tests/common.rs` 文件，然后将 `setup` 函数放入其中：

```rust
pub fn setup() {
    // 初始化一些测试状态
    // ...
}
```

但是当我们运行 `cargo test` 后，会发现该函数被当作集成测试函数运行了，即使它并没有包含任何测试功能，也没有被其它测试文件所调用:

```shell
$ cargo test
     Running tests/common.rs (target/debug/deps/common-5c21f4f2c87696fb)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

显然，这个结果并不是我们想要的。**为了避免这种输出，我们不能创建 `tests/common.rs`，而是要创建 `tests/common/mod.rs`。**，此时再运行 `cargo test` 就不会再看到相应的输出。 原因是**通过这种文件组织和命名方式， Rust 不再将 `common` 模块看作是集成测试文件。**

总结来说，**`tests` 目录下的子目录中的文件不会被当作独立的包，也不会有测试输出**。

```rust
use adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
```

此时，就可以在测试中调用 `common` 中的共享函数了，不过还有一点值得注意，为了使用 `common`，这里使用了 `mod common` 的方式来声明该模块。

#### 二进制包的集成测试

目前来说，Rust 只支持对 `lib` 类型的包进行集成测试，对于二进制包例如 `src/main.rs` 是无能为力的。原因在于，我们无法在其它包中使用 `use` 引入二进制包，而只有 `lib` 类型的包才能被引入，例如 `src/lib.rs`。

这就是为何我们需要将代码逻辑从 `src/main.rs` 剥离出去放入 `lib` 包中，例如很多 Rust 项目中都同时有 `src/main.rs` 和 `src/lib.rs` ，前者中只保留代码的主体脉络部分，而具体的实现通通放在类似后者的 `lib` 包中。

这样，我们就可以对 `lib` 包中的具体实现进行集成测试，由于 `main.rs` 中的主体脉络足够简单，当集成测试通过时，意味着 `main.rs` 中相应的调用代码也将正常运行。

## 总结

Rust 提供了单元测试和集成测试两种方式来帮助我们组织测试代码以解决代码正确性问题。

单元测试针对的是具体的代码单元，例如函数，而集成测试往往针对的是一个功能或接口 API，正因为目标上的不同，导致了两者在组织方式上的不同：

- 单元测试的模块和待测试的代码在同一个文件中，且可以很方便地对私有函数进行测试
- 集成测试文件放在项目根目录下的 `tests` 目录中，由于该目录下每个文件都是一个包，我们必须要引入待测试的代码到当前包的作用域中，才能进行测试，正因为此，集成测试只能对声明为 `pub` 的 API 进行测试

下个章节，我们再来看看该如何使用 `GitHub Actions` 对 Rust 项目进行持续集成。



================================================
FILE: src/test/write-tests.md
================================================
# 编写测试及控制执行

在 Rust 中，测试是通过函数的方式实现的，它可以用于验证被测试代码的正确性。测试函数往往依次执行以下三种行为：

1. 设置所需的数据或状态
2. 运行想要测试的代码
3. 判断( assert )返回的结果是否符合预期

让我们来看看该如何使用 Rust 提供的特性来按照上述步骤编写测试用例。

## 测试函数

当使用 `Cargo` 创建一个 `lib` 类型的包时，它会为我们自动生成一个测试模块。先来创建一个 `lib` 类型的 `adder` 包：

```shell
$ cargo new adder --lib
     Created library `adder` project
$ cd adder
```

创建成功后，在 _src/lib.rs_ 文件中可以发现如下代码:

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
```

其中，`tests` 就是一个测试模块，`it_works` 则是我们的主角：测试函数。

可以看出，测试函数需要使用 `test` 属性进行标注。关于属性( `attribute` )，我们在之前的章节已经见过类似的 `derive`，使用它可以派生自动实现的 `Debug` 、`Copy` 等特征，同样的，使用 `test` 属性，我们也可以获取 Rust 提供的测试特性。

经过 `test` 标记的函数就可以被测试执行器发现，并进行运行。当然，在测试模块 `tests` 中，还可以定义非测试函数，这些函数可以用于设置环境或执行一些通用操作：例如为部分测试函数提供某个通用的功能，这种功能就可以抽象为一个非测试函数。

换而言之，正是因为测试模块既可以定义测试函数又可以定义非测试函数，导致了我们必须提供一个特殊的标记 `test`，用于告知哪个函数才是测试函数。

#### assert_eq

在测试函数中，还使用到了一个内置的断言：`assert_eq`，该宏用于对结果进行断言：`2 + 2` 是否等于 `4`。与之类似，Rust 还内置了其它一些实用的断言，具体参见[后续章节](https://course.rs/test/assertion.html)。

## cargo test

下面使用 `cargo test` 命令来运行项目中的所有测试:

```shell
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

上面测试输出中，有几点值得注意:

- 测试用例是分批执行的，`running 1 test` 表示下面的输出 `test result` 来自一个测试用例的运行结果。
- `test tests::it_works` 中包含了测试用例的名称
- `test result: ok` 中的 `ok` 表示测试成功通过
- `1 passed` 代表成功通过一个测试用例(因为只有一个)，`0 failed` : 没有测试用例失败，`0 ignored` 说明我们没有将任何测试函数标记为运行时可忽略，`0 filtered` 意味着没有对测试结果做任何过滤，`0 measured` 代表[基准测试(benchmark)](https://course.rs/test/benchmark.html)的结果

关于 `filtered` 和 `ignored` 的使用，在本章节的后续内容我们会讲到，这里暂且略过。

还有一个很重要的点，输出中的 `Doc-tests adder` 代表了文档测试，由于我们的代码中没有任何文档测试的内容，因此这里的测试用例数为 `0`，关于文档测试的详细介绍请参见[这里](https://course.rs/basic/comment.html#文档注释)。

大家还可以尝试修改下测试函数的名称，例如修改为 `exploration`，看看运行结果将如何变化。

#### 失败的测试用例

是时候开始写自己的测试函数了，为了演示，这次我们来写一个会运行失败的:

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!("Make this test fail");
    }
}
```

新的测试函数 `another` 相当简单粗暴，直接使用 `panic` 来报错，使用 `cargo test` 运行看看结果：

```shell
running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'main' panicked at 'Make this test fail', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
```

从结果看，两个测试函数，一个成功，一个失败，同时在输出中准确的告知了失败的函数名: `failures: tests::another`，同时还给出了具体的失败原因： `tests::another stdout`。这两者虽然看起来存在重复，但是前者用于说明每个失败的具体原因，后者用于给出一眼可得结论的汇总信息。

有同学可能会好奇，这两个测试函数以什么方式运行？ 它们会运行在同一个线程中吗？答案是否定的，Rust 在默认情况下会为每一个测试函数启动单独的线程去处理，当主线程 `main` 发现有一个测试线程死掉时，`main` 会将相应的测试标记为失败。

事实上，多线程运行测试虽然性能高，但是存在数据竞争的风险，在后文我们会对其进行详细介绍并给出解决方案。

## 自定义失败信息

默认的失败信息在有时候并不是我们想要的，来看一个例子：

```rust
pub fn greeting(name: &str) -> String {
    format!("Hello {}!", name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Sunface");
        assert!(result.contains("孙飞"));
    }
}
```

使用 `cargo test` 运行后，错误如下：

```shell
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at 'assertion failed: result.contains(\"孙飞\")', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name
```

可以看出，这段报错除了告诉我们错误发生的地方，并没有更多的信息，那再来看看该如何提供一些更有用的信息：

```rust
fn greeting_contains_name() {
    let result = greeting("Sunface");
    let target = "孙飞";
    assert!(
        result.contains(target),
        "你的问候中并没有包含目标姓名 {} ，你的问候是 `{}`",
        target,
        result
    );
}
```

这段代码跟之前并无不同，只是为 `assert!` 新增了几个格式化参数，这种使用方式与 `format!` 并无区别。再次运行后，输出如下：

```shell
---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at '你的问候中并没有包含目标姓名 孙飞 ，你的问候是 `Hello Sunface!`', src/lib.rs:14:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

这次的报错就清晰太多了，真棒！在测试用例少的时候，也许这种信息还无法体现最大的价值，但是一旦测试多了后，详尽的报错信息将帮助我们更好的进行 Debug。

## 测试 panic

在之前的例子中，我们通过 `panic` 来触发报错，但是如果一个函数本来就会 `panic` ，而我们想要检查这种结果呢？

也就是说，我们需要一个办法来测试一个函数是否会 `panic`，对此， Rust 提供了 `should_panic` 属性注解，和 `test` 注解一样，对目标测试函数进行标注即可：

```rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
```

上面是一个简单的猜数字游戏，`Guess` 结构体的 `new` 方法在传入的值不在 [1,100] 之间时，会直接 `panic`，而在测试函数 `greater_than_100` 中，我们传入的值 `200` 显然没有落入该区间，因此 `new` 方法会直接 `panic`，为了测试这个预期的 `panic` 行为，我们使用 `#[should_panic]` 对其进行了标注。

```shell
running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

从输出可以看出， `panic` 的结果被准确的进行了测试，那如果测试函数中的代码不再 `panic` 呢？例如：

```rust
fn greater_than_100() {
    Guess::new(50);
}
```

此时显然会测试失败，因为我们预期一个 `panic`，但是 `new` 函数顺利的返回了一个 `Guess` 实例:

```shell
running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected // 测试并没有按照预期发生 panic
```

#### expected

虽然 `panic` 被成功测试到，但是如果代码发生的 `panic` 和我们预期的 `panic` 不符合呢？因为一段糟糕的代码可能会在不同的代码行生成不同的 `panic`。

鉴于此，我们可以使用可选的参数 `expected` 来说明预期的 `panic` 长啥样：

```rust
// --snip--
impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {}.",
                value
            );
        } else if value > 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {}.",
                value
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "Guess value must be less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}
```

这段代码会通过测试，因为通过增加了 `expected` ，我们成功指定了期望的 `panic` 信息，大家可以顺着代码推测下：把 `200` 带入到 `new` 函数中看看会触发哪个 `panic`。

如果注意看，你会发现 `expected` 的字符串和实际 `panic` 的字符串可以不同，前者只需要是后者的字符串前缀即可，如果改成 ` #[should_panic(expected = "Guess value must be less than")]`，一样可以通过测试。

这里由于篇幅有限，我们就不再展示测试失败的报错，大家可以自己修改下 `expected` 的信息，然后看看报错后的输出长啥样。

## 使用 `Result<T, E>`

在之前的例子中，`panic` 扫清一切障碍，但是它也不是万能的，例如你想在测试中使用 `?` 操作符进行链式调用该怎么办？那就得请出 `Result<T, E>` 了：

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -> Result<(), String> {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
}
```

如上所示，测试函数不会再使用 `assert_eq!` 导致 `panic`，而是手动进行了逻辑判断，并返回一个 `Result`。当然，当这么实现时，`#[should_panic]` 将无法再被使用。

至此，关于如何写测试的基本知识，大家已经了解的差不多了，下面来看看该如何控制测试的执行。

## 使用 `--` 分割命令行参数

大家应该都知道 `cargo build` 可以将代码编译成一个可执行文件，那你知道 `cargo run` 和 `cargo test` 是如何运行的吗？其实道理都一样，这两个也是将代码编译成可执行文件，然后进行运行，唯一的区别就在于这个可执行文件随后会被删除。

正因为如此，`cargo test` 也可以通过命令行参数来控制测试的执行，例如你可以通过参数来让默认的多线程测试变成单线程下的测试。需要注意的是命令行参数有两种，这两种通过 `--` 进行分割：

- 第一种是提供给 `cargo test` 命令本身的，这些参数在 `--` 之前指定
- 第二种是提供给编译后的可执行文件的，在 `--` 之后指定

例如我们可以使用 `cargo test --help` 来查看第一种参数的帮助列表，还可以通过 `cargo test -- --help` 来查看第二种的帮助列表。

先来看看第二种参数中的其中一个，它可以控制测试是并行运行还是顺序运行。

## 测试用例的并行或顺序执行

当运行多个测试函数时，默认情况下是为每个测试都生成一个线程，然后通过主线程来等待它们的完成和结果。这种模式的优点很明显，那就是并行运行会让整体测试时间变短很多，运行过大量测试用例的同学都明白并行测试的重要性：生命苦短，我用并行。

但是有利就有弊，并行测试最大的问题就在于共享状态的修改，因为你难以控制测试的运行顺序，因此如果多个测试共享一个数据，那么对该数据的使用也将变得不可控制。

例如，我们有多个测试，它们每个都会往该文件中写入一些**自己的数据**，最后再从文件中读取这些数据进行对比。由于所有测试都是同时运行的，当测试 `A` 写入数据准备读取并对比时，很有可能会被测试 `B` 写入新的数据，导致 `A` 写入的数据被覆盖，然后 `A` 再读取到的就是 `B` 写入的数据。结果 `A` 测试就会失败，而且这种失败还不是因为测试代码不正确导致的！

解决办法也有，我们可以让每个测试写入自己独立的文件中，当然，也可以让所有测试一个接着一个顺序运行:

```rust
$ cargo test -- --test-threads=1
```

首先能注意到的是该命令行参数是第二种类型：提供给编译后的可执行文件的，因为它在 `--` 之后进行传递。其次，细心的同学可能会想到，线程数不仅仅可以指定为 `1`，还可以指定为 `4`、`8`，当然，想要顺序运行，就必须是 `1`。

## 测试函数中的 `println!`

默认情况下，如果测试通过，那写入标准输出的内容是不会显示在测试结果中的:

```rust
fn prints_and_returns_10(a: i32) -> i32 {
    println!("I got the value {}", a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
```

上面代码使用 `println!` 输出收到的参数值，来看看测试结果:

```shell
running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

大家注意看，`I got the value 4` 并没有被输出，因为该测试顺利通过了，如果就是想要看所有的输出，该怎么办呢？

```rust
$ cargo test -- --show-output
```

如上所示，只需要增加一个参数，具体的输出就不再展示，总之这次大家一定可以顺利看到 `I got the value 4` 的身影。

## 指定运行一部分测试

在 Mysql 中有上百万的单元测试，如果使用类似 `cargo test` 的命令来运行全部的测试，那开发真的工作十分钟，吹牛八小时了。对于 Rust 的中大型项目也一样，每次都运行全部测试是不可接受的，特别是你的工作仅仅是项目中的一部分时。

```rust
pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
```

如果直接使用 `cargo test` 运行，那三个测试函数会同时并行的运行：

```shell
running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

就不说上百万测试，就说几百个，想象一下结果会是怎么样，下面我们来看看该如何解决这个问题。

#### 运行单个测试

这个很简单，只需要将指定的测试函数名作为参数即可：

```shell
$ cargo test one_hundred
running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s
```

此时，只有测试函数 `one_hundred` 会被运行，其它两个由于名称不匹配，会被直接忽略。同时，在上面的输出中，Rust 也通过 `2 filtered out` 提示我们：有两个测试函数被过滤了。

但是，如果你试图同时指定多个名称，那抱歉:

```shell
$ cargo test one_hundred,add_two_and_two
$ cargo test one_hundred add_two_and_two
```

这两种方式统统不行，此时就需要使用名称过滤的方式来实现了。

#### 通过名称来过滤测试

我们可以通过指定部分名称的方式来过滤运行相应的测试:

```shell
$ cargo test add
running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s
```

事实上，你不仅可以使用前缀，还能使用名称中间的一部分：

```shell
$ cargo test and
running 2 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s
```

其中还有一点值得注意，那就是测试模块 `tests` 的名称也出现在了最终结果中：`tests::add_two_and_two`，这是非常贴心的细节，也意味着我们可以通过**模块名称来过滤测试**：

```shell
$ cargo test tests

running 3 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

#### 忽略部分测试

有时候，一些测试会非常耗时间，因此我们希望在 `cargo test` 中对它进行忽略，如果使用之前的方式，我们需要将所有需要运行的名称指定一遍，这非常麻烦，好在 Rust 允许通过 `ignore` 关键字来忽略特定的测试用例:

```rust
#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // 这里的代码需要几十秒甚至几分钟才能完成
}
```

在这里，我们使用 `#[ignore]` 对 `expensive_test` 函数进行了标注，看看结果：

```shell
$ cargo test
running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

输出中的 `test expensive_test ... ignored` 意味着该测试函数被忽略了，因此并没有被执行。

当然，也可以通过以下方式运行被忽略的测试函数：

```shell
$ cargo test -- --ignored
running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

#### 组合过滤

上面的方式虽然很强大，但是单独使用依然存在局限性。好在它们还能组合使用，例如还是之前的代码：

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    #[ignore]
    fn expensive_test() {
        // 这里的代码需要几十秒甚至几分钟才能完成
    }

    #[test]
    #[ignore]
    fn expensive_run() {
        // 这里的代码需要几十秒甚至几分钟才能完成
    }
}
```

然后运行 `tests` 模块中的被忽略的测试函数

```shell
$ cargo test tests -- --ignored
running 2 tests
test tests::expensive_test ... ok
test tests::expensive_run ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s
```

运行名称中带 `run` 且被忽略的测试函数：

```shell
$ cargo test run -- --ignored
running 1 test
test tests::expensive_run ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s
```

类似的还有很多，大家可以自己摸索研究下，总之，熟练掌握测试的使用是非常重要的，虽然包括我在内的很多开发并不喜欢写测试 :)

## `[dev-dependencies]`

与 `package.json`( Nodejs )文件中的 `devDependencies` 一样， Rust 也能引入只在开发测试场景使用的外部依赖。

其中一个例子就是 [`pretty_assertions`](https://docs.rs/pretty_assertions/1.0.0/pretty_assertions/index.html)，它可以用来扩展标准库中的 `assert_eq!` 和 `assert_ne!`，例如提供彩色字体的结果对比。

在 `Cargo.toml` 文件中添加以下内容来引入 `pretty_assertions`：

```toml
# standard crate data is left out
[dev-dependencies]
pretty_assertions = "1"
```

然后在 `src/lib.rs` 中添加:

```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;
    use pretty_assertions::assert_eq; // 该包仅能用于测试

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }
}
```

在 `tests` 模块中，我们通过 `use pretty_assertions::assert_eq;` 成功的引入之前添加的包，由于 `tests` 模块明确的用于测试目的，这种引入并不会报错。 大家可以试试在正常代码(非测试代码)中引入该包，看看会发生什么。

## 生成测试二进制文件

在有些时候，我们可能希望将测试与别人分享，这种情况下生成一个类似 `cargo build` 的可执行二进制文件是很好的选择。

事实上，在 `cargo test` 运行的时候，系统会自动为我们生成一个可运行测试的二进制可执行文件:

```shell
$ cargo test
 Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests (target/debug/deps/study_cargo-0d693f72a0f49166)
```

这里的 `target/debug/deps/study_cargo-0d693f72a0f49166` 就是可执行文件的路径和名称，我们直接运行该文件来执行编译好的测试:

```shell
$ target/debug/deps/study_cargo-0d693f72a0f49166

running 3 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

如果你只想生成编译生成文件，不想看 `cargo test` 的输出结果，还可以使用 `cargo test --no-run`.




================================================
FILE: src/too-many-lists/do-we-need-it.md
================================================
## 我们到底需不需要链表
经常有读者询问该如何实现一个链表，怎么说呢，这个答案主要取决于你的需求，因此并不是很好回答。鉴于此，我决定通过这本书来详尽的介绍该如何实现一个链表，大家应该都能从这本书中找到答案。

书中我们将通过实现 6 种链表来学习基本和进阶 Rust 编程知识，在此过程中，你能学到：

- 指针类型: `&`, `&mut`, `Box`, `Rc`, `Arc`, `*const`, `*mut`, `NonNull`
- 所有权、借用、继承可变性、内部可变性、Copy
- 所有的关键字：struct、enum、fn、pub、impl、use, ...
- 模式匹配、泛型、解构
- 测试、安装新的工具链、使用 `miri`
- Unsafe: 裸指针、别名、栈借用、`UnsafeCell`、变体 variance

是的，链表就是这么可怕，只有将这些知识融会贯通后，你才能掌握 :( 


> 事实上这本书中关于 Rust 语言的绝大部分知识都在 `Rust语言圣经`中有讲，因此除非特殊情况，我们将直接提供链接供大家学习，重点还是放在链表实现上

#### 创建一个项目
在开始前，先来创建一个项目专门用于链表学习：
```shell
$ cargo new --lib lists
$ cd lists
```

之后，我们会将每个一个链表放入单独的文件中，需要注意的是我们会尽量模拟真实的 Rust 开发场景：你写了一段代码，然后编译器开始跳出试图教你做事，只有这样才能真正学会 Rust，温室环境是无法培养出强大的 Rustacean 的。

#### 义务告知
首先，本书不是保姆式教程，而且我个人认为编程应该是快乐，这种快乐往往需要你自己发现而不是别人的事无巨细的讲解。

其次，我讨厌链表。链表真的是一种糟糕的数据结构，尽管它在部分场景下确实很有用：

- 对列表进行大量的分割和合并操作
- 无锁并发
- 要实现内核或嵌入式的服务
- 你在使用一个纯函数式语言，由于受限的语法和缺少可变性，因此你需要使用链表来解决这些问题

但是实事求是的说，这些场景对于几乎任何 Rust 开发都是很少遇到的，99% 的场景你可以使用 `Vec` 来替代，然后 1% 中的 99% 可以使用 `VecDeque`。 由于它们具有更少的内存分配次数、更低的内存占用、随机访问和缓存亲和特性，因此能够适用于绝大多数工作场景。总之，类似于 `trie` 树，链表也是一种非常小众的数据结构，特别是对于 Rust 开发而言。

> 本书只是为了学习链表该如何实现，如果大家只是为了使用链表，强烈推荐直接使用标准库或者社区提供的现成实现，例如 [std::collections::LinkedList](https://doc.rust-lang.org/std/collections/struct.LinkedList.html)

#### 链表有 O(1) 的分割、合并、插入、移除性能
是的，但是你首先要考虑的是，这些代码被调用的频率是怎么样的？是否在热点路径？ 答案如果是否定的，那么还是强烈建议使用 `Vec` 等传统数据结构，况且整个数组的拷贝也是相当快的！

况且，`Vec` 上的 `push` 和 `pop` 操作是 `O(1)` 的，它们比链表提供的 `push` 和 `pop` 要更快！我们只需要通过一个指针 + 内存偏移就可以访问了。

> 关于是否使用链表这个问题，Bjarne Stroustrup 有过非常深入的[讲解](https://www.youtube.com/watch?v=YQs6IC-vgmo)

但是如果你的整体项目确实因为某一段分割、合并的代码导致了性能低下，那么就放心大胆的使用链表吧。


#### 我无法接受内存重新分配的代价
是的，`Vec` 当 [`capacity`](https://practice-zh.course.rs/collections/vector.html#capacity) 不够时，会重新分配一块内存，然后将之前的 `Vec` 全部拷贝过去，但是对于绝大多数使用场景，要么 `Vec` 不在热点路径中，要么 `Vec` 的容量可以提前预测。

对于前者，那性能如何自然无关紧要。而对于后者，我们只需要使用 `Vec::with_capacity` 提前分配足够的空间即可，同时，Rust 中所有的迭代器还提供了 `size_hint` 也可以解决这种问题。


当然，如果这段代码在热点路径，且你无法提前预测所需的容量，那么链表确实会更提升性能。

#### 链表更节省内存空间
首先，这个问题较为复杂。一个标准的数组调整策略是：增加或减少数组的长度使数组最多有一半为空，例如 capacity 增长是翻倍的策略。这确实会导致内存空间的浪费，特别是在 Rust 中，我们不会自动收缩集合类型。

但是上面说的是最坏的情况，如果是最好的情况，那整个数组其实只有 3 个指针大小(指针在 Rust 中占用一个 word 的空间，例如 64 位机器就是 8 个字节的大小)的内存浪费，或者说，没有浪费。

而且链表实际上也有内存浪费，例如链表中的每个元素都会占用额外的内存：单向链表浪费一个指针，双向链表浪费两个指针。当然，如果你的链表中每个元素都很大，那相对来说，这种浪费也微不足道，但是如果链表的元素较小且数量很多呢？那浪费的空间就相当可观了！

当然，这个也和使用的内存分配器有关( allocator )：对链表节点的分配和回收会经常发生，这样就不会浪费内存。

总之，如果链表的元素较大，你也无法预测数组的空间，同时还有一个不错的内存分配器，那链表确实可以节省空间！

#### 我在函数语言中一直使用链表
对于函数语言而言，链表确实非常棒，因为你可以解决可变性问题，还能递归地去使用，当然，可能还有一定的图方便的因素，因为链表不用操心长度等问题。

但彼之蜜糖不等于吾之蜜糖，函数语言的一些使用习惯不应该带入到其它语言中，例如 Rust。

- 函数语言往往将链表用于迭代，但是 Rust 中最适合迭代的数据结构是迭代器 `Iterator`
- 函数式语言的不可变对于 Rust 也不是问题
- Rust 还支持对数组进行切片以获取其中一部分连续的元素，而在函数语言中你可能得通过链表的 `head/tail` 分割来完成


其实，在函数语言中，我们也应该选择合适的数据结构来解决适合的场景，而不是*一根链表挂腰间，潇潇洒洒走天下*。


#### 链表适合构建并发数据结构
是这样的，如果有这样的需求，那么链表会非常合适！但是只有在你确实需要并发数据结构，且没有其它办法时，再考虑链表！

#### 链表非常适合教学目的
额... 这么说也没错，毕竟所有的编程语言课程都以链表来作为最常见的练手项目，包括本书也是服务于这个目的的。






================================================
FILE: src/too-many-lists/intro.md
================================================
# 手把手带你实现链表

> 其它语言：兄弟，语言学了吗？来写一个链表证明你基本掌握了语法。
> 
> Rust 语言: 兄弟，语言精通了吗？来写一个链表证明你已经精通了 Rust！


上面的对话非常真实，我们在之前的章节也讲过[避免从入门到放弃](https://course.rs/first-try/sth-you-should-not-do.html#千万别从链表或图开始练手)，其中最重要的就是 - 不要写链表或者类似的数据结构！

而本章，你就将见识到何为真正的深坑，看完后，就知道没有提早跳进去是一个多么幸运的事。总之，在专题中，你将学会如何使用 Rust 来实现链表。


**专题内容翻译自英文开源书 [Learning Rust With Entirely Too Many Linked Lists](https://rust-unofficial.github.io/too-many-lists/)，但是在内容上做了一些调整(原书虽然非常棒，但是在一些内容组织和文字细节上我觉得还是可以优化下的 ：D)，希望大家喜欢。**




================================================
FILE: src/too-many-lists/advanced-lists/double-singly.md
================================================
# 双单向链表
在之前的双向链表章节中，我们一度非常纠结，原因来自同样纠结成一团的所有权依赖。还有一个重要原因就是：先入为主的链表定义。

谁说所有的链接一定要一个方向呢？这里一起来尝试下新的东东：链表的其中一半朝左，另一半朝右。

新规矩( 老规矩是创建文件 )，创建一个新的模块:
```rust
// lib.rs
// ...
pub mod silly1;     // NEW!
```

```rust
// silly1.rs
use crate::second::List as Stack;

struct List<T> {
    left: Stack<T>,
    right: Stack<T>,
}
```

这里将之前的 `List` 引入进来，并重命名为 `Stack`，接着，创建一个新的链表。现在既可以向左增长又可以向右增长。

```rust
pub struct Stack<T> {
    head: Link<T>,
}

type Link<T> = Option<Box<Node<T>>>;

struct Node<T> {
    elem: T,
    next: Link<T>,
}

impl<T> Stack<T> {
    pub fn new() -> Self {
        Stack { head: None }
    }

    pub fn push(&mut self, elem: T) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&mut self) -> Option<T> {
        self.head.take().map(|node| {
            let node = *node;
            self.head = node.next;
            node.elem
        })
    }

    pub fn peek(&self) -> Option<&T> {
        self.head.as_ref().map(|node| {
            &node.elem
        })
    }

    pub fn peek_mut(&mut self) -> Option<&mut T> {
        self.head.as_mut().map(|node| {
            &mut node.elem
        })
    }
}

impl<T> Drop for Stack<T> {
    fn drop(&mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
```

稍微修改下 `push` 和 `pop`：
```rust
pub fn push(&mut self, elem: T) {
    let new_node = Box::new(Node {
        elem: elem,
        next: None,
    });

    self.push_node(new_node);
}

fn push_node(&mut self, mut node: Box<Node<T>>) {
    node.next = self.head.take();
    self.head = Some(node);
}

pub fn pop(&mut self) -> Option<T> {
    self.pop_node().map(|node| {
        node.elem
    })
}

fn pop_node(&mut self) -> Option<Box<Node<T>>> {
    self.head.take().map(|mut node| {
        self.head = node.next.take();
        node
    })
}
```

现在可以开始构造新的链表:
```rust
pub struct List<T> {
    left: Stack<T>,
    right: Stack<T>,
}

impl<T> List<T> {
    fn new() -> Self {
        List { left: Stack::new(), right: Stack::new() }
    }
}
```

当然，还有一大堆左左右右类型的操作:
```rust
pub fn push_left(&mut self, elem: T) { self.left.push(elem) }
pub fn push_right(&mut self, elem: T) { self.right.push(elem) }
pub fn pop_left(&mut self) -> Option<T> { self.left.pop() }
pub fn pop_right(&mut self) -> Option<T> { self.right.pop() }
pub fn peek_left(&self) -> Option<&T> { self.left.peek() }
pub fn peek_right(&self) -> Option<&T> { self.right.peek() }
pub fn peek_left_mut(&mut self) -> Option<&mut T> { self.left.peek_mut() }
pub fn peek_right_mut(&mut self) -> Option<&mut T> { self.right.peek_mut() }
```

其中最有趣的是：还可以来回闲逛了。
```rust
pub fn go_left(&mut self) -> bool {
    self.left.pop_node().map(|node| {
        self.right.push_node(node);
    }).is_some()
}

pub fn go_right(&mut self) -> bool {
    self.right.pop_node().map(|node| {
        self.left.push_node(node);
    }).is_some()
}
```

这里返回 `bool` 是为了告诉调用者我们是否成功的移动。最后，再来测试下：
```rust
#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn walk_aboot() {
        let mut list = List::new();             // [_]

        list.push_left(0);                      // [0,_]
        list.push_right(1);                     // [0, _, 1]
        assert_eq!(list.peek_left(), Some(&0));
        assert_eq!(list.peek_right(), Some(&1));

        list.push_left(2);                      // [0, 2, _, 1]
        list.push_left(3);                      // [0, 2, 3, _, 1]
        list.push_right(4);                     // [0, 2, 3, _, 4, 1]

        while list.go_left() {}                 // [_, 0, 2, 3, 4, 1]

        assert_eq!(list.pop_left(), None);
        assert_eq!(list.pop_right(), Some(0));  // [_, 2, 3, 4, 1]
        assert_eq!(list.pop_right(), Some(2));  // [_, 3, 4, 1]

        list.push_left(5);                      // [5, _, 3, 4, 1]
        assert_eq!(list.pop_right(), Some(3));  // [5, _, 4, 1]
        assert_eq!(list.pop_left(), Some(5));   // [_, 4, 1]
        assert_eq!(list.pop_right(), Some(4));  // [_, 1]
        assert_eq!(list.pop_right(), Some(1));  // [_]

        assert_eq!(list.pop_right(), None);
        assert_eq!(list.pop_left(), None);

    }
}
```

```shell
$ cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 16 tests
test fifth::test::into_iter ... ok
test fifth::test::basics ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test fourth::test::into_iter ... ok
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test first::test::basics ... ok
test second::test::into_iter ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test third::test::basics ... ok
test third::test::iter ... ok
test second::test::peek ... ok
test silly1::test::walk_aboot ... ok

test result: ok. 16 passed; 0 failed; 0 ignored; 0 measured
```

上上下下，左左右右，BABA，哦耶，这个链表无敌了！

以上是一个非常典型的<ruby>手指型数据结构<rt>finger data structure</rt></ruby>，在其中维护一个手指，然后操作所需的时间与手指的距离成正比。




================================================
FILE: src/too-many-lists/advanced-lists/intro.md
================================================
# 使用高级技巧实现链表

说句实话，我们之前实现的链表都达不到生产级可用的程度，而且也没有用到一些比较时髦的技巧。

本章我们一起来看一些更时髦的链表实现:

1. 双重单向链表
2. 栈分配的链表
3. 自引用和Arena分配器实现( 原文作者还未实现，所以... Todo )
4. GhostCell 实现( 同上 )



================================================
FILE: src/too-many-lists/advanced-lists/stack-allocated.md
================================================
# 栈上的链表
在之前的章节中，无一例外，我们创建的都是数据存储在堆上的链表，这种链表最常见也最实用：堆内存在动态分配的场景非常好用。

但是，既然是高级技巧章节，那栈链表也应该拥有一席之地。但与堆内存的简单分配相比，栈内存就没那么友好了，你们猜大名鼎鼎的 C 语言的 `alloca` 是因为什么而出名的 :)

限于章节篇幅，这里我们使用一个简单的栈分配方法：调用一个函数，获取一个新的、拥有更多空间的栈帧。说实话，该解决方法要多愚蠢有多愚蠢，但是它确实相当实用，甚至...有用。

任何时候，当我们在做一些递归的任务时，都可以将当前步骤状态的指针传递给下一个步骤。如果指针本身就是状态的一部分，那恭喜你：你在创建一个栈上分配的链表！

新的链表类型本身就是一个 Node，并且包含一个引用指向另一个 Node:
```rust
pub struct List<'a, T> {
    pub data: T,
    pub prev: Option<&'a List<'a, T>>,
}
```

该链表只有一个操作 `push`，需要注意的是，跟其它链表不同，这里的 `push` 是通过回调的方式来完成新元素推入，并将回调返回的值直接返回给 `push` 的调用者:
```rust
impl<'a, T> List<'a, T> {
    pub fn push<U>(
        prev: Option<&'a List<'a, T>>, 
        data: T, 
        callback: impl FnOnce(&List<'a, T>) -> U,
    ) -> U {
        let list = List { data, prev };
        callback(&list)
    }
}
```

搞定，提前问一句：你见过回调地狱吗？
```rust
List::push(None, 3, |list| {
    println!("{}", list.data);
    List::push(Some(list), 5, |list| {
        println!("{}", list.data);
        List::push(Some(list), 13, |list| {
            println!("{}", list.data);
        })
    })
})
```

不禁让人感叹，这段回调代码多么的美丽动人😿。

用户还可以简单地使用 `while-let` 的方式来编译遍历链表，但是为了增加一些趣味，咱们还是继续使用迭代器:
```rust
impl<'a, T> List<'a, T> {
    pub fn iter(&'a self) -> Iter<'a, T> {
        Iter { next: Some(self) }
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.prev;
            &node.data
        })
    }
}
```

测试下：
```rust
#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn elegance() {
        List::push(None, 3, |list| {
            assert_eq!(list.iter().copied().sum::<i32>(), 3);
            List::push(Some(list), 5, |list| {
                assert_eq!(list.iter().copied().sum::<i32>(), 5 + 3);
                List::push(Some(list), 13, |list| {
                    assert_eq!(list.iter().copied().sum::<i32>(), 13 + 5 + 3);
                })
            })
        })
    }
}
```
```shell
$ cargo test

running 18 tests
test fifth::test::into_iter ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test fifth::test::basics ... ok
test fifth::test::miri_food ... ok
test first::test::basics ... ok
test second::test::into_iter ... ok
test fourth::test::peek ... ok
test fourth::test::into_iter ... ok
test second::test::iter_mut ... ok
test fourth::test::basics ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test third::test::basics ... ok
test silly1::test::walk_aboot ... ok
test silly2::test::elegance ... ok
test second::test::peek ... ok
test third::test::iter ... ok

test result: ok. 18 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out;
```

部分读者此时可能会有一些大胆的想法：咦？我能否修改 Node 中的值？大胆但貌似可行，不妨来试试。
```rust
pub struct List<'a, T> {
    pub data: T,
    pub prev: Option<&'a mut List<'a, T>>,
}

pub struct Iter<'a, T> {
    next: Option<&'a List<'a, T>>,
}

impl<'a, T> List<'a, T> {
    pub fn push<U>(
        prev: Option<&'a mut List<'a, T>>, 
        data: T, 
        callback: impl FnOnce(&mut List<'a, T>) -> U,
    ) -> U {
        let mut list = List { data, prev };
        callback(&mut list)
    }

    pub fn iter(&'a self) -> Iter<'a, T> {
        Iter { next: Some(self) }
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.prev.as_ref().map(|prev| &**prev);
            &node.data
        })
    }
}
```

```shell
$ cargo test

error[E0521]: borrowed data escapes outside of closure
  --> src\silly2.rs:47:32
   |
46 |  List::push(Some(list), 13, |list| {
   |                              ----
   |                              |
   |              `list` declared here, outside of the closure body
   |              `list` is a reference that is only valid in the closure body
47 |      assert_eq!(list.iter().copied().sum::<i32>(), 13 + 5 + 3);
   |                 ^^^^^^^^^^^ `list` escapes the closure body here

error[E0521]: borrowed data escapes outside of closure
  --> src\silly2.rs:45:28
   |
44 |  List::push(Some(list), 5, |list| {
   |                             ----
   |                             |
   |              `list` declared here, outside of the closure body
   |              `list` is a reference that is only valid in the closure body
45 |      assert_eq!(list.iter().copied().sum::<i32>(), 5 + 3);
   |                 ^^^^^^^^^^^ `list` escapes the closure body here


<ad infinitum>
```

嗯，没想到是浓眉大眼的迭代器背叛了我们，为了验证到底是哪里出了问题，我们来修改下测试:
```rust
#[test]
fn elegance() {
    List::push(None, 3, |list| {
        assert_eq!(list.data, 3);
        List::push(Some(list), 5, |list| {
            assert_eq!(list.data, 5);
            List::push(Some(list), 13, |list| {
                assert_eq!(list.data, 13);
            })
        })
    })
}
```

```shell
$ cargo test

error[E0521]: borrowed data escapes outside of closure
  --> src\silly2.rs:46:17
   |
44 |   List::push(Some(list), 5, |list| {
   |                              ----
   |                              |
   |              `list` declared here, outside of the closure body
   |              `list` is a reference that is only valid in the closure body
45 |       assert_eq!(list.data, 5);
46 | /     List::push(Some(list), 13, |list| {
47 | |         assert_eq!(list.data, 13);
48 | |     })
   | |______^ `list` escapes the closure body here

error[E0521]: borrowed data escapes outside of closure
  --> src\silly2.rs:44:13
   |
42 |   List::push(None, 3, |list| {
   |                        ----
   |                        |
   |              `list` declared here, outside of the closure body
   |              `list` is a reference that is only valid in the closure body
43 |       assert_eq!(list.data, 3);
44 | /     List::push(Some(list), 5, |list| {
45 | |         assert_eq!(list.data, 5);
46 | |         List::push(Some(list), 13, |list| {
47 | |             assert_eq!(list.data, 13);
48 | |         })
49 | |     })
   | |______________^ `list` escapes the closure body here
```

原因在于我们的链表不小心依赖了<ruby>型变<rt>variance</rt></ruby>。型变是一个[相当复杂的概念](https://doc.rust-lang.org/nomicon/subtyping.html)，下面来简单了解下。

每一个节点( Node )都包含一个引用，该引用指向另一个节点， 且这两个节点是同一个类型。如果从最里面的节点角度来看，那所有外部的节点都在使用和它一样的生命周期，但这个显然是不对的：链表中的每一个节点都会比它指向的节点活得更久，因为它们的作用域是嵌套存在的。

那之前的不可变引用版本为何可以正常工作呢？原因是在大多数时候，编译器都能自己判断：虽然某些东东活得太久了，但是这是安全的。当我们把一个 List 塞入另一个时，编译器会迅速将生命周期进行收缩以满足新的 List 的需求，**这种生命周期收缩就是一种型变**。

如果大家还是觉得不太理解，我们来考虑下其它拥有继承特性的编程语言。在该语言中，当你将一个 `Cat` 传递给需要 `Animal` 的地方时( `Animal` 是 `Cat` 的父类型)，型变就发生了。从字面来说，将一只猫传给需要动物的地方，也是合适的，毕竟猫确实是动物的一种。

总之，可以看出无论是从大的生命周期收缩为小的生命周期，还是从 `Cat` 到 `Animal`，型变的典型特征就是：范围在减小，毕竟子类型的功能肯定是比父类型多的。

既然有型变，为何可变引用的版本会报错呢？其实在于型变不总是安全的，假如之前的代码可以编译，那我们可以写出<ruby>释放后再使用<rt>use-after-free</rt></ruby> 的代码:
```rust
List::push(None, 3, |list| {
    List::push(Some(list), 5, |list| {
        List::push(Some(list), 13, |list| {
            // 哈哈，好爽，由于所有的生命周期都是相同的，因此编译器允许我重写父节点，并让它持有一个可变指针指向我自己。
            // 我将创建所有的 use-after-free !
            *list.prev.as_mut().unwrap().prev = Some(list);
        })
    })
})
```

一旦引入可变性，型变就会造成这样的隐患：意外修改了不该被修改的代码，但这些代码的调用者还在期待着和往常一样的结果！例如以下例子：
```rust
let mut my_kitty = Cat;                  // Make a Cat (long lifetime)
let animal: &mut Animal = &mut my_kitty; // Forget it's a Cat (shorten lifetime)
*animal = Dog;                           // Write a Dog (short lifetime)
my_kitty.meow();                         // Meowing Dog! (Use After Free)
```

我们将长生命周期的猫转换成短生命周期的动物，可变的！然后通过短生命周期的动物将指针重新指向一只狗。此时我们想去撸软萌猫的时候，就听到：`旺旺...呜嗷嗷嗷`，对，你没听错，不仅没有了猫叫，甚至于狗还没叫完，就可能在某个地方又被修改成狼了。

因此，**虽然你可以修改可变引用的生命周期，但是一旦开始嵌套，它们就将失去型变，变成`不变( invariant )`**。此时，就再也无法对生命周期进行收缩了。

具体来说: `&mut &'big mut T` 无法被转换成 `&mut &'small mut T`，这里 `'big` 代表比 `'small` 更大的生命周期。或者用更正式的说法：`&'a mut T` 对于 `'a` 来说是协变( `covariant` )的，但是对于 `T` 是不变的( `invariant` )。

---

说了这么多高深的理论，那么该如何改变链表的数据呢？答案就是：使用老本行 - 内部可变性。

下面让我们回滚到之前的不可变版本，然后使用 `Cell` 来替代 `&mut`。
```rust
#[test]
fn cell() {
    use std::cell::Cell;

    List::push(None, Cell::new(3), |list| {
        List::push(Some(list), Cell::new(5), |list| {
            List::push(Some(list), Cell::new(13), |list| {
                // Multiply every value in the list by 10
                for val in list.iter() {
                    val.set(val.get() * 10)
                }

                let mut vals = list.iter();
                assert_eq!(vals.next().unwrap().get(), 130);
                assert_eq!(vals.next().unwrap().get(), 50);
                assert_eq!(vals.next().unwrap().get(), 30);
                assert_eq!(vals.next(), None);
                assert_eq!(vals.next(), None);
            })
        })
    })
}
```

```shell
$ cargo test

running 19 tests
test fifth::test::into_iter ... ok
test fifth::test::basics ... ok
test fifth::test::iter_mut ... ok
test fifth::test::iter ... ok
test fourth::test::basics ... ok
test fourth::test::into_iter ... ok
test second::test::into_iter ... ok
test first::test::basics ... ok
test fourth::test::peek ... ok
test second::test::basics ... ok
test fifth::test::miri_food ... ok
test silly2::test::cell ... ok
test third::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test silly1::test::walk_aboot ... ok
test silly2::test::elegance ... ok
test third::test::basics ... ok
test second::test::iter ... ok

test result: ok. 19 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out;
```

简简单单搞定，虽然之前我们嫌弃内部可变性，但是在这里：真香！


================================================
FILE: src/too-many-lists/advanced-lists/unsafe-deque.md
================================================
# 生产级可用的双向链表
打开[原文](https://rust-unofficial.github.io/too-many-lists/sixth.html)，发现这一篇只有两行，我以为自己看花了眼，揉了揉眼，定睛一看，还是两行。

没错，貌似作者想要偷懒，而且为了掩饰，他还提供了标准库的实现:) 如果大家想要学习，看[标准库](https://github.com/rust-lang/rust/blob/master/library/alloc/src/collections/linked_list.rs)吧 :D

> 为了能更好的看懂标准库实现，你可能还需要这本书的辅助: [Rustonomicon](https://doc.rust-lang.org/nightly/nomicon/)


================================================
FILE: src/too-many-lists/bad-stack/basic-operations.md
================================================
# 定义基本操作
这个章节我们一起来为新创建的 `List` 定义一些基本操作，首先从创建链表开始。

## New
为了将实际的代码跟类型关联在一起，我们需要使用 `impl` 语句块：
```rust
impl List {
    // TODO
}
```

下一步就是创建一个关联函数，用于构建 `List` 的新实例，该函数的作用类似于其他语言的构造函数。
```rust
impl List {
    pub fn new() -> Self {
        List { head: Link::Empty }
    }
}
```

> 学习链接: [impl、关联函数](https://course.rs/basic/method.html#关联函数)、[Self](https://course.rs/basic/trait/trait-object.html?highlight=Self#self-与-self) 


## Push
在开始实现之前，你需要先了解 [self、&self、&mut sef](https://course.rs/basic/method.html#selfself-和-mut-self) 这几个概念。

在创建链表后，下一步就是往链表中插入新的元素，由于 `push` 会改变链表，因此我们使用 `&mut self` 的方法签名:
```rust
impl List {
    pub fn push(&mut self, elem: i32) {
        // TODO
    }
}
```

根据之前的数据定义，首先需要创建一个 `Node` 来存放该元素:
```rust
pub fn push(&mut self, elem: i32) {
    let new_node = Node {
        elem: elem,
        next: ?????
    };
}
```

下一步需要让该节点指向之前的旧 `List`:
```rust
pub fn push(&mut self, elem: i32) {
    let new_node = Node {
        elem: elem,
        next: self.head,
    };
}
```

```shell
error[E0507]: cannot move out of `self.head` which is behind a mutable reference
  --> src/first.rs:23:19
   |
23 |             next: self.head,
   |                   ^^^^^^^^^ move occurs because `self.head` has type `Link`, which does not implement the `Copy` trait
```


但是，如上所示，这段代码会报错，因为试图将借用的值 `self` 中的 `head` 字段的所有权转移给 `next` ，在 Rust 中这是不被允许的。那如果我们试图将值再放回去呢？
```rust
pub fn push(&mut self, elem: i32) {
    let new_node = Box::new(Node {
        elem: elem,
        next: self.head,
    });

    self.head = Link::More(new_node);
}
```

其实在写之前，应该就预料到结果了，显然这也是不行的，虽然从我们的角度来看还挺正常的，但是 Rust 并不会接受(有多种原因，其中主要的是[Exception safety](https://doc.rust-lang.org/nightly/nomicon/exception-safety.html))。

我们需要一个办法，让 Rust 不再阻挠我们，其中一个可行的办法是使用 `clone`:
```rust
pub struct List {
    head: Link,
}

#[derive(Clone)]
enum Link {
    Empty,
    More(Box<Node>),
}

#[derive(Clone)]
struct Node {
    elem: i32,
    next: Link,
}

impl List {
    pub fn new() -> Self {
        List { head: Link::Empty }
    }

    pub fn push(&mut self, elem: i32) {
        let new_node = Node {
            elem: elem,
            next: self.head.clone(),
        };
    }
}
```

`clone` 用起来简单，且可解万愁，但是。。。既然是链表，性能那自然是很重要的，特别是要封装成库给其他代码使用时，那性能更是重中之重。

没办法了，我们只能向大名鼎鼎的 Rust 黑客 Indiana Jones求助了:
<img src="https://rust-unofficial.github.io/too-many-lists/img/indy.gif" />

经过一番诚心祈愿，Indy 建议我们使用 `mem::replace` 秘技。这个非常有用的函数允许我们从一个借用中偷出一个值的同时再放入一个新值。
```rust
pub fn push(&mut self, elem: i32) {
    let new_node = Box::new(Node {
        elem: elem,
        next: std::mem::replace(&mut self.head, Link::Empty),
    });

    self.head = Link::More(new_node);
}
```

这里，我们从借用 `self` 中偷出了它的值 `head` 并赋予给 `next` 字段，同时将一个新值 `Link::Empty` 放入到 `head` 中，成功完成偷梁换柱。不得不说，这个做法非常刺激，但是很不幸的是，目前为止，最好的办法可能也只能是它了。

但是不管怎样，我们成功的完成了 `push` 方法，下面再来看看 `pop`。

## Pop
`push` 是插入元素，那 `pop` 自然就是推出一个元素，因此也需要使用 `&mut self`，除此之外，推出的元素需要被返回，这样调用者就可以获取该元素:
```rust
pub fn pop(&mut self) -> Option<i32> {
    // TODO
}
```

我们还需要一个办法来根据 `Link` 是否有值进行不同的处理，这个可以使用 `match` 来进行模式匹配：
```rust
pub fn pop(&mut self) -> Option<i32> {
    match self.head {
        Link::Empty => {
            // TODO
        }
        Link::More(node) => {
            // TODO
        }
    };
}
```

目前的代码显然会报错，因为函数的返回值是 `Option<T>` 枚举，而目前的返回值是 [`()`](https://course.rs/basic/base-type/function.html#无返回值)。当然，我们可以返回一个`Option<T>` 的枚举成员 `None`，但是一个更好的做法是使用 `unimplemented!()`，该宏可以明确地说明目前的代码还没有实现，一旦代码执行到 `unimplemented!()` 的位置，就会发生一个 `panic`。

```rust
pub fn pop(&mut self) -> Option<i32> {
    match self.head {
        Link::Empty => {
            // TODO
        }
        Link::More(node) => {
            // TODO
        }
    };
    unimplemented!()
}
```
`panics` 是一种[发散函数](https://course.rs/basic/base-type/function.html?search=#永不返回的函数)，该函数永不返回任何值，因此可以用于需要返回任何类型的地方。这句话很不好理解，但是从上面的代码中可以看出 `unimplemented!()` 是永不返回的函数，但是它却可以用于一个返回 `Option<i32>` 的函数中来替代返回值。

以上代码果不其然又报错了:
```shell
$ cargo build

error[E0507]: cannot move out of borrowed content
  --> src/first.rs:28:15
   |
28 |         match self.head {
   |               ^^^^^^^^^
   |               |
   |               cannot move out of borrowed content
   |               help: consider borrowing here: `&self.head`
...
32 |             Link::More(node) => {
   |                        ---- data moved here
   |
note: move occurs because `node` has type `std::boxed::Box<first::Node>`, which does not implement the `Copy` trait
```

好在编译器偷偷提示了我们使用借用来替代所有权转移： `&self.head`。修改后，如下：
```rust
pub fn pop(&mut self) -> Option<i32> {
    match &self.head {
        Link::Empty => {
            // TODO
        }
        Link::More(node) => {
            // TODO
        }
    };
    unimplemented!()
}
```

是时候填写相应的逻辑了:
```rust
pub fn pop(&mut self) -> Option<i32> {
    let result;
    match &self.head {
        Link::Empty => {
            result = None;
        }
        Link::More(node) => {
            result = Some(node.elem);
            self.head = node.next;
        }
    };
    result
}
```

当链表为 `Empty` 时，返回一个 `None`，表示我们没有 `pop` 到任何元素；若不为空，则返回第一个元素，并将 `head` 指向下一个节点 `node.next`。但是这段代码又报错了：
```shell
error[E0507]: cannot move out of `node.next` which is behind a shared reference
  --> src/first.rs:37:29
   |
37 |                 self.head = node.next;
   |                             ^^^^^^^^^ move occurs because `node.next` has type `Link`, which does not implement the `Copy` trait
```


原因是试图转移 `node` 的所有权，但只有它的引用。回头仔细看看代码，会发现这里的关键是我们希望移除一些东西，这意味着需要通过值的方式获取链表的 head。看来只能故技重施了：
```rust
pub fn pop(&mut self) -> Option<i32> {
    let result;
    match std::mem::replace(&mut self.head, Link::Empty) {
        Link::Empty => {
            result = None;
        }
        Link::More(node) => {
            result = Some(node.elem);
            self.head = node.next;
        }
    };
    result
}
```

我们将 `self.head` 的值偷出来，然后再将 `Link::Empty` 填回到 `self.head` 中。此时用于 `match` 匹配的就是一个拥有所有权的值类型，而不是之前的引用类型。

事实上，上面的代码有些啰嗦，我们可以直接在 `match` 的两个分支中通过表达式进行返回:
```rust
pub fn pop(&mut self) -> Option<i32> {
    match std::mem::replace(&mut self.head, Link::Empty) {
        Link::Empty => None,
        Link::More(node) => {
            self.head = node.next;
            Some(node.elem)
        }
    }
}
```

这样修改后，代码就更加简洁，可读性也更好了，至此链表的基本操作已经完成，下面让我们写一个测试代码来测试下它的功能和正确性。


================================================
FILE: src/too-many-lists/bad-stack/final-code.md
================================================
# 一些收尾工作以及最终代码
在之前的章节中，我们完成了 Bad 单链表栈的数据定义和基本操作，下面一起来写一些测试代码。


## 单元测试
> 关于如何编写测试，请参见[自动化测试章节](https://course.rs/test/write-tests.html)

首先，单元测试代码要放在待测试的目标代码旁边，也就是同一个文件中:
```rust
// in first.rs
#[cfg(test)]
mod test {
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);
    }
}
```

在 `src/first.rs` 中添加以上测试模块，然后使用 `cargo test` 运行相关的测试用例：
```shell
$ cargo test

error[E0433]: failed to resolve: use of undeclared type or module `List`
  --> src/first.rs:43:24
   |
43 |         let mut list = List::new();
   |                        ^^^^ use of undeclared type or module `List`

```

Ooops! 报错了，从错误内容来看，是因为我们在一个不同的模块 `test` 中，引入了 `first` 模块中的代码，由于前者是后者的子模块，因此可以使用以下方式引入 `first` 模块中的 `List` 定义:
```rust
#[cfg(test)]
mod test {
    use super::List;
    // 其它代码保持不变
}
```

大家可以再次尝试使用 `cargo test` 运行测试用例，具体的结果就不再展开，关于结果的解读，请参看文章开头的链接。

## Drop
现在还有一个问题，我们是否需要手动来清理释放我们的链表？答案是 No，因为 Rust 为我们提供了 `Drop` 特征，若变量实现了该特征，则在它离开作用域时将自动调用解构函数以实现资源清理释放工作，最妙的是，这一切都发生在编译期，因此没有多余的性能开销。

> 关于 Drop 特征的详细介绍，请参见[智能指针 - Drop](https://course.rs/advance/smart-pointer/drop.html)

事实上，我们无需手动为自定义类型实现 `Drop` 特征，原因是 Rust 自动为几乎所有类型都实现了 `Drop`，例如我们自定义的结构体，只要结构体的所有字段都实现了 `Drop`，那结构体也会自动实现 `Drop` !

但是，有的时候这种自动实现可能不够优秀，例如考虑以下链表:
```shell
list -> A -> B -> C
```

当 `List` 被自动 `drop` 后，接着会去尝试 `Drop` A，然后是 `B`，最后是 `C`。这个时候，其中一部分读者可能会紧张起来，因此这其实是一段递归代码，可能会直接撑爆我们的 stack 栈。

例如以下的测试代码会试图创建一个很长的链表，然后会导致栈溢出错误:
```rust
#[test]
fn long_list() {
    let mut list = List::new();
    for i in 0..100000 {
        list.push(i);
    }
    drop(list);
}
```


```shell
thread 'first::test::long_list' has overflowed its stack
```

可能另一部分同学会想 "这显然是[尾递归](https://zh.wikipedia.org/wiki/尾调用)，一个靠谱的编程语言是不会让尾递归撑爆我们的 stack"。然后，这个想法并不正确，下面让我们尝试模拟编译器来看看 `Drop` 会如何实现:
```rust
impl Drop for List {
    fn drop(&mut self) {
        // NOTE: 在 Rust 代码中，我们不能显式的调用 `drop` 方法，只能调用 std::mem::drop 函数
        // 这里只是在模拟编译器!
        self.head.drop(); // 尾递归 - good!
    }
}

impl Drop for Link {
    fn drop(&mut self) {
        match *self {
            Link::Empty => {} // Done!
            Link::More(ref mut boxed_node) => {
                boxed_node.drop(); // 尾递归 - good!
            }
        }
    }
}

impl Drop for Box<Node> {
    fn drop(&mut self) {
        self.ptr.drop(); // 糟糕，这里不是尾递归!
        deallocate(self.ptr); // 不是尾递归的原因是在 `drop` 后，还有额外的操作
    }
}

impl Drop for Node {
    fn drop(&mut self) {
        self.next.drop();
    }
}
```

从上面的代码和注释可以看出为 `Box<Node>` 实现的 `drop` 方法中，在 `self.ptr.drop` 后调用的 `deallocate` 会导致非尾递归的情况发生。

因此我们需要手动为 `List` 实现 `Drop` 特征:
```rust
impl Drop for List {
    fn drop(&mut self) {
        let mut cur_link = mem::replace(&mut self.head, Link::Empty);
        while let Link::More(mut boxed_node) = cur_link {
            cur_link = mem::replace(&mut boxed_node.next, Link::Empty);
            // boxed_node 在这里超出作用域并被 drop,
            // 由于它的 `next` 字段拥有的 `Node` 被设置为 Link::Empty,
            // 因此这里并不会有无边界的递归发生
        }
    }
}
```

测试下上面的实现以及之前的长链表例子:
```shell
$ cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 2 tests
test first::test::basics ... ok
test first::test::long_list ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
```

完美！

<span style="float:left"><img src="https://rust-unofficial.github.io/too-many-lists/img/profbee.gif" /></span>

#### 为什么要提前优化？

事实上，我们在这里做了提前优化，否则可以使用 `while let Some(_) = self.pop() { }`, 这种实现显然更加简单. 那么问题来了：它们的区别是什么，有哪些性能上的好处？特别是在链表不仅仅支持 `i32` 时。

<details>
  <summary>点击这里展开答案</summary>

`self.pop()` 的会返回 `Option<i32>`, 而我们之前的实现仅仅对智能指针 `Box<Node>` 进行操作。前者会对值进行拷贝，而后者仅仅使用的是指针类型。

当链表中包含的值是其他较大的类型时，那这个拷贝的开销将变得非常高昂。
</details>

## 最终代码
```rust
use std::mem;

pub struct List {
    head: Link,
}

enum Link {
    Empty,
    More(Box<Node>),
}

struct Node {
    elem: i32,
    next: Link,
}

impl List {
    pub fn new() -> Self {
        List { head: Link::Empty }
    }

    pub fn push(&mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: mem::replace(&mut self.head, Link::Empty),
        });

        self.head = Link::More(new_node);
    }

    pub fn pop(&mut self) -> Option<i32> {
        match mem::replace(&mut self.head, Link::Empty) {
            Link::Empty => None,
            Link::More(node) => {
                self.head = node.next;
                Some(node.elem)
            }
        }
    }
}

impl Drop for List {
    fn drop(&mut self) {
        let mut cur_link = mem::replace(&mut self.head, Link::Empty);

        while let Link::More(mut boxed_node) = cur_link {
            cur_link = mem::replace(&mut boxed_node.next, Link::Empty);
        }
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);
    }
}
```

从代码行数也可以看出，我们实现的肯定不是一个精致的链表：总共只有 80 行代码，其中一半还是测试！

但是万事开头难，既然开了一个好头，那接下来我们一鼓作气，继续看看更精致的链表长什么样。



================================================
FILE: src/too-many-lists/bad-stack/intro.md
================================================
# 糟糕的单向链表栈
本章，让我们用一个不咋样的单向链表来实现一个栈数据结构，因为不咋样，实现起来倒是很简单。

首先，创建一个文件 `src/first.rs` 用于存放本章节的链表代码，虽然糟糕，也不能用完就扔，大家说是不 :P 然后在 `lib.rs` 中添加这一行代码：

```rust
// in lib.rs
pub mod first;
```



================================================
FILE: src/too-many-lists/bad-stack/layout.md
================================================
[Binary file]


================================================
FILE: src/too-many-lists/deque/final-code.md
================================================
# 最终代码
这一章真不好写( 也很难翻译... )，最终我们实现了一个 100% 安全但是功能残缺的双向链表。

同时在实现中，还有大量 `Rc` 和 `RefCell` 引起的运行时检查，最终会影响链表的性能。整个双向链表实现史就是一部别名和所有权的奋斗史。

总之，不管爱与不爱，它就这样了，特别是如果我们不在意内部的细节暴露给外面用户时。

而从下一章开始，我们将实现一个真正能够全盘掌控的链表，当然...通过 unsafe 代码实现！


```rust

#![allow(unused)]
fn main() {
use std::rc::Rc;
use std::cell::{Ref, RefMut, RefCell};

pub struct List<T> {
    head: Link<T>,
    tail: Link<T>,
}

type Link<T> = Option<Rc<RefCell<Node<T>>>>;

struct Node<T> {
    elem: T,
    next: Link<T>,
    prev: Link<T>,
}


impl<T> Node<T> {
    fn new(elem: T) -> Rc<RefCell<Self>> {
        Rc::new(RefCell::new(Node {
            elem: elem,
            prev: None,
            next: None,
        }))
    }
}

impl<T> List<T> {
    pub fn new() -> Self {
        List { head: None, tail: None }
    }

    pub fn push_front(&mut self, elem: T) {
        let new_head = Node::new(elem);
        match self.head.take() {
            Some(old_head) => {
                old_head.borrow_mut().prev = Some(new_head.clone());
                new_head.borrow_mut().next = Some(old_head);
                self.head = Some(new_head);
            }
            None => {
                self.tail = Some(new_head.clone());
                self.head = Some(new_head);
            }
        }
    }

    pub fn push_back(&mut self, elem: T) {
        let new_tail = Node::new(elem);
        match self.tail.take() {
            Some(old_tail) => {
                old_tail.borrow_mut().next = Some(new_tail.clone());
                new_tail.borrow_mut().prev = Some(old_tail);
                self.tail = Some(new_tail);
            }
            None => {
                self.head = Some(new_tail.clone());
                self.tail = Some(new_tail);
            }
        }
    }

    pub fn pop_back(&mut self) -> Option<T> {
        self.tail.take().map(|old_tail| {
            match old_tail.borrow_mut().prev.take() {
                Some(new_tail) => {
                    new_tail.borrow_mut().next.take();
                    self.tail = Some(new_tail);
                }
                None => {
                    self.head.take();
                }
            }
            Rc::try_unwrap(old_tail).ok().unwrap().into_inner().elem
        })
    }

    pub fn pop_front(&mut self) -> Option<T> {
        self.head.take().map(|old_head| {
            match old_head.borrow_mut().next.take() {
                Some(new_head) => {
                    new_head.borrow_mut().prev.take();
                    self.head = Some(new_head);
                }
                None => {
                    self.tail.take();
                }
            }
            Rc::try_unwrap(old_head).ok().unwrap().into_inner().elem
        })
    }

    pub fn peek_front(&self) -> Option<Ref<T>> {
        self.head.as_ref().map(|node| {
            Ref::map(node.borrow(), |node| &node.elem)
        })
    }

    pub fn peek_back(&self) -> Option<Ref<T>> {
        self.tail.as_ref().map(|node| {
            Ref::map(node.borrow(), |node| &node.elem)
        })
    }

    pub fn peek_back_mut(&mut self) -> Option<RefMut<T>> {
        self.tail.as_ref().map(|node| {
            RefMut::map(node.borrow_mut(), |node| &mut node.elem)
        })
    }

    pub fn peek_front_mut(&mut self) -> Option<RefMut<T>> {
        self.head.as_ref().map(|node| {
            RefMut::map(node.borrow_mut(), |node| &mut node.elem)
        })
    }

    pub fn into_iter(self) -> IntoIter<T> {
        IntoIter(self)
    }
}

impl<T> Drop for List<T> {
    fn drop(&mut self) {
        while self.pop_front().is_some() {}
    }
}

pub struct IntoIter<T>(List<T>);

impl<T> Iterator for IntoIter<T> {
    type Item = T;

    fn next(&mut self) -> Option<T> {
        self.0.pop_front()
    }
}

impl<T> DoubleEndedIterator for IntoIter<T> {
    fn next_back(&mut self) -> Option<T> {
        self.0.pop_back()
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop_front(), None);

        // Populate list
        list.push_front(1);
        list.push_front(2);
        list.push_front(3);

        // Check normal removal
        assert_eq!(list.pop_front(), Some(3));
        assert_eq!(list.pop_front(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push_front(4);
        list.push_front(5);

        // Check normal removal
        assert_eq!(list.pop_front(), Some(5));
        assert_eq!(list.pop_front(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop_front(), Some(1));
        assert_eq!(list.pop_front(), None);

        // ---- back -----

        // Check empty list behaves right
        assert_eq!(list.pop_back(), None);

        // Populate list
        list.push_back(1);
        list.push_back(2);
        list.push_back(3);

        // Check normal removal
        assert_eq!(list.pop_back(), Some(3));
        assert_eq!(list.pop_back(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push_back(4);
        list.push_back(5);

        // Check normal removal
        assert_eq!(list.pop_back(), Some(5));
        assert_eq!(list.pop_back(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop_back(), Some(1));
        assert_eq!(list.pop_back(), None);
    }

    #[test]
    fn peek() {
        let mut list = List::new();
        assert!(list.peek_front().is_none());
        assert!(list.peek_back().is_none());
        assert!(list.peek_front_mut().is_none());
        assert!(list.peek_back_mut().is_none());

        list.push_front(1); list.push_front(2); list.push_front(3);

        assert_eq!(&*list.peek_front().unwrap(), &3);
        assert_eq!(&mut *list.peek_front_mut().unwrap(), &mut 3);
        assert_eq!(&*list.peek_back().unwrap(), &1);
        assert_eq!(&mut *list.peek_back_mut().unwrap(), &mut 1);
    }

    #[test]
    fn into_iter() {
        let mut list = List::new();
        list.push_front(1); list.push_front(2); list.push_front(3);

        let mut iter = list.into_iter();
        assert_eq!(iter.next(), Some(3));
        assert_eq!(iter.next_back(), Some(1));
        assert_eq!(iter.next(), Some(2));
        assert_eq!(iter.next_back(), None);
        assert_eq!(iter.next(), None);
    }
}
}
```


================================================
FILE: src/too-many-lists/deque/intro.md
================================================
# 不太优秀的双端队列
在实现了之前的队列后，我们不禁浮想联翩，如果 `Rc` 是可变的，那是不是可以实现一个双向链表？

心动不如行动，先来创建新的链表文件 `fourth.rs`，并在 `src/lib.rs` 中添加以下内容：
```rust
// in lib.rs

pub mod first;
pub mod second;
pub mod third;
pub mod fourth;
```

依然是熟悉的从零开始，当然，也依然会用到熟悉的 CV 配方。

> 声明：大家看到目录名时，心里就应该在嘀咕了吧？其实你的嘀咕是对的，是的，本章的目的是为了证明之前的想法是糟糕的！


================================================
FILE: src/too-many-lists/deque/iterator.md
================================================
# 迭代器
坏男孩最令人头疼，而链表实现中，迭代器就是这样的坏男孩，所以我们放在最后来处理。

## IntoIter
由于是转移所有权，因此 `IntoIter` 一直都是最好实现的:
```rust
pub struct IntoIter<T>(List<T>);

impl<T> List<T> {
    pub fn into_iter(self) -> IntoIter<T> {
        IntoIter(self)
    }
}

impl<T> Iterator for IntoIter<T> {
    type Item = T;
    fn next(&mut self) -> Option<T> {
        self.0.pop_front()
    }
}
```

但是关于双向链表，有一个有趣的事实，它不仅可以从前向后迭代，还能反过来。前面实现的是传统的从前到后，那问题来了，反过来该如何实现呢？

答案是: `DoubleEndedIterator`，它继承自 `Iterator`( 通过 [`supertrait`](https://course.rs/basic/trait/advance-trait.html?highlight=supertrait#特征定义中的特征约束) )，因此意味着要实现该特征，首先需要实现 `Iterator`。

这样只要为 `DoubleEndedIterator` 实现 `next_back` 方法，就可以支持双向迭代了: `Iterator` 的 `next` 方法从前往后，而 `next_back` 从后向前。

```rust
impl<T> DoubleEndedIterator for IntoIter<T> {
    fn next_back(&mut self) -> Option<T> {
        self.0.pop_back()
    }
}
```

测试下:
```rust
#[test]
fn into_iter() {
    let mut list = List::new();
    list.push_front(1); list.push_front(2); list.push_front(3);

    let mut iter = list.into_iter();
    assert_eq!(iter.next(), Some(3));
    assert_eq!(iter.next_back(), Some(1));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next_back(), None);
    assert_eq!(iter.next(), None);
}
```

```shell
$ cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 11 tests
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test fourth::test::into_iter ... ok
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test third::test::iter ... ok
test third::test::basics ... ok
test second::test::into_iter ... ok
test second::test::peek ... ok

test result: ok. 11 passed; 0 failed; 0 ignored; 0 measured
```

## Iter
这里又要用到糟糕的 `Ref`:
```rust
pub struct Iter<'a, T>(Option<Ref<'a, Node<T>>>);

impl<T> List<T> {
    pub fn iter(&self) -> Iter<T> {
        Iter(self.head.as_ref().map(|head| head.borrow()))
    }
}
```

```shell
$ cargo build
```

迄今为止一切运行正常，接下来的 `next` 实现起来会有些麻烦:
```rust
impl<'a, T> Iterator for Iter<'a, T> {
    type Item = Ref<'a, T>;
    fn next(&mut self) -> Option<Self::Item> {
        self.0.take().map(|node_ref| {
            self.0 = node_ref.next.as_ref().map(|head| head.borrow());
            Ref::map(node_ref, |node| &node.elem)
        })
    }
}
```

```shell
$ cargo build

error[E0521]: borrowed data escapes outside of closure
   --> src/fourth.rs:155:13
    |
153 |     fn next(&mut self) -> Option<Self::Item> {
    |             --------- `self` is declared here, outside of the closure body
154 |         self.0.take().map(|node_ref| {
155 |             self.0 = node_ref.next.as_ref().map(|head| head.borrow());
    |             ^^^^^^   -------- borrow is only valid in the closure body
    |             |
    |             reference to `node_ref` escapes the closure body here

error[E0505]: cannot move out of `node_ref` because it is borrowed
   --> src/fourth.rs:156:22
    |
153 |     fn next(&mut self) -> Option<Self::Item> {
    |             --------- lifetime `'1` appears in the type of `self`
154 |         self.0.take().map(|node_ref| {
155 |             self.0 = node_ref.next.as_ref().map(|head| head.borrow());
    |             ------   -------- borrow of `node_ref` occurs here
    |             |
    |             assignment requires that `node_ref` is borrowed for `'1`
156 |             Ref::map(node_ref, |node| &node.elem)
    |                      ^^^^^^^^ move out of `node_ref` occurs here
```

果然，膝盖又中了一箭。

`node_ref` 活得不够久，跟一般的引用不同，Rust 不允许我们这样分割 `Ref`，从 `head.borrow()` 中取出的 `Ref` 只允许跟 `node_ref` 活得一样久。


而我们想要的函数是存在的:
```rust
pub fn map_split<U, V, F>(orig: Ref<'b, T>, f: F) -> (Ref<'b, U>, Ref<'b, V>) where
    F: FnOnce(&T) -> (&U, &V),
    U: ?Sized,
    V: ?Sized,
```

喔，这个函数定义的泛型直接晃瞎了我的眼睛。。
```rust
fn next(&mut self) -> Option<Self::Item> {
    self.0.take().map(|node_ref| {
        let (next, elem) = Ref::map_split(node_ref, |node| {
            (&node.next, &node.elem)
        });

        self.0 = next.as_ref().map(|head| head.borrow());

        elem
    })
}
```

```shell
$ cargo build

   Compiling lists v0.1.0 (/Users/ABeingessner/dev/temp/lists)
error[E0521]: borrowed data escapes outside of closure
   --> src/fourth.rs:159:13
    |
153 |     fn next(&mut self) -> Option<Self::Item> {
    |             --------- `self` is declared here, outside of the closure body
...
159 |             self.0 = next.as_ref().map(|head| head.borrow());
    |             ^^^^^^   ---- borrow is only valid in the closure body
    |             |
    |             reference to `next` escapes the closure body here
```

额，借用的内容只允许在闭包体中使用，看起来我们还是得用 `Ref::map` 来解决问题:
```rust
fn next(&mut self) -> Option<Self::Item> {
    self.0.take().map(|node_ref| {
        let (next, elem) = Ref::map_split(node_ref, |node| {
            (&node.next, &node.elem)
        });

        self.0 = if next.is_some() {
            Some(Ref::map(next, |next| &**next.as_ref().unwrap()))
        } else {
            None
        };

        elem
    })
}
```

```shell
error[E0308]: mismatched types
   --> src/fourth.rs:162:22
    |
162 |                 Some(Ref::map(next, |next| &**next.as_ref().unwrap()))
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `fourth::Node`, found struct `std::cell::RefCell`
    |
    = note: expected type `std::cell::Ref<'_, fourth::Node<_>>`
               found type `std::cell::Ref<'_, std::cell::RefCell<fourth::Node<_>>>`
```

晕, 多了一个 `RefCell` ，随着我们的对链表的逐步深入，`RefCell` 的代码嵌套变成了不可忽视的问题。

看起来我们已经无能为力了，只能试着去摆脱 `RefCell` 了。`Rc` 怎么样？我们完全可以对 `Rc` 进行完整的克隆:
```rust
pub struct Iter<T>(Option<Rc<Node<T>>>);

impl<T> List<T> {
    pub fn iter(&self) -> Iter<T> {
        Iter(self.head.as_ref().map(|head| head.clone()))
    }
}

impl<T> Iterator for Iter<T> {
    type Item =
```

等等，那现在返回的是什么？`&T` 还是 `Ref<T>` ?

两者都不是，现在我们的 `Iter` 已经没有生命周期了：无论是 `&T` 还是 `Ref<T>` 都需要我们在 `next` 之前声明好生命周期。但是我们试图从 `Rc` 中取出来的值其实是迭代器的引用。

也可以通过对 `Rc` 进行 map 获取到 `Rc<T>`？但是标准库并没有给我们提供相应的功能，第三方倒是有[一个](https://crates.io/crates/owning_ref)。

但是，即使这么做了，还有一个更大的坑在等着：一个会造成迭代器不合法的可怕幽灵。事实上，之前我们对于迭代器不合法是免疫的，但是一旦迭代器产生 `Rc`，那它们就不再会借用链表。这意味着人们可以在持有指向链表内部的指针时，还可以进行 `push` 和 `pop` 操作。

严格来说，`push` 问题不大，因为链表两端的增长不会对我们正在关注的某个子链表造成影响。

但是 `pop` 就是另一个故事了，如果在我们关注的子链表之外 `pop`, 那问题不大。但是如果是 `pop` 一个正在引用的子链表中的节点呢？那一切就完了，特别是，如果大家还试图去 unwrap `try_unwrap` 返回的 `Result` ，会直接造成整个程序的 `panic`。

仔细想一想，好像也不错，程序一切正常，除非去 `pop` 我们正在引用的节点，最美的是，就算遇到这种情况，程序也会直接崩溃，提示我们错误的发生。

其实我们大部分的努力都是为了实现隐藏的细节和优雅的 API，典型的二八原则，八成时间花在二成的细节上。但是如果不关心这些细节，可以接受自己的平凡的话，那把节点简单的到处传递就行。

总之，可以看出，内部可变性非常适合写一个安全性的应用程序，但是如果是安全性高的库，那内部可变性就有些捉襟见肘了。

最终，我选择了放弃，不再实现 `Iter` 和 `IterMut`，也许努力下，可以实现，但是。。。不愉快，算了。


================================================
FILE: src/too-many-lists/deque/layout.md
================================================
[Binary file]


================================================
FILE: src/too-many-lists/deque/peek.md
================================================
# Peek
`push` 和 `pop` 的防不胜防的编译报错着实让人出了些冷汗，下面来看看轻松的，至少在之前的链表中是很轻松的 :)

```rust
pub fn peek_front(&self) -> Option<&T> {
    self.head.as_ref().map(|node| {
        &node.elem
    })
}
```

额...好像被人发现我是复制黏贴的了，赶紧换一个:
```rust
pub fn peek_front(&self) -> Option<&T> {
    self.head.as_ref().map(|node| {
        // BORROW!!!!
        &node.borrow().elem
    })
}
```

```shell
$ cargo build

error[E0515]: cannot return value referencing temporary value
  --> src/fourth.rs:66:13
   |
66 |             &node.borrow().elem
   |             ^   ----------^^^^^
   |             |   |
   |             |   temporary value created here
   |             |
   |             returns a value referencing data owned by the current function
```

从报错可以看出，原因是我们引用了局部的变量并试图在函数中返回。为了解释这个问题，先来看看 `borrow` 的定义:
```rust
fn borrow<'a>(&'a self) -> Ref<'a, T>
fn borrow_mut<'a>(&'a self) -> RefMut<'a, T>
```

这里返回的并不是 `&T` 或 `&mut T`，而是一个 [`Ref`](https://doc.rust-lang.org/std/cell/struct.Ref.html) 和 [`RefMut`](https://doc.rust-lang.org/std/cell/struct.RefMut.html)，那么它们是什么？说白了，它们就是在借用到的引用外包裹了一层。而且 `Ref` 和 `RefMut` 分别实现了 `Deref` 和 `DerefMut`，在绝大多数场景中，我们都可以像使用 `&T` 一样去使用它们。


只能说是成是败都赖萧何，恰恰就因为这一层包裹，导致生命周期改变了，也就是 `Ref` 和内部引用的生命周期不再和 `RefCell` 相同，而 `Ref` 的生命周期是什么，相信大家都能看得出来，因此就造成了局部引用的问题。

事实上，这是必须的，如果内部的引用和外部的 `Ref` 生命周期不一致，那该如何管理？当 `Ref` 因超出作用域被 `drop` 时，内部的引用怎么办？

现在该怎么办？我们只想要一个引用，现在却多了一个 `Ref` 拦路虎。等等，如果我们不返回 `&T` 而是返回 `Ref` 呢？
```rust
use std::cell::{Ref, RefCell};

pub fn peek_front(&self) -> Option<Ref<T>> {
    self.head.as_ref().map(|node| {
        node.borrow()
    })
}
```

```shell
$ cargo build

error[E0308]: mismatched types
  --> src/fourth.rs:64:9
   |
64 | /         self.head.as_ref().map(|node| {
65 | |             node.borrow()
66 | |         })
   | |__________^ expected type parameter, found struct `fourth::Node`
   |
   = note: expected type `std::option::Option<std::cell::Ref<'_, T>>`
              found type `std::option::Option<std::cell::Ref<'_, fourth::Node<T>>>`
```

嗯，类型不匹配了，要返回的是 `Ref<T>` 但是获取的却是 `Ref<Node<T>>`，那么现在看上去有两个选择：

- 抛弃这条路，换一条重新开始
- 一条路走到死，最终通过更复杂的实现来解决

但是，仔细想想，这两个选择都不是我们想要的，那没办法了，只能继续深挖，看看有没有其它解决办法。啊哦，还真发现了一只野兽：
```rust
map<U, F>(orig: Ref<'b, T>, f: F) -> Ref<'b, U>
    where F: FnOnce(&T) -> &U,
          U: ?Sized
```

就像在 `Result` 和 `Option` 上使用 `map` 一样，我们还能在 `Ref` 上使用 `map`:
```rust
pub fn peek_front(&self) -> Option<Ref<T>> {
    self.head.as_ref().map(|node| {
        Ref::map(node.borrow(), |node| &node.elem)
    })
}
```

```shell
$ cargo build
```

Gooood! 本章节的编译错误可以说是多个链表中最难解决的之一，依然被我们成功搞定了！


下面来写下测试用例，需要注意的是 `Ref` 不能被直接比较，因此我们需要先利用 `Deref` 解引用出其中的值，再进行比较。

```rust
#[test]
fn peek() {
    let mut list = List::new();
    assert!(list.peek_front().is_none());
    list.push_front(1); list.push_front(2); list.push_front(3);

    assert_eq!(&*list.peek_front().unwrap(), &3);
}
```

```shell
$ cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 10 tests
test first::test::basics ... ok
test fourth::test::basics ... ok
test second::test::basics ... ok
test fourth::test::peek ... ok
test second::test::iter_mut ... ok
test second::test::into_iter ... ok
test third::test::basics ... ok
test second::test::peek ... ok
test second::test::iter ... ok
test third::test::iter ... ok

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured
```

终于可以把文章开头的冷汗擦拭干净了，忘掉这个章节吧，让我来养你...哦不对，让我们开始一段真正轻松的章节。


================================================
FILE: src/too-many-lists/deque/symmetric.md
================================================
# 基本操作的对称镜像
之前我们仅实现了头部的 `push`、`pop` ，现在来补全一下，大自然的对称之美咱的双向链表也不能少了。

```rust
tail <-> head
next <-> prev
front -> back
```

需要注意的是，这里还新增了 `mut` 类型的 peek:
```rust
use std::cell::{Ref, RefCell, RefMut};

//..

pub fn push_back(&mut self, elem: T) {
    let new_tail = Node::new(elem);
    match self.tail.take() {
        Some(old_tail) => {
            old_tail.borrow_mut().next = Some(new_tail.clone());
            new_tail.borrow_mut().prev = Some(old_tail);
            self.tail = Some(new_tail);
        }
        None => {
            self.head = Some(new_tail.clone());
            self.tail = Some(new_tail);
        }
    }
}

pub fn pop_back(&mut self) -> Option<T> {
    self.tail.take().map(|old_tail| {
        match old_tail.borrow_mut().prev.take() {
            Some(new_tail) => {
                new_tail.borrow_mut().next.take();
                self.tail = Some(new_tail);
            }
            None => {
                self.head.take();
            }
        }
        Rc::try_unwrap(old_tail).ok().unwrap().into_inner().elem
    })
}

pub fn peek_back(&self) -> Option<Ref<T>> {
    self.tail.as_ref().map(|node| {
        Ref::map(node.borrow(), |node| &node.elem)
    })
}

pub fn peek_back_mut(&mut self) -> Option<RefMut<T>> {
    self.tail.as_ref().map(|node| {
        RefMut::map(node.borrow_mut(), |node| &mut node.elem)
    })
}

pub fn peek_front_mut(&mut self) -> Option<RefMut<T>> {
    self.head.as_ref().map(|node| {
        RefMut::map(node.borrow_mut(), |node| &mut node.elem)
    })
}
```

再更新测试用例:
```rust
#[test]
fn basics() {
    let mut list = List::new();

    // Check empty list behaves right
    assert_eq!(list.pop_front(), None);

    // Populate list
    list.push_front(1);
    list.push_front(2);
    list.push_front(3);

    // Check normal removal
    assert_eq!(list.pop_front(), Some(3));
    assert_eq!(list.pop_front(), Some(2));

    // Push some more just to make sure nothing's corrupted
    list.push_front(4);
    list.push_front(5);

    // Check normal removal
    assert_eq!(list.pop_front(), Some(5));
    assert_eq!(list.pop_front(), Some(4));

    // Check exhaustion
    assert_eq!(list.pop_front(), Some(1));
    assert_eq!(list.pop_front(), None);

    // ---- back -----

    // Check empty list behaves right
    assert_eq!(list.pop_back(), None);

    // Populate list
    list.push_back(1);
    list.push_back(2);
    list.push_back(3);

    // Check normal removal
    assert_eq!(list.pop_back(), Some(3));
    assert_eq!(list.pop_back(), Some(2));

    // Push some more just to make sure nothing's corrupted
    list.push_back(4);
    list.push_back(5);

    // Check normal removal
    assert_eq!(list.pop_back(), Some(5));
    assert_eq!(list.pop_back(), Some(4));

    // Check exhaustion
    assert_eq!(list.pop_back(), Some(1));
    assert_eq!(list.pop_back(), None);
}

#[test]
fn peek() {
    let mut list = List::new();
    assert!(list.peek_front().is_none());
    assert!(list.peek_back().is_none());
    assert!(list.peek_front_mut().is_none());
    assert!(list.peek_back_mut().is_none());

    list.push_front(1); list.push_front(2); list.push_front(3);

    assert_eq!(&*list.peek_front().unwrap(), &3);
    assert_eq!(&mut *list.peek_front_mut().unwrap(), &mut 3);
    assert_eq!(&*list.peek_back().unwrap(), &1);
    assert_eq!(&mut *list.peek_back_mut().unwrap(), &mut 1);
}
```

什么？你问我这里的测试用例全吗？只能说如果测试全部的组合情况，这一章节会被撑爆。至于现在，能不出错就谢天谢地了 :(

```shell
$ cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 10 tests
test first::test::basics ... ok
test fourth::test::basics ... ok
test second::test::basics ... ok
test fourth::test::peek ... ok
test second::test::iter ... ok
test third::test::iter ... ok
test second::test::into_iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured
```

我想说：Ctrl CV 是最好的编程工具，大家同意吗？


================================================
FILE: src/too-many-lists/ok-stack/intro.md
================================================
# 还可以的单向链表
在之前我们写了一个最小可用的单向链表，下面一起来完善下，首先创建一个新的文件 `src/second.rs`，然后在 `lib.rs` 中引入：
```rust
// in lib.rs

pub mod first;
pub mod second;
```

并将 `first.rs` 中的所有内容拷贝到 `second.rs` 中。


================================================
FILE: src/too-many-lists/ok-stack/iter.md
================================================
[Binary file]


================================================
FILE: src/too-many-lists/ok-stack/itermut.md
================================================
# IterMut以及完整代码
上一章节中我们讲到了要为 `List` 实现三种类型的迭代器并实现了其中两种: `IntoIter` 和 `Iter`。下面再来看看最后一种 `IterMut`。

再来回顾下 `Iter` 的实现：
```rust
impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> { /* stuff */ }
}
```

这段代码可以进行下脱糖( desugar ):
```rust
impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next<'b>(&'b mut self) -> Option<&'a T> { /* stuff */ }
}
```

可以看出 `next` 方法的输入和输出之间的生命周期并没有关联，这样我们就可以无条件的一遍又一遍地调用 `next`:
```rust
let mut list = List::new();
list.push(1); list.push(2); list.push(3);

let mut iter = list.iter();
let x = iter.next().unwrap();
let y = iter.next().unwrap();
let z = iter.next().unwrap();
```

对于不可变借用而言，这种方式没有任何问题，因为不可变借用可以同时存在多个，但是如果是可变引用呢？因此，大家可能会以为使用安全代码来写 `IterMut` 是一件相当困难的事。但是令人诧异的是，事实上，我们可以使用安全的代码来为很多数据结构实现 `IterMut`。

先将之前的代码修改成可变的：
```rust
pub struct IterMut<'a, T> {
    next: Option<&'a mut Node<T>>,
}

impl<T> List<T> {
    pub fn iter_mut(&self) -> IterMut<'_, T> {
        IterMut { next: self.head.as_deref_mut() }
    }
}

impl<'a, T> Iterator for IterMut<'a, T> {
    type Item = &'a mut T;

    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.next.as_deref_mut();
            &mut node.elem
        })
    }
}
```

```shell
$ cargo build

error[E0596]: cannot borrow `self.head` as mutable, as it is behind a `&` reference
  --> src/second.rs:95:25
   |
94 |     pub fn iter_mut(&self) -> IterMut<'_, T> {
   |                     ----- help: consider changing this to be a mutable reference: `&mut self`
95 |         IterMut { next: self.head.as_deref_mut() }
   |                         ^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable

error[E0507]: cannot move out of borrowed content
   --> src/second.rs:103:9
    |
103 |         self.next.map(|node| {
    |         ^^^^^^^^^ cannot move out of borrowed content
```

果不其然，两个错误发生了。第一错误看上去很清晰，甚至告诉了我们该如何解决:
```rust
pub fn iter_mut(&mut self) -> IterMut<'_, T> {
    IterMut { next: self.head.as_deref_mut() }
}
```

但是另一个好像就没那么容易了。但是之前的代码就可以工作啊，为何这里就不行了？

原因在于有些类型可以 [Copy](https://course.rs/basic/ownership/ownership.html#拷贝浅拷贝)，有些不行。而`Option` 和不可变引用 `&T` 恰恰是可以 Copy 的，但尴尬的是，可变引用 `&mut T` 不可以，因此这里报错了。

因此我们需要使用 `take` 方法来处理这种情况：
```rust
fn next(&mut self) -> Option<Self::Item> {
    self.next.take().map(|node| {
        self.next = node.next.as_deref_mut();
        &mut node.elem
    })
}
```

```shell
$ cargo build
```

老规矩，来测试下:
```rust
#[test]
fn iter_mut() {
    let mut list = List::new();
    list.push(1); list.push(2); list.push(3);

    let mut iter = list.iter_mut();
    assert_eq!(iter.next(), Some(&mut 3));
    assert_eq!(iter.next(), Some(&mut 2));
    assert_eq!(iter.next(), Some(&mut 1));
}
```

```shell
$ cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 6 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::iter_mut ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::peek ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured
```

最终，我们完成了迭代器的功能，下面是完整的代码。

## 完整代码

```rust
pub struct List<T> {
    head: Link<T>,
}

type Link<T> = Option<Box<Node<T>>>;

struct Node<T> {
    elem: T,
    next: Link<T>,
}

impl<T> List<T> {
    pub fn new() -> Self {
        List { head: None }
    }

    pub fn push(&mut self, elem: T) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&mut self) -> Option<T> {
        self.head.take().map(|node| {
            self.head = node.next;
            node.elem
        })
    }

    pub fn peek(&self) -> Option<&T> {
        self.head.as_ref().map(|node| {
            &node.elem
        })
    }

    pub fn peek_mut(&mut self) -> Option<&mut T> {
        self.head.as_mut().map(|node| {
            &mut node.elem
        })
    }

    pub fn into_iter(self) -> IntoIter<T> {
        IntoIter(self)
    }

    pub fn iter(&self) -> Iter<'_, T> {
        Iter { next: self.head.as_deref() }
    }

    pub fn iter_mut(&mut self) -> IterMut<'_, T> {
        IterMut { next: self.head.as_deref_mut() }
    }
}

impl<T> Drop for List<T> {
    fn drop(&mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}

pub struct IntoIter<T>(List<T>);

impl<T> Iterator for IntoIter<T> {
    type Item = T;
    fn next(&mut self) -> Option<Self::Item> {
        // access fields of a tuple struct numerically
        self.0.pop()
    }
}

pub struct Iter<'a, T> {
    next: Option<&'a Node<T>>,
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;
    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.next.as_deref();
            &node.elem
        })
    }
}

pub struct IterMut<'a, T> {
    next: Option<&'a mut Node<T>>,
}

impl<'a, T> Iterator for IterMut<'a, T> {
    type Item = &'a mut T;

    fn next(&mut self) -> Option<Self::Item> {
        self.next.take().map(|node| {
            self.next = node.next.as_deref_mut();
            &mut node.elem
        })
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);
    }

    #[test]
    fn peek() {
        let mut list = List::new();
        assert_eq!(list.peek(), None);
        assert_eq!(list.peek_mut(), None);
        list.push(1); list.push(2); list.push(3);

        assert_eq!(list.peek(), Some(&3));
        assert_eq!(list.peek_mut(), Some(&mut 3));

        list.peek_mut().map(|value| {
            *value = 42
        });

        assert_eq!(list.peek(), Some(&42));
        assert_eq!(list.pop(), Some(42));
    }

    #[test]
    fn into_iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.into_iter();
        assert_eq!(iter.next(), Some(3));
        assert_eq!(iter.next(), Some(2));
        assert_eq!(iter.next(), Some(1));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&3));
        assert_eq!(iter.next(), Some(&2));
        assert_eq!(iter.next(), Some(&1));
    }

    #[test]
    fn iter_mut() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter_mut();
        assert_eq!(iter.next(), Some(&mut 3));
        assert_eq!(iter.next(), Some(&mut 2));
        assert_eq!(iter.next(), Some(&mut 1));
    }
}
```


================================================
FILE: src/too-many-lists/ok-stack/peek.md
================================================
[Binary file]


================================================
FILE: src/too-many-lists/ok-stack/type-optimizing.md
================================================
# 优化类型定义
首先，我们需要优化下类型的定义，可能一部分同学已经觉得之前的类型定义相当不错了，但是如果大家仔细观察下 `Link`:
```rust
enum Link {
    Empty,
    More(Box<Node>),
}
```

会发现，它其实跟 `Option<Box<Node>>` 非常类似。

## Option
但是为了代码可读性，我们不能直接使用这个冗长的类型，否则代码中将充斥着 `Option<Box<Node>>` 这种令人难堪的类型，为此可以使用类型别名。首先，将之前的代码使用新的 `Link` 进行修改：
```rust
use std::mem;

pub struct List {
    head: Link,
}

// 类型别名，type alias
type Link = Option<Box<Node>>;

struct Node {
    elem: i32,
    next: Link,
}

impl List {
    pub fn new() -> Self {
        List { head: None }
    }

    pub fn push(&mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: mem::replace(&mut self.head, None),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&mut self) -> Option<i32> {
        match mem::replace(&mut self.head, None) {
            None => None,
            Some(node) => {
                self.head = node.next;
                Some(node.elem)
            }
        }
    }
}

impl Drop for List {
    fn drop(&mut self) {
        let mut cur_link = mem::replace(&mut self.head, None);
        while let Some(mut boxed_node) = cur_link {
            cur_link = mem::replace(&mut boxed_node.next, None);
        }
    }
}
```

代码看上去稍微好了一些，但是 `Option` 的好处远不止这些。

首先，之前咱们用到了 `mem::replace` 这个让人胆战心惊但是又非常有用的函数，而 `Option` 直接提供了一个方法 `take` 用于替代它: 
```rust
pub struct List {
    head: Link,
}

type Link = Option<Box<Node>>;

struct Node {
    elem: i32,
    next: Link,
}

impl List {
    pub fn new() -> Self {
        List { head: None }
    }

    pub fn push(&mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&mut self) -> Option<i32> {
        match self.head.take() {
            None => None,
            Some(node) => {
                self.head = node.next;
                Some(node.elem)
            }
        }
    }
}

impl Drop for List {
    fn drop(&mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
```

其次，`match option { None => None, Some(x) => Some(y) }` 这段代码可以直接使用 `map` 方法代替，`map` 会对 `Some(x)` 中的值进行映射，最终返回一个新的 `Some(y)` 值。

> 我们往往将闭包作为参数传递给 map 方法，关于闭包可以参见[此章](https://course.rs/advance/functional-programing/closure.html)

```rust
pub fn pop(&mut self) -> Option<i32> {
    self.head.take().map(|node| {
        self.head = node.next;
        node.elem
    })
}
```

不错，看上去简洁了很多，下面运行下测试代码确保链表依然可以正常运行(这就是 TDD 的优点！) :
```shell
$ cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 2 tests
test first::test::basics ... ok
test second::test::basics ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
```

很棒，接下来让我们来解决目前链表最大的问题：只支持 `i32` 类型的元素值。

## 泛型
为了让链表支持任何类型的元素，泛型就是绕不过去的坎，首先将所有的类型定义修改为泛型实现：
```rust
pub struct List<T> {
    head: Link<T>,
}

type Link<T> = Option<Box<Node<T>>>;

struct Node<T> {
    elem: T,
    next: Link<T>,
}

impl<T> List<T> {
    pub fn new() -> Self {
        List { head: None }
    }

    pub fn push(&mut self, elem: T) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&mut self) -> Option<T> {
        self.head.take().map(|node| {
            self.head = node.next;
            node.elem
        })
    }
}

impl<T> Drop for List<T> {
    fn drop(&mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
```

大家在修改了 `List` 的定义后，别忘了将 `impl` 中的 `List` 修改为 `List<T>`，切记**泛型参数也是类型定义的一部分**。

```shell
$ cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 2 tests
test first::test::basics ... ok
test second::test::basics ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
```

如上所示，截至目前，测试用例依然运行良好，尽管我们把代码修改成了更加复杂的泛型。这里有一个点特别值得注意，我们并没有修改关联函数 `new` ：
```rust
pub fn new() -> Self {
    List { head: None }
}
```

原因是 `Self` 承载了我们所有的荣耀，`List` 时，`Self` 就代表 `List`，当变成 `List<T>` 时，`Self` 也随之变化，代表 `List<T>`，可以看出使用它可以让未来的代码重构变得更加简单。




================================================
FILE: src/too-many-lists/persistent-stack/drop-arc.md
================================================
# Drop、Arc 及完整代码

## Drop
与之前链表存在的问题相似，新的链表也有递归的问题。下面是之前的解决方法:
```rust
impl<T> Drop for List<T> {
    fn drop(&mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
```

但是 `boxed_node.next.take()` 的方式在新的链表中无法使用，因为我们没办法去修改 `Rc` 持有的值。

考虑一下相关的逻辑，可以发现，如果当前的节点仅被当前链表所引用(Rc 的引用计数为 1)，那该节点是可以安全 `drop` 的: 
```rust
impl<T> Drop for List<T> {
    fn drop(&mut self) {
        let mut head = self.head.take();
        while let Some(node) = head {
            if let Ok(mut node) = Rc::try_unwrap(node) {
                head = node.next.take();
            } else {
                break;
            }
        }
    }
}
```

这里有一个没见过的方法 `Rc::Try_unwrap` ，该方法会判断当前的 `Rc` 是否只有一个强引用，若是，则返回 `Rc` 持有的值，否则返回一个错误。

可以看出，我们会一直 drop 到第一个被其它链表所引用的节点：
```shell
list1 -> A ---+
              |
              v
list2 ------> B -> C -> D
              ^
              |
list3 -> X ---+
```

例如如果要 drop `List2`，那会从头节点开始一直 drop 到 `B` 节点时停止，剩余的 `B -> C -> D` 三个节点由于引用计数不为 1 (同时被多个链表引用) ，因此不会被 drop。


测试下新的代码:
```shell
$ cargo test

   Compiling lists v0.1.0 (/Users/ABeingessner/dev/too-many-lists/lists)
    Finished dev [unoptimized + debuginfo] target(s) in 1.10s
     Running /Users/ABeingessner/dev/too-many-lists/lists/target/debug/deps/lists-86544f1d97438f1f

running 8 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

完美通过，下面再来考虑一个问题，如果我们的链表要在多线程环境使用该怎么办？

## Arc
不可变链表的一个很大的好处就在于多线程访问时自带安全性，毕竟共享可变性是多线程危险的源泉，最好也是最简单的解决办法就是直接干掉可变性。

但是 `Rc<T>` 本身并不是线程安全的，原因在之前的章节也有讲：它内部的引用计数器并不是线程安全的，通俗来讲，计数器没有加锁也没有实现原子性。

再结合之前章节学过的内容，绝大部分同学应该都能想到, `Arc<T>` 就是我们的最终答案。

那么还有一个问题，我们怎么知道一个类型是不是类型安全？会不会在多线程误用了非线程安全的类型呢？这就是 Rust 安全性的另一个强大之处：Rust 通过提供 `Send` 和 `Sync` 两个特征来保证线程安全。

> 关于 `Send` 和 `Sync` 的详细介绍，请参见[此章节](https://course.rs/advance/concurrency-with-threads/send-sync.html)

## 完整代码
又到了喜闻乐见的环节，新链表的代码相比之前反而还更简单了，不可变就是香！

```rust
use std::rc::Rc;

pub struct List<T> {
    head: Link<T>,
}

type Link<T> = Option<Rc<Node<T>>>;

struct Node<T> {
    elem: T,
    next: Link<T>,
}

impl<T> List<T> {
    pub fn new() -> Self {
        List { head: None }
    }

    pub fn prepend(&self, elem: T) -> List<T> {
        List { head: Some(Rc::new(Node {
            elem: elem,
            next: self.head.clone(),
        }))}
    }

    pub fn tail(&self) -> List<T> {
        List { head: self.head.as_ref().and_then(|node| node.next.clone()) }
    }

    pub fn head(&self) -> Option<&T> {
        self.head.as_ref().map(|node| &node.elem)
    }

    pub fn iter(&self) -> Iter<'_, T> {
        Iter { next: self.head.as_deref() }
    }
}

impl<T> Drop for List<T> {
    fn drop(&mut self) {
        let mut head = self.head.take();
        while let Some(node) = head {
            if let Ok(mut node) = Rc::try_unwrap(node) {
                head = node.next.take();
            } else {
                break;
            }
        }
    }
}

pub struct Iter<'a, T> {
    next: Option<&'a Node<T>>,
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.next.as_deref();
            &node.elem
        })
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let list = List::new();
        assert_eq!(list.head(), None);

        let list = list.prepend(1).prepend(2).prepend(3);
        assert_eq!(list.head(), Some(&3));

        let list = list.tail();
        assert_eq!(list.head(), Some(&2));

        let list = list.tail();
        assert_eq!(list.head(), Some(&1));

        let list = list.tail();
        assert_eq!(list.head(), None);

        // Make sure empty tail works
        let list = list.tail();
        assert_eq!(list.head(), None);
    }

    #[test]
    fn iter() {
        let list = List::new().prepend(1).prepend(2).prepend(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&3));
        assert_eq!(iter.next(), Some(&2));
        assert_eq!(iter.next(), Some(&1));
    }
}
```



================================================
FILE: src/too-many-lists/persistent-stack/intro.md
================================================
# 持久化单向链表
迄今为止，我们已经掌握了如何实现一个可变的单向链表。但是之前的链表都是单所有权的，在实际使用中，共享所有权才是更实用的方式，下面一起来看看该如何实现一个不可变的、共享所有权的持久化链表( persistent )。

开始之前，还需要创建一个新文件 `third.rs` ，并在 `lib.rs` 中添加以下内容:
```rust
// in lib.rs

pub mod first;
pub mod second;
pub mod third;
```

与上一个链表有所不同，这次我们无需拷贝之前的代码，而是从零开始构建一个新的链表。





================================================
FILE: src/too-many-lists/persistent-stack/layout.md
================================================
[Binary file]


================================================
FILE: src/too-many-lists/production-unsafe-deque/basics.md
================================================
# Basics

好了，这就是本书最烂的部分，也是我花了 7 年时间才写完这一章的原因！是时候把我们已经做过 5 次的枯燥乏味的东西再写一遍了，但因为我们必须使用 `Option<NonNull<Node<T>>` 把每件事都做两遍，所以显得格外冗长！

```rust
impl<T> LinkedList<T> {
    pub fn new() -> Self {
        Self {
            front: None,
            back: None,
            len: 0,
            _boo: PhantomData,
        }
    }
}
```

PhantomData 是一种奇怪的类型，没有字段，所以你只需说出它的类型名称就能创建一个。

```rust
pub fn push_front(&mut self, elem: T) {
    // SAFETY: it's a linked-list, what do you want?
    unsafe {
        let new = NonNull::new_unchecked(Box::into_raw(Box::new(Node {
            front: None,
            back: None,
            elem,
        })));
        if let Some(old) = self.front {
            // Put the new front before the old one
            (*old).front = Some(new);
            (*new).back = Some(old);
        } else {
            // If there's no front, then we're the empty list and need 
            // to set the back too. Also here's some integrity checks
            // for testing, in case we mess up.
            debug_assert!(self.back.is_none());
            debug_assert!(self.front.is_none());
            debug_assert!(self.len == 0);
            self.back = Some(new);
        }
        self.front = Some(new);
        self.len += 1;
    }
}
error[E0614]: type `NonNull<Node<T>>` cannot be dereferenced
  --> src\lib.rs:39:17
   |
39 |                 (*old).front = Some(new);
   |                 ^^^^^^
```

是的，我真恨 `NonNull<Node<T>>`。我们需要明确地使用 `as_ptr` 从 NonNull 中获取原始指针，因为 DerefMut 是以 `&mut` 定义的，我们不想在不安全代码中随意引入安全引用！

```rust
            (*old.as_ptr()).front = Some(new);
            (*new.as_ptr()).back = Some(old);
   Compiling linked-list v0.0.3
warning: field is never read: `elem`
  --> src\lib.rs:16:5
   |
16 |     elem: T,
   |     ^^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: `linked-list` (lib) generated 1 warning (1 duplicate)
warning: `linked-list` (lib test) generated 1 warning
    Finished test [unoptimized + debuginfo] target(s) in 0.33s
```

很好，接下来是 `pop` 和 `len`：

```rust
pub fn pop_front(&mut self) -> Option<T> {
    unsafe {
        // Only have to do stuff if there is a front node to pop.
        // Note that we don't need to mess around with `take` anymore
        // because everything is Copy and there are no dtors that will
        // run if we mess up... right? :) Riiiight? :)))
        self.front.map(|node| {
            // Bring the Box back to life so we can move out its value and
            // Drop it (Box continues to magically understand this for us).
            let boxed_node = Box::from_raw(node.as_ptr());
            let result = boxed_node.elem;

            // Make the next node into the new front.
            self.front = boxed_node.back;
            if let Some(new) = self.front {
                // Cleanup its reference to the removed node
                (*new.as_ptr()).front = None;
            } else {
                // If the front is now null, then this list is now empty!
                debug_assert!(self.len == 1);
                self.back = None;
            }

            self.len -= 1;
            result
            // Box gets implicitly freed here, knows there is no T.
        })
    }
}

pub fn len(&self) -> usize {
    self.len
}
   Compiling linked-list v0.0.3
    Finished dev [unoptimized + debuginfo] target(s) in 0.37s
```

在我看来是合法的，是时候写一个测试了！

```rust
#[cfg(test)]
mod test {
    use super::LinkedList;

    #[test]
    fn test_basic_front() {
        let mut list = LinkedList::new();

        // Try to break an empty list
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Try to break a one item list
        list.push_front(10);
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Mess around
        list.push_front(10);
        assert_eq!(list.len(), 1);
        list.push_front(20);
        assert_eq!(list.len(), 2);
        list.push_front(30);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(30));
        assert_eq!(list.len(), 2);
        list.push_front(40);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(40));
        assert_eq!(list.len(), 2);
        assert_eq!(list.pop_front(), Some(20));
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
    }
}
   Compiling linked-list v0.0.3
    Finished test [unoptimized + debuginfo] target(s) in 0.40s
     Running unittests src\lib.rs

running 1 test
test test::test_basic_front ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

万幸，我们是完美的！是吗？



================================================
FILE: src/too-many-lists/production-unsafe-deque/boring-combinatorics.md
================================================
[Binary file]


================================================
FILE: src/too-many-lists/production-unsafe-deque/drop-and-panic-safety.md
================================================
# Drop and Panic Safety

嘿，你注意到这些注释了吗：

```rust
// Note that we don't need to mess around with `take` anymore
// because everything is Copy and there are no dtors that will
// run if we mess up... right? :) Riiiight? :)))
```

这对吗？

你忘记你正在读那本书了吗？当然这是错误的（部分上是）。

让我们再次看看 pop_front 内部:

```rust
// Bring the Box back to life so we can move out its value and
// Drop it (Box continues to magically understand this for us).
let boxed_node = Box::from_raw(node.as_ptr());
let result = boxed_node.elem;

// Make the next node into the new front.
self.front = boxed_node.back;
if let Some(new) = self.front {
    // Cleanup its reference to the removed node
    (*new.as_ptr()).front = None;
} else {
    // If the front is now null, then this list is now empty!
    debug_assert!(self.len == 1);
    self.back = None;
}

self.len -= 1;
result
// Box gets implicitly freed here, knows there is no T.
```

你看到 bug 了吗? 真可怕, 是这一行:

```rust
debug_assert!(self.len == 1);
```

大多数情况下，你不需要考虑或担心恐慌，但一旦你开始编写真正不安全的代码，并在 "invariants(不可变性) "上大做文章，你就需要对恐慌保持高度警惕！

我们必须谈谈 [*异常安全*](https://doc.rust-lang.org/nightly/nomicon/exception-safety.html) （又名恐慌安全、解除安全......）。

情况是这样的：在默认情况下，恐慌会被 unwinding。unwind 只是 "让每个函数立即返回 "的一种花哨说法。你可能会想："好吧，如果每个函数都返回，那么程序就要结束了，何必在乎它呢？"但你错了！

我们必须关注有两个原因：当函数返回时，析构函数会运行，而且可以捕获 unwind。在这两种情况下，代码都可能在恐慌发生后继续运行，因此我们必须非常小心，确保我们的不安全的集合在恐慌发生时始终处于某种一致的状态，因为每次恐慌都是隐式的提前返回！

让我们想一想，到这一行时，我们的集合处于什么状态：

我们将 boxed_node 放在栈上，并从中提取了元素。如果我们在此时返回，Box 将被丢弃，节点将被释放。self.back 仍然指向那个被释放的节点！一旦我们使用 self.back 来处理一些事情，这就可能导致释放后再使用！

有趣的是，这行也有类似的问题，但它要安全得多：

```rust
self.len -= 1;
```

默认情况下，Rust 会在调试构建时检查上溢和下溢，并在发生时产生恐慌。是的，每一次算术运算都会带来恐慌安全隐患！这行还好，他不会导致内存错误，因为之前已经完成了该做的所有操作。所以调试断言哪行在某种意义上更糟糕，因为它可能将一个小问题升级为关键问题！

在实现过程中，只要我们确保在别人注意到之前修复它们，我们可以临时性的破坏invariants(不可变性)。这实际上是 Rust 的集合所有权和借用系统的 "杀手级应用 "之一：如果一个操作需要一个 `&mut Self`，那么我们就能保证对我们的集合拥有独占访问权，而且我们可以暂时破坏invariants(不可变性)，因为我们知道没有人能偷偷摸摸地破坏它。

我们有两种方法可以让我们的代码更健壮：

- 更积极地使用 Option::take 这样的操作，因为它们更 "事务性"，更倾向于保留invariants(不可变性)。
- 放弃 debug_asserts，相信自己能写出更好的测试，并使用专用的 "完整性检查 "函数，而这些函数永远不会在用户代码中运行。

原则上，我喜欢第一种方案，但它对双链路列表的实际效果并不好，因为所有内容都是双冗余编码的。Option::take 并不能解决这里的问题，但将 debug_assert 下移一行却可以。不过说真的，为什么要为难我们自己呢？让我们移除那些 debug_asserts，并确保任何可能引起恐慌的事情都发生在我们方法的开头或结尾，而我们在这些地方保持invariants(不可变性)。

这是我们的全部实现：

```rust
use std::ptr::NonNull;
use std::marker::PhantomData;

pub struct LinkedList<T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
    _boo: PhantomData<T>,
}

type Link<T> = Option<NonNull<Node<T>>>;

struct Node<T> {
    front: Link<T>,
    back: Link<T>,
    elem: T, 
}

impl<T> LinkedList<T> {
    pub fn new() -> Self {
        Self {
            front: None,
            back: None,
            len: 0,
            _boo: PhantomData,
        }
    }

    pub fn push_front(&mut self, elem: T) {
        // SAFETY: it's a linked-list, what do you want?
        unsafe {
            let new = NonNull::new_unchecked(Box::into_raw(Box::new(Node {
                front: None,
                back: None,
                elem,
            })));
            if let Some(old) = self.front {
                // Put the new front before the old one
                (*old.as_ptr()).front = Some(new);
                (*new.as_ptr()).back = Some(old);
            } else {
                // If there's no front, then we're the empty list and need 
                // to set the back too.
                self.back = Some(new);
            }
            // These things always happen!
            self.front = Some(new);
            self.len += 1;
        }
    }

    pub fn pop_front(&mut self) -> Option<T> {
        unsafe {
            // Only have to do stuff if there is a front node to pop.
            self.front.map(|node| {
                // Bring the Box back to life so we can move out its value and
                // Drop it (Box continues to magically understand this for us).
                let boxed_node = Box::from_raw(node.as_ptr());
                let result = boxed_node.elem;

                // Make the next node into the new front.
                self.front = boxed_node.back;
                if let Some(new) = self.front {
                    // Cleanup its reference to the removed node
                    (*new.as_ptr()).front = None;
                } else {
                    // If the front is now null, then this list is now empty!
                    self.back = None;
                }

                self.len -= 1;
                result
                // Box gets implicitly freed here, knows there is no T.
            })
        }
    }

    pub fn len(&self) -> usize {
        self.len
    }
}
```

这还有什么可以引发恐慌？老实说，要知道这些需要你是 Rust 专家，不过幸好我是！

在这段代码中，我能看到的唯一可能引起恐慌的地方是 `Box::new`（用于内存不足的情况）和 `len` 运算。所有这些都在我们方法的最末端或最开始，所以，我们是安全的！



================================================
FILE: src/too-many-lists/production-unsafe-deque/filling-in-random-bits.md
================================================
# Filling In Random Bits

嘿，你不是说要做成精品吗？

为了成为一个 "好 "系列，这里还有一些乱七八糟的东西：

```rust
impl<T> LinkedList<T> {
    pub fn is_empty(&self) -> bool {
        self.len == 0
    }

    pub fn clear(&mut self) {
        // Oh look it's drop again
        while let Some(_) = self.pop_front() { }
    }
}
```

现在，我们已经有了一大堆大家都期待的特性需要实现：

```rust
impl<T> Default for LinkedList<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: Clone> Clone for LinkedList<T> {
    fn clone(&self) -> Self {
        let mut new_list = Self::new();
        for item in self {
            new_list.push_back(item.clone());
        }
        new_list
    }
}

impl<T> Extend<T> for LinkedList<T> {
    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {
        for item in iter {
            self.push_back(item);
        }
    }
}

impl<T> FromIterator<T> for LinkedList<T> {
    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {
        let mut list = Self::new();
        list.extend(iter);
        list
    }
}

impl<T: Debug> Debug for LinkedList<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_list().entries(self).finish()
    }
}

impl<T: PartialEq> PartialEq for LinkedList<T> {
    fn eq(&self, other: &Self) -> bool {
        self.len() == other.len() && self.iter().eq(other)
    }

    fn ne(&self, other: &Self) -> bool {
        self.len() != other.len() || self.iter().ne(other)
    }
}

impl<T: Eq> Eq for LinkedList<T> { }

impl<T: PartialOrd> PartialOrd for LinkedList<T> {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.iter().partial_cmp(other)
    }
}

impl<T: Ord> Ord for LinkedList<T> {
    fn cmp(&self, other: &Self) -> Ordering {
        self.iter().cmp(other)
    }
}

impl<T: Hash> Hash for LinkedList<T> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.len().hash(state);
        for item in self {
            item.hash(state);
        }
    }
}
```

另一个有趣的话题是哈希本身。你看到我们如何将 `len` 写入散列的吗？这其实非常重要！如果集合不把 `len` 加入散列，很可能会意外的造成前缀碰撞。例如，一个集合包含 `["he", "llo"]` 另一个集合包含 `["hello"]`，我们该如何区分？如果没有把集合长度或其它"分隔符"加入到散列 ，这将毫无意义！会让意外哈希碰撞发生变得太容易，会导致严重的后果，所以还是照做吧！

好了，这是我们现在的代码：

```rust
use std::cmp::Ordering;
use std::fmt::{self, Debug};
use std::hash::{Hash, Hasher};
use std::iter::FromIterator;
use std::ptr::NonNull;
use std::marker::PhantomData;

pub struct LinkedList<T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
    _boo: PhantomData<T>,
}

type Link<T> = Option<NonNull<Node<T>>>;

struct Node<T> {
    front: Link<T>,
    back: Link<T>,
    elem: T, 
}

pub struct Iter<'a, T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
    _boo: PhantomData<&'a T>,
}

pub struct IterMut<'a, T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
    _boo: PhantomData<&'a mut T>,
}

pub struct IntoIter<T> {
    list: LinkedList<T>,
}

impl<T> LinkedList<T> {
    pub fn new() -> Self {
        Self {
            front: None,
            back: None,
            len: 0,
            _boo: PhantomData,
        }
    }

    pub fn push_front(&mut self, elem: T) {
        // SAFETY: it's a linked-list, what do you want?
        unsafe {
            let new = NonNull::new_unchecked(Box::into_raw(Box::new(Node {
                front: None,
                back: None,
                elem,
            })));
            if let Some(old) = self.front {
                // Put the new front before the old one
                (*old.as_ptr()).front = Some(new);
                (*new.as_ptr()).back = Some(old);
            } else {
                // If there's no front, then we're the empty list and need 
                // to set the back too.
                self.back = Some(new);
            }
            // These things always happen!
            self.front = Some(new);
            self.len += 1;
        }
    }

    pub fn push_back(&mut self, elem: T) {
        // SAFETY: it's a linked-list, what do you want?
        unsafe {
            let new = NonNull::new_unchecked(Box::into_raw(Box::new(Node {
                back: None,
                front: None,
                elem,
            })));
            if let Some(old) = self.back {
                // Put the new back before the old one
                (*old.as_ptr()).back = Some(new);
                (*new.as_ptr()).front = Some(old);
            } else {
                // If there's no back, then we're the empty list and need 
                // to set the front too.
                self.front = Some(new);
            }
            // These things always happen!
            self.back = Some(new);
            self.len += 1;
        }
    }

    pub fn pop_front(&mut self) -> Option<T> {
        unsafe {
            // Only have to do stuff if there is a front node to pop.
            self.front.map(|node| {
                // Bring the Box back to life so we can move out its value and
                // Drop it (Box continues to magically understand this for us).
                let boxed_node = Box::from_raw(node.as_ptr());
                let result = boxed_node.elem;

                // Make the next node into the new front.
                self.front = boxed_node.back;
                if let Some(new) = self.front {
                    // Cleanup its reference to the removed node
                    (*new.as_ptr()).front = None;
                } else {
                    // If the front is now null, then this list is now empty!
                    self.back = None;
                }

                self.len -= 1;
                result
                // Box gets implicitly freed here, knows there is no T.
            })
        }
    }

    pub fn pop_back(&mut self) -> Option<T> {
        unsafe {
            // Only have to do stuff if there is a back node to pop.
            self.back.map(|node| {
                // Bring the Box front to life so we can move out its value and
                // Drop it (Box continues to magically understand this for us).
                let boxed_node = Box::from_raw(node.as_ptr());
                let result = boxed_node.elem;

                // Make the next node into the new back.
                self.back = boxed_node.front;
                if let Some(new) = self.back {
                    // Cleanup its reference to the removed node
                    (*new.as_ptr()).back = None;
                } else {
                    // If the back is now null, then this list is now empty!
                    self.front = None;
                }

                self.len -= 1;
                result
                // Box gets implicitly freed here, knows there is no T.
            })
        }
    }

    pub fn front(&self) -> Option<&T> {
        unsafe {
            self.front.map(|node| &(*node.as_ptr()).elem)
        }
    }

    pub fn front_mut(&mut self) -> Option<&mut T> {
        unsafe {
            self.front.map(|node| &mut (*node.as_ptr()).elem)
        }
    }

    pub fn back(&self) -> Option<&T> {
        unsafe {
            self.back.map(|node| &(*node.as_ptr()).elem)
        }
    }

    pub fn back_mut(&mut self) -> Option<&mut T> {
        unsafe {
            self.back.map(|node| &mut (*node.as_ptr()).elem)
        }
    }

    pub fn len(&self) -> usize {
        self.len
    }

    pub fn is_empty(&self) -> bool {
        self.len == 0
    }

    pub fn clear(&mut self) {
        // Oh look it's drop again
        while let Some(_) = self.pop_front() { }
    }

    pub fn iter(&self) -> Iter<T> {
        Iter { 
            front: self.front, 
            back: self.back,
            len: self.len,
            _boo: PhantomData,
        }
    }

    pub fn iter_mut(&mut self) -> IterMut<T> {
        IterMut { 
            front: self.front, 
            back: self.back,
            len: self.len,
            _boo: PhantomData,
        }
    }

    pub fn into_iter(self) -> IntoIter<T> {
        IntoIter { 
            list: self
        }
    }
}

impl<T> Drop for LinkedList<T> {
    fn drop(&mut self) {
        // Pop until we have to stop
        while let Some(_) = self.pop_front() { }
    }
}

impl<T> Default for LinkedList<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: Clone> Clone for LinkedList<T> {
    fn clone(&self) -> Self {
        let mut new_list = Self::new();
        for item in self {
            new_list.push_back(item.clone());
        }
        new_list
    }
}

impl<T> Extend<T> for LinkedList<T> {
    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {
        for item in iter {
            self.push_back(item);
        }
    }
}

impl<T> FromIterator<T> for LinkedList<T> {
    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {
        let mut list = Self::new();
        list.extend(iter);
        list
    }
}

impl<T: Debug> Debug for LinkedList<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_list().entries(self).finish()
    }
}

impl<T: PartialEq> PartialEq for LinkedList<T> {
    fn eq(&self, other: &Self) -> bool {
        self.len() == other.len() && self.iter().eq(other)
    }

    fn ne(&self, other: &Self) -> bool {
        self.len() != other.len() || self.iter().ne(other)
    }
}

impl<T: Eq> Eq for LinkedList<T> { }

impl<T: PartialOrd> PartialOrd for LinkedList<T> {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.iter().partial_cmp(other)
    }
}

impl<T: Ord> Ord for LinkedList<T> {
    fn cmp(&self, other: &Self) -> Ordering {
        self.iter().cmp(other)
    }
}

impl<T: Hash> Hash for LinkedList<T> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.len().hash(state);
        for item in self {
            item.hash(state);
        }
    }
}

impl<'a, T> IntoIterator for &'a LinkedList<T> {
    type IntoIter = Iter<'a, T>;
    type Item = &'a T;

    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        // While self.front == self.back is a tempting condition to check here,
        // it won't do the right for yielding the last element! That sort of
        // thing only works for arrays because of "one-past-the-end" pointers.
        if self.len > 0 {
            // We could unwrap front, but this is safer and easier
            self.front.map(|node| unsafe {
                self.len -= 1;
                self.front = (*node.as_ptr()).back;
                &(*node.as_ptr()).elem
            })
        } else {
            None
        }
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        (self.len, Some(self.len))
    }
}

impl<'a, T> DoubleEndedIterator for Iter<'a, T> {
    fn next_back(&mut self) -> Option<Self::Item> {
        if self.len > 0 {
            self.back.map(|node| unsafe {
                self.len -= 1;
                self.back = (*node.as_ptr()).front;
                &(*node.as_ptr()).elem
            })
        } else {
            None
        }
    }
}

impl<'a, T> ExactSizeIterator for Iter<'a, T> {
    fn len(&self) -> usize {
        self.len
    }
}

impl<'a, T> IntoIterator for &'a mut LinkedList<T> {
    type IntoIter = IterMut<'a, T>;
    type Item = &'a mut T;

    fn into_iter(self) -> Self::IntoIter {
        self.iter_mut()
    }
}

impl<'a, T> Iterator for IterMut<'a, T> {
    type Item = &'a mut T;

    fn next(&mut self) -> Option<Self::Item> {
        // While self.front == self.back is a tempting condition to check here,
        // it won't do the right for yielding the last element! That sort of
        // thing only works for arrays because of "one-past-the-end" pointers.
        if self.len > 0 {
            // We could unwrap front, but this is safer and easier
            self.front.map(|node| unsafe {
                self.len -= 1;
                self.front = (*node.as_ptr()).back;
                &mut (*node.as_ptr()).elem
            })
        } else {
            None
        }
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        (self.len, Some(self.len))
    }
}

impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {
    fn next_back(&mut self) -> Option<Self::Item> {
        if self.len > 0 {
            self.back.map(|node| unsafe {
                self.len -= 1;
                self.back = (*node.as_ptr()).front;
                &mut (*node.as_ptr()).elem
            })
        } else {
            None
        }
    }
}

impl<'a, T> ExactSizeIterator for IterMut<'a, T> {
    fn len(&self) -> usize {
        self.len
    }
}

impl<T> IntoIterator for LinkedList<T> {
    type IntoIter = IntoIter<T>;
    type Item = T;

    fn into_iter(self) -> Self::IntoIter {
        self.into_iter()
    }
}

impl<T> Iterator for IntoIter<T> {
    type Item = T;

    fn next(&mut self) -> Option<Self::Item> {
        self.list.pop_front()
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        (self.list.len, Some(self.list.len))
    }
}

impl<T> DoubleEndedIterator for IntoIter<T> {
    fn next_back(&mut self) -> Option<Self::Item> {
        self.list.pop_back()
    }
}

impl<T> ExactSizeIterator for IntoIter<T> {
    fn len(&self) -> usize {
        self.list.len
    }
}


#[cfg(test)]
mod test {
    use super::LinkedList;

    #[test]
    fn test_basic_front() {
        let mut list = LinkedList::new();

        // Try to break an empty list
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Try to break a one item list
        list.push_front(10);
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Mess around
        list.push_front(10);
        assert_eq!(list.len(), 1);
        list.push_front(20);
        assert_eq!(list.len(), 2);
        list.push_front(30);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(30));
        assert_eq!(list.len(), 2);
        list.push_front(40);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(40));
        assert_eq!(list.len(), 2);
        assert_eq!(list.pop_front(), Some(20));
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
    }
}
```



================================================
FILE: src/too-many-lists/production-unsafe-deque/final-code.md
================================================
# Final Code

我真不敢相信，我居然让你坐在那里，听我从头开始重新实现 std::collections::LinkedList，一路上我犯了很多繁琐的小错误。

我做到了，书写完了，我终于可以休息了。

好了，下面是我们完整重写的 1200 行代码的全部内容。这应该与 [this commit](https://github.com/contain-rs/linked-list/commit/5b69cc29454595172a5167a09277660342b78092) 的文本相同。

```rust
use std::cmp::Ordering;
use std::fmt::{self, Debug};
use std::hash::{Hash, Hasher};
use std::iter::FromIterator;
use std::marker::PhantomData;
use std::ptr::NonNull;

pub struct LinkedList<T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
    _boo: PhantomData<T>,
}

type Link<T> = Option<NonNull<Node<T>>>;

struct Node<T> {
    front: Link<T>,
    back: Link<T>,
    elem: T,
}

pub struct Iter<'a, T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
    _boo: PhantomData<&'a T>,
}

pub struct IterMut<'a, T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
    _boo: PhantomData<&'a mut T>,
}

pub struct IntoIter<T> {
    list: LinkedList<T>,
}

pub struct CursorMut<'a, T> {
    list: &'a mut LinkedList<T>,
    cur: Link<T>,
    index: Option<usize>,
}

impl<T> LinkedList<T> {
    pub fn new() -> Self {
        Self {
            front: None,
            back: None,
            len: 0,
            _boo: PhantomData,
        }
    }

    pub fn push_front(&mut self, elem: T) {
        // SAFETY: it's a linked-list, what do you want?
        unsafe {
            let new = NonNull::new_unchecked(Box::into_raw(Box::new(Node {
                front: None,
                back: None,
                elem,
            })));
            if let Some(old) = self.front {
                // Put the new front before the old one
                (*old.as_ptr()).front = Some(new);
                (*new.as_ptr()).back = Some(old);
            } else {
                // If there's no front, then we're the empty list and need
                // to set the back too.
                self.back = Some(new);
            }
            // These things always happen!
            self.front = Some(new);
            self.len += 1;
        }
    }

    pub fn push_back(&mut self, elem: T) {
        // SAFETY: it's a linked-list, what do you want?
        unsafe {
            let new = NonNull::new_unchecked(Box::into_raw(Box::new(Node {
                back: None,
                front: None,
                elem,
            })));
            if let Some(old) = self.back {
                // Put the new back before the old one
                (*old.as_ptr()).back = Some(new);
                (*new.as_ptr()).front = Some(old);
            } else {
                // If there's no back, then we're the empty list and need
                // to set the front too.
                self.front = Some(new);
            }
            // These things always happen!
            self.back = Some(new);
            self.len += 1;
        }
    }

    pub fn pop_front(&mut self) -> Option<T> {
        unsafe {
            // Only have to do stuff if there is a front node to pop.
            self.front.map(|node| {
                // Bring the Box back to life so we can move out its value and
                // Drop it (Box continues to magically understand this for us).
                let boxed_node = Box::from_raw(node.as_ptr());
                let result = boxed_node.elem;

                // Make the next node into the new front.
                self.front = boxed_node.back;
                if let Some(new) = self.front {
                    // Cleanup its reference to the removed node
                    (*new.as_ptr()).front = None;
                } else {
                    // If the front is now null, then this list is now empty!
                    self.back = None;
                }

                self.len -= 1;
                result
                // Box gets implicitly freed here, knows there is no T.
            })
        }
    }

    pub fn pop_back(&mut self) -> Option<T> {
        unsafe {
            // Only have to do stuff if there is a back node to pop.
            self.back.map(|node| {
                // Bring the Box front to life so we can move out its value and
                // Drop it (Box continues to magically understand this for us).
                let boxed_node = Box::from_raw(node.as_ptr());
                let result = boxed_node.elem;

                // Make the next node into the new back.
                self.back = boxed_node.front;
                if let Some(new) = self.back {
                    // Cleanup its reference to the removed node
                    (*new.as_ptr()).back = None;
                } else {
                    // If the back is now null, then this list is now empty!
                    self.front = None;
                }

                self.len -= 1;
                result
                // Box gets implicitly freed here, knows there is no T.
            })
        }
    }

    pub fn front(&self) -> Option<&T> {
        unsafe { self.front.map(|node| &(*node.as_ptr()).elem) }
    }

    pub fn front_mut(&mut self) -> Option<&mut T> {
        unsafe { self.front.map(|node| &mut (*node.as_ptr()).elem) }
    }

    pub fn back(&self) -> Option<&T> {
        unsafe { self.back.map(|node| &(*node.as_ptr()).elem) }
    }

    pub fn back_mut(&mut self) -> Option<&mut T> {
        unsafe { self.back.map(|node| &mut (*node.as_ptr()).elem) }
    }

    pub fn len(&self) -> usize {
        self.len
    }

    pub fn is_empty(&self) -> bool {
        self.len == 0
    }

    pub fn clear(&mut self) {
        // Oh look it's drop again
        while self.pop_front().is_some() {}
    }

    pub fn iter(&self) -> Iter<T> {
        Iter {
            front: self.front,
            back: self.back,
            len: self.len,
            _boo: PhantomData,
        }
    }

    pub fn iter_mut(&mut self) -> IterMut<T> {
        IterMut {
            front: self.front,
            back: self.back,
            len: self.len,
            _boo: PhantomData,
        }
    }

    pub fn cursor_mut(&mut self) -> CursorMut<T> {
        CursorMut {
            list: self,
            cur: None,
            index: None,
        }
    }
}

impl<T> Drop for LinkedList<T> {
    fn drop(&mut self) {
        // Pop until we have to stop
        while self.pop_front().is_some() {}
    }
}

impl<T> Default for LinkedList<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: Clone> Clone for LinkedList<T> {
    fn clone(&self) -> Self {
        let mut new_list = Self::new();
        for item in self {
            new_list.push_back(item.clone());
        }
        new_list
    }
}

impl<T> Extend<T> for LinkedList<T> {
    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {
        for item in iter {
            self.push_back(item);
        }
    }
}

impl<T> FromIterator<T> for LinkedList<T> {
    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {
        let mut list = Self::new();
        list.extend(iter);
        list
    }
}

impl<T: Debug> Debug for LinkedList<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_list().entries(self).finish()
    }
}

impl<T: PartialEq> PartialEq for LinkedList<T> {
    fn eq(&self, other: &Self) -> bool {
        self.len() == other.len() && self.iter().eq(other)
    }
}

impl<T: Eq> Eq for LinkedList<T> {}

impl<T: PartialOrd> PartialOrd for LinkedList<T> {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.iter().partial_cmp(other)
    }
}

impl<T: Ord> Ord for LinkedList<T> {
    fn cmp(&self, other: &Self) -> Ordering {
        self.iter().cmp(other)
    }
}

impl<T: Hash> Hash for LinkedList<T> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.len().hash(state);
        for item in self {
            item.hash(state);
        }
    }
}

impl<'a, T> IntoIterator for &'a LinkedList<T> {
    type IntoIter = Iter<'a, T>;
    type Item = &'a T;

    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        // While self.front == self.back is a tempting condition to check here,
        // it won't do the right for yielding the last element! That sort of
        // thing only works for arrays because of "one-past-the-end" pointers.
        if self.len > 0 {
            // We could unwrap front, but this is safer and easier
            self.front.map(|node| unsafe {
                self.len -= 1;
                self.front = (*node.as_ptr()).back;
                &(*node.as_ptr()).elem
            })
        } else {
            None
        }
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        (self.len, Some(self.len))
    }
}

impl<'a, T> DoubleEndedIterator for Iter<'a, T> {
    fn next_back(&mut self) -> Option<Self::Item> {
        if self.len > 0 {
            self.back.map(|node| unsafe {
                self.len -= 1;
                self.back = (*node.as_ptr()).front;
                &(*node.as_ptr()).elem
            })
        } else {
            None
        }
    }
}

impl<'a, T> ExactSizeIterator for Iter<'a, T> {
    fn len(&self) -> usize {
        self.len
    }
}

impl<'a, T> IntoIterator for &'a mut LinkedList<T> {
    type IntoIter = IterMut<'a, T>;
    type Item = &'a mut T;

    fn into_iter(self) -> Self::IntoIter {
        self.iter_mut()
    }
}

impl<'a, T> Iterator for IterMut<'a, T> {
    type Item = &'a mut T;

    fn next(&mut self) -> Option<Self::Item> {
        // While self.front == self.back is a tempting condition to check here,
        // it won't do the right for yielding the last element! That sort of
        // thing only works for arrays because of "one-past-the-end" pointers.
        if self.len > 0 {
            // We could unwrap front, but this is safer and easier
            self.front.map(|node| unsafe {
                self.len -= 1;
                self.front = (*node.as_ptr()).back;
                &mut (*node.as_ptr()).elem
            })
        } else {
            None
        }
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        (self.len, Some(self.len))
    }
}

impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {
    fn next_back(&mut self) -> Option<Self::Item> {
        if self.len > 0 {
            self.back.map(|node| unsafe {
                self.len -= 1;
                self.back = (*node.as_ptr()).front;
                &mut (*node.as_ptr()).elem
            })
        } else {
            None
        }
    }
}

impl<'a, T> ExactSizeIterator for IterMut<'a, T> {
    fn len(&self) -> usize {
        self.len
    }
}

impl<T> IntoIterator for LinkedList<T> {
    type IntoIter = IntoIter<T>;
    type Item = T;

    fn into_iter(self) -> Self::IntoIter {
        IntoIter { list: self }
    }
}

impl<T> Iterator for IntoIter<T> {
    type Item = T;

    fn next(&mut self) -> Option<Self::Item> {
        self.list.pop_front()
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        (self.list.len, Some(self.list.len))
    }
}

impl<T> DoubleEndedIterator for IntoIter<T> {
    fn next_back(&mut self) -> Option<Self::Item> {
        self.list.pop_back()
    }
}

impl<T> ExactSizeIterator for IntoIter<T> {
    fn len(&self) -> usize {
        self.list.len
    }
}

impl<'a, T> CursorMut<'a, T> {
    pub fn index(&self) -> Option<usize> {
        self.index
    }

    pub fn move_next(&mut self) {
        if let Some(cur) = self.cur {
            unsafe {
                // We're on a real element, go to its next (back)
                self.cur = (*cur.as_ptr()).back;
                if self.cur.is_some() {
                    *self.index.as_mut().unwrap() += 1;
                } else {
                    // We just walked to the ghost, no more index
                    self.index = None;
                }
            }
        } else if !self.list.is_empty() {
            // We're at the ghost, and there is a real front, so move to it!
            self.cur = self.list.front;
            self.index = Some(0)
        } else {
            // We're at the ghost, but that's the only element... do nothing.
        }
    }

    pub fn move_prev(&mut self) {
        if let Some(cur) = self.cur {
            unsafe {
                // We're on a real element, go to its previous (front)
                self.cur = (*cur.as_ptr()).front;
                if self.cur.is_some() {
                    *self.index.as_mut().unwrap() -= 1;
                } else {
                    // We just walked to the ghost, no more index
                    self.index = None;
                }
            }
        } else if !self.list.is_empty() {
            // We're at the ghost, and there is a real back, so move to it!
            self.cur = self.list.back;
            self.index = Some(self.list.len - 1)
        } else {
            // We're at the ghost, but that's the only element... do nothing.
        }
    }

    pub fn current(&mut self) -> Option<&mut T> {
        unsafe { self.cur.map(|node| &mut (*node.as_ptr()).elem) }
    }

    pub fn peek_next(&mut self) -> Option<&mut T> {
        unsafe {
            let next = if let Some(cur) = self.cur {
                // Normal case, try to follow the cur node's back pointer
                (*cur.as_ptr()).back
            } else {
                // Ghost case, try to use the list's front pointer
                self.list.front
            };

            // Yield the element if the next node exists
            next.map(|node| &mut (*node.as_ptr()).elem)
        }
    }

    pub fn peek_prev(&mut self) -> Option<&mut T> {
        unsafe {
            let prev = if let Some(cur) = self.cur {
                // Normal case, try to follow the cur node's front pointer
                (*cur.as_ptr()).front
            } else {
                // Ghost case, try to use the list's back pointer
                self.list.back
            };

            // Yield the element if the prev node exists
            prev.map(|node| &mut (*node.as_ptr()).elem)
        }
    }

    pub fn split_before(&mut self) -> LinkedList<T> {
        // We have this:
        //
        //     list.front -> A <-> B <-> C <-> D <- list.back
        //                               ^
        //                              cur
        //
        //
        // And we want to produce this:
        //
        //     list.front -> C <-> D <- list.back
        //                   ^
        //                  cur
        //
        //
        //    return.front -> A <-> B <- return.back
        //
        if let Some(cur) = self.cur {
            // We are pointing at a real element, so the list is non-empty.
            unsafe {
                // Current state
                let old_len = self.list.len;
                let old_idx = self.index.unwrap();
                let prev = (*cur.as_ptr()).front;

                // What self will become
                let new_len = old_len - old_idx;
                let new_front = self.cur;
                let new_back = self.list.back;
                let new_idx = Some(0);

                // What the output will become
                let output_len = old_len - new_len;
                let output_front = self.list.front;
                let output_back = prev;

                // Break the links between cur and prev
                if let Some(prev) = prev {
                    (*cur.as_ptr()).front = None;
                    (*prev.as_ptr()).back = None;
                }

                // Produce the result:
                self.list.len = new_len;
                self.list.front = new_front;
                self.list.back = new_back;
                self.index = new_idx;

                LinkedList {
                    front: output_front,
                    back: output_back,
                    len: output_len,
                    _boo: PhantomData,
                }
            }
        } else {
            // We're at the ghost, just replace our list with an empty one.
            // No other state needs to be changed.
            std::mem::replace(self.list, LinkedList::new())
        }
    }

    pub fn split_after(&mut self) -> LinkedList<T> {
        // We have this:
        //
        //     list.front -> A <-> B <-> C <-> D <- list.back
        //                         ^
        //                        cur
        //
        //
        // And we want to produce this:
        //
        //     list.front -> A <-> B <- list.back
        //                         ^
        //                        cur
        //
        //
        //    return.front -> C <-> D <- return.back
        //
        if let Some(cur) = self.cur {
            // We are pointing at a real element, so the list is non-empty.
            unsafe {
                // Current state
                let old_len = self.list.len;
                let old_idx = self.index.unwrap();
                let next = (*cur.as_ptr()).back;

                // What self will become
                let new_len = old_idx + 1;
                let new_back = self.cur;
                let new_front = self.list.front;
                let new_idx = Some(old_idx);

                // What the output will become
                let output_len = old_len - new_len;
                let output_front = next;
                let output_back = self.list.back;

                // Break the links between cur and next
                if let Some(next) = next {
                    (*cur.as_ptr()).back = None;
                    (*next.as_ptr()).front = None;
                }

                // Produce the result:
                self.list.len = new_len;
                self.list.front = new_front;
                self.list.back = new_back;
                self.index = new_idx;

                LinkedList {
                    front: output_front,
                    back: output_back,
                    len: output_len,
                    _boo: PhantomData,
                }
            }
        } else {
            // We're at the ghost, just replace our list with an empty one.
            // No other state needs to be changed.
            std::mem::replace(self.list, LinkedList::new())
        }
    }

    pub fn splice_before(&mut self, mut input: LinkedList<T>) {
        // We have this:
        //
        // input.front -> 1 <-> 2 <- input.back
        //
        // list.front -> A <-> B <-> C <- list.back
        //                     ^
        //                    cur
        //
        //
        // Becoming this:
        //
        // list.front -> A <-> 1 <-> 2 <-> B <-> C <- list.back
        //                                 ^
        //                                cur
        //
        unsafe {
            // We can either `take` the input's pointers or `mem::forget`
            // it. Using `take` is more responsible in case we ever do custom
            // allocators or something that also needs to be cleaned up!
            if input.is_empty() {
                // Input is empty, do nothing.
            } else if let Some(cur) = self.cur {
                // Both lists are non-empty
                let in_front = input.front.take().unwrap();
                let in_back = input.back.take().unwrap();

                if let Some(prev) = (*cur.as_ptr()).front {
                    // General Case, no boundaries, just internal fixups
                    (*prev.as_ptr()).back = Some(in_front);
                    (*in_front.as_ptr()).front = Some(prev);
                    (*cur.as_ptr()).front = Some(in_back);
                    (*in_back.as_ptr()).back = Some(cur);
                } else {
                    // No prev, we're appending to the front
                    (*cur.as_ptr()).front = Some(in_back);
                    (*in_back.as_ptr()).back = Some(cur);
                    self.list.front = Some(in_front);
                }
                // Index moves forward by input length
                *self.index.as_mut().unwrap() += input.len;
            } else if let Some(back) = self.list.back {
                // We're on the ghost but non-empty, append to the back
                let in_front = input.front.take().unwrap();
                let in_back = input.back.take().unwrap();

                (*back.as_ptr()).back = Some(in_front);
                (*in_front.as_ptr()).front = Some(back);
                self.list.back = Some(in_back);
            } else {
                // We're empty, become the input, remain on the ghost
                std::mem::swap(self.list, &mut input);
            }

            self.list.len += input.len;
            // Not necessary but Polite To Do
            input.len = 0;

            // Input dropped here
        }
    }

    pub fn splice_after(&mut self, mut input: LinkedList<T>) {
        // We have this:
        //
        // input.front -> 1 <-> 2 <- input.back
        //
        // list.front -> A <-> B <-> C <- list.back
        //                     ^
        //                    cur
        //
        //
        // Becoming this:
        //
        // list.front -> A <-> B <-> 1 <-> 2 <-> C <- list.back
        //                     ^
        //                    cur
        //
        unsafe {
            // We can either `take` the input's pointers or `mem::forget`
            // it. Using `take` is more responsible in case we ever do custom
            // allocators or something that also needs to be cleaned up!
            if input.is_empty() {
                // Input is empty, do nothing.
            } else if let Some(cur) = self.cur {
                // Both lists are non-empty
                let in_front = input.front.take().unwrap();
                let in_back = input.back.take().unwrap();

                if let Some(next) = (*cur.as_ptr()).back {
                    // General Case, no boundaries, just internal fixups
                    (*next.as_ptr()).front = Some(in_back);
                    (*in_back.as_ptr()).back = Some(next);
                    (*cur.as_ptr()).back = Some(in_front);
                    (*in_front.as_ptr()).front = Some(cur);
                } else {
                    // No next, we're appending to the back
                    (*cur.as_ptr()).back = Some(in_front);
                    (*in_front.as_ptr()).front = Some(cur);
                    self.list.back = Some(in_back);
                }
                // Index doesn't change
            } else if let Some(front) = self.list.front {
                // We're on the ghost but non-empty, append to the front
                let in_front = input.front.take().unwrap();
                let in_back = input.back.take().unwrap();

                (*front.as_ptr()).front = Some(in_back);
                (*in_back.as_ptr()).back = Some(front);
                self.list.front = Some(in_front);
            } else {
                // We're empty, become the input, remain on the ghost
                std::mem::swap(self.list, &mut input);
            }

            self.list.len += input.len;
            // Not necessary but Polite To Do
            input.len = 0;

            // Input dropped here
        }
    }
}

unsafe impl<T: Send> Send for LinkedList<T> {}
unsafe impl<T: Sync> Sync for LinkedList<T> {}

unsafe impl<'a, T: Send> Send for Iter<'a, T> {}
unsafe impl<'a, T: Sync> Sync for Iter<'a, T> {}

unsafe impl<'a, T: Send> Send for IterMut<'a, T> {}
unsafe impl<'a, T: Sync> Sync for IterMut<'a, T> {}

#[allow(dead_code)]
fn assert_properties() {
    fn is_send<T: Send>() {}
    fn is_sync<T: Sync>() {}

    is_send::<LinkedList<i32>>();
    is_sync::<LinkedList<i32>>();

    is_send::<IntoIter<i32>>();
    is_sync::<IntoIter<i32>>();

    is_send::<Iter<i32>>();
    is_sync::<Iter<i32>>();

    is_send::<IterMut<i32>>();
    is_sync::<IterMut<i32>>();

    fn linked_list_covariant<'a, T>(x: LinkedList<&'static T>) -> LinkedList<&'a T> {
        x
    }
    fn iter_covariant<'i, 'a, T>(x: Iter<'i, &'static T>) -> Iter<'i, &'a T> {
        x
    }
    fn into_iter_covariant<'a, T>(x: IntoIter<&'static T>) -> IntoIter<&'a T> {
        x
    }

    /// ```compile_fail,E0308
    /// use linked_list::IterMut;
    ///
    /// fn iter_mut_covariant<'i, 'a, T>(x: IterMut<'i, &'static T>) -> IterMut<'i, &'a T> { x }
    /// ```
    fn iter_mut_invariant() {}
}

#[cfg(test)]
mod test {
    use super::LinkedList;

    fn generate_test() -> LinkedList<i32> {
        list_from(&[0, 1, 2, 3, 4, 5, 6])
    }

    fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {
        v.iter().map(|x| (*x).clone()).collect()
    }

    #[test]
    fn test_basic_front() {
        let mut list = LinkedList::new();

        // Try to break an empty list
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Try to break a one item list
        list.push_front(10);
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Mess around
        list.push_front(10);
        assert_eq!(list.len(), 1);
        list.push_front(20);
        assert_eq!(list.len(), 2);
        list.push_front(30);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(30));
        assert_eq!(list.len(), 2);
        list.push_front(40);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(40));
        assert_eq!(list.len(), 2);
        assert_eq!(list.pop_front(), Some(20));
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
    }

    #[test]
    fn test_basic() {
        let mut m = LinkedList::new();
        assert_eq!(m.pop_front(), None);
        assert_eq!(m.pop_back(), None);
        assert_eq!(m.pop_front(), None);
        m.push_front(1);
        assert_eq!(m.pop_front(), Some(1));
        m.push_back(2);
        m.push_back(3);
        assert_eq!(m.len(), 2);
        assert_eq!(m.pop_front(), Some(2));
        assert_eq!(m.pop_front(), Some(3));
        assert_eq!(m.len(), 0);
        assert_eq!(m.pop_front(), None);
        m.push_back(1);
        m.push_back(3);
        m.push_back(5);
        m.push_back(7);
        assert_eq!(m.pop_front(), Some(1));

        let mut n = LinkedList::new();
        n.push_front(2);
        n.push_front(3);
        {
            assert_eq!(n.front().unwrap(), &3);
            let x = n.front_mut().unwrap();
            assert_eq!(*x, 3);
            *x = 0;
        }
        {
            assert_eq!(n.back().unwrap(), &2);
            let y = n.back_mut().unwrap();
            assert_eq!(*y, 2);
            *y = 1;
        }
        assert_eq!(n.pop_front(), Some(0));
        assert_eq!(n.pop_front(), Some(1));
    }

    #[test]
    fn test_iterator() {
        let m = generate_test();
        for (i, elt) in m.iter().enumerate() {
            assert_eq!(i as i32, *elt);
        }
        let mut n = LinkedList::new();
        assert_eq!(n.iter().next(), None);
        n.push_front(4);
        let mut it = n.iter();
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(it.next().unwrap(), &4);
        assert_eq!(it.size_hint(), (0, Some(0)));
        assert_eq!(it.next(), None);
    }

    #[test]
    fn test_iterator_double_end() {
        let mut n = LinkedList::new();
        assert_eq!(n.iter().next(), None);
        n.push_front(4);
        n.push_front(5);
        n.push_front(6);
        let mut it = n.iter();
        assert_eq!(it.size_hint(), (3, Some(3)));
        assert_eq!(it.next().unwrap(), &6);
        assert_eq!(it.size_hint(), (2, Some(2)));
        assert_eq!(it.next_back().unwrap(), &4);
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(it.next_back().unwrap(), &5);
        assert_eq!(it.next_back(), None);
        assert_eq!(it.next(), None);
    }

    #[test]
    fn test_rev_iter() {
        let m = generate_test();
        for (i, elt) in m.iter().rev().enumerate() {
            assert_eq!(6 - i as i32, *elt);
        }
        let mut n = LinkedList::new();
        assert_eq!(n.iter().rev().next(), None);
        n.push_front(4);
        let mut it = n.iter().rev();
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(it.next().unwrap(), &4);
        assert_eq!(it.size_hint(), (0, Some(0)));
        assert_eq!(it.next(), None);
    }

    #[test]
    fn test_mut_iter() {
        let mut m = generate_test();
        let mut len = m.len();
        for (i, elt) in m.iter_mut().enumerate() {
            assert_eq!(i as i32, *elt);
            len -= 1;
        }
        assert_eq!(len, 0);
        let mut n = LinkedList::new();
        assert!(n.iter_mut().next().is_none());
        n.push_front(4);
        n.push_back(5);
        let mut it = n.iter_mut();
        assert_eq!(it.size_hint(), (2, Some(2)));
        assert!(it.next().is_some());
        assert!(it.next().is_some());
        assert_eq!(it.size_hint(), (0, Some(0)));
        assert!(it.next().is_none());
    }

    #[test]
    fn test_iterator_mut_double_end() {
        let mut n = LinkedList::new();
        assert!(n.iter_mut().next_back().is_none());
        n.push_front(4);
        n.push_front(5);
        n.push_front(6);
        let mut it = n.iter_mut();
        assert_eq!(it.size_hint(), (3, Some(3)));
        assert_eq!(*it.next().unwrap(), 6);
        assert_eq!(it.size_hint(), (2, Some(2)));
        assert_eq!(*it.next_back().unwrap(), 4);
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(*it.next_back().unwrap(), 5);
        assert!(it.next_back().is_none());
        assert!(it.next().is_none());
    }

    #[test]
    fn test_eq() {
        let mut n: LinkedList<u8> = list_from(&[]);
        let mut m = list_from(&[]);
        assert!(n == m);
        n.push_front(1);
        assert!(n != m);
        m.push_back(1);
        assert!(n == m);

        let n = list_from(&[2, 3, 4]);
        let m = list_from(&[1, 2, 3]);
        assert!(n != m);
    }

    #[test]
    fn test_ord() {
        let n = list_from(&[]);
        let m = list_from(&[1, 2, 3]);
        assert!(n < m);
        assert!(m > n);
        assert!(n <= n);
        assert!(n >= n);
    }

    #[test]
    fn test_ord_nan() {
        let nan = 0.0f64 / 0.0;
        let n = list_from(&[nan]);
        let m = list_from(&[nan]);
        assert!(!(n < m));
        assert!(!(n > m));
        assert!(!(n <= m));
        assert!(!(n >= m));

        let n = list_from(&[nan]);
        let one = list_from(&[1.0f64]);
        assert!(!(n < one));
        assert!(!(n > one));
        assert!(!(n <= one));
        assert!(!(n >= one));

        let u = list_from(&[1.0f64, 2.0, nan]);
        let v = list_from(&[1.0f64, 2.0, 3.0]);
        assert!(!(u < v));
        assert!(!(u > v));
        assert!(!(u <= v));
        assert!(!(u >= v));

        let s = list_from(&[1.0f64, 2.0, 4.0, 2.0]);
        let t = list_from(&[1.0f64, 2.0, 3.0, 2.0]);
        assert!(!(s < t));
        assert!(s > one);
        assert!(!(s <= one));
        assert!(s >= one);
    }

    #[test]
    fn test_debug() {
        let list: LinkedList<i32> = (0..10).collect();
        assert_eq!(format!("{:?}", list), "[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]");

        let list: LinkedList<&str> = vec!["just", "one", "test", "more"]
            .iter()
            .copied()
            .collect();
        assert_eq!(format!("{:?}", list), r#"["just", "one", "test", "more"]"#);
    }

    #[test]
    fn test_hashmap() {
        // Check that HashMap works with this as a key

        let list1: LinkedList<i32> = (0..10).collect();
        let list2: LinkedList<i32> = (1..11).collect();
        let mut map = std::collections::HashMap::new();

        assert_eq!(map.insert(list1.clone(), "list1"), None);
        assert_eq!(map.insert(list2.clone(), "list2"), None);

        assert_eq!(map.len(), 2);

        assert_eq!(map.get(&list1), Some(&"list1"));
        assert_eq!(map.get(&list2), Some(&"list2"));

        assert_eq!(map.remove(&list1), Some("list1"));
        assert_eq!(map.remove(&list2), Some("list2"));

        assert!(map.is_empty());
    }

    #[test]
    fn test_cursor_move_peek() {
        let mut m: LinkedList<u32> = LinkedList::new();
        m.extend([1, 2, 3, 4, 5, 6]);
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        assert_eq!(cursor.current(), Some(&mut 1));
        assert_eq!(cursor.peek_next(), Some(&mut 2));
        assert_eq!(cursor.peek_prev(), None);
        assert_eq!(cursor.index(), Some(0));
        cursor.move_prev();
        assert_eq!(cursor.current(), None);
        assert_eq!(cursor.peek_next(), Some(&mut 1));
        assert_eq!(cursor.peek_prev(), Some(&mut 6));
        assert_eq!(cursor.index(), None);
        cursor.move_next();
        cursor.move_next();
        assert_eq!(cursor.current(), Some(&mut 2));
        assert_eq!(cursor.peek_next(), Some(&mut 3));
        assert_eq!(cursor.peek_prev(), Some(&mut 1));
        assert_eq!(cursor.index(), Some(1));

        let mut cursor = m.cursor_mut();
        cursor.move_prev();
        assert_eq!(cursor.current(), Some(&mut 6));
        assert_eq!(cursor.peek_next(), None);
        assert_eq!(cursor.peek_prev(), Some(&mut 5));
        assert_eq!(cursor.index(), Some(5));
        cursor.move_next();
        assert_eq!(cursor.current(), None);
        assert_eq!(cursor.peek_next(), Some(&mut 1));
        assert_eq!(cursor.peek_prev(), Some(&mut 6));
        assert_eq!(cursor.index(), None);
        cursor.move_prev();
        cursor.move_prev();
        assert_eq!(cursor.current(), Some(&mut 5));
        assert_eq!(cursor.peek_next(), Some(&mut 6));
        assert_eq!(cursor.peek_prev(), Some(&mut 4));
        assert_eq!(cursor.index(), Some(4));
    }

    #[test]
    fn test_cursor_mut_insert() {
        let mut m: LinkedList<u32> = LinkedList::new();
        m.extend([1, 2, 3, 4, 5, 6]);
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.splice_before(Some(7).into_iter().collect());
        cursor.splice_after(Some(8).into_iter().collect());
        // check_links(&m);
        assert_eq!(
            m.iter().cloned().collect::<Vec<_>>(),
            &[7, 1, 8, 2, 3, 4, 5, 6]
        );
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_prev();
        cursor.splice_before(Some(9).into_iter().collect());
        cursor.splice_after(Some(10).into_iter().collect());
        check_links(&m);
        assert_eq!(
            m.iter().cloned().collect::<Vec<_>>(),
            &[10, 7, 1, 8, 2, 3, 4, 5, 6, 9]
        );

        /* remove_current not impl'd
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_prev();
        assert_eq!(cursor.remove_current(), None);
        cursor.move_next();
        cursor.move_next();
        assert_eq!(cursor.remove_current(), Some(7));
        cursor.move_prev();
        cursor.move_prev();
        cursor.move_prev();
        assert_eq!(cursor.remove_current(), Some(9));
        cursor.move_next();
        assert_eq!(cursor.remove_current(), Some(10));
        check_links(&m);
        assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[1, 8, 2, 3, 4, 5, 6]);
        */

        let mut m: LinkedList<u32> = LinkedList::new();
        m.extend([1, 8, 2, 3, 4, 5, 6]);
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        let mut p: LinkedList<u32> = LinkedList::new();
        p.extend([100, 101, 102, 103]);
        let mut q: LinkedList<u32> = LinkedList::new();
        q.extend([200, 201, 202, 203]);
        cursor.splice_after(p);
        cursor.splice_before(q);
        check_links(&m);
        assert_eq!(
            m.iter().cloned().collect::<Vec<_>>(),
            &[200, 201, 202, 203, 1, 100, 101, 102, 103, 8, 2, 3, 4, 5, 6]
        );
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_prev();
        let tmp = cursor.split_before();
        assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);
        m = tmp;
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        let tmp = cursor.split_after();
        assert_eq!(
            tmp.into_iter().collect::<Vec<_>>(),
            &[102, 103, 8, 2, 3, 4, 5, 6]
        );
        check_links(&m);
        assert_eq!(
            m.iter().cloned().collect::<Vec<_>>(),
            &[200, 201, 202, 203, 1, 100, 101]
        );
    }

    fn check_links<T: Eq + std::fmt::Debug>(list: &LinkedList<T>) {
        let from_front: Vec<_> = list.iter().collect();
        let from_back: Vec<_> = list.iter().rev().collect();
        let re_reved: Vec<_> = from_back.into_iter().rev().collect();

        assert_eq!(from_front, re_reved);
    }
}
```



================================================
FILE: src/too-many-lists/production-unsafe-deque/implementing-cursors.md
================================================
[Binary file]


================================================
FILE: src/too-many-lists/production-unsafe-deque/intro.md
================================================
# A Production-Quality Unsafe Doubly-Linked Deque

我们终于成功了。我最大的克星：**[std::collections::LinkedList](https://github.com/rust-lang/rust/blob/master/library/alloc/src/collections/linked_list.rs)，双向链接的 Deque**。

我尝试过但未能击败的那个。

来吧，我将向你展示你需要知道的一切，帮助我一劳永逸地摧毁它--实现一个 **unsafe** 的生产质量双向链接 Deque 所需要知道的一切。

我们将彻底重写我那古老的 Rust 1.0 linked-list crate，那个 linked-list 客观上比 std 要好，它从 2015 年开始，就存在 Cursors (游标，后面文章会介绍)！而标准库2022年了还没有的东西！



================================================
FILE: src/too-many-lists/production-unsafe-deque/layout.md
================================================
[Binary file]


================================================
FILE: src/too-many-lists/production-unsafe-deque/send-sync-and-compile-tests.md
================================================
# Send, Sync, and Compile Tests

好吧，其实我们还有一对特征需要考虑，但它们很特别。我们必须对付 Rust 的神圣罗马帝国： unsafe 的 Opt-in Built-out 特征（OIBITs）： Send 和 Sync，它们实际上是（opt-out）和（built-out）（3 个中有 1 个已经很不错了！）。

与 Copy 一样，这些特征完全没有相关代码，只是标记您的类型具有特定属性。Send 表示你的类型可以安全地发送到另一个线程。Sync 表示你的类型可以在线程间安全共享（&Self: Send）。

关于 LinkedList *covariant(协变的)* 论点在这里同样适用：一般来说，不使用花哨的内部可变技巧的普通集合可以安全地进行 Send 和 Sync。

But I said they're *opt out*. So actually, are we already? How would we know?

让我们在代码中添加一些新的魔法：随机的私有垃圾，除非我们的类型具有我们所期望的属性，否则将无法编译：

```rust
#[allow(dead_code)]
fn assert_properties() {
    fn is_send<T: Send>() {}
    fn is_sync<T: Sync>() {}

    is_send::<LinkedList<i32>>();
    is_sync::<LinkedList<i32>>();

    is_send::<IntoIter<i32>>();
    is_sync::<IntoIter<i32>>();

    is_send::<Iter<i32>>();
    is_sync::<Iter<i32>>();

    is_send::<IterMut<i32>>();
    is_sync::<IterMut<i32>>();

    is_send::<Cursor<i32>>();
    is_sync::<Cursor<i32>>();

    fn linked_list_covariant<'a, T>(x: LinkedList<&'static T>) -> LinkedList<&'a T> { x }
    fn iter_covariant<'i, 'a, T>(x: Iter<'i, &'static T>) -> Iter<'i, &'a T> { x }
    fn into_iter_covariant<'a, T>(x: IntoIter<&'static T>) -> IntoIter<&'a T> { x }
}
cargo build
   Compiling linked-list v0.0.3 
error[E0277]: `NonNull<Node<i32>>` cannot be sent between threads safely
   --> src\lib.rs:433:5
    |
433 |     is_send::<LinkedList<i32>>();
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ `NonNull<Node<i32>>` cannot be sent between threads safely
    |
    = help: within `LinkedList<i32>`, the trait `Send` is not implemented for `NonNull<Node<i32>>`
    = note: required because it appears within the type `Option<NonNull<Node<i32>>>`
note: required because it appears within the type `LinkedList<i32>`
   --> src\lib.rs:8:12
    |
8   | pub struct LinkedList<T> {
    |            ^^^^^^^^^^
note: required by a bound in `is_send`
   --> src\lib.rs:430:19
    |
430 |     fn is_send<T: Send>() {}
    |                   ^^^^ required by this bound in `is_send`

<a million more errors>
```

我骗你说原始指针只有一个安全保护：这是另一个。 `*const` 和 `*mut` explicitly opt out of Send and Sync to be safe, so we do *actually* have to opt back in:

```rust
unsafe impl<T: Send> Send for LinkedList<T> {}
unsafe impl<T: Sync> Sync for LinkedList<T> {}

unsafe impl<'a, T: Send> Send for Iter<'a, T> {}
unsafe impl<'a, T: Sync> Sync for Iter<'a, T> {}

unsafe impl<'a, T: Send> Send for IterMut<'a, T> {}
unsafe impl<'a, T: Sync> Sync for IterMut<'a, T> {}
```

请注意，我们必须在这里编写不安全的 impl：这些是不安全的特征！不安全代码（如并发库）只能依靠我们正确地实现这些特征！由于没有实际代码，我们所做的保证只是：是的，我们在线程间发送或共享确实是安全的！

别以为这些都是随便说说的，我可是经过认证的专业人士，我在这里要说：是的，这些都是完全没问题的。请注意，我们并不需要为 IntoIter 实现 Send 和 Sync：它只是包含 LinkedList，所以会自动生成 Send 和 Sync--我告诉过你它们实际上是 opt out！

```text
cargo build
   Compiling linked-list v0.0.3
    Finished dev [unoptimized + debuginfo] target(s) in 0.18s
```

很好

IterMut 绝对不应该是协变的，因为它 "就像" `&mut T`。

用魔术！其实是用 rustdoc！好吧，我们不一定要使用 rustdoc，但这是最有趣的用法。你看，如果你写了一个 doccomment 并包含了一个代码块，那么 rustdoc 就会尝试编译并运行它，所以我们可以用它来创建新的匿名 "程序"，而这些程序不会影响主程序：

```rust
    /// ```
    /// use linked_list::IterMut;
    /// 
    /// fn iter_mut_covariant<'i, 'a, T>(x: IterMut<'i, &'static T>) -> IterMut<'i, &'a T> { x }
    /// ```
    fn iter_mut_invariant() {}
cargo test

...

   Doc-tests linked-list

running 1 test
test src\lib.rs - assert_properties::iter_mut_invariant (line 458) ... FAILED

failures:

---- src\lib.rs - assert_properties::iter_mut_invariant (line 458) stdout ----
error[E0308]: mismatched types
 --> src\lib.rs:461:86
  |
6 | fn iter_mut_covariant<'i, 'a, T>(x: IterMut<'i, &'static T>) -> IterMut<'i, &'a T> { x }
  |                                                                                      ^ lifetime mismatch
  |
  = note: expected struct `linked_list::IterMut<'_, &'a T>`
             found struct `linked_list::IterMut<'_, &'static T>`
```

好吧，我们已经证明了它是不变的，但现在我们的测试失败了。不用担心，rustdoc 会让你在栅栏上注释 compile_fail，说明这是意料之中的！

(实际上，我们只证明了它 "不是*covariant(协变的)*"，但老实说，如果你能让一个类型 "意外地、错误地*contravariant(逆变的)* "，那么，恭喜你。）

```rust
    /// ```compile_fail
    /// use linked_list::IterMut;
    /// 
    /// fn iter_mut_covariant<'i, 'a, T>(x: IterMut<'i, &'static T>) -> IterMut<'i, &'a T> { x }
    /// ```
    fn iter_mut_invariant() {}
cargo test
   Compiling linked-list v0.0.3
    Finished test [unoptimized + debuginfo] target(s) in 0.49s
     Running unittests src\lib.rs

...

   Doc-tests linked-list

running 1 test
test src\lib.rs - assert_properties::iter_mut_invariant (line 458) - compile fail ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.12s
```

是的！我建议在进行测试时不要使用 compile_fail，这样你可以看到错误是不是和你预期的一致。例如，你忘记了使用 use 关键字，这是错误的，但因为 compile_fail通过了测试。如果不使用compile_fail，测试会因为没有使用 use 失败，这不是我们想要的， 我们想要的是：测试因为 `mut` 是*covariant(协变的)*的而失败！

(哦，等等，我们其实可以在 compile_fail 旁边指定我们想要的错误代码，但这只适用于 nightly，而且由于上述原因，依赖它是个坏主意。在 not-nightly 版本运行时，它将被默默忽略）。

```rust
    /// ```compile_fail,E0308
    /// use linked_list::IterMut;
    /// 
    /// fn iter_mut_covariant<'i, 'a, T>(x: IterMut<'i, &'static T>) -> IterMut<'i, &'a T> { x }
    /// ```
    fn iter_mut_invariant() {}
```

......还有，你注意到我们实际上把 IterMut 变成*invariant(不变的)*的那部分了吗？这很容易被忽略，因为我 "只是 "复制粘贴了 Iter 并把它放在了最后。这是最后一行：

```rust
pub struct IterMut<'a, T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
    _boo: PhantomData<&'a mut T>,
}
```

我们试着去掉 PhantomData:

```text
 cargo build
   Compiling linked-list v0.0.3 (C:\Users\ninte\dev\contain\linked-list)
error[E0392]: parameter `'a` is never used
  --> src\lib.rs:30:20
   |
30 | pub struct IterMut<'a, T> {
   |                    ^^ unused parameter
   |
   = help: consider removing `'a`, referring to it in a field, or using a marker such as `PhantomData`
```

哈！编译器在背后支持我们，提示我们未使用的 lifetime。让我们试着用一个错误的例子来代替：

```rust
    _boo: PhantomData<&'a T>,
cargo build
   Compiling linked-list v0.0.3 (C:\Users\ninte\dev\contain\linked-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
```

它可以构建！我们的测试可以发现问题吗？

```text
cargo test

...

   Doc-tests linked-list

running 1 test
test src\lib.rs - assert_properties::iter_mut_invariant (line 458) - compile fail ... FAILED

failures:

---- src\lib.rs - assert_properties::iter_mut_invariant (line 458) stdout ----
Test compiled successfully, but it's marked `compile_fail`.

failures:
    src\lib.rs - assert_properties::iter_mut_invariant (line 458)

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.15s
```

Eyyy!!.！这个系统真管用！我喜欢那些能真正完成任务的测试，这样我就不必为那些若隐若现的错误而感到恐惧了！



================================================
FILE: src/too-many-lists/production-unsafe-deque/testing-cursors.md
================================================
# Testing Cursors

是时候找出我在上一节中犯了多少令人尴尬的错误了！

哦，天哪，我们的 API 既不像标准版，也不像旧版。好吧，那我打算从这两个地方拼凑一些东西吧。是的，让我们 "借用 " 标准版中的这些测试：

```rust
    #[test]
    fn test_cursor_move_peek() {
        let mut m: LinkedList<u32> = LinkedList::new();
        m.extend([1, 2, 3, 4, 5, 6]);
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        assert_eq!(cursor.current(), Some(&mut 1));
        assert_eq!(cursor.peek_next(), Some(&mut 2));
        assert_eq!(cursor.peek_prev(), None);
        assert_eq!(cursor.index(), Some(0));
        cursor.move_prev();
        assert_eq!(cursor.current(), None);
        assert_eq!(cursor.peek_next(), Some(&mut 1));
        assert_eq!(cursor.peek_prev(), Some(&mut 6));
        assert_eq!(cursor.index(), None);
        cursor.move_next();
        cursor.move_next();
        assert_eq!(cursor.current(), Some(&mut 2));
        assert_eq!(cursor.peek_next(), Some(&mut 3));
        assert_eq!(cursor.peek_prev(), Some(&mut 1));
        assert_eq!(cursor.index(), Some(1));

        let mut cursor = m.cursor_mut();
        cursor.move_prev();
        assert_eq!(cursor.current(), Some(&mut 6));
        assert_eq!(cursor.peek_next(), None);
        assert_eq!(cursor.peek_prev(), Some(&mut 5));
        assert_eq!(cursor.index(), Some(5));
        cursor.move_next();
        assert_eq!(cursor.current(), None);
        assert_eq!(cursor.peek_next(), Some(&mut 1));
        assert_eq!(cursor.peek_prev(), Some(&mut 6));
        assert_eq!(cursor.index(), None);
        cursor.move_prev();
        cursor.move_prev();
        assert_eq!(cursor.current(), Some(&mut 5));
        assert_eq!(cursor.peek_next(), Some(&mut 6));
        assert_eq!(cursor.peek_prev(), Some(&mut 4));
        assert_eq!(cursor.index(), Some(4));
    }

    #[test]
    fn test_cursor_mut_insert() {
        let mut m: LinkedList<u32> = LinkedList::new();
        m.extend([1, 2, 3, 4, 5, 6]);
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.splice_before(Some(7).into_iter().collect());
        cursor.splice_after(Some(8).into_iter().collect());
        // check_links(&m);
        assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[7, 1, 8, 2, 3, 4, 5, 6]);
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_prev();
        cursor.splice_before(Some(9).into_iter().collect());
        cursor.splice_after(Some(10).into_iter().collect());
        check_links(&m);
        assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[10, 7, 1, 8, 2, 3, 4, 5, 6, 9]);
        
        /* remove_current not impl'd
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_prev();
        assert_eq!(cursor.remove_current(), None);
        cursor.move_next();
        cursor.move_next();
        assert_eq!(cursor.remove_current(), Some(7));
        cursor.move_prev();
        cursor.move_prev();
        cursor.move_prev();
        assert_eq!(cursor.remove_current(), Some(9));
        cursor.move_next();
        assert_eq!(cursor.remove_current(), Some(10));
        check_links(&m);
        assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[1, 8, 2, 3, 4, 5, 6]);
        */

       let mut m: LinkedList<u32> = LinkedList::new();
    m.extend([1, 8, 2, 3, 4, 5, 6]);
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        let mut p: LinkedList<u32> = LinkedList::new();
        p.extend([100, 101, 102, 103]);
        let mut q: LinkedList<u32> = LinkedList::new();
        q.extend([200, 201, 202, 203]);
        cursor.splice_after(p);
        cursor.splice_before(q);
        check_links(&m);
        assert_eq!(
            m.iter().cloned().collect::<Vec<_>>(),
            &[200, 201, 202, 203, 1, 100, 101, 102, 103, 8, 2, 3, 4, 5, 6]
        );
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_prev();
        let tmp = cursor.split_before();
        assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);
        m = tmp;
        let mut cursor = m.cursor_mut();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        cursor.move_next();
        let tmp = cursor.split_after();
        assert_eq!(tmp.into_iter().collect::<Vec<_>>(), &[102, 103, 8, 2, 3, 4, 5, 6]);
        check_links(&m);
        assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[200, 201, 202, 203, 1, 100, 101]);
    }

    fn check_links<T>(_list: &LinkedList<T>) {
        // would be good to do this!
    }
```

见证奇迹的时候！

```text
cargo test

   Compiling linked-list v0.0.3
    Finished test [unoptimized + debuginfo] target(s) in 1.03s
     Running unittests src\lib.rs

running 14 tests
test test::test_basic_front ... ok
test test::test_basic ... ok
test test::test_debug ... ok
test test::test_iterator_mut_double_end ... ok
test test::test_ord ... ok
test test::test_cursor_move_peek ... FAILED
test test::test_cursor_mut_insert ... FAILED
test test::test_iterator ... ok
test test::test_mut_iter ... ok
test test::test_eq ... ok
test test::test_rev_iter ... ok
test test::test_iterator_double_end ... ok
test test::test_hashmap ... ok
test test::test_ord_nan ... ok

failures:

---- test::test_cursor_move_peek stdout ----
thread 'test::test_cursor_move_peek' panicked at 'assertion failed: `(left == right)`
  left: `None`,
 right: `Some(1)`', src\lib.rs:1079:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

---- test::test_cursor_mut_insert stdout ----
thread 'test::test_cursor_mut_insert' panicked at 'assertion failed: `(left == right)`
  left: `[200, 201, 202, 203, 10, 100, 101, 102, 103, 7, 1, 8, 2, 3, 4, 5, 6, 9]`,
 right: `[200, 201, 202, 203, 1, 100, 101, 102, 103, 8, 2, 3, 4, 5, 6]`', src\lib.rs:1153:9


failures:
    test::test_cursor_move_peek
    test::test_cursor_mut_insert

test result: FAILED. 12 passed; 2 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

我得承认，我在这里有些自负，希望自己能成功。这就是我们写测试的原因（但也许我只是在移植测试时做得不好？）

第一次失败是什么？

```rust
let mut m: LinkedList<u32> = LinkedList::new();
m.extend([1, 2, 3, 4, 5, 6]);
let mut cursor = m.cursor_mut();

cursor.move_next();
assert_eq!(cursor.current(), Some(&mut 1));
assert_eq!(cursor.peek_next(), Some(&mut 2));
assert_eq!(cursor.peek_prev(), None);
assert_eq!(cursor.index(), Some(0));

cursor.move_prev();
assert_eq!(cursor.current(), None);
assert_eq!(cursor.peek_next(), Some(&mut 1)); // DIES HERE
```

```rust
pub fn peek_next(&mut self) -> Option<&mut T> {
    unsafe {
        self.cur
            .and_then(|node| (*node.as_ptr()).back)
            .map(|node| &mut (*node.as_ptr()).elem)
    }
}
```

就是这错了。如果 `self.cur` 是 None, 我们不应该就这样放弃，我们还需要检查 self.list.front，因为我们在幽灵节点上！因此，我们只需在链中添加一个 or_else：

```rust
pub fn peek_next(&mut self) -> Option<&mut T> {
    unsafe {
        self.cur
            .and_then(|node| (*node.as_ptr()).back)
            .or_else(|| self.list.front)
            .map(|node| &mut (*node.as_ptr()).elem)
    }
}

pub fn peek_prev(&mut self) -> Option<&mut T> {
    unsafe {
        self.cur
            .and_then(|node| (*node.as_ptr()).front)
            .or_else(|| self.list.back)
            .map(|node| &mut (*node.as_ptr()).elem)
    }
}
```

这样就修复好了吗？

```text
---- test::test_cursor_move_peek stdout ----
thread 'test::test_cursor_move_peek' panicked at 'assertion failed: `(left == right)`
  left: `Some(6)`,
 right: `None`', src\lib.rs:1078:9
```

又错了。好吧，显然这比我想象的要难得多。盲目地把这些情况串联起来简直是一场灾难，让我们对幽灵节点与非幽灵节点的情况做不同的判断吧：

```rust
pub fn peek_next(&mut self) -> Option<&mut T> {
    unsafe {
        let next = if let Some(cur) = self.cur {
            // Normal case, try to follow the cur node's back pointer
            (*cur.as_ptr()).back
        } else {
            // Ghost case, try to use the list's front pointer
            self.list.front
        };

        // Yield the element if the next node exists
        next.map(|node| &mut (*node.as_ptr()).elem)
    }
}

pub fn peek_prev(&mut self) -> Option<&mut T> {
    unsafe {
        let prev = if let Some(cur) = self.cur {
            // Normal case, try to follow the cur node's front pointer
            (*cur.as_ptr()).front
        } else {
            // Ghost case, try to use the list's back pointer
            self.list.back
        };

        // Yield the element if the prev node exists
        prev.map(|node| &mut (*node.as_ptr()).elem)
    }
}
```

我对这一次充满信心！

```rust

 cargo test
   Compiling linked-list v0.0.3
    Finished test [unoptimized + debuginfo] target(s) in 0.70s
     Running unittests src\lib.rs

running 14 tests
test test::test_basic_front ... ok
test test::test_basic ... ok
test test::test_cursor_move_peek ... ok
test test::test_eq ... ok
test test::test_cursor_mut_insert ... ok
test test::test_iterator ... ok
test test::test_iterator_double_end ... ok
test test::test_ord_nan ... ok
test test::test_mut_iter ... ok
test test::test_hashmap ... ok
test test::test_debug ... ok
test test::test_ord ... ok
test test::test_iterator_mut_double_end ... ok
test test::test_rev_iter ... ok

test result: ok. 14 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests linked-list

running 1 test
test src\lib.rs - assert_properties::iter_mut_invariant (line 803) - compile fail ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.12s
```

嘿嘿，看看这个......好吧，现在我开始疑神疑鬼了。让我们正确填写 check_links，并在 miri 下进行测试：

```rust
fn check_links<T: Eq + std::fmt::Debug>(list: &LinkedList<T>) {
    let from_front: Vec<_> = list.iter().collect();
    let from_back: Vec<_> = list.iter().rev().collect();
    let re_reved: Vec<_> = from_back.into_iter().rev().collect();

    assert_eq!(from_front, re_reved);
}
```

```text
$env:MIRIFLAGS="-Zmiri-tag-raw-pointers"
cargo miri test
   Compiling linked-list v0.0.3
    Finished test [unoptimized + debuginfo] target(s) in 0.25s
     Running unittests src\lib.rs

running 14 tests
test test::test_basic ... ok
test test::test_basic_front ... ok
test test::test_cursor_move_peek ... ok
test test::test_cursor_mut_insert ... ok
test test::test_debug ... ok
test test::test_eq ... ok
test test::test_hashmap ... ok
test test::test_iterator ... ok
test test::test_iterator_double_end ... ok
test test::test_iterator_mut_double_end ... ok
test test::test_mut_iter ... ok
test test::test_ord ... ok
test test::test_ord_nan ... ok
test test::test_rev_iter ... ok

test result: ok. 14 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests linked-list

running 1 test
test src\lib.rs - assert_properties::iter_mut_invariant (line 803) - compile fail ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.10s
```

完成。

我们成功了 我们做出了一个具有生产质量的 LinkedList，其功能与 std 中的 LinkedList 基本相同。我们是否在这里或那里缺少了一些小的便利方法？当然有。我会把它们添加到最终发布的版本中吗？也许会！

但是，我已经非常累了。

所以。我们赢了

等等 我们正在生产质量。好吧，最后一个步骤： clippy。

```text
cargo clippy

cargo clippy
    Checking linked-list v0.0.3 (C:\Users\ninte\dev\contain\linked-list)
warning: redundant pattern matching, consider using `is_some()`
   --> src\lib.rs:189:19
    |
189 |         while let Some(_) = self.pop_front() { }
    |         ----------^^^^^^^------------------- help: try this: `while self.pop_front().is_some()`
    |
    = note: `#[warn(clippy::redundant_pattern_matching)]` on by default
    = note: this will change drop order of the result, as well as all temporaries
    = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important
    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#redundant_pattern_matching

warning: method `into_iter` can be confused for the standard trait method `std::iter::IntoIterator::into_iter`
   --> src\lib.rs:210:5
    |
210 | /     pub fn into_iter(self) -> IntoIter<T> {
211 | |         IntoIter {
212 | |             list: self
213 | |         }
214 | |     }
    | |_____^
    |
    = note: `#[warn(clippy::should_implement_trait)]` on by default
    = help: consider implementing the trait `std::iter::IntoIterator` or choosing a less ambiguous method name
    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#should_implement_trait

warning: redundant pattern matching, consider using `is_some()`
   --> src\lib.rs:228:19
    |
228 |         while let Some(_) = self.pop_front() { }
    |         ----------^^^^^^^------------------- help: try this: `while self.pop_front().is_some()`
    |
    = note: this will change drop order of the result, as well as all temporaries
    = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important
    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#redundant_pattern_matching

warning: re-implementing `PartialEq::ne` is unnecessary
   --> src\lib.rs:275:5
    |
275 | /     fn ne(&self, other: &Self) -> bool {
276 | |         self.len() != other.len() || self.iter().ne(other)
277 | |     }
    | |_____^
    |
    = note: `#[warn(clippy::partialeq_ne_impl)]` on by default
    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#partialeq_ne_impl

warning: `linked-list` (lib) generated 4 warnings
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
```

好的 clippy, 按照你的要求修改。

再来一次：

```text
cargo clippy
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
```

太棒了，称为生产品质的最后一件事: fmt.

```text
cargo fmt
```

**我们现在终于真正的完成啦!!!!!!!!!!!!!!!!!!!!!**



================================================
FILE: src/too-many-lists/production-unsafe-deque/testing.md
================================================
# Testing

好吧，我推迟了一段时间测试，因为我们都知道，我们现在是 Rust 的主人，不会再犯错了！另外，这是对一个旧 crate 的重写，所以我已经有了所有的测试。你已经看过很多测试了。它们就在这里：

```rust
#[cfg(test)]
mod test {
    use super::LinkedList;

    fn generate_test() -> LinkedList<i32> {
        list_from(&[0, 1, 2, 3, 4, 5, 6])
    }

    fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {
        v.iter().map(|x| (*x).clone()).collect()
    }

    #[test]
    fn test_basic_front() {
        let mut list = LinkedList::new();

        // Try to break an empty list
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Try to break a one item list
        list.push_front(10);
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);

        // Mess around
        list.push_front(10);
        assert_eq!(list.len(), 1);
        list.push_front(20);
        assert_eq!(list.len(), 2);
        list.push_front(30);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(30));
        assert_eq!(list.len(), 2);
        list.push_front(40);
        assert_eq!(list.len(), 3);
        assert_eq!(list.pop_front(), Some(40));
        assert_eq!(list.len(), 2);
        assert_eq!(list.pop_front(), Some(20));
        assert_eq!(list.len(), 1);
        assert_eq!(list.pop_front(), Some(10));
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
        assert_eq!(list.pop_front(), None);
        assert_eq!(list.len(), 0);
    }

    #[test]
    fn test_basic() {
        let mut m = LinkedList::new();
        assert_eq!(m.pop_front(), None);
        assert_eq!(m.pop_back(), None);
        assert_eq!(m.pop_front(), None);
        m.push_front(1);
        assert_eq!(m.pop_front(), Some(1));
        m.push_back(2);
        m.push_back(3);
        assert_eq!(m.len(), 2);
        assert_eq!(m.pop_front(), Some(2));
        assert_eq!(m.pop_front(), Some(3));
        assert_eq!(m.len(), 0);
        assert_eq!(m.pop_front(), None);
        m.push_back(1);
        m.push_back(3);
        m.push_back(5);
        m.push_back(7);
        assert_eq!(m.pop_front(), Some(1));

        let mut n = LinkedList::new();
        n.push_front(2);
        n.push_front(3);
        {
            assert_eq!(n.front().unwrap(), &3);
            let x = n.front_mut().unwrap();
            assert_eq!(*x, 3);
            *x = 0;
        }
        {
            assert_eq!(n.back().unwrap(), &2);
            let y = n.back_mut().unwrap();
            assert_eq!(*y, 2);
            *y = 1;
        }
        assert_eq!(n.pop_front(), Some(0));
        assert_eq!(n.pop_front(), Some(1));
    }

    #[test]
    fn test_iterator() {
        let m = generate_test();
        for (i, elt) in m.iter().enumerate() {
            assert_eq!(i as i32, *elt);
        }
        let mut n = LinkedList::new();
        assert_eq!(n.iter().next(), None);
        n.push_front(4);
        let mut it = n.iter();
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(it.next().unwrap(), &4);
        assert_eq!(it.size_hint(), (0, Some(0)));
        assert_eq!(it.next(), None);
    }

    #[test]
    fn test_iterator_double_end() {
        let mut n = LinkedList::new();
        assert_eq!(n.iter().next(), None);
        n.push_front(4);
        n.push_front(5);
        n.push_front(6);
        let mut it = n.iter();
        assert_eq!(it.size_hint(), (3, Some(3)));
        assert_eq!(it.next().unwrap(), &6);
        assert_eq!(it.size_hint(), (2, Some(2)));
        assert_eq!(it.next_back().unwrap(), &4);
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(it.next_back().unwrap(), &5);
        assert_eq!(it.next_back(), None);
        assert_eq!(it.next(), None);
    }

    #[test]
    fn test_rev_iter() {
        let m = generate_test();
        for (i, elt) in m.iter().rev().enumerate() {
            assert_eq!(6 - i as i32, *elt);
        }
        let mut n = LinkedList::new();
        assert_eq!(n.iter().rev().next(), None);
        n.push_front(4);
        let mut it = n.iter().rev();
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(it.next().unwrap(), &4);
        assert_eq!(it.size_hint(), (0, Some(0)));
        assert_eq!(it.next(), None);
    }

    #[test]
    fn test_mut_iter() {
        let mut m = generate_test();
        let mut len = m.len();
        for (i, elt) in m.iter_mut().enumerate() {
            assert_eq!(i as i32, *elt);
            len -= 1;
        }
        assert_eq!(len, 0);
        let mut n = LinkedList::new();
        assert!(n.iter_mut().next().is_none());
        n.push_front(4);
        n.push_back(5);
        let mut it = n.iter_mut();
        assert_eq!(it.size_hint(), (2, Some(2)));
        assert!(it.next().is_some());
        assert!(it.next().is_some());
        assert_eq!(it.size_hint(), (0, Some(0)));
        assert!(it.next().is_none());
    }

    #[test]
    fn test_iterator_mut_double_end() {
        let mut n = LinkedList::new();
        assert!(n.iter_mut().next_back().is_none());
        n.push_front(4);
        n.push_front(5);
        n.push_front(6);
        let mut it = n.iter_mut();
        assert_eq!(it.size_hint(), (3, Some(3)));
        assert_eq!(*it.next().unwrap(), 6);
        assert_eq!(it.size_hint(), (2, Some(2)));
        assert_eq!(*it.next_back().unwrap(), 4);
        assert_eq!(it.size_hint(), (1, Some(1)));
        assert_eq!(*it.next_back().unwrap(), 5);
        assert!(it.next_back().is_none());
        assert!(it.next().is_none());
    }

    #[test]
    fn test_eq() {
        let mut n: LinkedList<u8> = list_from(&[]);
        let mut m = list_from(&[]);
        assert!(n == m);
        n.push_front(1);
        assert!(n != m);
        m.push_back(1);
        assert!(n == m);

        let n = list_from(&[2, 3, 4]);
        let m = list_from(&[1, 2, 3]);
        assert!(n != m);
    }

    #[test]
    fn test_ord() {
        let n = list_from(&[]);
        let m = list_from(&[1, 2, 3]);
        assert!(n < m);
        assert!(m > n);
        assert!(n <= n);
        assert!(n >= n);
    }

    #[test]
    fn test_ord_nan() {
        let nan = 0.0f64 / 0.0;
        let n = list_from(&[nan]);
        let m = list_from(&[nan]);
        assert!(!(n < m));
        assert!(!(n > m));
        assert!(!(n <= m));
        assert!(!(n >= m));

        let n = list_from(&[nan]);
        let one = list_from(&[1.0f64]);
        assert!(!(n < one));
        assert!(!(n > one));
        assert!(!(n <= one));
        assert!(!(n >= one));

        let u = list_from(&[1.0f64, 2.0, nan]);
        let v = list_from(&[1.0f64, 2.0, 3.0]);
        assert!(!(u < v));
        assert!(!(u > v));
        assert!(!(u <= v));
        assert!(!(u >= v));

        let s = list_from(&[1.0f64, 2.0, 4.0, 2.0]);
        let t = list_from(&[1.0f64, 2.0, 3.0, 2.0]);
        assert!(!(s < t));
        assert!(s > one);
        assert!(!(s <= one));
        assert!(s >= one);
    }

    #[test]
    fn test_debug() {
        let list: LinkedList<i32> = (0..10).collect();
        assert_eq!(format!("{:?}", list), "[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]");

        let list: LinkedList<&str> = vec!["just", "one", "test", "more"]
            .iter().copied()
            .collect();
        assert_eq!(format!("{:?}", list), r#"["just", "one", "test", "more"]"#);
    }

    #[test]
    fn test_hashmap() {
        // Check that HashMap works with this as a key

        let list1: LinkedList<i32> = (0..10).collect();
        let list2: LinkedList<i32> = (1..11).collect();
        let mut map = std::collections::HashMap::new();

        assert_eq!(map.insert(list1.clone(), "list1"), None);
        assert_eq!(map.insert(list2.clone(), "list2"), None);

        assert_eq!(map.len(), 2);

        assert_eq!(map.get(&list1), Some(&"list1"));
        assert_eq!(map.get(&list2), Some(&"list2"));

        assert_eq!(map.remove(&list1), Some("list1"));
        assert_eq!(map.remove(&list2), Some("list2"));

        assert!(map.is_empty());
    }
}
```

现在是关键时刻：

```text
cargo test
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests src\lib.rs

running 12 tests
test test::test_basic ... ok
test test::test_basic_front ... ok
test test::test_eq ... ok
test test::test_iterator ... ok
test test::test_iterator_mut_double_end ... ok
test test::test_ord_nan ... ok
test test::test_iterator_double_end ... ok
test test::test_mut_iter ... ok
test test::test_rev_iter ... ok
test test::test_hashmap ... ok
test test::test_ord ... ok
test test::test_debug ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
$env:MIRIFLAGS="-Zmiri-tag-raw-pointers"
cargo miri test
   Compiling linked-list v0.0.3
    Finished test [unoptimized + debuginfo] target(s) in 0.35s
     Running unittests src\lib.rs

running 12 tests
test test::test_basic ... ok
test test::test_basic_front ... ok
test test::test_debug ... ok
test test::test_eq ... ok
test test::test_hashmap ... ok
test test::test_iterator ... ok
test test::test_iterator_double_end ... ok
test test::test_iterator_mut_double_end ... ok
test test::test_mut_iter ... ok
test test::test_ord ... ok
test test::test_ord_nan ... ok
test test::test_rev_iter ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

😭

我们做到了，我们真的没有搞砸。这不是小把戏！我们所有的练习和训练终于值得了！我们终于写出了好代码

现在，我们可以回到 "有趣的事情 "上来了！



================================================
FILE: src/too-many-lists/production-unsafe-deque/variance-and-phantomData.md
================================================
# Variance and PhantomData

如果现在不做，等以后再修，会很麻烦，所以我们现在要做的是硬核布局。

建造 Rust collections 时，有这五个可怕的难题：

1. [Variance](https://doc.rust-lang.org/nightly/nomicon/subtyping.html)
2. [Drop Check](https://doc.rust-lang.org/nightly/nomicon/dropck.html)
3. [NonNull Optimizations](https://doc.rust-lang.org/nightly/std/ptr/struct.NonNull.html)
4. [The isize::MAX Allocation Rule](https://doc.rust-lang.org/nightly/nomicon/vec/vec-alloc.html)
5. [Zero-Sized Types](https://doc.rust-lang.org/nightly/nomicon/vec/vec-zsts.html)

幸好，后面2个对我们来说都不是问题。

我们可以把第三个问题变成我们的问题，但这带来的麻烦比它的价值更多。

第二个问题是我以前一直坚持认为非常重要的，std 也会乱用它，但默认值是安全的，而且你需要非常努力才能注意到默认值的限制，所以不用担心这个问题。

所以只剩下了 Variance(型变)。

Rust 有子类型了。通常，`&'big T`  是 `&'small T` 的子类型。因为如果某些代码需要在程序的某个特定区域存活的引用，那么通常完全可以给它一个存在*时间更长的*引用。直觉上这是正确的，对吧？

为什么这很重要？想象一下，一些代码采用两个具有相同类型的值：

```rust
fn take_two<T>(_val1: T, _val2: T) { }
```

这是一些非常无聊的代码，并且我们期望它能够很好地与 T=&u32 一起使用，对吧？

```rust
fn two_refs<'big: 'small, 'small>(
    big: &'big u32, 
    small: &'small u32,
) {
    take_two(big, small);
}

fn take_two<T>(_val1: T, _val2: T) { }
```

是的，编译得很好！

现在让我们找点乐子，把它包起来：`std::cell::Cell`

```rust
use std::cell::Cell;

fn two_refs<'big: 'small, 'small>(
    // NOTE: these two lines changed
    big: Cell<&'big u32>, 
    small: Cell<&'small u32>,
) {
    take_two(big, small);
}

fn take_two<T>(_val1: T, _val2: T) { }
error[E0623]: lifetime mismatch
 --> src/main.rs:7:19
  |
4 |     big: Cell<&'big u32>, 
  |               ---------
5 |     small: Cell<&'small u32>,
  |                 ----------- these two types are declared with different lifetimes...
6 | ) {
7 |     take_two(big, small);
  |                   ^^^^^ ...but data from `small` flows into `big` here
```

哼？？？我们没有碰过生命周期，为什么编译器现在生气了！？

啊，好吧，生命周期的“子类型”必须非常简单，所以如果你将引用包装在任何东西中，它就会被破坏，看看 Vec：

```rust
fn two_refs<'big: 'small, 'small>(
    big: Vec<&'big u32>, 
    small: Vec<&'small u32>,
) {
    take_two(big, small);
}

fn take_two<T>(_val1: T, _val2: T) { }
    Finished dev [unoptimized + debuginfo] target(s) in 1.07s
     Running `target/debug/playground`
```

看到它没有编译成功 ——等等???Vec是魔术??????

是的。这种魔力就是✨*Variance*✨。

如果您想要所有细节，请阅读 [nomicon 关于子类型的章节](https://doc.rust-lang.org/nightly/nomicon/subtyping.html)，但基本上子类型*并不总是*安全的。特别是，当涉及可变引用时，它就更不安全了，。因为你可能会使用诸如`mem::swap`的东西，突然哎呀，悬空指针！

可变引用是 *invariant(不变的)*，这意味着它们会阻止对泛型参数子类型化。因此，为了安全起见， `&mut T` 在 T 上是不变的，并且 `Cell<T>` 在 T 上也是不变的（因为内部可变性），因为 `&Cell<T>` 本质上就像 `&mut T`。

几乎所有不是 *invariant* 的东西都是 *covariant(协变的)* ，这意味着子类型可以正常工作（也有 *contravariant(逆变的)* 的类型使子类型倒退，但它们真的很少见，没有人喜欢它们，所以我不会再提到它们）。

集合通常包含指向其数据的可变指针，因此你可能希望它们也是不变的，但事实上，它们并不需要不变！由于 Rust 的所有权系统，`Vec<T>` 在语义上等同于 `T`，这意味着它可以安全地保持*covariant(协变的)* ！

不幸的的是，下面的定义是 *invariant(不变的)*:

```rust
pub struct LinkedList<T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
}

type Link<T> = *mut Node<T>;

struct Node<T> {
    front: Link<T>,
    back: Link<T>,
    elem: T, 
}
```

所以我们的类型定义中哪里惹 Rust 编译器不高兴了? `*mut`！

Rust 中的裸指针其实就是让你可以做任何事情，但它们只有一个安全特性：因为大多数人都不知道 Rust 中还有 *Variance(型变)* 和子类型，而错误地使用 *covariant(协变的)* 会非常危险，所以 `*mut T` 是*invariant(不变的)*，因为它很有可能被 "作为" `&mut T` 使用。

作为一个花了大量时间在 Rust 中编写集合的人，这让我感到厌烦。这就是为什么我在制作 [std::ptr::NonNull](https://doc.rust-lang.org/std/ptr/struct.NonNull.html), 时添加了这个小魔法：

> 与 *mut T 不同，`NonNull<T>` 在 T 上是 *covariant(协变的)*。这使得使用 `NonNull<T>` 构建*covariant(协变的)*类型成为可能，但如果在不应该是 *covariant(协变的)* 的地方中使用，则会带来不健全的风险。

这是一个围绕着 `*mut T` 构建的类型。真的是魔法吗？让我们来看一下：

```rust
pub struct NonNull<T> {
    pointer: *const T,
}


impl<T> NonNull<T> {
    pub unsafe fn new_unchecked(ptr: *mut T) -> Self {
        // SAFETY: the caller must guarantee that `ptr` is non-null.
        unsafe { NonNull { pointer: ptr as *const T } }
    }
}
```

不，这里没有魔法！NonNull 只是滥用了 *const T 是 *covariant(协变的)* 这一事实，并将其存储起来。这就是 Rust 中集合的协变方式！这可真是惨不忍睹！所以我为你做了这个 Good Pointer Type ！不客气好好享受子类型吧

解决你所有问题的办法就是使用 NonNull，然后如果你想再次使用可空指针，就使用 `Option<NonNull<T>>`。我们真的要这么做吗？

是的！这很糟糕，但我们要做的是生产级的链表，所以我们要吃尽千辛万苦（我们可以直接使用裸*const T，然后在任何地方都进行转换，但我真的想看看这样做有多痛苦......为了人体工程学科学）。

下面就是我们最终的类型定义：

```rust
use std::ptr::NonNull;

// !!!This changed!!!
pub struct LinkedList<T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
}

type Link<T> = Option<NonNull<Node<T>>>;

struct Node<T> {
    front: Link<T>,
    back: Link<T>,
    elem: T, 
}
```

...等等，不，最后一件事。每当你使用裸指针时，你都应该添加一个 Ghost 来保护你的指针：

```rust
use std::marker::PhantomData;

pub struct LinkedList<T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
    /// We semantically store values of T by-value.
    _boo: PhantomData<T>,
}
```

在这种情况下，我认为我们*实际上*不需要 [PhantomData](https://doc.rust-lang.org/std/marker/struct.PhantomData.html)，但每当你使用 NonNull（或一般的裸指针）时，为了安全起见，你都应该始终添加它，并向编译器和其他人清楚地表明你的想法，你在做什么。

PhantomData 是我们给编译器提供一个额外的 "示例 "字段的方法，这个字段在概念上存在于你的类型中，但由于各种原因（间接、类型擦除......）并不存在。在本例中，我们使用 NonNull 是因为我们声称我们的类型 "好像 "存储了一个值 T，所以我们添加了一个 PhantomData 来明确这一点。

...好吧，我们现在已经完成了布局！进入实际的基本功能！



================================================
FILE: src/too-many-lists/unsafe-queue/basics.md
================================================
# 基本操作

> 本章节的代码中有一个隐藏的 bug，因为它藏身于 unsafe 中，因此不会导致报错，我们会在后续章节解决这个问题，所以，请不要在生产环境使用此处的代码

在开始之前，大家需要先了解 unsafe 的[相关知识](https://course.rs/advance/unsafe/intro.html)。那么，言归正传，该如何构建一个链表？在之前我们是这么做的：
```rust
impl<T> List<T> {
    pub fn new() -> Self {
        List { head: None, tail: None }
    }
}
```

但是我们不再在 `tail` 中使用 `Option`:
```shell
$ cargo build

error[E0308]: mismatched types
  --> src/fifth.rs:15:34
   |
15 |         List { head: None, tail: None }
   |                                  ^^^^ expected *-ptr, found 
   |                                       enum `std::option::Option`
   |
   = note: expected type `*mut fifth::Node<T>`
              found type `std::option::Option<_>`
```

我们是可以使用 `Option` 包裹一层，但是 `*mut` 裸指针之所以裸，是因为它狂，它可以是 `null` ! 因此 `Option` 就变得没有意义:
```rust
use std::ptr;

// defns...

impl<T> List<T> {
    pub fn new() -> Self {
        List { head: None, tail: ptr::null_mut() }
    }
}
```

如上所示，通过 `std::ptr::null_mut` 函数可以获取一个 `null`，当然，还可以使用 `0 as *mut _`，但是...已经这么不安全了，好歹我们要留一点代码可读性上的尊严吧 = , =

好了，现在是时候去重新实现 `push` ，之前获取的是 `Option<&mut Node<T>>` 成为我们的拦路虎，这次来看看如果是获取 `*mut Node<T>` 还会不会有类似的问题。

首先，该如何将一个普通的引用变成裸指针？答案是：强制转换 Coercions。

```rust
let raw_tail: *mut _ = &mut *new_tail;
```

来看看 `push` 的实现:
```rust
pub fn push(&mut self, elem: T) {
    let mut new_tail = Box::new(Node {
        elem: elem,
        next: None,
    });

    let raw_tail: *mut _ = &mut *new_tail;

    // .is_null 会检查是否为 null, 在功能上等价于 `None` 的检查
    if !self.tail.is_null() {
        // 如果 old tail 存在，那将其指向新的 tail
        self.tail.next = Some(new_tail);
    } else {
        // 否则让 head 指向新的 tail
        self.head = Some(new_tail);
    }

    self.tail = raw_tail;
}
```

```shell
$ cargo build

error[E0609]: no field `next` on type `*mut fifth::Node<T>`
  --> src/fifth.rs:31:23
   |
31 |             self.tail.next = Some(new_tail);
   |             ----------^^^^
   |             |
   |             help: `self.tail` is a raw pointer; 
   |             try dereferencing it: `(*self.tail).next`
```

当使用裸指针时，一些 Rust 提供的便利条件也将不复存在，例如由于不安全性的存在，裸指针需要我们手动去解引用( deref ):
```rust
*self.tail.next = Some(new_tail);
```

```shell
$ cargo build

error[E0609]: no field `next` on type `*mut fifth::Node<T>`
  --> src/fifth.rs:31:23
   |
31 |             *self.tail.next = Some(new_tail);
   |             -----------^^^^
   |             |
   |             help: `self.tail` is a raw pointer; 
   |             try dereferencing it: `(*self.tail).next`
```

哦哦，运算符的优先级问题:
```rust
(*self.tail).next = Some(new_tail);
```

```shell
$ cargo build

error[E0133]: dereference of raw pointer is unsafe and requires 
              unsafe function or block

  --> src/fifth.rs:31:13
   |
31 |             (*self.tail).next = Some(new_tail);
   |             ^^^^^^^^^^^^^^^^^ dereference of raw pointer
   |
   = note: raw pointers may be NULL, dangling or unaligned; 
     they can violate aliasing rules and cause data races: 
     all of these are undefined behavior
```

哎...太难了，错误一个连一个，好在编译器给出了提示：由于我们在进行不安全的操作，因此需要使用 `unsafe` 语句块。那么问题来了，是将某几行代码包在 `unsafe` 中还是将整个函数包在 `unsafe` 中呢？如果大家不知道哪个是正确答案的话，证明[之前的章节](https://course.rs/advance/unsafe/intro.html#控制-unsafe-的使用边界)还是没有仔细学，请回去再看一下，巩固巩固:) 

```rust
pub fn push(&mut self, elem: T) {
    let mut new_tail = Box::new(Node {
        elem: elem,
        next: None,
    });

    let raw_tail: *mut _ = &mut *new_tail;

    if !self.tail.is_null() {
        // 你好编译器，我知道我在做危险的事情，我向你保证：就算犯错了，也和你没有关系，都是我这个不优秀的程序员的责任
        unsafe {
            (*self.tail).next = Some(new_tail);
        }
    } else {
        self.head = Some(new_tail);
    }

    self.tail = raw_tail;
}
```

```shell
$ cargo build
warning: field is never used: `elem`
  --> src/fifth.rs:11:5
   |
11 |     elem: T,
   |     ^^^^^^^
   |
   = note: #[warn(dead_code)] on by default
```

细心的同学可能会发现:不是所有的裸指针代码都有 unsafe 的身影。原因在于：**创建原生指针是安全的行为，而解引用原生指针才是不安全的行为**

呼，长出了一口气，终于成功实现了 `push` ，下面来看看 `pop`:
```rust
pub fn pop(&mut self) -> Option<T> {
    self.head.take().map(|head| {
        let head = *head;
        self.head = head.next;

        if self.head.is_none() {
            self.tail = ptr::null_mut();
        }

        head.elem
    })
}
```

测试下:
```rust
#[cfg(test)]
mod test {
    use super::List;
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), None);

        // Check the exhaustion case fixed the pointer right
        list.push(6);
        list.push(7);

        // Check normal removal
        assert_eq!(list.pop(), Some(6));
        assert_eq!(list.pop(), Some(7));
        assert_eq!(list.pop(), None);
    }
}
```

摊牌了，我们偷懒了，这些测试就是从之前的栈链表赋值过来的，但是依然做了些改变，例如在末尾增加了几个步骤以确保在 `pop` 中不会发生尾指针损坏( tail-pointer corruption  )的情况。

```shell
$ cargo test

running 12 tests
test fifth::test::basics ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test second::test::basics ... ok
test fourth::test::into_iter ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured
```




================================================
FILE: src/too-many-lists/unsafe-queue/extra-junk.md
================================================
# 额外的操作
在搞定 `push`、`pop` 后，剩下的基本跟栈链表的实现没有啥区别。只有会改变链表长度的操作才会使用<ruby>尾<rt>tail</rt></ruby>指针。

当然，现在一切都是裸指针，因此我们要重写代码来使用它们，在此过程中必须要确保没有遗漏地修改所有地方。

首先，先从栈链表实现中拷贝以下代码:
```rust
// ...

pub struct IntoIter<T>(List<T>);

pub struct Iter<'a, T> {
    next: Option<&'a Node<T>>,
}

pub struct IterMut<'a, T> {
    next: Option<&'a mut Node<T>>,
}
```

这里的 `Iter` 和 `IterMut` 并没有实现裸指针，先来修改下：
```rust
pub struct IntoIter<T>(List<T>);

pub struct Iter<'a, T> {
    next: *mut Node<T>,
}

pub struct IterMut<'a, T> {
    next: *mut Node<T>,
}

impl<T> List<T> {
    pub fn into_iter(self) -> IntoIter<T> {
        IntoIter(self)
    }

    pub fn iter(&self) -> Iter<'_, T> {
        Iter { next: self.head }
    }

    pub fn iter_mut(&mut self) -> IterMut<'_, T> {
        IterMut { next: self.head }
    }
}
```

看起来不错!
```text
error[E0392]: parameter `'a` is never used
  --> src\fifth.rs:17:17
   |
17 | pub struct Iter<'a, T> {
   |                 ^^ unused parameter
   |
   = help: consider removing `'a`, referring to it in a field, 
     or using a marker such as `PhantomData`

error[E0392]: parameter `'a` is never used
  --> src\fifth.rs:21:20
   |
21 | pub struct IterMut<'a, T> {
   |                    ^^ unused parameter
   |
   = help: consider removing `'a`, referring to it in a field, 
     or using a marker such as `PhantomData`
```

咦？这里的 [PhantomData](https://doc.rust-lang.org/std/marker/struct.PhantomData.html) 是什么?

> PhantomData 是<ruby>零大小<rt>zero sized</rt></ruby>的类型
>
> 在你的类型中添加一个 `PhantomData<T>` 字段，可以告诉编译器你的类型对 `T` 进行了使用，虽然并没有。说白了，就是让编译器不再给出 `T` 未被使用的警告或者错误。
>
> 如果想要更深入的了解，可以看下 [Nomicon](https://doc.rust-lang.org/nightly/nomicon/)

大概最适用于 PhantomData 的场景就是一个结构体拥有未使用的生命周期，典型的就是在 unsafe 中使用。

总之，之前的错误是可以通过 PhantomData 来解决的，但是我想将这个秘密武器留到下一章中的双向链表，它才是真正的需要。

那现在只能破坏我们之前的豪言壮语了，灰溜溜的继续使用引用貌似也是不错的选择。能使用引用的原因是：我们可以创建一个迭代器，在其中使用安全引用，然后再丢弃迭代器。一旦迭代器被丢弃后，就可以继续使用 `push` 和 `pop` 了。

事实上，在迭代期间，我们还是需要解引用大量的裸指针，但是可以把引用看作裸指针的再借用。

偷偷的说一句：对于这个方法，我不敢保证一定能成功，先来试试吧..
```rust
pub struct IntoIter<T>(List<T>);

pub struct Iter<'a, T> {
    next: Option<&'a Node<T>>,
}

pub struct IterMut<'a, T> {
    next: Option<&'a mut Node<T>>,
}

impl<T> List<T> {
    pub fn into_iter(self) -> IntoIter<T> {
        IntoIter(self)
    }

    pub fn iter(&self) -> Iter<'_, T> {
        unsafe {
            Iter { next: self.head.as_ref() }
        }
    }

    pub fn iter_mut(&mut self) -> IterMut<'_, T> {
        unsafe {
            IterMut { next: self.head.as_mut() }
        }
    }
}
```

为了存储引用，这里使用 `Option` 来包裹，并通过 [`ptr::as_ref`](https://doc.rust-lang.org/std/primitive.pointer.html#method.as_ref-1) 和 [`ptr::as_mut`](https://doc.rust-lang.org/std/primitive.pointer.html#method.as_mut) 来将裸指针转换成引用。

通常，我会尽量避免使用 `as_ref` 这类方法，因为它们在做一些不可思议的转换！但是上面却是极少数可以使用的场景之一。

这两个方法的使用往往会伴随很多警告，其中最有趣的是：

> 你必须要遵循混叠(Aliasing)的规则，原因是返回的生命周期 `'a` 只是任意选择的，并不能代表数据真实的生命周期。特别的，在这段生命周期的过程中，指针指向的内存区域绝不能被其它指针所访问。

好消息是，我们貌似不存在这个问题，因为混叠是我们一直在讨论和避免的问题。除此之外，还有一个恶魔：
```rust
pub unsafe fn as_mut<'a>(self) -> Option<&'a mut T>
```

大家注意到这个凭空出现的 `'a` 吗？这里 `self` 是一个值类型，按照生命周期的规则，`'a` 无根之木，它就是[无界生命周期](https://course.rs/advance/lifetime/advance.html#无界生命周期)。

兄弟们，我很紧张，但是该继续的还是得继续，让我们从栈链表中再复制一些代码过来：
```rust
impl<T> Iterator for IntoIter<T> {
    type Item = T;
    fn next(&mut self) -> Option<Self::Item> {
        self.0.pop()
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        unsafe {
            self.next.map(|node| {
                self.next = node.next.as_ref();
                &node.elem
            })
        }
    }
}

impl<'a, T> Iterator for IterMut<'a, T> {
    type Item = &'a mut T;

    fn next(&mut self) -> Option<Self::Item> {
        unsafe {
            self.next.take().map(|node| {
                self.next = node.next.as_mut();
                &mut node.elem
            })
        }
    }
}
```

验证下测试用例：
```rust
cargo test

running 15 tests
test fifth::test::basics ... ok
test fifth::test::into_iter ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::into_iter ... ok
test fourth::test::peek ... ok
test second::test::basics ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::iter ... ok
test third::test::basics ... ok

test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out;
```

还有 miri:
```text
MIRIFLAGS="-Zmiri-tag-raw-pointers" cargo +nightly-2022-01-21 miri test

running 15 tests
test fifth::test::basics ... ok
test fifth::test::into_iter ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::into_iter ... ok
test fourth::test::peek ... ok
test second::test::basics ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

嗯，还有 `peek` 和 `peek_mut` 的实现：
```rust
pub fn peek(&self) -> Option<&T> {
    unsafe {
        self.head.as_ref()
    }
}

pub fn peek_mut(&mut self) -> Option<&mut T> {
    unsafe {
        self.head.as_mut()
    }
}
```

实现这么简单，运行起来肯定没问题：
```text
$ cargo build
error[E0308]: mismatched types
  --> src\fifth.rs:66:13
   |
25 | impl<T> List<T> {
   |      - this type parameter
...
64 |     pub fn peek(&self) -> Option<&T> {
   |                           ---------- expected `Option<&T>` 
   |                                      because of return type
65 |         unsafe {
66 |             self.head.as_ref()
   |             ^^^^^^^^^^^^^^^^^^ expected type parameter `T`, 
   |                                found struct `fifth::Node`
   |
   = note: expected enum `Option<&T>`
              found enum `Option<&fifth::Node<T>>`
```

哦，这个简单，map 以下就可以了:
```rust
pub fn peek(&self) -> Option<&T> {
    unsafe {
        self.head.as_ref().map(|node| &node.elem)
    }
}

pub fn peek_mut(&mut self) -> Option<&mut T> {
    unsafe {
        self.head.as_mut().map(|node| &mut node.elem)
    }
}
```

我感觉有很多错误正在赶来的路上，因此大家需要提高警惕，要么先写一个测试吧：把我们的 API 都混合在一起，让 miri 来享用 - miri food!
```rust
#[test]
fn miri_food() {
    let mut list = List::new();

    list.push(1);
    list.push(2);
    list.push(3);

    assert!(list.pop() == Some(1));
    list.push(4);
    assert!(list.pop() == Some(2));
    list.push(5);

    assert!(list.peek() == Some(&3));
    list.push(6);
    list.peek_mut().map(|x| *x *= 10);
    assert!(list.peek() == Some(&30));
    assert!(list.pop() == Some(30));

    for elem in list.iter_mut() {
        *elem *= 100;
    }

    let mut iter = list.iter();
    assert_eq!(iter.next(), Some(&400));
    assert_eq!(iter.next(), Some(&500));
    assert_eq!(iter.next(), Some(&600));
    assert_eq!(iter.next(), None);
    assert_eq!(iter.next(), None);

    assert!(list.pop() == Some(400));
    list.peek_mut().map(|x| *x *= 10);
    assert!(list.peek() == Some(&5000));
    list.push(7);

    // Drop it on the ground and let the dtor exercise itself
}
```

```text
cargo test

running 16 tests
test fifth::test::basics ... ok
test fifth::test::into_iter ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test fifth::test::miri_food ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::into_iter ... ok
test fourth::test::peek ... ok
test second::test::into_iter ... ok
test second::test::basics ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::iter ... ok
test second::test::iter ... ok
test third::test::basics ... ok

test result: ok. 16 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out



MIRIFLAGS="-Zmiri-tag-raw-pointers" cargo +nightly-2022-01-21 miri test

running 16 tests
test fifth::test::basics ... ok
test fifth::test::into_iter ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test fifth::test::miri_food ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::into_iter ... ok
test fourth::test::peek ... ok
test second::test::into_iter ... ok
test second::test::basics ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::iter ... ok
test second::test::iter ... ok
test third::test::basics ... ok

test result: ok. 16 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

完美。


================================================
FILE: src/too-many-lists/unsafe-queue/final-code.md
================================================
# 最终代码
得益于不安全代码的引入，新的实现可以获得线性的性能提升，同时我们还设法复用了栈链表的很多代码。

当然，这个过程中，我们还引入了新的概念，例如借用栈，相信直到现在有些同学还晕乎乎的。不管如何，我们不用再去写一大堆嵌套来嵌套去的 `Rc` 和 `RefCell`。

下面来看看咱们这个不安全链表的全貌吧。

```rust
use std::ptr;

pub struct List<T> {
    head: Link<T>,
    tail: *mut Node<T>,
}

type Link<T> = *mut Node<T>;

struct Node<T> {
    elem: T,
    next: Link<T>,
}

pub struct IntoIter<T>(List<T>);

pub struct Iter<'a, T> {
    next: Option<&'a Node<T>>,
}

pub struct IterMut<'a, T> {
    next: Option<&'a mut Node<T>>,
}

impl<T> List<T> {
    pub fn new() -> Self {
        List { head: ptr::null_mut(), tail: ptr::null_mut() }
    }
    pub fn push(&mut self, elem: T) {
        unsafe {
            let new_tail = Box::into_raw(Box::new(Node {
                elem: elem,
                next: ptr::null_mut(),
            }));

            if !self.tail.is_null() {
                (*self.tail).next = new_tail;
            } else {
                self.head = new_tail;
            }

            self.tail = new_tail;
        }
    }
    pub fn pop(&mut self) -> Option<T> {
        unsafe {
            if self.head.is_null() {
                None
            } else {
                let head = Box::from_raw(self.head);
                self.head = head.next;

                if self.head.is_null() {
                    self.tail = ptr::null_mut();
                }

                Some(head.elem)
            }
        }
    }

    pub fn peek(&self) -> Option<&T> {
        unsafe {
            self.head.as_ref().map(|node| &node.elem)
        }
    }

    pub fn peek_mut(&mut self) -> Option<&mut T> {
        unsafe {
            self.head.as_mut().map(|node| &mut node.elem)
        }
    }

    pub fn into_iter(self) -> IntoIter<T> {
        IntoIter(self)
    }

    pub fn iter(&self) -> Iter<'_, T> {
        unsafe {
            Iter { next: self.head.as_ref() }
        }
    }

    pub fn iter_mut(&mut self) -> IterMut<'_, T> {
        unsafe {
            IterMut { next: self.head.as_mut() }
        }
    }
}

impl<T> Drop for List<T> {
    fn drop(&mut self) {
        while let Some(_) = self.pop() { }
    }
}

impl<T> Iterator for IntoIter<T> {
    type Item = T;
    fn next(&mut self) -> Option<Self::Item> {
        self.0.pop()
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        unsafe {
            self.next.map(|node| {
                self.next = node.next.as_ref();
                &node.elem
            })
        }
    }
}

impl<'a, T> Iterator for IterMut<'a, T> {
    type Item = &'a mut T;

    fn next(&mut self) -> Option<Self::Item> {
        unsafe {
            self.next.take().map(|node| {
                self.next = node.next.as_mut();
                &mut node.elem
            })
        }
    }
}

#[cfg(test)]
mod test {
    use super::List;
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), None);

        // Check the exhaustion case fixed the pointer right
        list.push(6);
        list.push(7);

        // Check normal removal
        assert_eq!(list.pop(), Some(6));
        assert_eq!(list.pop(), Some(7));
        assert_eq!(list.pop(), None);
    }

    #[test]
    fn into_iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.into_iter();
        assert_eq!(iter.next(), Some(1));
        assert_eq!(iter.next(), Some(2));
        assert_eq!(iter.next(), Some(3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&1));
        assert_eq!(iter.next(), Some(&2));
        assert_eq!(iter.next(), Some(&3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter_mut() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter_mut();
        assert_eq!(iter.next(), Some(&mut 1));
        assert_eq!(iter.next(), Some(&mut 2));
        assert_eq!(iter.next(), Some(&mut 3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn miri_food() {
        let mut list = List::new();

        list.push(1);
        list.push(2);
        list.push(3);

        assert!(list.pop() == Some(1));
        list.push(4);
        assert!(list.pop() == Some(2));
        list.push(5);

        assert!(list.peek() == Some(&3));
        list.push(6);
        list.peek_mut().map(|x| *x *= 10);
        assert!(list.peek() == Some(&30));
        assert!(list.pop() == Some(30));

        for elem in list.iter_mut() {
            *elem *= 100;
        }

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&400));
        assert_eq!(iter.next(), Some(&500));
        assert_eq!(iter.next(), Some(&600));
        assert_eq!(iter.next(), None);
        assert_eq!(iter.next(), None);

        assert!(list.pop() == Some(400));
        list.peek_mut().map(|x| *x *= 10);
        assert!(list.peek() == Some(&5000));
        list.push(7);

        // Drop it on the ground and let the dtor exercise itself
    }
}
```


================================================
FILE: src/too-many-lists/unsafe-queue/intro.md
================================================
# 不错的unsafe队列
在之前章节中，基于内部可变性和引用计数的双向链表有些失控了，原因在于 `Rc` 和 `RefCell` 对于简单的任务而言，它们是非常称职的，但是对于复杂的任务，它们可能会变得相当笨拙，特别是当我们试图隐藏一些细节时。

总之，一定有更好的办法！下面来看看该如何使用裸指针和 unsafe 代码实现一个单向链表。

> 大家可能想等着看我犯错误，unsafe 嘛，不犯错误不可能的，但是呢，俺偏就不犯错误：）

国际惯例，添加第五个链表所需的文件 `fifth.rs`:
```rust
// in lib.rs

pub mod first;
pub mod second;
pub mod third;
pub mod fourth;
pub mod fifth;
```

虽然我们依然会从零开始撸代码，但是 `fifth.rs` 的代码会跟 `second.rs` 存在一定的重叠，因为对于链表而言，队列其实就是栈的增强。




================================================
FILE: src/too-many-lists/unsafe-queue/layout.md
================================================
[Binary file]


================================================
FILE: src/too-many-lists/unsafe-queue/layout2.md
================================================
# 数据布局2: 再裸一些吧

> TL;DR 在之前部分中，将安全的指针 `&` 、`&mut` 和 `Box` 跟不安全的裸指针 `*mut` 和 `*const` 混用是 UB 的根源之一，原因是安全指针会引入额外的约束，但是裸指针并不会遵守这些约束。

一个好消息，一个坏消息。坏消息是我们又要开始写链表了，悲剧 = , = 好消息呢是之前我们已经讨论过该如何设计了，之前做的工作基本都是正确的，除了混用安全指针和不安全指针的部分。

## 布局
在新的布局中我们将只使用裸指针，然后大家就等着好消息吧！

下面是之前的"破代码" ：
```rust
pub struct List<T> {
    head: Link<T>,
    tail: *mut Node<T>, // 好人一枚
}

type Link<T> = Option<Box<Node<T>>>; // 恶魔一只

struct Node<T> {
    elem: T,
    next: Link<T>,
}
```

现在删除恶魔:
```rust
pub struct List<T> {
    head: Link<T>,
    tail: *mut Node<T>,
}

type Link<T> = *mut Node<T>; // 嘀，新的好人卡，请查收

struct Node<T> {
    elem: T,
    next: Link<T>,
}
```

请大家牢记：当使用裸指针时，`Option` 对我们是相当不友好的，所以这里不再使用。在后面还将引入 `NonNull` 类型，但是现在还无需操心。

## 基本操作
`List::new` 与之前几乎没有区别：
```rust
use ptr;

impl<T> List<T> {
    pub fn new() -> Self {
        List { head: ptr::null_mut(), tail: ptr::null_mut() }
    }
}
```

`Push` 也几乎没区...
```rust
pub fn push(&mut self, elem: T) {
    let mut new_tail = Box::new(
```

等等，我们不再使用 `Box` 了，既然如此，该怎么分配内存呢？

也许我们可以使用 `std::alloc::alloc`，但是大家想象一下拿着武士刀进厨房切菜的场景，所以，还是算了吧。

我们想要 `Box` 又不想要，这里有一个也许很野但是管用的方法:
```rust
struct Node<T> {
    elem: T,
    real_next: Option<Box<Node<T>>>,
    next: *mut Node<T>,
}
```

先创建一个 `Box` ，并使用一个裸指针指向 `Box` 中的 `Node`，然后就一直使用该裸指针直到我们处理完 `Node` 且可以销毁它之时。最后，可以将 `Box` 从 `real_next` 中 `take` 出来，并 `drop` 掉。

从上面来看，这个非常符合我们之前的简化版借用栈模型？借用 `Box`，再借用一个裸指针，然后先弹出该裸指针，再弹出 `Box`，嗯，果然很符合。

但是问题来了，这样做看上去有趣，但是你能保证这个简化版借用栈顺利的工作吗？所以，我们还是使用 [Box::into_raw](https://doc.rust-lang.org/std/boxed/struct.Box.html#method.into_raw) 函数吧！

> `pub fn into_raw(b: Box<T>) -> *mut T`
>
> 消费掉 `Box` (拿走所有权)，返回一个裸指针。该指针会被正确的对齐且不为 null
> 
> 在调用该函数后，调用者需要对之前被 Box 所管理的内存负责，特别地，调用者需要正确的清理 `T` 并释放相应的内存。最简单的方式是通过 `Box::from_raw` 函数将裸指针再转回到 `Box`，然后 `Box` 的析构器就可以自动执行清理了。
>
> 注意：这是一个关联函数，因此 `b.into_raw()` 是不正确的，我们得使用 `Box::into_raw(b)`。因此该函数不会跟内部类型的同名方法冲突。
>
> ### 示例
>
> 将裸指针转换成 `Box` 以实现自动的清理:
>
> ```rust
>
> let x = Box::new(String::from("Hello"));
> let ptr = Box::into_raw(x);
> let x = unsafe { Box::from_raw(ptr) };

太棒了，简直为我们量身定制。而且它还很符合我们试图遵循的规则： 从安全的东东开始，将其转换成裸指针，最后再将裸指针转回安全的东东以实现安全的 drop。

现在，我们就可以到处使用裸指针，也无需再注意 unsafe 的范围，反正现在都是 unsafe 了，无所谓。
```rust
pub fn push(&mut self, elem: T) {
    unsafe {
        // 一开始就将 Box 转换成裸指针
        let new_tail = Box::into_raw(Box::new(Node {
            elem: elem,
            next: ptr::null_mut(),
        }));

        if !self.tail.is_null() {
            (*self.tail).next = new_tail;
        } else {
            self.head = new_tail;
        }

        self.tail = new_tail;
    }
}
```

嘿，都说 unsafe 不应该使用，但没想到 unsafe 真的是好！现在代码整体看起来简洁多了。

继续实现 `pop`，它跟之前区别不大，但是我们不要忘了使用 `Box::from_raw` 来清理内存:
```rust
pub fn pop(&mut self) -> Option<T> {
    unsafe {
        if self.head.is_null() {
            None
        } else {
            let head = Box::from_raw(self.head);
            self.head = head.next;

            if self.head.is_null() {
                self.tail = ptr::null_mut();
            }

            Some(head.elem)
        }
    }
}
```

纪念下死去的 `take` 和 `map`，现在我们得手动检查和设置 `null` 了。

然后再实现下析构器，直接循环 `pop` 即可，怎么说，简单可爱，谁不爱呢?
```rust
impl<T> Drop for List<T> {
    fn drop(&mut self) {
        while let Some(_) = self.pop() { }
    }
}
```

现在到了检验正确性的时候:
```rust
#[cfg(test)]
mod test {
    use super::List;
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), None);

        // Check the exhaustion case fixed the pointer right
        list.push(6);
        list.push(7);

        // Check normal removal
        assert_eq!(list.pop(), Some(6));
        assert_eq!(list.pop(), Some(7));
        assert_eq!(list.pop(), None);
    }
}
```

```shell
$ cargo test

running 12 tests
test fifth::test::basics ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test second::test::basics ... ok
test fourth::test::into_iter ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured
```

测试没问题，还有一个拦路虎 `miri` 呢。
```rust
MIRIFLAGS="-Zmiri-tag-raw-pointers" cargo +nightly-2022-01-21 miri test

running 12 tests
test fifth::test::basics ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test second::test::basics ... ok
test fourth::test::into_iter ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured
```

苦尽甘来，苦尽甘来啊！我们这些章节的努力没有白费，它终于成功的工作了。


================================================
FILE: src/too-many-lists/unsafe-queue/miri.md
================================================
# Miri
看到这里，大家是不是暗中松了口气？unsafe 不过如此嘛，不知道为何其它人都谈之色变。

怎么说呢？你以为的编译器已经不是以前的编译器了，它不报错不代表没有错误。包括测试用例也是，正常地运行不能意味着代码没有任何错误。

在周星驰电影功夫中，还有一个奇怪大叔 10 元一本主动上门卖如来神掌，那么有没有 10 元一本的 Rust 秘笈呢？( 喂，Rust语言圣经都免费让你读了，有了摩托车，还要什么拖拉机... 哈哈，开个玩笑 )

有的，奇怪大叔正在赶来，他告诉我们先来安装一个命令:
```shell
rustup +nightly-2022-01-21 component add miri
info: syncing channel updates for 'nightly-2022-01-21-x86_64-pc-windows-msvc'
info: latest update on 2022-01-21, rust version 1.60.0-nightly (777bb86bc 2022-01-20)
info: downloading component 'cargo'
info: downloading component 'clippy'
info: downloading component 'rust-docs'
info: downloading component 'rust-std'
info: downloading component 'rustc'
info: downloading component 'rustfmt'
info: installing component 'cargo'
info: installing component 'clippy'
info: installing component 'rust-docs'
info: installing component 'rust-std'
info: installing component 'rustc'
info: installing component 'rustfmt'
info: downloading component 'miri'
info: installing component 'miri'
```

等等，你在我电脑上装了什么奇怪的东西？！  "好东西"


> miri 目前只能在 nightly Rust 上安装，`+nightly-2022-01-21` 告诉 `rustup` 我们想要安装的 `nightly` 版本，事实上，你可以直接通过 `rustup +nightly component add miri` 安装，这里指定版本主要因为 `miri` 有时候会因为某些版本而出错。
>
> 2022-01-21 是我所知的 miri 可以成功运行的版本，你可以检查[这个网址](https://rust-lang.github.io/rustup-components-history/)获取更多信息
>
> + 是一种临时性的规则运用，如果你不想每次都使用 `+nightly-2022-01-21`，可以使用 [`rustup override set`](https://course.rs/appendix/rust-version.html#rustup-和-rust-nightly-的职责) 命令对当前项目的 Rust 版本进行覆盖

```shell
$ cargo +nightly-2022-01-21 miri test

I will run `"cargo.exe" "install" "xargo"` to install
a recent enough xargo. Proceed? [Y/n]
```

额，`xargo` 是什么东东？"不要担心，选择 y 就行，我像是会坑你的人吗？"

```shell
> y

    Updating crates.io index
  Installing xargo v0.3.24
...
    Finished release [optimized] target(s) in 10.65s
  Installing C:\Users\ninte\.cargo\bin\xargo-check.exe
  Installing C:\Users\ninte\.cargo\bin\xargo.exe
   Installed package `xargo v0.3.24` (executables `xargo-check.exe`, `xargo.exe`)

I will run `"rustup" "component" "add" "rust-src"` to install 
the `rust-src` component for the selected toolchain. Proceed? [Y/n]
```

额？ "不要怕，多给你一份 Rust 源代码，不开心嘛？"

```shell
> y

info: downloading component 'rust-src'
info: installing component 'rust-src'
```

"看吧，我就说我不会骗你的，不相信我，等着错误砸脸吧!" 真是一个奇怪的大叔...
```shell
 Compiling lists v0.1.0 (C:\Users\ninte\dev\tmp\lists)
    Finished test [unoptimized + debuginfo] target(s) in 0.25s
     Running unittests (lists-5cc11d9ee5c3e924.exe)

error: Undefined Behavior: trying to reborrow for Unique at alloc84055, 
       but parent tag <209678> does not have an appropriate item in 
       the borrow stack

   --> \lib\rustlib\src\rust\library\core\src\option.rs:846:18
    |
846 |             Some(x) => Some(f(x)),
    |                  ^ trying to reborrow for Unique at alloc84055, 
    |                    but parent tag <209678> does not have an 
    |                    appropriate item in the borrow stack
    |
    = help: this indicates a potential bug in the program: 
      it performed an invalid operation, but the rules it 
      violated are still experimental
    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md 
      for further information

    = note: inside `std::option::Option::<std::boxed::Box<fifth::Node<i32>>>::map::<i32, [closure@src\fifth.rs:31:30: 40:10]>` at \lib\rustlib\src\rust\library\core\src\option.rs:846:18

note: inside `fifth::List::<i32>::pop` at src\fifth.rs:31:9
   --> src\fifth.rs:31:9
    |
31  | /         self.head.take().map(|head| {
32  | |             let head = *head;
33  | |             self.head = head.next;
34  | |
...   |
39  | |             head.elem
40  | |         })
    | |__________^
note: inside `fifth::test::basics` at src\fifth.rs:74:20
   --> src\fifth.rs:74:20
    |
74  |         assert_eq!(list.pop(), Some(1));
    |                    ^^^^^^^^^^
note: inside closure at src\fifth.rs:62:5
   --> src\fifth.rs:62:5
    |
61  |       #[test]
    |       ------- in this procedural macro expansion
62  | /     fn basics() {
63  | |         let mut list = List::new();
64  | |
65  | |         // Check empty list behaves right
...   |
96  | |         assert_eq!(list.pop(), None);
97  | |     }
    | |_____^
 ...
error: aborting due to previous error
```

咦还真有错误，大叔，这是什么错误？大叔？...奇怪的大叔默默离开了，留下我在风中凌乱。

果然不靠谱...还是得靠自己，首先得了解下何为 `miri`。


[`miri`](https://github.com/rust-lang/miri) 可以生成 Rust 的中间层表示 MIR，对于编译器来说，我们的 Rust 代码首先会被编译为 MIR ，然后再提交给 LLVM 进行处理。

可以通过 `rustup component add miri` 来安装它，并通过 `cargo miri` 来使用，同时还可以使用 `cargo miri test` 来运行测试代码。

`miri` 可以帮助我们检查常见的未定义行为(UB = Undefined Behavior)，以下列出了一部分:

- 内存越界检查和内存释放后再使用(use-after-free)
- 使用未初始化的数据
- 数据竞争
- 内存对齐问题

UB 检测是必须的，因为它发生在运行时，因此很难发现，如果 `miri` 能在编译期检测出来，那自然是最好不过的。

总之，`miri` 的使用很简单:
```shell
$ cargo +nightly-2022-01-21 miri test
```

下面来看看具体的错误：
```shell
error: Undefined Behavior: trying to reborrow for Unique at alloc84055, but parent tag <209678> does not have an appropriate item in the borrow stack

   --> \lib\rustlib\src\rust\library\core\src\option.rs:846:18
    |
846 |             Some(x) => Some(f(x)),
    |                  ^ trying to reborrow for Unique at alloc84055, 
    |                    but parent tag <209678> does not have an 
    |                    appropriate item in the borrow stack
    |

    = help: this indicates a potential bug in the program: it 
      performed an invalid operation, but the rules it 
      violated are still experimental
    
    = help: see 
      https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md 
      for further information
```

嗯，只能看出是一个错误，其它完全看不懂了，例如什么是 `borrow stack`？





================================================
FILE: src/too-many-lists/unsafe-queue/stacked-borrow.md
================================================
# 栈借用( Stacked Borrorw)
上一章节中我们运行 miri 时遇到了一个栈借用错误，还给了文档链接，但这些文档主要是给编译器开发者和 Rust 研究者看的，因此就不进行讲解了。

而这里，我们将从一个更高层次的角度来看看何为栈借用。

> 目前栈借用在 Rust 语义模型中还是试验阶段，因此破坏这些规则不一定说明你的程序错了。但是除非你在做编译器开发，否则最好还是修复这些错误。事前的麻烦总比事后的不安全要好，特别是当涉及到 UB 未定义行为时

## 指针混叠( Pointer Aliasing )
在开始了解我们破坏的规则之前，首先应该了解为何会有这些规则的存在。这里有多个动机，但是我认为最重要的动机是： 指针混叠.

当两个指针指向的内存区域存在重叠时，就说这两个指针发生了混叠，这种情况会造成一些问题。例如，编译器使用指针混叠的信息来优化内存的访问，当这些信息出错时，那程序就会被不正确地编译，然后产生一些奇怪的结果。

> 实际上，混叠更多关心的是内存访问而不是指针本身，而且只有在其中一个访问是可变的时，才可能出问题。之所以说指针，是因为指针这个概念更方便跟一些规则进行关联。

再比如，编译器需要获取一个值时，是该去缓存中查询还是每次都去内存中加载呢？关于这个选择，编译器需要清晰地知道是否有一个指针在背后修改内存，如果内存值被修改了，那缓存显然就失效了。

## 安全地栈借用
有了之前的铺垫，大家肯定希望编译器能对指针混叠的信息了若指掌，但是可以吗？对于 Rust 正常代码而言，这种情况是可以避免的，因为严格的借用规则是我们的后盾：要么同时存在一个可变引用，要么同时存在多个不可变引用，这种规则简直完美避免了：两个指针指向同一块儿重叠内存区域，而其中一个是可变指针。

然而实际使用中，有一些情况会较为复杂，例如以下代码中发生了可变引用的再借用( reborrow )：
```rust
let mut data = 10;
let ref1 = &mut data;
let ref2 = &mut *ref1;

*ref2 += 2;
*ref1 += 1;

println!("{}", data);
```

看上去像是违反了借用规则，但是这段代码确实可以正常编译运行，如果交换下引用使用的顺序呢？
```rust
let mut data = 10;
let ref1 = &mut data;
let ref2 = &mut *ref1;

// ORDER SWAPPED!
*ref1 += 1;
*ref2 += 2;

println!("{}", data);
```

```shell
error[E0503]: cannot use `*ref1` because it was mutably borrowed
 --> src/main.rs:6:5
  |
4 |     let ref2 = &mut *ref1;
  |                ---------- borrow of `*ref1` occurs here
5 |     
6 |     *ref1 += 1;
  |     ^^^^^^^^^^ use of borrowed `*ref1`
7 |     *ref2 += 2;
  |     ---------- borrow later used here

For more information about this error, try `rustc --explain E0503`.
error: could not compile `playground` due to previous error
```

果不其然，编译器抛出了错误，当我们再借用了一个可变引用时，那原始的引用就不能再被使用，直到借用者完成了任务：借用者的借用有效范围并不是看作用域，而是看最后一次使用的位置，正因为如此，第一段代码可以编译通过，而第二段不行，这是著名的生命周期 [NLL 规则](https://course.rs/advance/lifetime/advance.html#nll-non-lexical-lifetime)。

以上就是我们拥有再借用但是还拥有混叠信息的原因：所有的再借用都在清晰地进行嵌套，因此每个再借用都不会与其它的冲突。那大家知道什么方法可以很好的展现嵌套的事物吗？答案就是使用栈来存放这些嵌套的借用。

嘿，这不就是栈借用吗？

这个栈的顶部借用就是当前正在使用( live )的借用，而它清晰的知道在它使用的期间不会发生混叠。当对一个指针进行再借用时，新的借用会被插入到栈的顶部，并变成 live 状态。如果要将一个旧的指针变成 live，就需要将借用栈上在它之前的借用全部弹出( pop )。

通过栈借用的方式，我们保证了尽管存在多个再借用，但是在同一个时间，只会有一个可变引用访问目标内存，再也不用担心指针混叠的问题了。只要不去访问一个已经被弹出借用栈的指针，就会非常安全！

从表述方式来说，与其说使用 `ref1` 会让 `ref2` 不合法，不如说 `ref2` 必须要在所有使用情况下合法，`ref1` 恰恰是其中一种情况，会破坏 `ref2` 的合法性。而编译器的报错也是选择了第二种表述方式：无法使用 `*ref1`，原因是它已经被可变借用了，可以看出，第二种表述方式比第一种要更加符合直觉。

**但是，当使用 `unsafe` 指针时，借用检查器就无法再帮助我们了！**

## 不安全地栈借用
所以，我们现在需要一个方式让 unsafe 指针也可以参与到栈借用系统中来，即使编译器无法正确地跟踪它们。同时我们也希望这个系统能宽松一些，不要很容易就产生 UB。

这是一个困难的问题，我也不知道该如何解决，但是目前在编写栈借用系统的开发者显然是有想法的，例如 miri 就是其中一个产物。

从一个高抽象层次来看，当我们将一个引用转换成裸指针时，就是一种再借用。那么随后，裸指针就可以对目标内存进行操作，当再借用结束时，发生的事情跟正常的再借用结束也没有区别。

但是问题是，你还可以将一个裸指针转变成引用，最重要的是，还可以对裸指针进行拷贝！如果发生了以下转换 `&mut -> *mut -> &mut -> *mut`，然后去访问第一个 `*mut`，这种见鬼的情况下，栈借用该如何发挥作用？

反正我不知道，只能求助于 miri 了。事实上，正因为这种情况，miri 还提供了试验性的模式: `-Zmiri-tag-raw-pointers`。可以通过环境的方式来开启该模式：
```shell
MIRIFLAGS="-Zmiri-tag-raw-pointers" cargo +nightly-2022-01-21 miri test
```

如果是 Windows，你需要设置全局变量:
```shell
$env:MIRIFLAGS="-Zmiri-tag-raw-pointers"
cargo +nightly-2022-01-21 miri test
```

## 管理栈借用
因为之前的问题，使用裸指针，应该遵守一个原则：**一旦开始使用裸指针，就要尝试着只使用它**。

现在，我们依然希望在接口中使用安全的引用去构建一个安全的抽象，例如在函数参数中使用引用而不是裸指针，这样我们的用户就无需操心 unsafe 的问题。

为此，我们需要做以下事情：

1. 在开始时，将输入参数中的引用转换成裸指针
2. 在函数体中只使用裸指针
3. 返回之前，将裸指针转换成安全的指针

但是由于数据结构中的字段都是私有的，无需暴露给用户，因此无需这么麻烦，直接使用裸指针即可。

事实上，一个依然存在的问题就是还在继续使用 `Box`, 它会告诉编译器：hey，这个看上去很像是 `&mut` ，因为它唯一的持有那个指针。

但是我们在链表中一直使用的裸指针是指向 Box 的内部，所以无论何时我们通过正常的方式访问 Box，我们都有可能让该裸指针的再借用变得不合法。




================================================
FILE: src/too-many-lists/unsafe-queue/testing-stacked-borrow.md
================================================
[Binary file]


================================================
FILE: src/usecases/aws-rust.md
================================================
[Binary file]


================================================
FILE: src/usecases/intro.md
================================================
# Rust的使用案例
自从 Rust 基金会成立后，一些优秀的落地案例如雨后春笋般冒了出来，这些充分说明了 Rust 语言在全球范围的流行。

这里我们将通过几个精心挑选的使用案例，来帮助大家看看 Rust 能为企业解决哪些痛点，以及该如何在企业内落地。


================================================
FILE: theme/index1.hbs
================================================
<!DOCTYPE HTML>
<html lang="{{ language }}" class="{{ default_theme }}" dir="{{ text_direction }}">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>{{ title }}</title>
        {{#if is_print }}
        <meta name="robots" content="noindex">
        {{/if}}
        {{#if base_url}}
        <base href="{{ base_url }}">
        {{/if}}


        <!-- Custom HTML head -->
        {{> head}}

        <meta name="description" content="{{ description }}">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        {{#if favicon_svg}}
        <link rel="icon" href="{{ path_to_root }}favicon.svg">
        {{/if}}
        {{#if favicon_png}}
        <link rel="shortcut icon" href="{{ path_to_root }}favicon.png">
        {{/if}}
        <link rel="stylesheet" href="{{ path_to_root }}css/variables.css">
        <link rel="stylesheet" href="{{ path_to_root }}css/general.css">
        <link rel="stylesheet" href="{{ path_to_root }}css/chrome.css">
        {{#if print_enable}}
        <link rel="stylesheet" href="{{ path_to_root }}css/print.css" media="print">
        {{/if}}

        <!-- Fonts -->
        <link rel="stylesheet" href="{{ path_to_root }}FontAwesome/css/font-awesome.css">
        {{#if copy_fonts}}
        <link rel="stylesheet" href="{{ path_to_root }}fonts/fonts.css">
        {{/if}}

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="{{ path_to_root }}highlight.css">
        <link rel="stylesheet" href="{{ path_to_root }}tomorrow-night.css">
        <link rel="stylesheet" href="{{ path_to_root }}ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        {{#each additional_css}}
        <link rel="stylesheet" href="{{ ../path_to_root }}{{ this }}">
        {{/each}}

        {{#if mathjax_support}}
        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        {{/if}}
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "{{ path_to_root }}";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "{{ preferred_dark_theme }}" : "{{ default_theme }}";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('{{ default_theme }}')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                {{#toc}}{{/toc}}
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>
        
        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                {{> header}}
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        {{#if search_enabled}}
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        {{/if}}
                    </div>

                    <h1 class="menu-title">{{ book_title }}</h1>

                    <div class="right-buttons">
                        {{#if print_enable}}
                        <a href="{{ path_to_root }}print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        {{/if}}
                        {{#if git_repository_url}}
                        <a href="{{git_repository_url}}" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa {{git_repository_icon}}"></i>
                        </a>
                        {{/if}}
                        {{#if git_repository_edit_url}}
                        <a href="{{git_repository_edit_url}}" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                        {{/if}}

                    </div>
                </div>

                {{#if search_enabled}}
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                {{/if}}

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        {{{ content }}}
                        <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        {{#previous}}
                            <a rel="prev" href="{{ path_to_root }}{{link}}" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        {{/previous}}

                        {{#next}}
                            <a rel="next prefetch" href="{{ path_to_root }}{{link}}" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        {{/next}}

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                {{#previous}}
                    <a rel="prev" href="{{ path_to_root }}{{link}}" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                {{/previous}}

                {{#next}}
                    <a rel="next prefetch" href="{{ path_to_root }}{{link}}" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                {{/next}}
            </nav>

        </div>

        {{#if live_reload_endpoint}}
        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "{{{live_reload_endpoint}}}";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        {{/if}}

        {{#if google_analytics}}
        <!-- Google Analytics Tag -->
        <script>
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', '{{google_analytics}}', 'auto');
                ga('send', 'pageview');
            }
        </script>
        {{/if}}

        {{#if playground_line_numbers}}
        <script>
            window.playground_line_numbers = true;
        </script>
        {{/if}}

        {{#if playground_copyable}}
        <script>
            window.playground_copyable = true;
        </script>
        {{/if}}

        {{#if playground_js}}
        <script src="{{ path_to_root }}ace.js"></script>
        <script src="{{ path_to_root }}editor.js"></script>
        <script src="{{ path_to_root }}mode-rust.js"></script>
        <script src="{{ path_to_root }}theme-dawn.js"></script>
        <script src="{{ path_to_root }}theme-tomorrow_night.js"></script>
        {{/if}}

        {{#if search_js}}
        <script src="{{ path_to_root }}elasticlunr.min.js"></script>
        <script src="{{ path_to_root }}mark.min.js"></script>
        <script src="{{ path_to_root }}searcher.js"></script>
        {{/if}}

        <script src="{{ path_to_root }}clipboard.min.js"></script>
        <script src="{{ path_to_root }}highlight.js"></script>
        <script src="{{ path_to_root }}book.js"></script>

        <script type="text/javascript" charset="utf-8">
        var pagePath = "{{ path }}"
        </script>


        <!-- Custom JS scripts -->
        {{#each additional_js}}
        <script src="{{ ../path_to_root }}{{this}}"></script>
        {{/each}}

        {{#if is_print}}
        {{#if mathjax_support}}
        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        {{else}}
        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        {{/if}}
        {{/if}}

    </div>
    </body>
</html>


================================================
FILE: theme/style.css
================================================
@media only screen and (max-width:1080px) {
    .sidetoc {
        display: none !important;
    }
}

@media only screen and (min-width:1080px) {
    main {
        position: relative;
        padding-right: 170px;
    }
    .sidetoc {
        margin-left: auto;
        margin-right: auto;
        /*left: calc(100% + (var(--content-max-width))/4 - 180px);*/
        left: calc(100% - 200px);
        position: absolute;
    }
    .pagetoc {
        position: fixed;
        width: 200px;
        height: calc(100vh - var(--menu-bar-height) - 10rem);
        overflow: auto;
        z-index: 1000;
    }
    .pagetoc a {
        border-left: 1px solid var(--sidebar-bg);
        color: var(--fg) !important;
        display: block;
        padding-bottom: 5px;
        padding-top: 5px;
        padding-left: 10px;
        text-align: left;
        text-decoration: none;
        font-size: 1.2rem;
    }
    .pagetoc a:hover,
    .pagetoc a.active {
        background: var(--sidebar-bg);
        color: var(--sidebar-fg) !important;
    }
    .pagetoc .active {
        background: var(--sidebar-bg);
        color: var(--sidebar-fg);
    }
}

.page-footer {
    margin-top: 50px;
    border-top: 1px solid #ccc;
    overflow: hidden;
    padding: 10px 0;
    color: gray;
}

/* 修改章节目录的间距 */
.chapter li.chapter-item {
    /* 没有文件时的文字颜色 */
    color: #939da3;
    margin-top: 1.5rem;
}

/* 修改滚动条宽度 */
::-webkit-scrollbar {
    width: 5px;
    height: 5px;
}
::-webkit-scrollbar-thumb {
    background: #99ccff;
    border-radius: 3px;
}

/* 表格靠左对齐 */
table {
    margin-left: 0 !important;
}

/* 只使用底部的页面跳转，因为左右两边的宽跳转会被 page-toc 遮盖 */
@media only screen and (max-width: 2560px) {
    .nav-wide-wrapper { display: none; }
    .nav-wrapper { 
        display: block;
        position: fixed;
        bottom: 50px;
        left: var(--page-padding);
        right: var(--page-padding); 
    }
}
@media only screen and (max-width: 2560px) {
    .sidebar-visible .nav-wide-wrapper { display: none; }
    .sidebar-visible .nav-wrapper { 
        display: block;
        left: calc(var(--sidebar-width) + var(--page-padding));
    }
}

.mobile-nav-chapters {
    width: 40px;
    font-size: 2.5rem
}

/* 修改顶部图标大小 */
/* #menu-bar {
    font-size: 17px;
} */
/* 修改 github 样式 */
.fa-github {
    font-weight: 550;
}
.fa-github:after{
    content: "繁星点点尽在你的指尖 🌟";
    margin-left: 4px;
}

/* Fix on mobile device */
code {
    word-break: break-word;
}

/* 修复可编辑代码框顶部过窄的问题 */
code.editable, .ace_scroller {
    top: 10px;
}

/* 修改书侧边目录的区域分隔行样式 */

.chapter .spacer {
    background-color: #99CCFF;
    height: 2px;
    margin-top: 8px;
}

.chapter li .md-viewed {
    color: #777;
}



================================================
FILE: .github/workflows/ci.yml
================================================
name: CI

on:
  push:
    branches:
      - main

  pull_request:
    branches:
      - main

jobs:
  test:
    name: test
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    steps:
      - uses: actions/checkout@v4
      - name: Install Rust
        run: |
          rustup set profile minimal
          rustup toolchain install stable
          rustup default stable
      - name: Setup mdBook
        uses: peaceiris/actions-mdbook@v2
        with:
          mdbook-version: "latest"
      - name: Run tests
        run: mdbook test



================================================
FILE: .github/workflows/deploy.yml
================================================
name: Deploy

on:
  push:
    branches:
      - main

  pull_request:
    branches:
      - main

defaults:
  run:
    shell: bash

permissions:
  contents: write

jobs:
  deploy:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    steps:
      - uses: actions/checkout@v4
      - name: Install Rust
        run: |
          rustup set profile minimal
          rustup toolchain install stable
          rustup default stable
      - name: Setup mdBook
        uses: peaceiris/actions-mdbook@v2
        with:
          mdbook-version: "latest"
      - run: mdbook build
      - name: Copy Assets
        run: |
          chmod +x ci/copy-assets.sh
          ci/copy-assets.sh ${{ matrix.os }}
      - name: Deploy
        uses: peaceiris/actions-gh-pages@v3
        if: ${{ github.ref == 'refs/heads/main' }}
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./book


