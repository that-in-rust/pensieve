Directory structure:
└── rust-lang-rust-repos/
    ├── README.md
    ├── Cargo.toml
    ├── ci-update.sh
    ├── LICENSE
    ├── data/
    │   └── state.json
    ├── src/
    │   ├── config.rs
    │   ├── data.rs
    │   ├── main.rs
    │   ├── prelude.rs
    │   ├── utils.rs
    │   └── github/
    │       ├── api.rs
    │       └── mod.rs
    └── .github/
        ├── dependabot.yml
        └── workflows/
            ├── test.yml
            └── updater.yml

================================================
FILE: README.md
================================================
# Rust repositories list

This repository contains a scraped list of all the public GitHub repos with source code
written in the [Rust programming language][rust]. The source code for the scraper is
also included.

Everything in this repository, unless otherwise specified, is released under
the MIT license.

[rust]: https://www.rust-lang.org

## Running the scraper

To run the scraper, execute the program with the `GITHUB_TOKEN` environment
variable (containing a valid GitHub API token -- no permissions are required)
and the data directory as the first argument:

```
$ GITHUB_TOKEN=foobar cargo run --release -- data
```

The scraper automatically saves its state to disk, so it can be interrupted and
it will resume where it left. This also allows incremental updates of the list.

## Using the data

The data is available in the `data/github.csv` file, in CSV format. That file
contains the GitHub GraphQL ID of the repository, its name, and whether it
contains a `Cargo.toml` and `Cargo.lock`.

All the repositories contained in the dataset are marked as using the language
by GitHub. Some results might be inaccurate for this reason.



================================================
FILE: Cargo.toml
================================================
[package]
name = "rust-repos"
version = "0.1.0"
authors = ["Pietro Albini <pietro@pietroalbini.org>"]

[dependencies]
failure = "0.1.5"
reqwest = { version = "0.11.12", features = ["blocking", "json"] }
serde = "1.0.147"
serde_derive = "1.0.147"
serde_json = "1.0.87"
log = "0.4.6"
env_logger = "0.9.1"
csv = "1.0.5"
ctrlc = "3.1.1"
crossbeam-utils = "0.8.12"



================================================
FILE: ci-update.sh
================================================
#!/bin/bash
# Copyright (c) 2018 Pietro Albini <pietro@pietroalbini.org>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

set -euo pipefail
IFS=$'\n\t'


GIT_COMMIT_MESSAGE="Automatic lists update"
GIT_EMAIL="7378925+lists-updater@users.noreply.github.com"
GIT_NAME="lists updater"
GIT_REPO="rust-lang/rust-repos"
GIT_BRANCH="master"


if [[ -z "${GITHUB_ACTIONS+x}" ]]; then
    echo "Error: this script is meant to be run on GitHub Actions."
    exit 1
fi

if [[ -z "${DEPLOY_KEY+x}" ]]; then
    echo "Error: the \$DEPLOY_KEY environment variable is not set!"
    exit 1
fi

if [[ -z "${HIGHFIVE_GH_TOKEN}" ]]; then
    echo "Error: the \$HIGHFIVE_GH_TOKEN environment variable is not set!"
    exit 1
fi

git checkout "${GIT_BRANCH}"
GITHUB_TOKEN="${HIGHFIVE_GH_TOKEN}" cargo run --release -- data


if git diff --quiet data/; then
    echo "No changes to commit."
else
    # Configure the deploy key on the local system
    mkdir -p ~/.ssh
    echo "${DEPLOY_KEY}" | base64 -d > ~/.ssh/id_rsa
    chmod 0600 ~/.ssh/id_rsa

    git status
    git add data/
    git -c "commit.gpgsign=false" \
        -c "user.name=${GIT_NAME}" \
        -c "user.email=${GIT_EMAIL}" \
        commit -m "${GIT_COMMIT_MESSAGE}"
    git push "git@github.com:${GIT_REPO}" "${GIT_BRANCH}"
fi



================================================
FILE: LICENSE
================================================
Copyright (c) 2018 Pietro Albini <pietro@pietroalbini.org>

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: data/state.json
================================================
{
  "last_id": {
    "github": 1066782364
  }
}



================================================
FILE: src/config.rs
================================================
// Copyright (c) 2018 Pietro Albini <pietro@pietroalbini.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use std::path::PathBuf;

pub struct Config {
    pub github_token: String,
    pub data_dir: PathBuf,
    pub timeout: Option<u64>,
}



================================================
FILE: src/data.rs
================================================
// Copyright (c) 2018 Pietro Albini <pietro@pietroalbini.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use config::Config;
use csv;
use prelude::*;
use serde_json;
use std::collections::HashMap;
use std::path::PathBuf;
use std::sync::{Arc, Mutex};
use std::{
    fs::{self, File, OpenOptions},
    io::{prelude::*, BufWriter},
};

#[derive(Default, Serialize, Deserialize)]
struct State {
    last_id: HashMap<String, usize>,
}

#[derive(Serialize, Deserialize)]
pub struct Repo {
    pub id: String,
    pub name: String,
    pub has_cargo_toml: bool,
    pub has_cargo_lock: bool,
}

pub struct Data {
    base_dir: PathBuf,

    csv_write_lock: Arc<Mutex<()>>,

    state_path: PathBuf,
    state_cache: Arc<Mutex<Option<State>>>,
}

impl Data {
    pub fn new(config: &Config) -> Self {
        Data {
            base_dir: config.data_dir.clone(),

            csv_write_lock: Arc::new(Mutex::new(())),

            state_path: config.data_dir.join("state.json"),
            state_cache: Arc::new(Mutex::new(None)),
        }
    }

    fn edit_state<T, F: Fn(&mut State) -> Fallible<T>>(&self, f: F) -> Fallible<T> {
        let mut state_cache = self.state_cache.lock().unwrap();

        if state_cache.is_none() {
            if self.state_path.exists() {
                *state_cache = Some(serde_json::from_slice(&fs::read(&self.state_path)?)?);
            } else {
                *state_cache = Some(Default::default());
            }
        }

        let state = state_cache.as_mut().unwrap();
        let result = f(state)?;

        let mut file = BufWriter::new(File::create(&self.state_path)?);
        serde_json::to_writer_pretty(&mut file, &state)?;
        file.write_all(&[b'\n'])?;

        Ok(result)
    }

    pub fn get_last_id(&self, platform: &str) -> Fallible<Option<usize>> {
        self.edit_state(|state| Ok(state.last_id.get(platform).cloned()))
    }

    pub fn set_last_id(&self, platform: &str, id: usize) -> Fallible<()> {
        self.edit_state(|state| {
            state.last_id.insert(platform.to_string(), id);
            Ok(())
        })
    }

    pub fn store_repo(&self, platform: &str, repo: Repo) -> Fallible<()> {
        // Ensure only one thread can write to CSV files at once
        let _lock = self.csv_write_lock.lock().unwrap();

        let file = self.base_dir.join(format!("{}.csv", platform));

        // Create the new file or append to it
        let mut csv = if file.exists() {
            csv::WriterBuilder::new()
                .has_headers(false)
                .from_writer(OpenOptions::new().append(true).open(&file)?)
        } else {
            csv::WriterBuilder::new().from_path(&file)?
        };

        csv.serialize(repo)?;

        Ok(())
    }
}



================================================
FILE: src/main.rs
================================================
// Copyright (c) 2018 Pietro Albini <pietro@pietroalbini.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

extern crate crossbeam_utils;
extern crate csv;
extern crate ctrlc;
extern crate env_logger;
#[macro_use]
extern crate failure;
#[macro_use]
extern crate log;
extern crate reqwest;
extern crate serde;
#[macro_use]
extern crate serde_derive;
#[macro_use]
extern crate serde_json;

mod config;
mod data;
mod github;
mod prelude;
mod utils;

use config::Config;
use prelude::*;
use std::path::PathBuf;
use std::sync::{
    atomic::{AtomicBool, Ordering},
    Arc,
};
use std::time::Instant;

fn app() -> Fallible<()> {
    // Get the GitHub token from the environment
    let github_token =
        std::env::var("GITHUB_TOKEN").context("failed to get the GitHub API token")?;

    let timeout = if let Ok(var) = std::env::var("RUST_REPOS_TIMEOUT") {
        Some(
            var.parse::<u64>()
                .context("failed to parse RUST_REPOS_TIMEOUT")?,
        )
    } else {
        None
    };

    // Parse CLI arguments
    let args = std::env::args().skip(1).collect::<Vec<String>>();
    if args.is_empty() {
        bail!("missing argument: <data_dir>");
    } else if args.len() > 1 {
        bail!("too many arguments");
    }

    // Ensure the data directory exists
    let data_dir = PathBuf::from(&args[0]);
    if !data_dir.is_dir() {
        debug!(
            "created missing data directory: {}",
            data_dir.to_string_lossy()
        );
        std::fs::create_dir_all(&data_dir)?;
    }

    let config = Config {
        github_token,
        data_dir,
        timeout,
    };

    let data = data::Data::new(&config);

    let should_stop = Arc::new(AtomicBool::new(false));
    let stop = should_stop.clone();
    ctrlc::set_handler(move || {
        info!("received Ctrl+C, terminating...");
        stop.store(true, Ordering::SeqCst);
    })?;

    github::scrape(&data, &config, &should_stop)?;

    Ok(())
}

fn main() {
    // Initialize logging
    // This doesn't use from_default_env() because it doesn't allow to override filter_module()
    // with the RUST_LOG environment variable
    let mut logger = env_logger::Builder::new();
    logger.filter_module("rust_repos", log::LevelFilter::Info);
    if let Ok(content) = std::env::var("RUST_LOG") {
        logger.parse_filters(&content);
    }
    logger.init();

    let start = Instant::now();

    let result = app();
    if let Err(ref err) = &result {
        utils::log_error(err);
    }

    info!(
        "execution completed in {} seconds",
        start.elapsed().as_secs()
    );

    if result.is_err() {
        std::process::exit(1);
    }
}



================================================
FILE: src/prelude.rs
================================================
// Copyright (c) 2018 Pietro Albini <pietro@pietroalbini.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub use failure::{err_msg, Error, Fail, Fallible, ResultExt};



================================================
FILE: src/utils.rs
================================================
// Copyright (c) 2018 Pietro Albini <pietro@pietroalbini.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use prelude::*;

pub fn log_error(err: &Error) {
    error!("{}", err);
    for cause in err.iter_causes() {
        error!("  caused by: {}", cause);
    }
}

pub fn wrap_thread<F: FnOnce() -> Fallible<()>>(f: F) {
    if let Err(err) = f() {
        log_error(&err);
    }
}



================================================
FILE: src/github/api.rs
================================================
// Copyright (c) 2018 Pietro Albini <pietro@pietroalbini.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use config::Config;
use prelude::*;
use reqwest::blocking::{Client, RequestBuilder, Response};
use reqwest::{header, Method, StatusCode};
use serde::{de::DeserializeOwned, Serialize};
use std::borrow::Cow;
use std::sync::{
    atomic::{AtomicBool, AtomicUsize, Ordering},
    Arc,
};
use std::time::Duration;

static USER_AGENT: &str = "rust-repos (https://github.com/rust-ops/rust-repos)";

static GRAPHQL_QUERY_REPOSITORIES: &str = "
query($ids: [ID!]!) {
    nodes(ids: $ids) {
        ... on Repository {
            id
            nameWithOwner
            defaultBranchRef {
                name
            }
            languages(first: 100, orderBy: { field: SIZE, direction: DESC }) {
                nodes {
                    name
                }
            }
        }
    }

    rateLimit {
        cost
    }
}
";

#[derive(Fail, Debug)]
#[fail(display = "internal github error: {:?}", _0)]
struct RetryRequest(StatusCode);

trait ResponseExt {
    fn handle_errors(self) -> Fallible<Self>
    where
        Self: Sized;
}

impl ResponseExt for Response {
    fn handle_errors(self) -> Fallible<Self> {
        let status = self.status();
        match status {
            StatusCode::INTERNAL_SERVER_ERROR
            | StatusCode::BAD_GATEWAY
            | StatusCode::SERVICE_UNAVAILABLE
            | StatusCode::GATEWAY_TIMEOUT => Err(RetryRequest(status).into()),
            _ => Ok(self),
        }
    }
}

pub struct GitHubApi<'conf> {
    config: &'conf Config,
    client: Client,
    slow_down: Arc<AtomicBool>,
    concurrent_requests: Arc<AtomicUsize>,
}

impl<'conf> GitHubApi<'conf> {
    pub fn new(config: &'conf Config) -> Self {
        GitHubApi {
            config,
            client: Client::new(),
            slow_down: Arc::new(AtomicBool::new(false)),
            concurrent_requests: Arc::new(AtomicUsize::new(0)),
        }
    }

    fn retry<T, F: Fn() -> Fallible<T>>(&self, f: F) -> Fallible<T> {
        let mut wait = Duration::from_secs(10);
        let mut first = true;

        loop {
            let concurrent = self.concurrent_requests.fetch_add(1, Ordering::SeqCst);
            debug!(
                "currently making {} concurrent requests to the GitHub API",
                concurrent + 1
            );
            let res = f();
            self.concurrent_requests.fetch_sub(1, Ordering::SeqCst);

            match res {
                Ok(res) => return Ok(res),
                Err(err) => {
                    let mut retry = false;
                    if let Some(error) = err.downcast_ref::<RetryRequest>() {
                        warn!(
                            "API call to GitHub returned status code {}, retrying in {} seconds",
                            error.0,
                            wait.as_secs()
                        );
                        retry = true;
                    } else if let Some(error) = err.downcast_ref::<reqwest::Error>() {
                        if error.is_timeout() {
                            warn!(
                                "API call to GitHub timed out, retrying in {} seconds",
                                wait.as_secs()
                            );
                            retry = true;
                        }
                    } else if let Some(error) = err.downcast_ref::<std::io::Error>() {
                        if error.kind() == std::io::ErrorKind::ConnectionReset {
                            warn!(
                                "connection to the API reset by peer, retrying in {} seconds",
                                wait.as_secs()
                            );
                            retry = true;
                        }
                    }

                    if !retry {
                        return Err(err);
                    }
                }
            }

            // Slow down only once per API call
            if first {
                self.slow_down.store(true, Ordering::SeqCst);
            }

            ::std::thread::sleep(wait);

            // Stop doubling the time after a few increments, to avoid waiting too long
            // This is still a request every ~10 minutes
            if wait.as_secs() < 640 {
                wait *= 2;
            }

            first = false;
        }
    }

    fn build_request(&self, method: Method, url: &str) -> RequestBuilder {
        let url = if !url.starts_with("https://") {
            Cow::Owned(format!("https://api.github.com/{}", url))
        } else {
            Cow::Borrowed(url)
        };

        self.client
            .request(method, url.as_ref())
            .header(
                header::AUTHORIZATION,
                format!("token {}", self.config.github_token),
            )
            .header(header::USER_AGENT, USER_AGENT)
    }

    fn graphql<T: DeserializeOwned, V: Serialize>(&self, query: &str, variables: V) -> Fallible<T> {
        self.retry(|| {
            let resp: GraphResponse<T> = self
                .build_request(Method::POST, "graphql")
                .json(&json!({
                    "query": query,
                    "variables": variables,
                }))
                .send()?
                .handle_errors()?
                .json()?;

            if let Some(data) = resp.data {
                if let Some(errors) = resp.errors {
                    for error in errors {
                        if let Some(ref type_) = error.type_ {
                            if type_ == "NOT_FOUND" {
                                debug!("ignored GraphQL error: {}", error.message);
                                continue;
                            }
                        }

                        warn!("non-fatal GraphQL error: {}", error.message);
                    }
                }

                Ok(data)
            } else if let Some(mut errors) = resp.errors {
                Err(err_msg(errors.pop().unwrap().message)
                    .context("GitHub GraphQL call failed")
                    .into())
            } else if let Some(message) = resp.message {
                if message.contains("abuse") {
                    warn!("triggered GitHub abuse detection systems");
                    Err(RetryRequest(StatusCode::TOO_MANY_REQUESTS).into())
                } else {
                    Err(err_msg(message)
                        .context("GitHub GraphQL call failed")
                        .into())
                }
            } else {
                Err(err_msg("empty GraphQL response"))
            }
        })
    }

    pub fn scrape_repositories(&self, since: usize) -> Fallible<Vec<Option<RestRepository>>> {
        self.retry(|| {
            let resp = self
                .build_request(Method::GET, &format!("repositories?since={}", since))
                .send()?
                .handle_errors()?;

            let status = resp.status();
            if status == StatusCode::OK {
                Ok(resp.json()?)
            } else {
                let error: GitHubError = resp.json()?;
                if error.message.contains("abuse") {
                    warn!("triggered GitHub abuse detection systems");
                    Err(RetryRequest(StatusCode::TOO_MANY_REQUESTS).into())
                } else {
                    Err(err_msg(error.message)
                        .context(format!(
                            "GitHub API call failed with status code: {}",
                            status
                        ))
                        .context(format!(
                            "failed to fetch GitHub repositories since ID {}",
                            since
                        ))
                        .into())
                }
            }
        })
    }

    pub fn load_repositories(&self, node_ids: &[String]) -> Fallible<Vec<Option<GraphRepository>>> {
        let data: GraphRepositories = self.graphql(
            GRAPHQL_QUERY_REPOSITORIES,
            json!({
                "ids": node_ids,
            }),
        )?;

        assert!(
            data.rate_limit.cost <= 1,
            "load repositories query too costly"
        );
        Ok(data.nodes)
    }

    pub fn file_exists(&self, repo: &GraphRepository, path: &str) -> Fallible<bool> {
        let url = format!(
            "https://raw.githubusercontent.com/{}/{}/{}",
            repo.name_with_owner,
            if let Some(ref_) = &repo.default_branch_ref {
                &ref_.name
            } else {
                "master"
            },
            path,
        );

        self.retry(|| {
            let resp = self
                .build_request(Method::GET, &url)
                .send()?
                .handle_errors()?;
            match resp.status() {
                StatusCode::OK => Ok(true),
                StatusCode::NOT_FOUND => Ok(false),
                status => Err(
                    err_msg(format!("GitHub API returned status code {}", status))
                        .context(format!(
                            "failed to fetch file {} from repo {}",
                            path, repo.name_with_owner,
                        ))
                        .into(),
                ),
            }
        })
    }

    pub fn should_slow_down(&self) -> bool {
        self.slow_down.swap(false, Ordering::SeqCst)
    }
}

#[derive(Deserialize)]
struct GitHubError {
    message: String,
    #[serde(rename = "type")]
    type_: Option<String>,
}

#[derive(Deserialize)]
pub struct RestRepository {
    pub id: usize,
    pub full_name: String,
    pub node_id: String,
    pub fork: bool,
}

#[derive(Deserialize)]
struct GraphResponse<T> {
    data: Option<T>,
    errors: Option<Vec<GitHubError>>,
    message: Option<String>,
}

#[derive(Deserialize)]
struct GraphRateLimit {
    cost: u16,
}

#[derive(Deserialize)]
#[serde(rename_all = "camelCase")]
struct GraphRepositories {
    nodes: Vec<Option<GraphRepository>>,
    rate_limit: GraphRateLimit,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GraphRepository {
    pub id: String,
    pub name_with_owner: String,
    pub default_branch_ref: Option<GraphRef>,
    pub languages: GraphLanguages,
}

#[derive(Debug, Deserialize)]
pub struct GraphLanguages {
    pub nodes: Vec<Option<GraphLanguage>>,
}

#[derive(Debug, Deserialize)]
pub struct GraphLanguage {
    pub name: String,
}

#[derive(Debug, Deserialize)]
pub struct GraphRef {
    pub name: String,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum GitHubErrorType {
    NotFound,
    Other(String),
}



================================================
FILE: src/github/mod.rs
================================================
// Copyright (c) 2018 Pietro Albini <pietro@pietroalbini.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

mod api;

use config::Config;
use crossbeam_utils::thread::scope;
use data::{Data, Repo};
use github::api::GitHubApi;
use prelude::*;
use std::sync::atomic::{AtomicBool, Ordering};
use std::time::{Duration, Instant};
use utils::wrap_thread;

static WANTED_LANG: &str = "Rust";

fn load_thread(api: &GitHubApi, data: &Data, to_load: Vec<String>) -> Fallible<()> {
    debug!(
        "collected {} non-fork repositories, loading them",
        to_load.len()
    );

    let mut graph_repos = api.load_repositories(&to_load)?;
    for repo in graph_repos.drain(..).flatten() {
        let mut found = false;
        for lang in repo.languages.nodes.iter().filter_map(Option::as_ref) {
            if lang.name == WANTED_LANG {
                found = true;
                break;
            }
        }

        if found {
            let has_cargo_toml = api.file_exists(&repo, "Cargo.toml")?;
            let has_cargo_lock = api.file_exists(&repo, "Cargo.lock")?;

            data.store_repo(
                "github",
                Repo {
                    id: repo.id,
                    name: repo.name_with_owner.clone(),
                    has_cargo_toml,
                    has_cargo_lock,
                },
            )?;

            info!(
                "found {}: Cargo.toml = {:?}, Cargo.lock = {:?}",
                repo.name_with_owner, has_cargo_toml, has_cargo_lock,
            );
        }
    }

    // Applease Clippy
    ::std::mem::drop(to_load);

    Ok(())
}

pub fn scrape(data: &Data, config: &Config, should_stop: &AtomicBool) -> Fallible<()> {
    info!("started scraping for GitHub repositories");

    let gh = api::GitHubApi::new(config);
    let mut to_load = Vec::with_capacity(100);

    let result = scope(|scope| {
        let mut last_id = data.get_last_id("github")?.unwrap_or(0);
        let scrape_start = Instant::now();

        loop {
            if let Some(timeout) = config.timeout {
                if scrape_start.elapsed() >= Duration::from_secs(timeout) {
                    info!("timeout reached, stopping the scraping loop");
                    break;
                }
            }

            // Wait 2 minutes if GitHub is slowing us down
            if gh.should_slow_down() {
                warn!("slowing down the scraping (2 minutes pause)");
                ::std::thread::sleep(Duration::from_secs(120));
            }

            let start = Instant::now();

            debug!("scraping 100 repositories from the REST API");

            // Load all the non-fork repositories in the to_load vector
            let mut repos = gh.scrape_repositories(last_id)?;
            let finished = repos.len() < 100 || should_stop.load(Ordering::SeqCst);
            for repo in repos.drain(..).flatten() {
                last_id = repo.id;
                if repo.fork {
                    continue;
                }

                to_load.push(repo.node_id);

                if to_load.len() == 100 {
                    let to_load_now = to_load.clone();
                    scope.spawn(|_| wrap_thread(|| load_thread(&gh, data, to_load_now)));
                    to_load.clear();
                }
            }

            data.set_last_id("github", last_id)?;

            if finished {
                // Ensure all the remaining repositories are loaded
                if !to_load.is_empty() {
                    let to_load_now = to_load.clone();
                    scope.spawn(|_| wrap_thread(|| load_thread(&gh, data, to_load_now)));
                }

                break;
            }

            // Avoid hammering GitHub too much
            if let Some(sleep) = Duration::from_secs(1).checked_sub(start.elapsed()) {
                ::std::thread::sleep(sleep);
            }
        }

        Ok(())
    })
    .unwrap();

    info!("finished scraping for GitHub repositories");
    result
}



================================================
FILE: .github/dependabot.yml
================================================
---
version: 2

updates:
  - package-ecosystem: "cargo"
    directory: "/"
    schedule:
      interval: "weekly"



================================================
FILE: .github/workflows/test.yml
================================================
---

name: Test
on:
  push:
    paths-ignore:
      - 'data/**'
  pull_request:

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Install Rust (stable)
        run: |
          rustup update stable
          rustup component add rustfmt
          rustup component add clippy

      - name: Check formatting
        run: cargo fmt --check

      - name: Check Clippy
        run: cargo clippy -- -Dwarnings

      - name: Run tests
        run: cargo test



================================================
FILE: .github/workflows/updater.yml
================================================
---

name: Updater
on:
  schedule:
    - cron: "0 */12 * * *"

jobs:
  github:
    name: GitHub
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Install Rust (stable)
        run: |
          rustup update stable
          rustup component add rustfmt
          rustup component add clippy

      - name: Build the updater
        run: cargo build --release

      - name: Run the updater
        run: ./ci-update.sh
        env:
          HIGHFIVE_GH_TOKEN: "${{ secrets.HIGHFIVE_GH_TOKEN }}"
          DEPLOY_KEY: "${{ secrets.DEPLOY_KEY }}"
          RUST_REPOS_TIMEOUT: 3600  # 1 hour


