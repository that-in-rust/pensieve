Directory structure:
└── google-comprehensive-rust/
    ├── README.md
    ├── book.toml
    ├── Cargo.toml
    ├── CONTRIBUTING.md
    ├── dprint.json
    ├── GEMINI.md
    ├── LICENSE
    ├── rustfmt.toml
    ├── STYLE.md
    ├── TRANSLATIONS.md
    ├── mdbook-course/
    │   ├── README.md
    │   ├── Cargo.toml
    │   └── src/
    │       ├── course.rs
    │       ├── frontmatter.rs
    │       ├── lib.rs
    │       ├── markdown.rs
    │       ├── replacements.rs
    │       └── timing_info.rs
    ├── mdbook-exerciser/
    │   ├── README.md
    │   ├── Cargo.toml
    │   └── src/
    │       ├── lib.rs
    │       └── main.rs
    ├── src/
    │   ├── README.md
    │   ├── android.md
    │   ├── bare-metal.md
    │   ├── borrowing.md
    │   ├── cargo.md
    │   ├── chromium.md
    │   ├── closures.md
    │   ├── control-flow-basics.md
    │   ├── credits.md
    │   ├── error-handling.md
    │   ├── generics.md
    │   ├── glossary.md
    │   ├── hello-world.md
    │   ├── index.md
    │   ├── iterators.md
    │   ├── lifetimes.md
    │   ├── memory-management.md
    │   ├── methods-and-traits.md
    │   ├── modules.md
    │   ├── other-resources.md
    │   ├── pattern-matching.md
    │   ├── references.md
    │   ├── running-the-course.md
    │   ├── smart-pointers.md
    │   ├── std-traits.md
    │   ├── std-types.md
    │   ├── SUMMARY.md
    │   ├── testing.md
    │   ├── thanks.md
    │   ├── tuples-and-arrays.md
    │   ├── types-and-values.md
    │   ├── unsafe-rust.md
    │   ├── user-defined-types.md
    │   ├── welcome-day-1-afternoon.md
    │   ├── welcome-day-1.md
    │   ├── welcome-day-2-afternoon.md
    │   ├── welcome-day-2.md
    │   ├── welcome-day-3-afternoon.md
    │   ├── welcome-day-3.md
    │   ├── welcome-day-4-afternoon.md
    │   ├── welcome-day-4.md
    │   ├── android/
    │   │   ├── aidl.md
    │   │   ├── bpfmt.sh
    │   │   ├── build-rules.md
    │   │   ├── build_all.sh
    │   │   ├── interoperability.md
    │   │   ├── logging.md
    │   │   ├── setup.md
    │   │   ├── testing.md
    │   │   ├── aidl/
    │   │   │   ├── birthday-service.md
    │   │   │   ├── types.md
    │   │   │   ├── birthday_service/
    │   │   │   │   ├── Android.bp
    │   │   │   │   ├── aidl/
    │   │   │   │   │   ├── Android.bp
    │   │   │   │   │   └── com/
    │   │   │   │   │       └── example/
    │   │   │   │   │           └── birthdayservice/
    │   │   │   │   │               ├── BirthdayInfo.aidl
    │   │   │   │   │               ├── IBirthdayInfoProvider.aidl
    │   │   │   │   │               └── IBirthdayService.aidl
    │   │   │   │   └── src/
    │   │   │   │       ├── client.rs
    │   │   │   │       ├── lib.rs
    │   │   │   │       └── server.rs
    │   │   │   ├── example-service/
    │   │   │   │   ├── changing-definition.md
    │   │   │   │   ├── changing-implementation.md
    │   │   │   │   ├── client.md
    │   │   │   │   ├── deploy.md
    │   │   │   │   ├── implementation.md
    │   │   │   │   ├── interface.md
    │   │   │   │   ├── server.md
    │   │   │   │   ├── service-bindings.md
    │   │   │   │   └── service.md
    │   │   │   └── types/
    │   │   │       ├── arrays.md
    │   │   │       ├── file-descriptor.md
    │   │   │       ├── objects.md
    │   │   │       ├── parcelables.md
    │   │   │       └── primitives.md
    │   │   ├── build-rules/
    │   │   │   ├── binary.md
    │   │   │   ├── library.md
    │   │   │   ├── binary/
    │   │   │   │   ├── Android.bp
    │   │   │   │   └── src/
    │   │   │   │       └── main.rs
    │   │   │   └── library/
    │   │   │       ├── Android.bp
    │   │   │       └── src/
    │   │   │           ├── lib.rs
    │   │   │           └── main.rs
    │   │   ├── interoperability/
    │   │   │   ├── cpp.md
    │   │   │   ├── java.md
    │   │   │   ├── with-c.md
    │   │   │   ├── cpp/
    │   │   │   │   ├── android-build-cpp.md
    │   │   │   │   ├── android-build-rust.md
    │   │   │   │   ├── android-cpp-genrules.md
    │   │   │   │   ├── bridge.md
    │   │   │   │   ├── cpp-bridge.md
    │   │   │   │   ├── cpp-exception.md
    │   │   │   │   ├── generated-cpp.md
    │   │   │   │   ├── rust-bridge.md
    │   │   │   │   ├── rust-result.md
    │   │   │   │   ├── shared-enums.md
    │   │   │   │   ├── shared-types.md
    │   │   │   │   └── type-mapping.md
    │   │   │   ├── java/
    │   │   │   │   ├── Android.bp
    │   │   │   │   ├── HelloWorld.java
    │   │   │   │   └── src/
    │   │   │   │       └── lib.rs
    │   │   │   └── with-c/
    │   │   │       ├── bindgen.md
    │   │   │       ├── c-library.md
    │   │   │       ├── hand-written.md
    │   │   │       ├── run-our-binary.md
    │   │   │       ├── rust-library.md
    │   │   │       ├── rust.md
    │   │   │       ├── bindgen/
    │   │   │       │   ├── Android.bp
    │   │   │       │   ├── c-library.md
    │   │   │       │   ├── libbirthday.c
    │   │   │       │   ├── libbirthday.h
    │   │   │       │   ├── libbirthday_wrapper.h
    │   │   │       │   └── main.rs
    │   │   │       └── rust/
    │   │   │           ├── analyze/
    │   │   │           │   ├── Android.bp
    │   │   │           │   └── main.c
    │   │   │           └── libanalyze/
    │   │   │               ├── analyze.h
    │   │   │               ├── analyze.rs
    │   │   │               └── Android.bp
    │   │   ├── logging/
    │   │   │   ├── Android.bp
    │   │   │   └── src/
    │   │   │       └── main.rs
    │   │   └── testing/
    │   │       ├── Android.bp
    │   │       ├── Cargo.toml
    │   │       ├── googletest.md
    │   │       ├── googletest.rs
    │   │       ├── mockall.rs
    │   │       ├── mocking.md
    │   │       └── src/
    │   │           └── lib.rs
    │   ├── bare-metal/
    │   │   ├── alloc.md
    │   │   ├── android.md
    │   │   ├── aps.md
    │   │   ├── microcontrollers.md
    │   │   ├── minimal.md
    │   │   ├── no_std.md
    │   │   ├── useful-crates.md
    │   │   ├── alloc-example/
    │   │   │   ├── Cargo.toml
    │   │   │   ├── src/
    │   │   │   │   └── main.rs
    │   │   │   └── .cargo/
    │   │   │       └── config.toml
    │   │   ├── android/
    │   │   │   └── vmbase.md
    │   │   ├── aps/
    │   │   │   ├── aarch64-rt.md
    │   │   │   ├── better-uart.md
    │   │   │   ├── entry-point.md
    │   │   │   ├── exceptions.md
    │   │   │   ├── inline-assembly.md
    │   │   │   ├── logging.md
    │   │   │   ├── mmio.md
    │   │   │   ├── other-projects.md
    │   │   │   ├── uart.md
    │   │   │   ├── better-uart/
    │   │   │   │   ├── bitflags.md
    │   │   │   │   ├── driver.md
    │   │   │   │   └── registers.md
    │   │   │   ├── examples/
    │   │   │   │   ├── Cargo.toml
    │   │   │   │   ├── image.ld
    │   │   │   │   ├── Makefile
    │   │   │   │   ├── src/
    │   │   │   │   │   ├── asm.rs
    │   │   │   │   │   ├── entry.S
    │   │   │   │   │   ├── exceptions.rs
    │   │   │   │   │   ├── exceptions.S
    │   │   │   │   │   ├── idmap.S
    │   │   │   │   │   ├── logger.rs
    │   │   │   │   │   ├── main_improved.rs
    │   │   │   │   │   ├── main_logger.rs
    │   │   │   │   │   ├── main_minimal.rs
    │   │   │   │   │   ├── main_psci.rs
    │   │   │   │   │   ├── main_rt.rs
    │   │   │   │   │   ├── main_safemmio.rs
    │   │   │   │   │   ├── pl011.rs
    │   │   │   │   │   ├── pl011_minimal.rs
    │   │   │   │   │   └── pl011_struct.rs
    │   │   │   │   └── .cargo/
    │   │   │   │       └── config.toml
    │   │   │   ├── logging/
    │   │   │   │   └── using.md
    │   │   │   ├── safemmio/
    │   │   │   │   ├── driver.md
    │   │   │   │   ├── registers.md
    │   │   │   │   └── using.md
    │   │   │   └── uart/
    │   │   │       ├── traits.md
    │   │   │       └── using.md
    │   │   ├── microcontrollers/
    │   │   │   ├── board-support.md
    │   │   │   ├── debugging.md
    │   │   │   ├── embedded-hal.md
    │   │   │   ├── hals.md
    │   │   │   ├── mmio.md
    │   │   │   ├── other-projects.md
    │   │   │   ├── pacs.md
    │   │   │   ├── probe-rs.md
    │   │   │   ├── type-state.md
    │   │   │   └── examples/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Embed.toml
    │   │   │       └── .cargo/
    │   │   │           └── config.toml
    │   │   └── useful-crates/
    │   │       ├── aarch64-paging.md
    │   │       ├── buddy_system_allocator.md
    │   │       ├── spin.md
    │   │       ├── tinyvec.md
    │   │       ├── zerocopy.md
    │   │       ├── allocator-example/
    │   │       │   ├── Cargo.toml
    │   │       │   └── src/
    │   │       │       └── main.rs
    │   │       └── zerocopy-example/
    │   │           ├── Cargo.toml
    │   │           └── src/
    │   │               └── main.rs
    │   ├── borrowing/
    │   │   ├── borrowck.md
    │   │   ├── Cargo.toml
    │   │   ├── examples.md
    │   │   ├── exercise.md
    │   │   ├── interior-mutability.md
    │   │   ├── shared.md
    │   │   ├── solution.md
    │   │   └── interior-mutability/
    │   │       ├── cell.md
    │   │       └── refcell.md
    │   ├── cargo/
    │   │   ├── code-samples.md
    │   │   ├── running-locally.md
    │   │   └── rust-ecosystem.md
    │   ├── chromium/
    │   │   ├── adding-third-party-crates.md
    │   │   ├── build-rules.md
    │   │   ├── cargo.md
    │   │   ├── interoperability-with-cpp.md
    │   │   ├── policy.md
    │   │   ├── setup.md
    │   │   ├── testing.md
    │   │   ├── adding-third-party-crates/
    │   │   │   ├── checking-in.md
    │   │   │   ├── configuring-cargo-toml.md
    │   │   │   ├── configuring-gnrt-config-toml.md
    │   │   │   ├── depending-on-a-crate.md
    │   │   │   ├── downloading-crates.md
    │   │   │   ├── generating-gn-build-rules.md
    │   │   │   ├── keeping-up-to-date.md
    │   │   │   ├── resolving-problems.md
    │   │   │   ├── reviews-and-audits.md
    │   │   │   └── resolving-problems/
    │   │   │       ├── build-scripts-which-generate-code.md
    │   │   │       └── build-scripts-which-take-arbitrary-actions.md
    │   │   ├── build-rules/
    │   │   │   ├── depending.md
    │   │   │   ├── unsafe.md
    │   │   │   └── vscode.md
    │   │   ├── interoperability-with-cpp/
    │   │   │   ├── error-handling-png.md
    │   │   │   ├── error-handling-qr.md
    │   │   │   ├── error-handling.md
    │   │   │   ├── example-bindings.md
    │   │   │   ├── limitations-of-cxx.md
    │   │   │   └── using-cxx-in-chromium.md
    │   │   └── testing/
    │   │       ├── build-gn.md
    │   │       ├── chromium-import-macro.md
    │   │       └── rust-gtest-interop.md
    │   ├── closures/
    │   │   ├── capturing.md
    │   │   ├── exercise.md
    │   │   ├── exercise.rs
    │   │   ├── solution.md
    │   │   ├── syntax.md
    │   │   └── traits.md
    │   ├── concurrency/
    │   │   ├── async-control-flow.md
    │   │   ├── async-exercises.md
    │   │   ├── async-pitfalls.md
    │   │   ├── async.md
    │   │   ├── channels.md
    │   │   ├── send-sync.md
    │   │   ├── shared-state.md
    │   │   ├── sync-exercises.md
    │   │   ├── threads.md
    │   │   ├── welcome-async.md
    │   │   ├── welcome.md
    │   │   ├── async/
    │   │   │   ├── async-await.md
    │   │   │   ├── futures.md
    │   │   │   ├── runtimes.md
    │   │   │   ├── state-machine.md
    │   │   │   ├── tasks.md
    │   │   │   └── runtimes/
    │   │   │       └── tokio.md
    │   │   ├── async-control-flow/
    │   │   │   ├── channels.md
    │   │   │   ├── join.md
    │   │   │   └── select.md
    │   │   ├── async-exercises/
    │   │   │   ├── afternoon.md
    │   │   │   ├── chat-app.md
    │   │   │   ├── dining-philosophers.md
    │   │   │   ├── dining-philosophers.rs
    │   │   │   ├── solutions.md
    │   │   │   └── chat-async/
    │   │   │       └── Cargo.toml
    │   │   ├── async-pitfalls/
    │   │   │   ├── async-traits.md
    │   │   │   ├── blocking-executor.md
    │   │   │   ├── cancellation.md
    │   │   │   └── pin.md
    │   │   ├── channels/
    │   │   │   ├── bounded.md
    │   │   │   ├── senders-receivers.md
    │   │   │   └── unbounded.md
    │   │   ├── send-sync/
    │   │   │   ├── examples.md
    │   │   │   ├── marker-traits.md
    │   │   │   ├── send.md
    │   │   │   └── sync.md
    │   │   ├── shared-state/
    │   │   │   ├── arc.md
    │   │   │   ├── example.md
    │   │   │   └── mutex.md
    │   │   ├── sync-exercises/
    │   │   │   ├── Cargo.toml
    │   │   │   ├── dining-philosophers.md
    │   │   │   ├── dining-philosophers.rs
    │   │   │   ├── link-checker.md
    │   │   │   ├── link-checker.rs
    │   │   │   └── solutions.md
    │   │   └── threads/
    │   │       ├── plain.md
    │   │       └── scoped.md
    │   ├── control-flow-basics/
    │   │   ├── blocks-and-scopes.md
    │   │   ├── break-continue.md
    │   │   ├── Cargo.toml
    │   │   ├── exercise.md
    │   │   ├── exercise.rs
    │   │   ├── functions.md
    │   │   ├── if.md
    │   │   ├── loops.md
    │   │   ├── macros.md
    │   │   ├── match.md
    │   │   ├── solution.md
    │   │   ├── break-continue/
    │   │   │   └── labels.md
    │   │   └── loops/
    │   │       ├── for.md
    │   │       └── loop.md
    │   ├── error-handling/
    │   │   ├── anyhow.md
    │   │   ├── Cargo.toml
    │   │   ├── error.md
    │   │   ├── exercise.md
    │   │   ├── exercise.rs
    │   │   ├── panics.md
    │   │   ├── result.md
    │   │   ├── solution.md
    │   │   ├── thiserror.md
    │   │   ├── try-conversions.md
    │   │   └── try.md
    │   ├── exercises/
    │   │   ├── bare-metal/
    │   │   │   ├── afternoon.md
    │   │   │   ├── compass.md
    │   │   │   ├── morning.md
    │   │   │   ├── rtc.md
    │   │   │   ├── solutions-afternoon.md
    │   │   │   ├── solutions-morning.md
    │   │   │   ├── compass/
    │   │   │   │   ├── Cargo.toml
    │   │   │   │   ├── Embed.toml
    │   │   │   │   ├── src/
    │   │   │   │   │   └── main.rs
    │   │   │   │   └── .cargo/
    │   │   │   │       └── config.toml
    │   │   │   └── rtc/
    │   │   │       ├── build.rs
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Makefile
    │   │   │       ├── memory.ld
    │   │   │       ├── src/
    │   │   │       │   ├── exceptions.rs
    │   │   │       │   ├── logger.rs
    │   │   │       │   ├── main.rs
    │   │   │       │   └── pl031.rs
    │   │   │       └── .cargo/
    │   │   │           └── config.toml
    │   │   └── chromium/
    │   │       ├── bringing-it-together.md
    │   │       ├── build-rules.md
    │   │       ├── interoperability-with-cpp.md
    │   │       ├── solutions.md
    │   │       ├── testing.md
    │   │       └── third-party.md
    │   ├── generics/
    │   │   ├── Cargo.toml
    │   │   ├── dyn-trait.md
    │   │   ├── exercise.md
    │   │   ├── exercise.rs
    │   │   ├── generic-data.md
    │   │   ├── generic-functions.md
    │   │   ├── generic-traits.md
    │   │   ├── impl-trait.md
    │   │   ├── solution.md
    │   │   └── trait-bounds.md
    │   ├── hello-world/
    │   │   ├── benefits.md
    │   │   ├── playground.md
    │   │   └── what-is-rust.md
    │   ├── idiomatic/
    │   │   ├── leveraging-the-type-system.md
    │   │   ├── welcome.md
    │   │   └── leveraging-the-type-system/
    │   │       ├── newtype-pattern.md
    │   │       ├── typestate-pattern.md
    │   │       ├── newtype-pattern/
    │   │       │   ├── is-it-encapsulated.md
    │   │       │   ├── parse-don-t-validate.md
    │   │       │   └── semantic-confusion.md
    │   │       └── typestate-pattern/
    │   │           ├── typestate-advanced.md
    │   │           ├── typestate-example.md
    │   │           ├── typestate-generics.md
    │   │           ├── typestate-generics.rs
    │   │           └── typestate-generics/
    │   │               ├── complete.md
    │   │               ├── property.md
    │   │               ├── root.md
    │   │               └── struct.md
    │   ├── iterators/
    │   │   ├── Cargo.toml
    │   │   ├── collect.md
    │   │   ├── exercise.md
    │   │   ├── exercise.rs
    │   │   ├── helpers.md
    │   │   ├── intoiterator.md
    │   │   ├── iterator.md
    │   │   ├── motivation.md
    │   │   └── solution.md
    │   ├── lifetimes/
    │   │   ├── Cargo.toml
    │   │   ├── exercise.md
    │   │   ├── exercise.rs
    │   │   ├── lifetime-annotations.md
    │   │   ├── lifetime-elision.md
    │   │   ├── solution.md
    │   │   └── struct-lifetimes.md
    │   ├── memory-management/
    │   │   ├── approaches.md
    │   │   ├── Cargo.toml
    │   │   ├── clone.md
    │   │   ├── copy-types.md
    │   │   ├── drop.md
    │   │   ├── exercise.md
    │   │   ├── exercise.rs
    │   │   ├── move.md
    │   │   ├── ownership.md
    │   │   ├── review.md
    │   │   └── solution.md
    │   ├── methods-and-traits/
    │   │   ├── Cargo.toml
    │   │   ├── deriving.md
    │   │   ├── exercise.md
    │   │   ├── exercise.rs
    │   │   ├── methods.md
    │   │   ├── solution.md
    │   │   ├── traits.md
    │   │   └── traits/
    │   │       ├── associated-types.md
    │   │       ├── implementing.md
    │   │       └── supertraits.md
    │   ├── modules/
    │   │   ├── Cargo.toml
    │   │   ├── encapsulation.md
    │   │   ├── exercise.md
    │   │   ├── exercise.rs
    │   │   ├── filesystem.md
    │   │   ├── modules.md
    │   │   ├── paths.md
    │   │   ├── solution.md
    │   │   └── visibility.md
    │   ├── pattern-matching/
    │   │   ├── Cargo.toml
    │   │   ├── destructuring-enums.md
    │   │   ├── destructuring-structs.md
    │   │   ├── exercise.md
    │   │   ├── exercise.rs
    │   │   ├── infallible.md
    │   │   ├── let-control-flow.md
    │   │   ├── match.md
    │   │   ├── solution.md
    │   │   └── let-control-flow/
    │   │       ├── if-let.md
    │   │       ├── let-else.md
    │   │       └── while-let.md
    │   ├── references/
    │   │   ├── Cargo.toml
    │   │   ├── dangling.md
    │   │   ├── exclusive.md
    │   │   ├── exercise.md
    │   │   ├── exercise.rs
    │   │   ├── shared.md
    │   │   ├── slices.md
    │   │   ├── solution.md
    │   │   └── strings.md
    │   ├── running-the-course/
    │   │   ├── course-structure.md
    │   │   ├── keyboard-shortcuts.md
    │   │   └── translations.md
    │   ├── smart-pointers/
    │   │   ├── box.md
    │   │   ├── Cargo.toml
    │   │   ├── exercise.md
    │   │   ├── exercise.rs
    │   │   ├── rc.md
    │   │   ├── solution.md
    │   │   └── trait-objects.md
    │   ├── std-traits/
    │   │   ├── Cargo.toml
    │   │   ├── casting.md
    │   │   ├── comparisons.md
    │   │   ├── default.md
    │   │   ├── exercise.md
    │   │   ├── exercise.rs
    │   │   ├── from-and-into.md
    │   │   ├── operators.md
    │   │   ├── read-and-write.md
    │   │   └── solution.md
    │   ├── std-types/
    │   │   ├── Cargo.toml
    │   │   ├── docs.md
    │   │   ├── exercise.md
    │   │   ├── exercise.rs
    │   │   ├── hashmap.md
    │   │   ├── option.md
    │   │   ├── result.md
    │   │   ├── solution.md
    │   │   ├── std.md
    │   │   ├── string.md
    │   │   └── vec.md
    │   ├── testing/
    │   │   ├── Cargo.toml
    │   │   ├── exercise.md
    │   │   ├── exercise.rs
    │   │   ├── lints.md
    │   │   ├── other.md
    │   │   ├── solution.md
    │   │   └── unit-tests.md
    │   ├── tuples-and-arrays/
    │   │   ├── arrays.md
    │   │   ├── Cargo.toml
    │   │   ├── destructuring.md
    │   │   ├── exercise.md
    │   │   ├── exercise.rs
    │   │   ├── iteration.md
    │   │   ├── solution.md
    │   │   └── tuples.md
    │   ├── types-and-values/
    │   │   ├── arithmetic.md
    │   │   ├── Cargo.toml
    │   │   ├── exercise.md
    │   │   ├── exercise.rs
    │   │   ├── hello-world.md
    │   │   ├── inference.md
    │   │   ├── solution.md
    │   │   ├── values.md
    │   │   └── variables.md
    │   ├── unsafe-deep-dive/
    │   │   ├── Cargo.toml
    │   │   ├── foundations.md
    │   │   ├── motivations.md
    │   │   ├── setup.md
    │   │   ├── welcome.md
    │   │   ├── foundations/
    │   │   │   ├── actions-might-not-be.md
    │   │   │   ├── data-structures-are-safe.md
    │   │   │   ├── less-powerful.md
    │   │   │   ├── what-is-unsafe.md
    │   │   │   └── when-is-unsafe-used.md
    │   │   └── motivations/
    │   │       ├── data-structures.md
    │   │       ├── interop.md
    │   │       └── performance.md
    │   ├── unsafe-rust/
    │   │   ├── Cargo.toml
    │   │   ├── dereferencing.md
    │   │   ├── exercise.md
    │   │   ├── exercise.rs
    │   │   ├── mutable-static.md
    │   │   ├── solution.md
    │   │   ├── unions.md
    │   │   ├── unsafe-functions.md
    │   │   ├── unsafe-traits.md
    │   │   ├── unsafe.md
    │   │   └── unsafe-functions/
    │   │       ├── calling.md
    │   │       ├── extern-c.md
    │   │       └── rust.md
    │   └── user-defined-types/
    │       ├── aliases.md
    │       ├── Cargo.toml
    │       ├── const.md
    │       ├── enums.md
    │       ├── exercise.md
    │       ├── exercise.rs
    │       ├── named-structs.md
    │       ├── solution.md
    │       ├── static.md
    │       └── tuple-structs.md
    ├── tests/
    │   ├── README.md
    │   ├── package.json
    │   ├── tsconfig.json
    │   ├── wdio.conf-mdbook.ts
    │   ├── wdio.conf.ts
    │   └── src/
    │       ├── generic-page.test.ts
    │       ├── playground.test.ts
    │       ├── slide-style-guide.test.ts
    │       ├── speaker-notes.test.ts
    │       ├── objects/
    │       │   ├── playground.ts
    │       │   └── slide.ts
    │       └── slides/
    │           ├── create-slide.list.sh
    │           ├── slide-exemptions.list.ts
    │           └── slides.list.ts
    ├── theme/
    │   ├── book.js
    │   ├── head.hbs
    │   ├── index.hbs
    │   ├── instructor-menu.js
    │   ├── redbox.js
    │   ├── save-playgrounds.js
    │   ├── speaker-notes.js
    │   └── css/
    │       ├── language-picker.css
    │       ├── redbox.css
    │       ├── rtl.css
    │       ├── speaker-notes.css
    │       └── svgbob.css
    ├── third_party/
    │   ├── README.md
    │   ├── cxx/
    │   │   ├── README.md
    │   │   ├── LICENSE-APACHE
    │   │   ├── LICENSE-MIT
    │   │   ├── blobstore/
    │   │   │   ├── Android.bp
    │   │   │   ├── BUILD
    │   │   │   ├── build.rs
    │   │   │   ├── Cargo.toml
    │   │   │   ├── include/
    │   │   │   │   └── blobstore.h
    │   │   │   └── src/
    │   │   │       ├── blobstore.cc
    │   │   │       └── main.rs
    │   │   └── book/
    │   │       ├── snippets.cc
    │   │       └── snippets.rs
    │   ├── mdbook/
    │   │   ├── README.md
    │   │   ├── LICENSE
    │   │   ├── book.js -> book.js
    │   │   └── index.hbs -> index.hbs
    │   ├── rust-by-example/
    │   │   ├── README.md
    │   │   ├── destructuring-arrays.rs
    │   │   ├── destructuring-structs.rs
    │   │   ├── LICENSE-APACHE
    │   │   ├── LICENSE-MIT
    │   │   ├── match-guards.rs
    │   │   └── webevent.rs
    │   └── rust-on-exercism/
    │       ├── README.md
    │       ├── health-statistics.md
    │       ├── health-statistics.rs
    │       └── LICENSE
    ├── xtask/
    │   ├── README.md
    │   ├── Cargo.toml
    │   └── src/
    │       └── main.rs
    ├── .cargo/
    │   └── config.toml
    └── .github/
        ├── CODEOWNERS
        ├── dependabot.yml
        ├── labeler.yml
        ├── typos.toml
        ├── pandoc/
        │   ├── README.md
        │   ├── ja.yaml
        │   ├── ko.yaml
        │   ├── zh-CN.yaml
        │   └── zh-TW.yaml
        └── workflows/
            ├── build.sh
            ├── build.yml
            ├── check-msgid-changes.py
            ├── check-msgid-changes.yml
            ├── labeler.yml
            ├── lint.yml
            ├── publish.yml
            ├── apt-get-install/
            │   └── action.yml
            ├── install-mdbook/
            │   └── action.yml
            └── setup-rust-cache/
                └── action.yml

================================================
FILE: README.md
================================================
# Comprehensive Rust 🦀

[![Build workflow](https://img.shields.io/github/actions/workflow/status/google/comprehensive-rust/build.yml?style=flat-square)](https://github.com/google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain)
[![GitHub contributors](https://img.shields.io/github/contributors/google/comprehensive-rust?style=flat-square)](https://github.com/google/comprehensive-rust/graphs/contributors)
[![GitHub stars](https://img.shields.io/github/stars/google/comprehensive-rust?style=flat-square)](https://github.com/google/comprehensive-rust/stargazers)

This repository has the source code for Comprehensive Rust 🦀, a multi-day Rust
course developed by the Android team. The course covers all aspects of Rust,
from basic syntax to generics and error handling. It also includes deep dives on
[Android], [Chromium], [bare-metal], and [concurrency].

[Android]: https://google.github.io/comprehensive-rust/android.html
[Chromium]: https://google.github.io/comprehensive-rust/chromium.html
[bare-metal]: https://google.github.io/comprehensive-rust/bare-metal.html
[concurrency]: https://google.github.io/comprehensive-rust/concurrency.html

Read the course at **https://google.github.io/comprehensive-rust/**.

## Course Format and Target Audience

The course is used internally at Google to teach Rust to experienced software
engineers, typically with a background in C++ or Java.

The course is taught in a classroom setting, and we hope it will be useful for
others who want to teach Rust to their team. The course is less ideal for
self-study, since you would miss out on classroom discussions. You would not see
the questions and answers, nor the compiler errors we trigger when going through
the code samples. We hope to improve the self-study experience via
[speaker notes](https://github.com/google/comprehensive-rust/issues/53) and by
[publishing videos](https://github.com/google/comprehensive-rust/issues/52).

## Press

Articles and blog posts from around the web which cover Comprehensive Rust:

- 2023-09-08:
  _[Teaching Rust in 5 days](https://mo8it.com/blog/teaching-rust/)_.
  Comprehensive Rust was used as a base for a 5-day university class on Rust.
- 2023-09-21:
  _[Scaling Rust Adoption Through Training](https://security.googleblog.com/2023/09/scaling-rust-adoption-through-training.html)_.
  We published a blog post with details on the development of the course.
- 2023-10-02:
  _[In Search of Rust Developers, Companies Turn to In-House Training](https://www.darkreading.com/application-security/seeking-rust-developers-in-house-training)_.
  About how Microsoft, Google, and others are training people in Rust.
- 2024-10-18:
  _[Rust Training at Scale | Rust Global @ RustConf 2024](https://youtu.be/7h5KyMqt2-Q?si=4M99HdWWxMaqN8Zr)_.
  What Google learned from teaching Comprehensive Rust for more than two years.

## Setup

The course is built using a few tools:

- [mdbook](https://github.com/rust-lang/mdBook)
- [mdbook-svgbob](https://github.com/boozook/mdbook-svgbob)
- [mdbook-i18n-helpers and i18n-report](https://github.com/google/mdbook-i18n-helpers)
- [mdbook-exerciser](mdbook-exerciser/)
- [mdbook-course](mdbook-course/)
- [mdbook-linkcheck2](https://github.com/marxin/mdbook-linkcheck2)

First, install Rust by following the instructions on https://rustup.rs/. Then
clone this repository:

```shell
git clone https://github.com/google/comprehensive-rust/
cd comprehensive-rust
```

Then run the following command to install the correct versions of all tools
mentioned above:

```shell
cargo xtask install-tools
```

This uses `cargo install` to install the tools, so you will find them in your
`~/.cargo/bin/` directory afterwards.

## Commands

Here are some of the commonly used commands you can run in the project. Run
`cargo xtask` to view all available commands.

| Command                     | Description                                                                                                                                                                                                                                                                                                                                                                                                                            |
| --------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `cargo xtask install-tools` | Install all the tools the project depends on.                                                                                                                                                                                                                                                                                                                                                                                          |
| `cargo xtask serve`         | Start a web server with the course. You'll find the content on http://localhost:3000. To serve any of the translated versions of the course, add the language flag (--language or -l) followed by xx, where xx is the ISO 639 language code (e.g. cargo xtask serve -l da for the Danish translation).                                                                                                                                 |
| `cargo xtask rust-tests`    | Test the included Rust snippets.                                                                                                                                                                                                                                                                                                                                                                                                       |
| `cargo xtask web-tests`     | Run the web driver tests in the tests directory.                                                                                                                                                                                                                                                                                                                                                                                       |
| `cargo xtask build`         | Create a static version of the course in the `book/` directory. Note that you have to separately build and zip exercises and add them to book/html. To build any of the translated versions of the course, add the language flag (--language or -l) followed by xx, where xx is the ISO 639 language code (e.g. cargo xtask build -l da for the Danish translation). [TRANSLATIONS.md](TRANSLATIONS.md) contains further instructions. |

> **Note** On Windows, you need to enable symlinks
> (`git config --global core.symlinks true`) and Developer Mode.

## Contributing

We welcome contributions. Please see [CONTRIBUTING.md](CONTRIBUTING.md) for
details.

## Contact

For questions or comments, please contact
[Martin Geisler](mailto:mgeisler@google.com) or start a
[discussion on GitHub](https://github.com/google/comprehensive-rust/discussions).
We would love to hear from you.



================================================
FILE: book.toml
================================================
[book]
authors = ["Martin Geisler"]
language = "en"
src = "src"
title = "Comprehensive Rust 🦀"

[rust]
edition = "2024"

[build]
extra-watch-dirs = ["po", "third_party"]

[preprocessor.gettext]
after = ["links"]

[preprocessor.svgbob]
renderers = ["html"]
after = ["gettext"]
class = "bob"

[preprocessor.course]
verbose = false # Report timing information.

[output.xgettext]
optional = true
pot-file = "messages.pot"
granularity = 0

[output.pandoc]
optional = true
disabled = true
hosted-html = "https://google.github.io/comprehensive-rust/"

[output.pandoc.profile.pdf]
output-file = "comprehensive-rust.pdf"
pdf-engine = "lualatex"

[output.pandoc.profile.pdf.variables]
mainfont = "Noto Serif"
sansfont = "Noto Sans"
monofont = "Noto Sans Mono"
mainfontfallback = [
  "NotoColorEmoji:mode=harf",
  "NotoNaskhArabic:",
]
sansfontfallback = [
  "NotoSansArabic:",
]
monofontfallback = [
  "NotoColorEmoji:mode=harf",
  "NotoSansMath:",
  "NotoSansMonoCJKSC:",
  "NotoSansArabic:",
]
geometry = ["margin=1.25in"]
linkcolor = "blue"
urlcolor = "red"

[output.html]
smart-punctuation = true
additional-js = [
  "theme/speaker-notes.js",
]
additional-css = [
  "theme/css/svgbob.css",
  "theme/css/redbox.css",
  "theme/css/speaker-notes.css",
  "theme/css/language-picker.css",
  "theme/css/rtl.css",
]
site-url = "/comprehensive-rust/"
git-repository-url = "https://github.com/google/comprehensive-rust"
edit-url-template = "https://github.com/google/comprehensive-rust/edit/main/{path}"

[output.html.fold]
enable = true
level = 0

[output.html.playground]
editable = true
line-numbers = true

[output.html.search]
use-boolean-and = true

# Redirects in the form of "old-path" = "new-path", where the new path
# is relative to the old path.
#
# Please keep the table sorted and avoid multi-step redirects.
[output.html.redirect]
"async/async-await.html" = "../concurrency/async/async-await.html"
"async/channels.html" = "../concurrency/async-control-flow/channels.html"
"async/concurrency/channels.html" = "../channels.html"
"async/control-flow/join.html" = "../concurrency/async-control-flow/join.html"
"async/control-flow/select.html" = "../concurrency/async-control-flow/select.html"
"async/futures.html" = "../concurrency/async/futures.html"
"async.html" = "concurrency/welcome-async.html"
"async/pitfall/async-traits.html" = "../async-pitfalls/async-traits.html"
"async/pitfalls/async-traits.html" = "../concurrency/async-pitfalls/async-traits.html"
"async/pitfalls/blocking-executor.html" = "../concurrency/async-pitfalls/blocking-executor.html"
"async/pitfalls/cancellation.html" = "../concurrency/async-pitfalls/cancellation.html"
"async/pitfalls.html" = "../concurrency/async-pitfalls.html"
"async/pitfalls/pin.html" = "../concurrency/async-pitfalls/pin.html"
"async/runtimes.html" = "../concurrency/async/runtimes.html"
"async/runtimes/tokio.html" = "../concurrency/async/runtimes/tokio.html"
"async/tasks.html" = "../concurrency/async/tasks.html"
"basic-syntax/compound-types.html" = "../tuples-and-arrays/tuples-and-arrays.html"
"basic-syntax/functions.html" = "../control-flow-basics/functions.html"
"basic-syntax/functions-interlude.html" = "../control-flow-basics/functions.html"
"basic-syntax.html" = "control-flow-basics.html"
"basic-syntax/methods.html" = "../control-flow-basics/functions.html"
"basic-syntax/references-dangling.html" = "../references/shared.html"
"basic-syntax/references.html" = "../references/shared.html"
"basic-syntax/rustdoc.html" = "../std-types/docs.html"
"basic-syntax/scalar-types.html" = "../types-and-values/values.html"
"basic-syntax/scopes-shadowing.html" = "../control-flow-basics/blocks-and-scopes.html"
"basic-syntax/slices.html" = "../references/slices.html"
"basic-syntax/static-and-const.html" = "../unsafe-rust/static-and-const.html"
"basic-syntax/string-slices.html" = "../references/strings.html"
"basic-syntax/type-inference.html" = "../types-and-values/inference.html"
"basic-syntax/variables.html" = "../types-and-values/variables.html"
"concurrency.html" = "concurrency/welcome.html"
"concurrency/scoped-threads.html" = "threads/scoped.html"
"concurrency/shared_state/arc.html" = "../shared-state/arc.html"
"concurrency/shared_state/example.html" = "../shared-state/example.html"
"concurrency/shared_state.html" = "shared-state.html"
"concurrency/shared_state/mutex.html" = "../shared-state/mutex.html"
"control-flow-basics/conditionals.html" = "if.html"
"control-flow/blocks.html" = "../control-flow-basics/blocks-and-scopes.html"
"control-flow/break-continue.html" = "../control-flow-basics/break-continue.html"
"control-flow/for-expressions.html" = "../control-flow-basics/loops.html"
"control-flow.html" = "control-flow-basics.html"
"control-flow/if-expressions.html" = "../control-flow-basics/conditionals.html"
"control-flow/if-let-expressions.html" = "../pattern-matching/let-control-flow.html"
"control-flow/loop-expressions.html" = "../control-flow-basics/loops.html"
"control-flow/match-expressions.html" = "../tuples-and-arrays/match.html"
"control-flow/novel.html" = "../pattern-matching/let-control-flow.html"
"control-flow/while-expressions.html" = "../control-flow-basics/loops.html"
"control-flow/while-let-expression.html" = "while-let-expressions.html"
"control-flow/while-let-expressions.html" = "../pattern-matching/let-control-flow.html"
"enums.html" = "user-defined-types/enums.html"
"enums/sizes.html" = "../user-defined-types/enums.html"
"enums/variant-payloads.html" = "../user-defined-types/enums.html"
"error-handling/converting-error-types-example.html" = "../error-handling/try-conversions.html"
"error-handling/converting-error-types.html" = "../error-handling/try-conversions.html"
"error-handling/deriving-error-enums.html" = "../error-handling/error.html"
"error-handling/dynamic-errors.html" = "../error-handling/anyhow.html"
"error-handling/error-contexts.html" = "../error-handling/anyhow.html"
"error-handling/thiserror-and-anyhow.html" = "../error-handling/anyhow.html"
"error-handling/panic-unwind.html" = "../error-handling/panics.html"
"error-handling/try-operator.html" = "../error-handling/try.html"
"exercises/concurrency/afternoon.html" = "../../concurrency/async-exercises.html"
"exercises/concurrency/chat-app.html" = "../../concurrency/async-exercises/chat-app.html"
"exercises/concurrency/dining-philosophers-async.html" = "../../concurrency/async-exercises/dining-philosophers.html"
"exercises/concurrency/dining-philosophers.html" = "../../concurrency/sync-exercises/dining-philosophers.html"
"exercises/concurrency/elevator.html" = "chat-app.html"
"exercises/concurrency/link-checker.html" = "../../concurrency/sync-exercises/link-checker.html"
"exercises/concurrency/morning.html" = "../../concurrency/sync-exercises.html"
"exercises/concurrency/solutions-afternoon.html" = "../../concurrency/async-exercises/solutions.html"
"exercises/concurrency/solutions-morning.html" = "../../concurrency/sync-exercises/solutions.html"
"exercises/day-1/afternoon.html" = "../../control-flow-basics/exercise.html"
"exercises/day-1/book-library.html" = "../day-2/book-library.html"
"exercises/day-1/for-loops.html" = "../../tuples-and-arrays/exercise.html"
"exercises/day-1/implicit-conversions.html" = "../../std-traits/exercise.html"
"exercises/day-1/iterators-and-ownership.html" = "../day-2/iterators-and-ownership.html"
"exercises/day-1/luhn.html" = "../../testing/exercise.html"
"exercises/day-1/morning.html" = "../../control-flow-basics/exercise.html"
"exercises/day-1/pattern-matching.html" = "../../user-defined-types/exercise.html"
"exercises/day-1/soluções-tarde.html" = "solutions-afternoon.html"
"exercises/day-2/afternoon.html" = "../../control-flow-basics/exercise.html"
"exercises/day-2/book-library.html" = "../../std-types/exercise.html"
"exercises/day-2/health-statistics.html" = "../../borrowing/exercise.html"
"exercises/day-2/iterators-and-ownership.html" = "../../iterators/intoiterator.html"
"exercises/day-2/luhn.html" = "../day-1/luhn.html"
"exercises/day-2/morning.html" = "../../control-flow-basics/exercise.html"
"exercises/day-2/points-polygons.html" = "../day-3/points-polygons.html"
"exercises/day-2/soluções-tarde.html" = "solutions-afternoon.html"
"exercises/day-2/strings-iterators.html" = "../../iterators/exercise.html"
"exercises/day-3/afternoon.html" = "../../control-flow-basics/exercise.html"
"exercises/day-3/morning.html" = "../../control-flow-basics/exercise.html"
"exercises/day-3/points-polygons.html" = "../../references/exercise.html"
"exercises/day-3/safe-ffi-wrapper.html" = "../../unsafe-rust/exercise.html"
"exercises/day-3/simple-gui.html" = "../../methods-and-traits/exercise.html"
"exercises/day-3/simples-gui.html" = "simple-gui.html"
"exercises/day-3/soluções-tarde.html" = "solutions-afternoon.html"
"exercises/day-4/afternoon.html" = "../android/morning.html"
"exercises/day-4/android.html" = "../android/morning.html"
"exercises/day-4/dining-philosophers.html" = "../concurrency/dining-philosophers.html"
"exercises/day-4/elevator.html" = "../concurrency/elevator.html"
"exercises/day-4/link-checker.html" = "../concurrency/link-checker.html"
"exercises/day-4/morning.html" = "../concurrency/morning.html"
"exercises/day-4/solutions-morning.html" = "../concurrency/solutions-morning.html"
"generics/closures.html" = "../traits/closures.html"
"generics/data-types.html" = "../generics/generic-data.html"
"generics/methods.html" = "../generics/generic-data.html"
"generics/monomorphization.html" = "../generics/generic-functions.html"
"generics/trait-objects.html" = "../traits/trait-objects.html"
"hello-world/basic-syntax/functions-interlude.html" = "../../control-flow-basics/functions.html"
"hello-world/hello-world.html" = "../types-and-values/hello-world.html"
"memory-management/manual.html" = "../memory-management/approaches.html"
"memory-management/rust.html" = "../memory-management/ownership.html"
"memory-management/scope-based.html" = "../memory-management/approaches.html"
"memory-management/stack.html" = "../memory-management/review.html"
"memory-management/stack-vs-heap.html" = "../memory-management/review.html"
"methods-and-traits/trait-objects.html" = "../smart-pointers/trait-objects.html"
"methods/example.html" = "../methods-and-traits/methods.html"
"methods.html" = "methods-and-traits/methods.html"
"methods/receiver.html" = "../methods-and-traits/methods.html"
"outros-recursos.html" = "other-resources.html"
"ownership/borrowing.html" = "../borrowing/shared.html"
"ownership/copy-clone.html" = "../memory-management/copy-types.html"
"ownership/double-free-modern-cpp.html" = "../memory-management/move.html"
"ownership.html" = "memory-management/ownership.html"
"ownership/lifetimes-data-structures.html" = "../lifetimes/struct-lifetimes.html"
"ownership/lifetimes-function-calls.html" = "../lifetimes/lifetime-elision.html"
"ownership/lifetimes.html" = "../lifetimes/lifetime-annotations.html"
"ownership/moved-strings-rust.html" = "../memory-management/move.html"
"ownership/move-semantics.html" = "../memory-management/move.html"
"ownership/moves-function-calls.html" = "../memory-management/move.html"
"ownership/shared-unique-borrows.html" = "../borrowing/shared.html"
"pattern-matching/destructuring-arrays.html" = "../tuples-and-arrays/destructuring.html"
"pattern-matching/destructuring.html" = "destructuring-structs.html"
"pattern-matching/match-guards.html" = "../tuples-and-arrays/match.html"
"running-the-course/day-4.html" = "course-structure.html"
"sintaxe-básica/funções-interlude.html" = "../basic-syntax/functions-interlude.html"
"slices-and-lifetimes/exercise.html" = "../lifetimes/exercise.html"
"slices-and-lifetimes.html" = "lifetimes.html"
"slices-and-lifetimes/lifetime-annotations.html" = "../lifetimes/lifetime-annotations.html"
"slices-and-lifetimes/lifetime-elision.html" = "../lifetimes/lifetime-elision.html"
"slices-and-lifetimes/slices.html" = "../references/slices.html"
"slices-and-lifetimes/solution.html" = "../lifetimes/solution.html"
"slices-and-lifetimes/str.html" = "../references/strings.html"
"slices-and-lifetimes/struct-lifetimes.html" = "../lifetimes/struct-lifetimes.html"
"std/box.html" = "../smart-pointers/box.html"
"std/box-niche.html" = "../smart-pointers/box.html"
"std/box-recursive.html" = "../smart-pointers/box.html"
"std/cell.html" = "../borrowing/interior-mutability.html"
"std/hashmap.html" = "../std-types/hashmap.html"
"std.html" = "std-types/std.html"
"std/option-result.html" = "../std-types/option.html"
"std/rc.html" = "../smart-pointers/rc.html"
"std/string.html" = "../std-types/string.html"
"std/vec.html" = "../std-types/vec.html"
"structs/field-shorthand.html" = "../user-defined-types/named-structs.html"
"structs.html" = "user-defined-types/named-structs.html"
"structs/tuple-structs.html" = "../user-defined-types/tuple-structs.html"
"structure.html" = "running-the-course/course-structure.html"
"testing/doc-tests.html" = "../testing/other.html"
"testing/googletest.html" = "../android/testing/googletest.html"
"testing/integration-tests.html" = "../testing/other.html"
"testing/mockall.html" = "../android/testing/mockall.html"
"testing/useful-crates.html" = "../testing.html"
"traits/closures.html" = "../std-traits/closures.html"
"traits/default.html" = "../std-traits/default.html"
"traits/default-methods.html" = "../methods-and-traits/traits.html"
"traits/deriving-traits.html" = "../methods-and-traits/deriving.html"
"traits/drop.html" = "../memory-management/drop.html"
"traits/from-into.html" = "../std-traits/from-and-into.html"
"traits/from-iterator.html" = "../iterators/fromiterator.html"
"traits.html" = "methods-and-traits/traits.html"
"traits/impl-trait.html" = "../generics/impl-trait.html"
"traits/important-traits.html" = "../std-traits/comparisons.html"
"traits/iterator.html" = "../iterators/iterators.html"
"traits/operators.html" = "../std-traits/operators.html"
"traits/read-write.html" = "../std-traits/read-and-write.html"
"traits/trait-bounds.html" = "../generics/trait-bounds.html"
"traits/trait-objects.html" = "../smart-pointers/trait-objects.html"
"tuples-and-arrays/match.html" = "../pattern-matching/match.html"
"tuples-and-arrays/tuples-and-arrays.html" = "tuples.html"
"types-and-values/strings.html" = "../references/strings.html"
"unsafe/calling-unsafe-functions.html" = "../unsafe-rust/unsafe-functions.html"
"unsafe/extern-functions.html" = "../unsafe-rust/unsafe-functions.html"
"unsafe.html" = "unsafe-rust/unsafe.html"
"unsafe/mutable-static-variables.html" = "../unsafe-rust/mutable-static.html"
"unsafe/mutable-static-variables.md" = "mutable-static-variables.html"
"unsafe/raw-pointers.html" = "../unsafe-rust/dereferencing.html"
"unsafe/unions.html" = "../unsafe-rust/unions.html"
"unsafe/unsafe-functions.html" = "calling-unsafe-functions.html"
"unsafe/unsafe-traits.html" = "../unsafe-rust/unsafe-traits.html"
"unsafe/writing-unsafe-functions.html" = "../unsafe-rust/unsafe-functions.html"
"user-defined-types/static-and-const.html" = "../user-defined-types/static.html"
"welcome-bare-metal.html" = "bare-metal.html"
"welcome-day-1/what-is-rust.html" = "../hello-world/what-is-rust.html"
"welcome.html" = "./"
"why-rust/an-example-in-c.html" = "../hello-world/example.html"
"why-rust/compile-time.html" = "../hello-world/benefits.html"
"why-rust.html" = "hello-world/benefits.html"
"why-rust/modern.html" = "../hello-world/benefits.html"
"why-rust/runtime.html" = "../hello-world/benefits.html"

[output.exerciser]
output-directory = "comprehensive-rust-exercises"

[output.linkcheck]
optional = true
follow-web-links = false # change to true to check web links
exclude = [
  "comprehensive-rust.pdf",
  "comprehensive-rust-exercises.zip",
  # "crates.io", # uncomment when follow-web-links is true
]

[output.linkcheck2]
optional = true
follow-web-links = false # change to true to check web links
exclude = [
  "comprehensive-rust.pdf",
  "comprehensive-rust-exercises.zip",
  # "crates.io", # uncomment when follow-web-links is true
]



================================================
FILE: Cargo.toml
================================================
[workspace]
# Please keep the workspace members sorted.
members = [
  "mdbook-course",
  "mdbook-exerciser",
  "src/android/testing",
  "src/bare-metal/useful-crates/allocator-example",
  "src/bare-metal/useful-crates/zerocopy-example",
  "src/borrowing",
  "src/concurrency/async-exercises/chat-async",
  "src/concurrency/sync-exercises",
  "src/control-flow-basics",
  "src/error-handling",
  "src/generics",
  "src/iterators",
  "src/lifetimes",
  "src/memory-management",
  "src/methods-and-traits",
  "src/modules",
  "src/pattern-matching",
  "src/references",
  "src/smart-pointers",
  "src/std-traits",
  "src/std-types",
  "src/testing",
  "src/tuples-and-arrays",
  "src/types-and-values",
  "src/unsafe-rust",
  "src/user-defined-types",
  "third_party/cxx/blobstore",
  "xtask",
]
resolver = "2"



================================================
FILE: CONTRIBUTING.md
================================================
# How to Contribute

We'd love to accept your patches and contributions to this project. There are
just a few small guidelines you need to follow.

Make sure you can build the book with `mdbook build`, that `mdbook serve` works,
and that `dprint fmt` formats the code. Please use `cargo xtask install-tools`
to install the necessary dependencies, following the
[instructions in the README].

[instructions in the README]: README.md#building

## Writing Exercises

Each segment ends with an exercise. Exercises are typically structured as an
`exercise.rs` containing the problem and solution. This is referenced from
`exercise.md` and `solution.md`, using `{{#include exercise.rs:anchor_name}}` to
match ANCHOR comments in the `exercise.rs` file. Each segment also has a
`Cargo.toml` file containing a `[[bin]]` or `[lib]` section referring to
`exercise.rs`, and that Cargo package is referenced from the workspace the root
`Cargo.toml`. The result is that `exercise.rs` is built and tested by
`cargo test`.

For segments on day 1, exercises should use `fn main() { .. }` and `dbg!` or
`println!`, with students visually verifying the correct output. On subsequent
days, prefer tests and omit `fn main() { .. }`. However, where tests would be
difficult and visual verification is more natural (such as in the Logger
exercise), using `fn main { .. }` is OK.

Especially for exercises without tests, consider including tests in
`exercise.rs` that do not appear in either `exercise.md` or `solution.md`, as
these can ensure the solution is correct.

## Testing

We test the course material in several ways:

- `mdbook test`: This will test the code samples. Some code sampes are marked
  with `ignore` in the Markdown file because the Playground is missing some of
  the crates we use. For this we have
- `cargo test`: This will build and test the Rust code found in our tooling, as
  well as the code samples which cannot be tested using the Playground.
- `npm test`: This will test the functionality of the rendered web pages. See
  the [testing README](tests/README.md) for details.

## Formatting

Please ensure that your files are formatted consistently. We use a few tools for
this:

- [`dprint`] for driving the formatting.
- [`rustfmt`] for formatting Rust code.
- [`yapf`] for formatting Python code.
- [`msgcat`] for formatting PO files.

Run `dprint fmt` to automatically format all files.

**Note:** To make sure you have the correct version of `rustfmt` installed,
please run:

```bash
cargo xtask install-tools
```

This will install the pinned nightly toolchain and add the `rustfmt` component,
so your local formatting will match the CI.

### Linux

Install `dprint` using their
[installation instructions](https://dprint.dev/install/) and install `rustfmt`
via `rustup`.

Install [pandoc 3.7.0.1](https://github.com/jgm/pandoc/releases/tag/3.7.0.1).

On Debian, you can install the other tools using:

```sh
sudo apt install yapf3 gettext texlive texlive-luatex texlive-lang-cjk texlive-lang-arabic librsvg2-bin fonts-noto
```

### MacOS

On MacOS with [Homebrew], you can install the necessary tools with:

```shell
brew install dprint yapf gettext
```

### Windows

On Windows, you can should install [Gettext tools for Windows].

Install `dprint` using their
[installation instructions](https://dprint.dev/install/) and install `rustfmt`
via `rustup`.

> _TODO: fill in how to install `yapf` on Windows._

[`dprint`]: https://dprint.dev/
[`rustfmt`]: https://github.com/rust-lang/rustfmt
[`yapf`]: https://github.com/google/yapf
[`msgcat`]: https://www.gnu.org/software/gettext/manual/html_node/msgcat-Invocation.html
[Homebrew]: https://brew.sh/
[Gettext tools for Windows]: https://github.com/vslavik/gettext-tools-windows/releases

## Contributor License Agreement

Contributions to this project must be accompanied by a Contributor License
Agreement. You (or your employer) retain the copyright to your contribution;
this simply gives us permission to use and redistribute your contributions as
part of the project. Head over to <https://cla.developers.google.com/> to see
your current agreements on file or to sign a new one.

You generally only need to submit a CLA once, so if you've already submitted one
(even if it was for a different project), you probably don't need to do it
again.

## Code Reviews

All submissions, including submissions by project members, require review. We
use GitHub pull requests for this purpose. Consult
[GitHub Help](https://help.github.com/articles/about-pull-requests/) for more
information on using pull requests.

## Community Guidelines

This project follows
[Google's Open Source Community Guidelines](https://opensource.google/conduct/).



================================================
FILE: dprint.json
================================================
{
  "lineWidth": 80,
  "json": {},
  "markdown": {
    "textWrap": "always"
  },
  "exec": {
    "commands": [{
      "command": "yapf3",
      "exts": ["py"]
    }, {
      "command": "rustup run nightly-2025-09-01 rustfmt --edition 2024",
      "exts": ["rs"]
    }]
  },
  "excludes": [
    "/book/",
    "/theme/*.hbs",
    "/theme/book.js",
    "/third_party/",
    "target/"
  ],
  "plugins": [
    "https://plugins.dprint.dev/exec-0.5.1.json@492414e39dea4dccc07b4af796d2f4efdb89e84bae2bd4e1e924c0cc050855bf",
    "https://plugins.dprint.dev/json-0.20.0.wasm",
    "https://plugins.dprint.dev/markdown-0.18.0.wasm",
    "https://plugins.dprint.dev/toml-0.7.0.wasm",
    "https://plugins.dprint.dev/prettier-0.56.0.json@0b67676535141b03f0eb0648172d3a20f13044b3d8df677d645bd79e3ee5147f"
  ]
}



================================================
FILE: GEMINI.md
================================================
# Project Overview

This repository contains the source code for Comprehensive Rust, a family of
courses on Rust developed by Google, starting with Rust foundations, and
including deep dives into specialized topics like Android, Chromium, bare-metal
development, and concurrency. The project is a Rust workspace that leverages
`mdbook` to generate a course website.

## Key Technologies

- **Rust:** The primary programming language for the course subject, custom
  tools, and examples.
- **mdbook:** A command-line tool to create books from Markdown files, used for
  generating the course website.
- **Custom mdbook Preprocessors:** `mdbook-course` and `mdbook-exerciser` are
  Rust binaries that extend `mdbook`'s functionality, for example, to extract
  exercise starter code.
- **`cargo xtask`:** A custom binary within the workspace used for project
  automation, simplifying common development tasks.

# Building and Running

The project uses `cargo xtask` for project-specific automation, like builds,
tests, and managing translations.

## Setup

1. **Install Rust:** Follow the instructions on
   [https://rustup.rs/](https://rustup.rs/).
2. **Clone Repository:**
   ```bash
   git clone https://github.com/google/comprehensive-rust/
   cd comprehensive-rust
   ```
3. **Install Project Tools:**
   ```bash
   cargo xtask install-tools
   ```
   This is a necessary first step for working with this repository. It will
   install the correct versions of all tools used by the project.

## Commands

All commands are run using `cargo xtask`. Run `cargo xtask --help` for a full
list of options.

- **Serve the Course Locally:** Starts a web server to view the course content.
  ```bash
  cargo xtask serve [--language <ISO_639_language_code>] [--output <output_directory>]
  ```
  (e.g., `cargo xtask serve -l da` for the Danish translation)

- **Build the Course:** Creates a static version of the course in the `book/`
  directory.
  ```bash
  cargo xtask build [--language <ISO_639_language_code>] [--output <output_directory>]
  ```

- **Run Rust Snippet Tests:** Tests all Rust code snippets included in the
  course material.
  ```bash
  cargo xtask rust-tests
  ```

- **Run Web Driver Tests:** Executes web driver tests located in the `tests/`
  directory.
  ```bash
  cargo xtask web-tests [--dir <book_html_directory>]
  ```

# Development Conventions

- **Project Automation:** `cargo xtask` is the primary interface for common
  development tasks.
- **Course Content:** Markdown files in the `src/` directory, structured
  according to `src/SUMMARY.md`.
- **Code Formatting:** `dprint fmt` is used to format all source files according
  to `rustfmt.toml` and `dprint.json`. Note that you must first install the
  project tools with `cargo xtask install-tools`.
- **Contributions:** Refer to `CONTRIBUTING.md` for guidelines on contributing
  to the project.
- **Style:** Refer to `STYLE.md` for style guidelines. When making changes to
  Markdown files in `src/`, always first read `STYLE.md` and follow its
  conventions.
- **GitHub Actions:** The project uses composite GitHub Actions to simplify CI
  workflows. These actions should be preferred over hand-written commands.
  - **`apt-get-install`:** This action efficiently installs Debian packages. It
    configures `dpkg` and `apt` to skip documentation and translations, and
    ensures that `apt-get update` is run only once per job. This significantly
    speeds up CI runs.
  - **`install-mdbook`:** A composite action to install `mdbook` and its
    dependencies, including `pandoc` and `texlive`.
  - **`setup-rust-cache`:** A composite action that configures the
    `Swatinem/rust-cache` action.

## Markdown Conventions

- **Headings:**
  - **H1 (`#`):** Used for the main title of each page. Each slide has exactly
    one title.
  - **H2 (`##`):** Used for major sections. Slides do not use H2 headings to
    save vertical space; more slides are created instead.
  - **H3 (`###`):** Used for sub-sections, but not on slides.

- **Emphasis:**
  - **Bold (`**...**`):** Used to highlight key terms, commands, and for notes
    (e.g., `**Note:**`). The colon (`:`) is included inside the bold text for
    notes.
  - **Italic (`_..._`):** Used for general emphasis, titles of external
    articles, and for terms being defined.

- **Code:**
  - **Inline Code (`` `...` ``):** Used for code snippets, file names, commands,
    type names, and language keywords. Rust fragments are formatted as `rustfmt`
    would.
  - **Code Blocks (`` ```...``` ``):** Fenced code blocks are used for
    multi-line code examples, annotated with a language identifier (e.g.,
    `rust`, `c`, `ignore`).
  - **Interactive Code Blocks:** Rust examples are made interactive with
    `editable`. Examples that fail to compile are marked with `compile_fail` or
    `should_panic`.
  - **Diagrams:** The `bob` language identifier is used in code blocks to
    generate ASCII art diagrams.
  - **Formatting Control:** The `#[rustfmt::skip]` attribute is used to prevent
    `rustfmt` from formatting specific code blocks, though it is used rarely.

- **Lists:**
  - **Bulleted Lists:** Unordered lists are the primary way to lay out key
    points on slides.
  - **Glossary Format:** The glossary uses a specific format with a colon and
    backslash (`:\`) after each term to create a hard line break for visual
    formatting.

- **Other Markdown Elements:**
  - **Block Quotes (`> ...`):** Used sparingly for important notes, warnings, or
    supplementary information to draw attention.
  - **Links:** Both standard (`[text](url)`) and reference-style
    (`[text][label]`) links are used.
  - **Tables:** Markdown tables are used to present structured data.
  - **Horizontal Rules (`---`):** Not used on slides.

- **HTML Tags:**
  - **`<details>`:** Used for collapsible "speaker notes".
  - **`<kbd>`:** Used to denote keyboard keys. Each key in a combination must be
    wrapped in its own tag, e.g., `<kbd>Ctrl</kbd> + <kbd>S</kbd>`.
  - **`<style>`:** Used rarely for targeted custom CSS.
  - **`<img>`:** Used to embed images.

- **Project-Specific Conventions:**
  - **mdbook Includes:** The `{{#include ...}}` helper is used to include
    snippets from other files.
  - **mdbook Segments:** The `{{%segment ...%}}` and `{{%session ...%}}` helpers
    are used for course structuring.
  - **Frontmatter:** Files start with YAML frontmatter (enclosed in `---`) to
    provide metadata.
  - **Doc Comments:** Standard Rust doc comments (`///`, `//!`) are used.
    `/// # Safety` is used to document safety preconditions for `unsafe` code.
  - **Comments:** HTML comments (`<!-- ... -->`) are used for editor/translator
    instructions and content control (e.g., `mdbook-xgettext: skip`).

# Project-Specific Technical Context

This section contains critical, non-obvious technical details about this
project's tooling and environment that an AI assistant needs to know to perform
its tasks correctly.

## `mdbook` Behavior

- **Isolated Code Snippets:** `mdbook` treats each fenced Rust code block (e.g.,
  `` ```rust ... ``` ``) as a separate compilation unit. When analyzing a code
  snippet, treat it as a self-contained program. Do not assume it shares a scope
  or context with other snippets in the same file unless the surrounding text
  explicitly states otherwise.



================================================
FILE: LICENSE
================================================

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.



================================================
FILE: rustfmt.toml
================================================
# Please use a nightly rustfmt for these settings.
unstable_features = true
imports_granularity = "module"
wrap_comments = true

# The code blocks get a scrollbar if they are wider than this.
max_width = 85
# Allow all constructs to take up max_width columns.
use_small_heuristics = "Max"



================================================
FILE: STYLE.md
================================================
# Comprehensive Rust 🦀 Style Guide

The course has been expanded and improved by tons of volunteers like you! Thank
you for that! To help ensure a consistent style throughout the course, we have
written down some guidelines for you to follow.

## Course Philosophy and Design

To contribute effectively, it's helpful to understand the core design principles
of Comprehensive Rust. This is not a self-study book; it is a set of slides and
notes for an **instructor-led course**.

### Target Audience

The course is designed for an audience of experienced software engineers who are
new to Rust. We assume they have 2-3 years of experience in an imperative
language like C, C++11+, Java 7+, Python, or Go.

We **do not** assume familiarity with functional programming concepts or
features from more modern languages like Swift or Kotlin. Course material should
build upon the concepts that are likely to be familiar to this audience.

### Goals

The goal of the course is to provide a solid foundation in Rust within a bounded
time frame. This prepares students to continue learning effectively as they
begin to apply their new skills on the job.

### Pedagogical Principles

We follow a few key principles to make the material effective for learning:

- **Build on a Foundation:** New Rust concepts should be connected to what a
  learner already knows, either from their prior language experience or from
  earlier parts of this course.
- **Provide a Working Mental Model (The "No Magic" Rule):** As much as possible,
  avoid telling students to accept syntax or behavior that will be explained
  later. For everything that appears on the slides or in exercises, we must
  provide a working mental model that allows the student to understand and use
  the concept.
- **Use a [Spiral Approach](https://en.wikipedia.org/wiki/Spiral_approach):** To
  avoid overwhelming the learner, it is highly encouraged to introduce a concept
  by first providing basic facts and a simplified mental model. The topic can
  then be revisited later to provide more detail. For example, very early in the
  course we explain the basics of `println!`, mention that it is a macro so the
  usage syntax is a bit unusual, but we don't go into details of format strings
  or macros. We explain details of format strings later, once we have covered
  traits and can mention the `Debug` and `Display` traits.
- **Live, Interactive Instruction:** The instructor is expected to run and
  modify the code on the slides, and use compiler errors as a teaching tool. The
  audience is expected to frequently interrupt with questions, and the
  instructor would often experiment with the code on the slide to illustrate the
  answer.

### Pacing and Structure

The course is designed for approximately 5 hours of teaching per day, typically
split into a 3-hour morning session and a 2-hour afternoon session.

This pacing is important context for contributors. Material should be structured
to fit this rhythm, with clear sections that can be taught in roughly 45-50
minute blocks to accommodate short breaks and Q&A.

Each slide must include a `minutes` field in its frontmatter, which specifies
the estimated teaching time for that slide. This helps ensure the overall pacing
of the course remains consistent.

### Course Structure

The course starts with a core **Rust Fundamentals** curriculum, followed by a
collection of specialized **deep dives**. All students take the Fundamentals
course and can then opt into any deep dives that are relevant to them.

#### The Rust Fundamentals Course

The **Rust Fundamentals** course provides a solid foundation in a strictly
bounded, four-day time frame. This duration is firm, and its scope is carefully
managed to focus on the most essential concepts for new Rust programmers.

The overall progression of the course starts with the parts of the Rust language
that should be conceptually familiar to most students from other languages. Then
we move on to more difficult parts (for example, enums with payloads and
generics), and parts that are unique to Rust (lifetimes and the borrow checker).

Contributors should keep this structure in mind. The four-day schedule for the
Fundamentals course is completely full, leaving no time slack for new topics.
Proposals to add material to the Rust Fundamentals course must also include a
plan to shorten or remove existing content. Refinements to existing topics are
always welcome. Topics that are not essential for all new Rust programmers
should be proposed as new deep dives.

## Course Slides

Please take the following into account when updating the course material.

### Vertical Space

What looks like pages in a browser, are actually slides in a presentation. It is
important to keep this in mind when adding content: we only have limited
vertical space. Scrolling up and down should be avoided since it is very jarring
for people who attend the class.

You can test the amount of space available using a simple tool. This tool can be
used by clicking a toggle button next to the search button on left side of the
navbar.

The rectangle has an aspect ratio similar to what you can see when you share
your screen on a 16:9 display or projector.

Use the rectangle as a rough guide for how much you can fit on a single slide.
If you find yourself adding too much detail, move the details to the speaker
notes (see below).

### One Core Idea Per Slide

Ideally, each slide should focus on a single, clear takeaway. If a slide
introduces a core concept and then explores an important but distinct tangent
(e.g., a limitation or an advanced use case), that tangent should be moved to
its own slide. This keeps the presentation focused and easier to follow.

Consider the instructor's workflow. If the speaker notes require a long or
complex series of live edits, it can be difficult for the instructor to execute
well every time. It may be better to add a new slide that presents the desired
state of the code.

### Pedagogical Flow

When introducing a new concept, start with a simple, relatable, and concrete
example. A good opening example grounds the concept for the learner and provides
motivation for the more detailed explanation that will follow.

### Use Meaningful Examples

Code samples on the slides should be short and do something meaningful. Avoid
using generic placeholders like `Foo`, `Bar`, and `Baz`. Using descriptive names
from a real-world, even if simplified, domain makes the code easier to
understand and relate to.

### Plan Interactive Code Snippets

All Rust code blocks in the course are not static text but are live, editable
playgrounds. An important teaching method is for the instructor to edit these
snippets live to demonstrate concepts, introduce and fix errors, and explore
variations based on student questions.

Contributors should design their slides with this interactivity in mind. The
initial state of the code should be a good starting point for a live
demonstration.

### `mdbook` and `mdbook-course` Conventions

The project uses `mdbook` features in specific ways, as well as a custom
preprocessor, `mdbook-course`. The following conventions are mandatory:

- **YAML Frontmatter:** Every slide file **must** include YAML frontmatter at
  the top. At a minimum, this must include the `minutes` field to specify the
  estimated teaching time.
- **Outline Helpers:** Pages that serve as an index for a session or segment
  **must** use the `{{%session outline%}}` or `{{%segment outline%}}` helpers.
- **File Includes:** Code for exercises and their solutions **must** be included
  from external files using the standard `mdbook` `{{#include ...}}` helper.
- **Translation Directives:** To prevent an element (such as a paragraph, code
  block, or list item) from being translated, place a
  `<!-- mdbook-xgettext: skip -->` comment on a line by itself, followed by a
  blank line, immediately before the element.

For a complete explanation of the custom helpers and all available frontmatter
fields, please refer to the [`mdbook-course` README](mdbook-course/README.md).

### Language and Tone

The courses are written in American English, so write "initialize", not
"initialise".

Use an informal, friendly, and concise tone. Remember that the courses are meant
to be taught by an experienced programmer to other experienced programmers. When
possible, prefer terminology used in
[the official Rust Book](https://doc.rust-lang.org/book/). If a less common but
necessary term is used, provide a brief definition.

## Exercises

At the end of some sections, learners will actively engage with the material by
completing a small exercise. The goal of an exercise is to provide hands-on
practice with the concepts just taught.

Please keep the following principles in mind when creating or updating
exercises:

- **Focused Scope:** An exercise should focus on the topic of the preceding
  section. It should not require knowledge of concepts that have not yet been
  taught.
- **Short Duration:** An exercise should be solvable by the target audience in
  approximately 10-15 minutes. The goal is a quick, successful application of
  knowledge, not a complex project.
- **Clear Instructions:** The problem description should be clear and
  unambiguous.

## Speaker Notes

We have extended `mdbook` with support for speaker notes: content added between
`<details> ... </details>` tags is rendered in a special box that can be
collapsed or removed entirely from the slide.

- Speaker notes suggest a narrative structure for the instructor.

- The speaker notes should expand on the topic of the slide. Use them to provide
  interesting background information for both the instructor and for students
  who look at the material outside of a class. Remember that many more people
  will read the course by themselves, so make the notes complete and useful even
  when there is no Rust expert around.

- For slides with evolving code examples, the notes provide a clear,
  step-by-step flow for how the code is modified and presented. This is a
  suggested flow for the instructor's live-coding session within the slide's
  interactive playground. This includes:

  - The order in which to introduce concepts, how to motivate them.

  - Framing of the code example: the problem it tries to solve, if not obvious.

  - How to demonstrate variations of the code example (e.g., code that does not
    compile or illustrates a bug).

  - How to change the code on the slide to illustrate the concepts being taught.

  - Where to pause and engage the class with questions.

- Speaker notes should serve as a quick reference for instructors, not a
  verbatim script. Because instructors have limited time to glance at notes, the
  content should be concise and easy to scan.

  **Avoid** long, narrative paragraphs meant to be read aloud:
  > **Bad:** _"In this example, we define a trait named `StrExt`. This trait has
  > a single method, `is_palindrome`, which takes a `&self` receiver and returns
  > a boolean value indicating if the string is the same forwards and
  > backwards..."_

  **Instead, prefer** bullet points with background information or actionable
  **teaching prompts**:
  > **Good:**
  >
  > - Note: The `Ext` suffix is a common convention.
  > - Ask: What happens if the `use` statement is removed?
  > - Demo: Comment out the `use` statement to show the compiler error.

- Nevertheless, include all of the necessary teaching prompts for the instructor
  in the speaker notes. Unlike the main content, the speaker notes don't have to
  fit on a single slide.

### More to Explore

Use the "More to Explore" section for valuable topics that are outside the main
scope of the class. The content should be placed within the `<details>` block as
shown below:

```markdown
<details>

...

## More to Explore

...

</details>
```

This section can contain a deeper explanation of a concept or provide specific
pointers to external resources. A link should be accompanied by a brief
explanation of what the resource contains and why it is relevant. A vague
reference is not helpful, but a specific one can be a great tool for
self-learners.

## Code Blocks Mechanics

Code blocks are a critical part of the course. To ensure they are consistent and
behave as expected, please follow these conventions.

### Language Identifiers

Use the following language identifiers for fenced code blocks:

- **`rust`**: For Rust code examples.
- **`shell`**: For shell commands. Use a `$` prompt for consistency. Omit the
  prompt for multi-line commands or when the output is shown.
- **`bob`**: For ASCII art diagrams generated by `mdbook-bob`.
- **`ignore`**: For code snippets that are not complete, self-contained programs
  or are for illustrative purposes only and should not be compiled.

### mdbook Annotations

You can add annotations to Rust code blocks to control how they are tested and
displayed:

- **`editable`**: Makes the code block an interactive playground where users can
  edit and run the code. This should be used for most Rust examples.
- **`compile_fail`**: Indicates that the code is expected to fail compilation.
  This is used to demonstrate specific compiler errors.
- **`should_panic`**: Indicates that the code is expected to panic when run.
- **`warnunused`**: Re-enables `unused` lints for a code block. By default, the
  course's test runner disables lints for unused variables, imports, etc., to
  avoid distracting warnings. Use this annotation only when a warning is part of
  the lesson.

### Rust Code Formatting

When showing Rust code inline, please use the same spacing as `rustfmt`: `3 * x`
instead of `3*x`. However, feel free to remove newlines when it can make the
code more compact and easier to understand, e.g., you can define a struct on one
line if it is not the focus of your example:

<!-- dprint-ignore-start -->

```rust
struct Person { name: String }
```

<!-- dprint-ignore-end -->

Enclose the code block in `<!-- dprint-ignore-start -->` and
`<!-- dprint-ignore-end -->` to suppress the automatic formatting. Please use
this sparingly.

## Translations

This section is about what you write in the translation. We describe
[how to create or update translations elsewhere](TRANSLATIONS.md).

When translating the course, please take the following into account:

- Do not translate:
  - The course name ("Comprehensive Rust 🦀"). If the name is not easily
    understood in your language, please add the translated version after the
    original name.
  - Variable names (you _should_ translate the comments, though.)

- If the Rust Book has been
  [translated into your language](https://doc.rust-lang.org/book/appendix-06-translation.html),
  please use the same vocabulary.

- The text you write is in Markdown format. Make sure to preserve the original
  formatting in the translation by marking text as `` `code` ``, `_emphasis_`
  and `**strong emphasis**` like in the original.

- If you find mistakes or things that sound awkward in the original English
  text, please submit PRs to fix them in the English text! Fixing typos in the
  translation is great, but we want everybody to benefit from the fixes and that
  is why we need the fix to be made in the English text too.



================================================
FILE: TRANSLATIONS.md
================================================
# Translations of Comprehensive Rust 🦀

We would love to have your help with translating the course into other
languages! Please see the [translations page] for the existing translations.

[translations page]: https://google.github.io/comprehensive-rust/running-the-course/translations.html

We use the [Gettext] system for translations. This means that you don't modify
the Markdown files directly: instead you modify `.po` files in a `po/`
directory. The `.po` files are small text-based translation databases.

> **Tip:** You should not edit the `.po` files by hand. Instead use a PO editor,
> such as [Poedit](https://poedit.net/). There are also several online editors
> available. This will ensure that the file is encoded correctly.

> **Important:** You need to run `dprint fmt` after editing the PO file. This
> ensures consistent formatting of the file. You need to install the Gettext
> tools for this, see the Preparation section below.

There is a `.po` file for each language. They are named after the [ISO 639]
language codes: Danish would go into `po/da.po`, Korean would go into
`po/ko.po`, etc. The `.po` files contain all the English text plus the
translations. They are initialized from a `messages.pot` file (a PO template)
which contains only the English text.

We will show how to update and manipulate the `.po` and `.pot` files using the
GNU Gettext utilities below.

[Gettext]: https://www.gnu.org/software/gettext/manual/html_node/index.html
[ISO 639]: https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes

## Preparation

Please make sure you can [build the course](README.md#building). You will also
need the `msgmerge` and `msgcat` Gettext tool installed. Please see our
[contribution guide](CONTRIBUTING.md#formatting) for details.

## Creating and Updating Translations

First, you need to know how to update the `.pot` and `.po` files.

You should never touch the auto-generated `book/xgettext/messages.pot` file. You
should also never edit the `msgid` entries in a `po/xx.po` file. If you find
mistakes, you need to update the original English text instead. The fixes to the
English text will flow into the `.po` files the next time the translators update
them.

> **Tip:** See our [style guide](STYLE.md) for some things to keep in mind when
> writing the translation.

### Generating the PO Template

To extract the original English text and generate a `messages.pot` file, you
build the book. This will automatically invoke the `mdbook-xgettext` renderer:

```shell
mdbook build
```

You will find the generated POT file as `book/xgettext/messages.pot`.

### Initialize a New Translation

To start a new translation, first generate the `book/xgettext/messages.pot`
file. Then use `msginit` to create a `xx.po` file for the fictional `xx`
language:

```shell
msginit -i book/xgettext/messages.pot -l xx -o po/xx.po
```

You can also simply copy `book/xgettext/messages.pot` to `po/xx.po`. Then update
the file header (the first entry with `msgid ""`) to the correct language.

> **Tip:** You can use the
> [`cloud-translate`](https://github.com/mgeisler/cloud-translate) tool to
> quickly machine-translate a new translation. Install it with
>
> ```shell
> cargo install cloud-translate
> ```
>
> Untranslated entries will be sent through GCP Cloud Translate. Some of the
> translations will be wrong after this, so you must inspect them by hand
> afterwards.

Next, please update the file `.github/labeler.yml` to include the new language:

```diff
+"translation/xx":
+  - changed-files:
+      - any-glob-to-any-file: po/xx.po
```

### Refreshing an Existing Translation

As the English text changes, translations gradually become outdated. The
translations contain a POT-Creation-Date header which tells you when they were
last updated with new English messages.

To update the `po/xx.po` file with new messages, first extract the English text
into a `book/xgettext/messages.pot` template file. Then run

```shell
msgmerge --update po/xx.po book/xgettext/messages.pot
```

Notice that the POT-Creation-Date field is updated to the current time and date.
This becomes the new baseline for the translation: new English text added
afterwards will not show up in your translation, including completely new pages.

When running `msgmerge`, unchanged messages stay intact, deleted messages are
marked as old, and updated messages are marked "fuzzy". A fuzzy entry is not
used when we publish a translation! You have to go over the fuzzy entries by
hand and verify that the translation is correct the fuzzy marker.

> **Note:** Your PRs should either be the result of running `msgmerge` or the
> result of new translation work on the PO file for your language. Avoid mixing
> the two since it often creates a very large diff, which is hard or impossible
> to review.

### Editing a Translation

You should install a PO editor to edit the `.po` file for your language. The
files are simple text files, but it helps to use a dedicated editor since it
will take care of escaping things like `"` correctly.

There are many PO editors available. [Poedit](https://poedit.net/) is a popular
cross-platform choice, but you can also find several online editors.

### Formatting a Translation

If the file is not formatted correct, you will get an error on the PR. Make sure
to follow the [steps](#preparation) to install [Gettext] and
[`dprint`](https://dprint.dev/) and then run:

```shell
dprint fmt po/xx.po
```

This will automatically format the `.po` file for you. Commit the formatting fix
and push to your branch. Your PR should now be error free.

## Using Translations

This will show you how to use the translations to generate localized HTML
output.

> **Note:** `mdbook` will use original untranslated entries for all entries
> marked as "fuzzy" (visible as "Needs work" in Poedit). This is especially
> important when using
> [`cloud-translate`](https://github.com/mgeisler/cloud-translate) for initial
> translation as all entries will be marked as "fuzzy".

### Building a Translation

Make sure you have gone through the [build setup](./README.md#building) at least
once.

To use the `po/xx.po` file for your output, run the following command:

```shell
MDBOOK_BOOK__LANGUAGE=xx mdbook build -d book/xx
```

This will tell the `mdbook-gettext` preprocessor to translate the book using the
`po/xx.po` file. The HTML output can be found in `book/xx/html/`.

### Serving a Translation

Like normal, you can use `mdbook serve` to view your translation as you work on
it. You use the same command as with `mdbook build` above:

```shell
MDBOOK_BOOK__LANGUAGE=xx mdbook serve -d book/xx
```

When you update the `po/xx.po` file, the translated book will automatically
reload.

## Reviewing Translations

When a new translation is started, we look for people who can help review it.
These reviewers are often Googlers, but they don't have to be. To automatically
get an email when new PRs are created for your language, please add yourself to
the [CODEOWNERS] file.

When reviewing a translation, please keep in mind that translations are a labour
of love. Someone spends their free time translating the course because they want
to bring Rust to users who speak their language.

Nothing is published right away after a PR lands for a new in-progress language.
It is therefore safe to merge the PR as long as the translation is reasonable.
This is often better than leaving 50+ comments since this can be overwhelming
for the contributor. Instead, please work with the contributor to improve things
in follow-up PRs.

### GitHub Suggestions

When reviewing a translation PR, please use the
[GitHub suggestion feature](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/commenting-on-a-pull-request).
This feature allows you to directly write how you think a line or paragraph
should be phrased. Use the left-most button in the toolbar to create a
suggestion.

The PR author can
[apply the changes with a single click](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/incorporating-feedback-in-your-pull-request)
afterwards, drastically reducing the number of round-trips needed in a review.

### Incomplete Translations

When the first 1-2 days of the course have been translated, we can publish the
translation and link it from the [translations page]. The idea is to celebrate
the hard work, even if it is incomplete.

[CODEOWNERS]: https://github.com/google/comprehensive-rust/blob/main/.github/CODEOWNERS

## Publication Workflow

> This section is for the developers of Comprehensive Rust, but it might give
> you valuable background information on how the translations are published.

When a change is made to the `main` branch, the [`publish.yml`] GitHub CI
workflow starts.

The `publish` job in this workflow will:

- Install dependencies as described in [`CONTRIBUTING`](CONTRIBUTING.md).

- Build every translation of the course, including the original English, using
  [`build.sh`]. The English HTML ends up in `book/html/`, the HTML for the `xx`
  language ends up in `book/xx/html/`.

- Publish the entire `book/html/` directory to
  https://google.github.io/comprehensive-rust/.

[`build.sh`]: https://github.com/google/comprehensive-rust/blob/main/.github/workflows/build.sh

### `build.sh`

The `build.sh` script is used both when testing code from a PR (with
[`build.yml`]) and when publishing the finished book (with [`publish.yml`]).

[`build.yml`]: https://github.com/google/comprehensive-rust/blob/main/.github/workflows/build.yml
[`publish.yml`]: https://github.com/google/comprehensive-rust/blob/main/.github/workflows/publish.yml

The job of the script is to call `mdbook build`, but with a few extra steps:

- It will enable the PDF output using `mdbook-pandoc`. This is disabled by
  default to make it easier for people to run `mdbook build` without having to
  configure LaTeX.

#### Restoring Translations

When building a translation (languages other than English), `build.sh` will
restore all Markdown files to how they looked at the time recorded in the
POT-Creation-Date header.

This means that:

- A translation does not degrade when the English text is changed.
- A translation will not received the latest fixes to the English text.

The script restores the Markdown with a simple

```sh
$ git restore --source $LAST_COMMIT src/ third_party/
```

command, where `$LAST_COMMIT` is the commit at the time of the POT-Creation-Date
header.

A consequence of this is that we use the latest theme, CSS, JavaScript, etc for
each translation.

After `build.sh` was run, the working copy is left in this dirty state. Beware
of this if you want to build the English version next, as you will have to clean
up manually.

## Status reports

Two translation status reports are automatically generated:

- [Translation status as checked in][translation-report]
- [Translation status after syncing to the latest version of the source with msgmerge][synced-translation-report]

You can also generate this report locally to see the effect of your local
changes:

```shell
i18n-report translation-report.html po/*.po
```

[translation-report]: https://google.github.io/comprehensive-rust/translation-report.html
[synced-translation-report]: https://google.github.io/comprehensive-rust/synced-translation-report.html



================================================
FILE: mdbook-course/README.md
================================================
# mdbook-course

This is an mdBook preprocessor to handle some specific details of Comprehensive
Rust.

It provides three binaries:

- `mdbook-course` -- the actual preprocessor
- `course-schedule` -- prints the course schedule with timings
- `course-content` -- dumps all course content to stdout, in order

## Frontmatter

The preprocessor parses "frontmatter" -- YAML between `---` at the beginning of
a Markdown file -- and removes it from the rendered result.

Frontmatter is optional, and can contain any of the following fields, defined
below:

```yaml
minutes: NNN
target_minutes: NNN
course: COURSE NAME
session: SESSION NAME
```

## Course Structure

A book can contain multiple _courses_. Each course is made up of _sessions_,
which are blocks of instructional time (and include breaks). Typically two
sessions are taught per day, morning and afternoon.

Each session is comprised of _segments_, which are slides on a related theme.
Breaks are scheduled between segments.

Each segment is comprised of _slides_. A slide can be made up of one or more
mdBook chapters.

The course structure is derived from the mdBook structure. Each top-level mdBook
"section" is treated as a segment, and may optionally begin a new session or
course. Within each section, the first chapter and subsequent second-level
chapters are each treated as a slide. Any further-nested chapters are treated as
parts of the parent slide. For example:

```ignore
- [Frobnication](frobnication.md)
  - [Integer Frobnication](frobnication/integers.md)
  - [Frob Expansion](frobnication/expansion.md)
    - [Structs](frobnication/expansion-structs.md)
    - [Enums](frobnication/expansion-structs.md)
  - [Exercise](frobnication/exercise.md)
    - [Solution](frobnication/Solution.md)
```

In this segment, there are four slides: "Frobnication", "Integer Frobnication",
"Frob Expansion", and "Exercise". The last two slides are made up of multiple
chapters.

The first chapter of a segment can use the `course` and `session` fields in its
frontmatter to indicate that it is the first segment in a session or course.

## Timing

Each chapter should specify an estimate of the instructional time it will
require in the `minutes` field. This information is summed, with breaks
automatically added between segments, to give time estimates for segments,
sessions, and courses.

Each session should list a `target_minutes` that is the target duration of the
session.

## Directives

Within the course material, the following directives can be used:

```
{{%segment outline}}
{{%session outline}}
{{%course outline}}
{{%course outline COURSENAME}}
```

These will be replaced with a markdown outline of the current segment, session,
or course. The last directive can refer to another course by name and is used in
the "Running the Course" section.

# Course-Schedule Comments

The `course-schedule` binary generates Markdown output that is included in a
GitHub pull request comment, based on the information provided in the above
format.



================================================
FILE: mdbook-course/Cargo.toml
================================================
[package]
name = "mdbook-course"
version = "0.1.0"
authors = ["Dustin Mitchell <djmitche@google.com>"]
edition = "2024"
license = "Apache-2.0"
publish = false
repository = "https://github.com/google/comprehensive-rust"
description = "An mdbook preprocessor for comprehensive-rust."

[dependencies]
anyhow = "1.0.99"
clap = "4.5.46"
lazy_static = "1.5"
log = "0.4.27"
matter = "0.1.0-alpha4"
mdbook = "0.4.52"
pretty_env_logger = "0.5.0"
regex = "1.11"
serde = "1.0.219"
serde_json = "1.0.143"
serde_yaml = "0.9"



================================================
FILE: mdbook-course/src/course.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Representation of Comprehensive Rust as a hierarchy of types.
//!
//! ```ignore
//! Courses -- a collection of courses
//!   Course -- the level of content at which students enroll (fundamentals, android, etc.)
//!     Session -- a block of instructional time (typically morning or afternoon)
//!       Segment -- a collection of slides with a related theme
//!         Slide -- a single topic (may be represented by multiple mdBook chapters)
//! ```
//!
//! This structure is parsed from the format of the book using a combination of
//! the order in which chapters are listed in `SUMMARY.md` and annotations in
//! the frontmatter of each chapter.
//!
//! A book contains a sequence of BookItems, each of which can contain
//! sub-items. A top-level item can potentially introduce a new course, session,
//! segment, and slide all in the same item. If the item has a `course` property
//! in its frontmatter, then it introduces a new course. If it has a `session`
//! property, then it introduces a new session. A top-level item always
//! corresponds 1-to-1 with a segment (as long as it is a chapter), and that
//! item becomes the first slide in that segment. Any other sub-items of the
//! top-level item are treated as further slides in the same segment.

use crate::frontmatter::{Frontmatter, split_frontmatter};
use crate::markdown::{Table, duration};
use mdbook::book::{Book, BookItem, Chapter};
use std::fmt::Write;
use std::path::PathBuf;

/// Duration, in minutes, of breaks between segments in the course.
const BREAK_DURATION: u64 = 10;

/// Courses is simply a collection of Courses.
///
/// Non-instructional material (such as the introduction) has `course: none` and
/// is not included in this data structure.
#[derive(Default, Debug)]
pub struct Courses {
    pub courses: Vec<Course>,
}

/// A Course is the level of content at which students enroll.
///
/// Courses are identified by the `course` property in a session's frontmatter.
/// All sessions with the same value for `course` are grouped into a Course.
#[derive(Default, Debug)]
pub struct Course {
    pub name: String,
    pub sessions: Vec<Session>,
}

/// A Session is a block of instructional time, containing segments. Typically a
/// full day of instruction contains two sessions: morning and afternoon.
///
/// A session is identified by the `session` property in the session's
/// frontmatter. There can be only one session with a given name in a course.
#[derive(Default, Debug)]
pub struct Session {
    pub name: String,
    pub segments: Vec<Segment>,
    target_minutes: u64,
}

/// A Segment is a collection of slides with a related theme.
///
/// A segment is identified as a top-level chapter within a session.
#[derive(Default, Debug)]
pub struct Segment {
    pub name: String,
    pub slides: Vec<Slide>,
}

/// A Slide presents a single topic. It may contain multiple mdBook chapters.
///
/// A slide is identified as an sub-chapter of a segment. Any sub-items of
/// that chapter are also included in the slide.
#[derive(Default, Debug)]
pub struct Slide {
    pub name: String,
    /// Minutes this slide should take to teach.
    pub minutes: u64,
    /// Source paths (`.md` files) in this slide.
    pub source_paths: Vec<PathBuf>,
}

impl Courses {
    /// Extract the course structure from the book. As a side-effect, the
    /// frontmatter is stripped from each slide.
    pub fn extract_structure(mut book: Book) -> anyhow::Result<(Self, Book)> {
        let mut courses = Courses::default();
        let mut current_course_name = None;
        let mut current_session_name = None;

        for item in &mut book.sections {
            // We only want to process chapters, omitting part titles and separators.
            let BookItem::Chapter(chapter) = item else {
                continue;
            };

            let (frontmatter, content) = split_frontmatter(chapter)?;
            chapter.content = content;

            // If 'course' is given, use that course (if not 'none') and reset the
            // session.
            if let Some(course_name) = &frontmatter.course {
                current_session_name = None;
                if course_name == "none" {
                    current_course_name = None;
                } else {
                    current_course_name = Some(course_name.clone());
                }
            }

            // If 'session' is given, use that session.
            if let Some(session_name) = &frontmatter.session {
                current_session_name = Some(session_name.clone());
            }

            if current_course_name.is_some() && current_session_name.is_none() {
                anyhow::bail!(
                    "{:?}: 'session' must appear in frontmatter when 'course' appears",
                    chapter.path
                );
            }

            // If we have a course and session, then add this chapter to it as a
            // segment.
            if let (Some(course_name), Some(session_name)) =
                (&current_course_name, &current_session_name)
            {
                let course = courses.course_mut(course_name);
                let session = course.session_mut(session_name);
                session.target_minutes += frontmatter.target_minutes.unwrap_or(0);
                session.add_segment(frontmatter, chapter)?;
            }
        }
        Ok((courses, book))
    }

    /// Get a reference to a course, adding a new one if none by this name
    /// exists.
    fn course_mut(&mut self, name: impl AsRef<str>) -> &mut Course {
        let name = name.as_ref();
        if let Some(found_idx) =
            self.courses.iter().position(|course| course.name == name)
        {
            return &mut self.courses[found_idx];
        }
        let course = Course::new(name);
        self.courses.push(course);
        self.courses.last_mut().unwrap()
    }

    /// Find a course by name.
    pub fn find_course(&self, name: impl AsRef<str>) -> Option<&Course> {
        let name = name.as_ref();
        self.courses.iter().find(|c| c.name == name)
    }

    /// Find the slide generated from the given Chapter within these courses,
    /// returning the "path" to that slide.
    pub fn find_slide(
        &self,
        chapter: &Chapter,
    ) -> Option<(&Course, &Session, &Segment, &Slide)> {
        let source_path = chapter.source_path.as_ref()?;

        for course in self {
            for session in course {
                for segment in session {
                    for slide in segment {
                        if slide.source_paths.contains(source_path) {
                            return Some((course, session, segment, slide));
                        }
                    }
                }
            }
        }

        None
    }
}

impl<'a> IntoIterator for &'a Courses {
    type Item = &'a Course;
    type IntoIter = std::slice::Iter<'a, Course>;

    fn into_iter(self) -> Self::IntoIter {
        self.courses.iter()
    }
}

impl Course {
    fn new(name: impl Into<String>) -> Self {
        Course { name: name.into(), ..Default::default() }
    }

    /// Get a reference to a session, adding a new one if none by this name
    /// exists.
    fn session_mut(&mut self, name: impl AsRef<str>) -> &mut Session {
        let name = name.as_ref();
        if let Some(found_idx) =
            self.sessions.iter().position(|session| session.name == name)
        {
            return &mut self.sessions[found_idx];
        }
        let session = Session::new(name);
        self.sessions.push(session);
        self.sessions.last_mut().unwrap()
    }

    /// Return the total duration of this course, as the sum of all segment
    /// durations.
    ///
    /// This includes breaks between segments, but does not count time between
    /// between sessions.
    pub fn minutes(&self) -> u64 {
        self.into_iter().map(|s| s.minutes()).sum()
    }

    /// Return the target duration of this course, as the sum of all segment
    /// target durations.
    ///
    /// This includes breaks between segments, but does not count time between
    /// sessions.
    pub fn target_minutes(&self) -> u64 {
        self.into_iter().map(|s| s.target_minutes()).sum()
    }

    /// Generate a Markdown schedule for this course, for placement at the given
    /// path.
    pub fn schedule(&self) -> String {
        let mut outline = String::from("Course schedule:\n");
        for session in self {
            writeln!(
                &mut outline,
                " * {} ({}, including breaks)\n",
                session.name,
                duration(session.minutes())
            )
            .unwrap();
            let mut segments = Table::new(["Segment".into(), "Duration".into()]);
            for segment in session {
                // Skip short segments (welcomes, wrap-up, etc.)
                if segment.minutes() == 0 {
                    continue;
                }
                segments
                    .add_row([segment.name.clone(), duration(segment.minutes())]);
            }
            writeln!(&mut outline, "{}\n", segments).unwrap();
        }
        outline
    }
}

impl<'a> IntoIterator for &'a Course {
    type Item = &'a Session;
    type IntoIter = std::slice::Iter<'a, Session>;

    fn into_iter(self) -> Self::IntoIter {
        self.sessions.iter()
    }
}

impl Session {
    fn new(name: impl Into<String>) -> Self {
        Session { name: name.into(), ..Default::default() }
    }

    /// Add a new segment to the session, representing sub-items as slides.
    fn add_segment(
        &mut self,
        frontmatter: Frontmatter,
        chapter: &mut Chapter,
    ) -> anyhow::Result<()> {
        let mut segment = Segment::new(&chapter.name);
        segment.add_slide(frontmatter, chapter, false)?;
        for sub_chapter in &mut chapter.sub_items {
            let BookItem::Chapter(sub_chapter) = sub_chapter else {
                continue;
            };
            let (frontmatter, content) = split_frontmatter(sub_chapter)?;
            sub_chapter.content = content;

            segment.add_slide(frontmatter, sub_chapter, true)?;
        }
        self.segments.push(segment);
        Ok(())
    }

    /// Generate a Markdown outline for this session, for placement at the given
    /// path.
    pub fn outline(&self) -> String {
        let mut segments = Table::new(["Segment".into(), "Duration".into()]);
        for segment in self {
            // Skip short segments (welcomes, wrap-up, etc.)
            if segment.minutes() == 0 {
                continue;
            }
            segments.add_row([segment.name.clone(), duration(segment.minutes())]);
        }
        format!(
            "Including {BREAK_DURATION} minute breaks, this session should take about {}. It contains:\n\n{}",
            duration(self.minutes()),
            segments
        )
    }

    /// Return the total duration of this session.
    pub fn minutes(&self) -> u64 {
        let instructional_time: u64 = self.into_iter().map(|s| s.minutes()).sum();
        if instructional_time == 0 {
            return instructional_time;
        }
        let breaks = (self.into_iter().filter(|s| s.minutes() > 0).count() - 1)
            as u64
            * BREAK_DURATION;
        instructional_time + breaks
    }

    /// Return the target duration of this session.
    ///
    /// This includes breaks between segments.
    pub fn target_minutes(&self) -> u64 {
        if self.target_minutes > 0 { self.target_minutes } else { self.minutes() }
    }
}

impl<'a> IntoIterator for &'a Session {
    type Item = &'a Segment;
    type IntoIter = std::slice::Iter<'a, Segment>;

    fn into_iter(self) -> Self::IntoIter {
        self.segments.iter()
    }
}

impl Segment {
    fn new(name: impl Into<String>) -> Self {
        Segment { name: name.into(), ..Default::default() }
    }

    /// Create a slide from a chapter. If `recurse` is true, sub-items of this
    /// chapter are included in this slide as well.
    fn add_slide(
        &mut self,
        frontmatter: Frontmatter,
        chapter: &mut Chapter,
        recurse: bool,
    ) -> anyhow::Result<()> {
        let mut slide = Slide::new(frontmatter, chapter);

        if recurse {
            slide.add_sub_chapters(chapter)?;
        }
        self.slides.push(slide);
        Ok(())
    }

    /// Return the total duration of this segment (the sum of the durations of
    /// the enclosed slides).
    pub fn minutes(&self) -> u64 {
        self.into_iter().map(|s| s.minutes()).sum()
    }

    pub fn outline(&self) -> String {
        let mut slides = Table::new(["Slide".into(), "Duration".into()]);
        for slide in self {
            if slide.minutes() == 0 {
                continue;
            }
            slides.add_row([slide.name.clone(), duration(slide.minutes())]);
        }
        format!(
            "This segment should take about {}. It contains:\n\n{}",
            duration(self.minutes()),
            slides,
        )
    }
}

impl<'a> IntoIterator for &'a Segment {
    type Item = &'a Slide;
    type IntoIter = std::slice::Iter<'a, Slide>;

    fn into_iter(self) -> Self::IntoIter {
        self.slides.iter()
    }
}

impl Slide {
    fn new(frontmatter: Frontmatter, chapter: &Chapter) -> Self {
        let mut slide = Self { name: chapter.name.clone(), ..Default::default() };
        slide.add_frontmatter(&frontmatter);
        slide.push_source_path(&chapter.source_path);
        slide
    }

    fn add_frontmatter(&mut self, frontmatter: &Frontmatter) {
        self.minutes += frontmatter.minutes.unwrap_or(0);
    }

    fn push_source_path(&mut self, source_path: &Option<PathBuf>) {
        if let Some(source_path) = &source_path {
            self.source_paths.push(source_path.clone());
        }
    }

    /// Add sub-chapters of this chapter to this slide (recursively).
    fn add_sub_chapters(&mut self, chapter: &mut Chapter) -> anyhow::Result<()> {
        for sub_slide in &mut chapter.sub_items {
            let BookItem::Chapter(sub_slide) = sub_slide else {
                continue;
            };
            let (frontmatter, content) = split_frontmatter(sub_slide)?;
            sub_slide.content = content;

            if frontmatter.course.is_some() || frontmatter.session.is_some() {
                anyhow::bail!(
                    "{:?}: sub-slides may not have 'course' or 'session' set",
                    sub_slide.path
                );
            }
            self.add_frontmatter(&frontmatter);
            self.push_source_path(&sub_slide.source_path);
            self.add_sub_chapters(sub_slide)?;
        }
        Ok(())
    }

    /// Determine whether the given chapter is a sub-chapter of this slide.
    pub fn is_sub_chapter(&self, chapter: &Chapter) -> bool {
        // The first `source_path` in the slide is the "parent" chapter, so anything
        // else is a sub-chapter.
        chapter.source_path.as_ref() != self.source_paths.first()
    }

    /// Return the total duration of this slide.
    pub fn minutes(&self) -> u64 {
        self.minutes
    }
}



================================================
FILE: mdbook-course/src/frontmatter.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use anyhow::Context;
use matter::matter;
use mdbook::book::Chapter;
use serde::Deserialize;

#[derive(Deserialize, Debug, Default)]
pub struct Frontmatter {
    pub minutes: Option<u64>,
    pub target_minutes: Option<u64>,
    pub course: Option<String>,
    pub session: Option<String>,
}

/// Split a chapter's contents into frontmatter and the remaining contents.
pub fn split_frontmatter(
    chapter: &Chapter,
) -> anyhow::Result<(Frontmatter, String)> {
    if let Some((frontmatter, content)) = matter(&chapter.content) {
        let frontmatter: Frontmatter = serde_yaml::from_str(&frontmatter)
            .with_context(|| {
                format!("error parsing frontmatter in {:?}", chapter.source_path)
            })?;

        Ok((frontmatter, content))
    } else {
        Ok((Frontmatter::default(), chapter.content.clone()))
    }
}



================================================
FILE: mdbook-course/src/lib.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

pub mod course;
pub mod frontmatter;
pub mod markdown;
pub mod replacements;
pub mod timing_info;



================================================
FILE: mdbook-course/src/markdown.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::fmt;
use std::path::Path;

/// Given a source_path for the markdown file being rendered and a source_path
/// for the target, generate a relative link.
pub fn relative_link(
    doc_path: impl AsRef<Path>,
    target_path: impl AsRef<Path>,
) -> String {
    let doc_path = doc_path.as_ref();
    let target_path = target_path.as_ref();

    let mut dotdot = -1;
    for parent in doc_path.ancestors() {
        if target_path.starts_with(parent) {
            break;
        }
        dotdot += 1;
    }
    if dotdot > 0 {
        format!("{}{}", "../".repeat(dotdot as usize), target_path.display())
    } else {
        format!("./{}", target_path.display())
    }
}

/// Represent the given duration in a human-readable way.
///
/// This will round times longer than 5 minutes to the next 5-minute interval.
pub fn duration(mut minutes: u64) -> String {
    if minutes > 5 {
        minutes += 4;
        minutes -= minutes % 5;
    }

    let (hours, minutes) = (minutes / 60, minutes % 60);
    match (hours, minutes) {
        (0, 1) => "1 minute".into(),
        (0, m) => format!("{m} minutes"),
        (1, 0) => "1 hour".into(),
        (1, m) => format!("1 hour and {m} minutes"),
        (h, 0) => format!("{h} hours"),
        (h, m) => format!("{h} hours and {m} minutes"),
    }
}

/// Table implements Display to format a two-dimensional table as markdown,
/// following https://github.github.com/gfm/#tables-extension-.
pub struct Table<const N: usize> {
    header: [String; N],
    rows: Vec<[String; N]>,
}

impl<const N: usize> Table<N> {
    pub fn new(header: [String; N]) -> Self {
        Self { header, rows: Vec::new() }
    }

    pub fn add_row(&mut self, row: [String; N]) {
        self.rows.push(row);
    }

    fn write_row<'a, I: Iterator<Item = &'a str>>(
        &self,
        f: &mut fmt::Formatter<'_>,
        iter: I,
    ) -> fmt::Result {
        write!(f, "|")?;
        for cell in iter {
            write!(f, " {} |", cell)?;
        }
        writeln!(f)
    }
}

impl<const N: usize> fmt::Display for Table<N> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.write_row(f, self.header.iter().map(|s| s.as_str()))?;
        self.write_row(f, self.header.iter().map(|_| "-"))?;
        for row in &self.rows {
            self.write_row(f, row.iter().map(|s| s.as_str()))?;
        }
        Ok(())
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn relative_link_same_dir() {
        assert_eq!(
            relative_link(Path::new("welcome.md"), Path::new("hello-world.md")),
            "./hello-world.md".to_string()
        );
    }

    #[test]
    fn relative_link_subdir() {
        assert_eq!(
            relative_link(
                Path::new("hello-world.md"),
                Path::new("hello-world/foo.md")
            ),
            "./hello-world/foo.md".to_string()
        );
    }

    #[test]
    fn relative_link_parent_dir() {
        assert_eq!(
            relative_link(
                Path::new("references/foo.md"),
                Path::new("hello-world.md")
            ),
            "../hello-world.md".to_string()
        );
    }

    #[test]
    fn relative_link_deep_parent_dir() {
        assert_eq!(
            relative_link(
                Path::new("references/foo/bar.md"),
                Path::new("hello-world.md")
            ),
            "../../hello-world.md".to_string()
        );
    }

    #[test]
    fn relative_link_peer_dir() {
        assert_eq!(
            relative_link(
                Path::new("references/foo.md"),
                Path::new("hello-world/foo.md")
            ),
            "../hello-world/foo.md".to_string()
        );
    }

    #[test]
    fn duration_no_time() {
        assert_eq!(duration(0), "0 minutes");
    }

    #[test]
    fn duration_single_minute() {
        assert_eq!(duration(1), "1 minute");
    }

    #[test]
    fn duration_two_minutes() {
        assert_eq!(duration(2), "2 minutes");
    }

    #[test]
    fn duration_seven_minutes() {
        assert_eq!(duration(7), "10 minutes");
    }

    #[test]
    fn duration_hour() {
        assert_eq!(duration(60), "1 hour");
    }

    #[test]
    fn duration_hour_mins() {
        assert_eq!(duration(61), "1 hour and 5 minutes");
    }

    #[test]
    fn duration_hours() {
        assert_eq!(duration(120), "2 hours");
    }

    #[test]
    fn duration_hours_mins() {
        assert_eq!(duration(130), "2 hours and 10 minutes");
    }

    #[test]
    fn table() {
        let mut table = Table::new(["a".into(), "b".into()]);
        table.add_row(["a1".into(), "b1".into()]);
        table.add_row(["a2".into(), "b2".into()]);
        assert_eq!(
            format!("{}", table),
            "| a | b |\n| - | - |\n| a1 | b1 |\n| a2 | b2 |\n"
        );
    }
}



================================================
FILE: mdbook-course/src/replacements.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::course::{Course, Courses, Segment, Session};
use mdbook::book::Chapter;
use regex::Regex;

lazy_static::lazy_static! {
    static ref DIRECTIVE: Regex = Regex::new(r#"\{\{%([^}]*)}}"#).unwrap();
}

/// Replace supported directives with the relevant content.
///
/// See the mdbook-course README for details.
#[allow(unused_variables)]
pub fn replace(
    courses: &Courses,
    course: Option<&Course>,
    session: Option<&Session>,
    segment: Option<&Segment>,
    chapter: &mut Chapter,
) {
    let Some(source_path) = &chapter.source_path else {
        return;
    };
    chapter.content = DIRECTIVE
        .replace_all(&chapter.content, |captures: &regex::Captures| {
            let directive_str = captures[1].trim();
            let directive: Vec<_> = directive_str.split_whitespace().collect();
            match directive.as_slice() {
                ["session", "outline"] if session.is_some() => {
                    session.unwrap().outline()
                }
                ["segment", "outline"] if segment.is_some() => {
                    segment.unwrap().outline()
                }
                ["course", "outline"] if course.is_some() => {
                    course.unwrap().schedule()
                }
                ["course", "outline", course_name @ ..] => {
                    let course_name = course_name.join(" ");
                    let Some(course) = courses.find_course(course_name) else {
                        return format!("not found - {}", &captures[0]);
                    };
                    course.schedule()
                }
                _ => directive_str.to_owned(),
            }
        })
        .to_string();
}



================================================
FILE: mdbook-course/src/timing_info.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::course::Slide;
use mdbook::book::Chapter;

/// Insert timing information for this slide into the speaker notes.
pub fn insert_timing_info(slide: &Slide, chapter: &mut Chapter) {
    if slide.minutes > 0
        && !slide.is_sub_chapter(chapter)
        && chapter.content.contains("<details>")
    {
        // Include the minutes in the speaker notes.
        let minutes = slide.minutes;
        let plural = if slide.minutes == 1 { "minute" } else { "minutes" };
        let mut subslides = "";
        if slide.source_paths.len() > 1 {
            subslides = "and its sub-slides ";
        }
        let timing_message =
            format!("This slide {subslides}should take about {minutes} {plural}. ");
        chapter.content = chapter
            .content
            .replace("<details>", &format!("<details>\n{timing_message}"));
    }
}



================================================
FILE: mdbook-exerciser/README.md
================================================
# exerciser

This is an mdBook renderer to generate templates for exercises from the Markdown
source. Given a Markdown file `example.md` with one or more sections like:

````markdown
<!-- File src/main.rs -->

```rust,compile_fail
{{#include example/src/main.rs:main}}

fn some_more_code() {
    // TODO: Write some Rust code here.
}
```
````

and mdbook configuration in `book.toml` like:

```toml
[output.exerciser]
output-directory = "comprehensive-rust-exercises"
```

It will create a file
`book/exerciser/comprehensive-rust-exercises/example/src/main.rs` with the
appropriate contents.



================================================
FILE: mdbook-exerciser/Cargo.toml
================================================
[package]
name = "mdbook-exerciser"
version = "0.1.0"
authors = ["Andrew Walbran <qwandor@google.com>"]
edition = "2024"
license = "Apache-2.0"
repository = "https://github.com/google/comprehensive-rust"
description = "A tool for extracting starter code for exercises from Markdown files."

[dependencies]
anyhow = "1.0.99"
log = "0.4.27"
mdbook = "0.4.52"
pretty_env_logger = "0.5.0"
pulldown-cmark = { version = "0.13.0", default-features = false }



================================================
FILE: mdbook-exerciser/src/lib.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use log::{info, trace};
use pulldown_cmark::{Event, Parser, Tag, TagEnd};
use std::fs::{File, create_dir_all};
use std::io::Write;
use std::path::Path;

const FILENAME_START: &str = "<!-- File ";
const FILENAME_END: &str = " -->";

pub fn process(output_directory: &Path, input_contents: &str) -> anyhow::Result<()> {
    let parser = Parser::new(input_contents);

    // Find a specially-formatted comment followed by a code block, and then call
    // `write_output` with the contents of the code block, to write to a file
    // named by the comment. Code blocks without matching comments will be
    // ignored, as will comments which are not followed by a code block.
    let mut next_filename: Option<String> = None;
    let mut current_file: Option<File> = None;
    for event in parser {
        trace!("{:?}", event);
        match event {
            Event::Html(html) => {
                let html = html.trim();
                if html.starts_with(FILENAME_START) && html.ends_with(FILENAME_END) {
                    next_filename = Some(
                        html[FILENAME_START.len()..html.len() - FILENAME_END.len()]
                            .to_string(),
                    );
                    info!("Next file: {:?}:", next_filename);
                }
            }
            Event::Start(Tag::CodeBlock(x)) => {
                info!("Start {:?}", x);
                if let Some(filename) = &next_filename {
                    let full_filename = output_directory.join(filename);
                    info!("Opening {:?}", full_filename);
                    if let Some(directory) = full_filename.parent() {
                        create_dir_all(directory)?;
                    }
                    current_file = Some(File::create(full_filename)?);
                    next_filename = None;
                }
            }
            Event::Text(text) => {
                info!("Text: {:?}", text);
                if let Some(output_file) = &mut current_file {
                    output_file.write_all(text.as_bytes())?;
                }
            }
            Event::End(TagEnd::CodeBlock) => {
                info!("End");
                current_file = None;
            }
            _ => {}
        }
    }

    Ok(())
}



================================================
FILE: mdbook-exerciser/src/main.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use anyhow::Context;
use log::trace;
use mdbook::BookItem;
use mdbook::book::Book;
use mdbook::renderer::RenderContext;
use mdbook_exerciser::process;
use std::fs::{create_dir, remove_dir_all};
use std::io::stdin;
use std::path::Path;

fn main() -> anyhow::Result<()> {
    pretty_env_logger::init();

    let context = RenderContext::from_json(&mut stdin()).context("Parsing stdin")?;

    let config = context
        .config
        .get_renderer("exerciser")
        .context("Missing output.exerciser configuration")?;

    let output_directory = Path::new(
        config
            .get("output-directory")
            .context(
                "Missing output.exerciser.output-directory configuration value",
            )?
            .as_str()
            .context("Expected a string for output.exerciser.output-directory")?,
    );

    let _ = remove_dir_all(output_directory);
    create_dir(output_directory).with_context(|| {
        format!("Failed to create output directory {:?}", output_directory)
    })?;

    process_all(&context.book, output_directory)?;

    Ok(())
}

fn process_all(book: &Book, output_directory: &Path) -> anyhow::Result<()> {
    for item in book.iter() {
        if let BookItem::Chapter(chapter) = item {
            trace!("Chapter {:?} / {:?}", chapter.path, chapter.source_path);
            if let Some(chapter_path) = &chapter.path {
                // Put the exercises in a subdirectory named after the chapter file,
                // without its parent directories.
                let chapter_output_directory =
                    output_directory.join(chapter_path.file_stem().with_context(
                        || format!("Chapter {:?} has no file stem", chapter_path),
                    )?);
                process(&chapter_output_directory, &chapter.content)?;
            }
        }
    }

    Ok(())
}



================================================
FILE: src/README.md
================================================
# Course Content

The files in this directory make up the content of the course. The files here
can include third-party content from `../third_party/` as well.

When we publish a translation of the course, we `git restore` the `src/` and
`third_party/` directories at the repository root back to the date listed in the
POT-Creation-Date header of the translation. **It is crucial, that all
translatable content lives in those two directories.** The other files (such as
`book.toml` and `theme/`) are not restored and we always use the latest version
of them.



================================================
FILE: src/android.md
================================================
---
course: Android
session: Android
---

# Welcome to Rust in Android

Rust is supported for system software on Android. This means that you can write
new services, libraries, drivers or even firmware in Rust (or improve existing
code as needed).

<details>

The speaker may mention any of the following given the increased use of Rust in
Android:

- Service example:
  [DNS over HTTP](https://security.googleblog.com/2022/07/dns-over-http3-in-android.html).

- Libraries:
  [Rutabaga Virtual Graphics Interface](https://crosvm.dev/book/appendix/rutabaga_gfx.html).

- Kernel Drivers:
  [Binder](https://lore.kernel.org/rust-for-linux/20231101-rust-binder-v1-0-08ba9197f637@google.com/).

- Firmware:
  [pKVM firmware](https://security.googleblog.com/2023/10/bare-metal-rust-in-android.html).

</details>



================================================
FILE: src/bare-metal.md
================================================
---
course: Bare Metal
session: Morning
---

# Welcome to Bare Metal Rust

This is a standalone one-day course about bare-metal Rust, aimed at people who
are familiar with the basics of Rust (perhaps from completing the Comprehensive
Rust course), and ideally also have some experience with bare-metal programming
in some other language such as C.

Today we will talk about 'bare-metal' Rust: running Rust code without an OS
underneath us. This will be divided into several parts:

- What is `no_std` Rust?
- Writing firmware for microcontrollers.
- Writing bootloader / kernel code for application processors.
- Some useful crates for bare-metal Rust development.

For the microcontroller part of the course we will use the
[BBC micro:bit](https://microbit.org/) v2 as an example. It's a
[development board](https://tech.microbit.org/hardware/) based on the Nordic
nRF52833 microcontroller with some LEDs and buttons, an I2C-connected
accelerometer and compass, and an on-board SWD debugger.

To get started, install some tools we'll need later. On gLinux or Debian:

<!-- mdbook-xgettext: skip -->

```bash
sudo apt install gdb-multiarch libudev-dev picocom pkg-config qemu-system-arm build-essential
rustup update
rustup target add aarch64-unknown-none thumbv7em-none-eabihf
rustup component add llvm-tools-preview
cargo install cargo-binutils
curl --proto '=https' --tlsv1.2 -LsSf https://github.com/probe-rs/probe-rs/releases/latest/download/probe-rs-tools-installer.sh | sh
```

And give users in the `plugdev` group access to the micro:bit programmer:

<!-- mdbook-xgettext: skip -->

```bash
echo 'SUBSYSTEM=="hidraw", ATTRS{idVendor}=="0d28", MODE="0660", GROUP="logindev", TAG+="uaccess"' |\
  sudo tee /etc/udev/rules.d/50-microbit.rules
sudo udevadm control --reload-rules
```

You should see "NXP ARM mbed" in the output of `lsusb` if the device is
available. If you are using a Linux environment on a Chromebook, you will need
to share the USB device with Linux, via
`chrome://os-settings/crostini/sharedUsbDevices`.

On MacOS:

<!-- mdbook-xgettext: skip -->

```bash
xcode-select --install
brew install gdb picocom qemu
rustup update
rustup target add aarch64-unknown-none thumbv7em-none-eabihf
rustup component add llvm-tools-preview
cargo install cargo-binutils
curl --proto '=https' --tlsv1.2 -LsSf https://github.com/probe-rs/probe-rs/releases/latest/download/probe-rs-tools-installer.sh | sh
```



================================================
FILE: src/borrowing.md
================================================
# Borrowing

{{%segment outline}}



================================================
FILE: src/cargo.md
================================================
# Using Cargo

When you start reading about Rust, you will soon meet
[Cargo](https://doc.rust-lang.org/cargo/), the standard tool used in the Rust
ecosystem to build and run Rust applications. Here we want to give a brief
overview of what Cargo is and how it fits into the wider ecosystem and how it
fits into this training.

## Installation

> **Please follow the instructions on <https://rustup.rs/>.**

This will give you the Cargo build tool (`cargo`) and the Rust compiler
(`rustc`). You will also get `rustup`, a command line utility that you can use
to install different compiler versions.

After installing Rust, you should configure your editor or IDE to work with
Rust. Most editors do this by talking to [rust-analyzer], which provides
auto-completion and jump-to-definition functionality for [VS Code], [Emacs],
[Vim/Neovim], and many others. There is also a different IDE available called
[RustRover].

<details>

- On Debian/Ubuntu, you can install `rustup` via `apt`:

  ```shell
  sudo apt install rustup
  ```

- On macOS, you can use [Homebrew](https://brew.sh/) to install Rust, but this
  may provide an outdated version. Therefore, it is recommended to install Rust
  from the official site.

</details>

[rust-analyzer]: https://rust-analyzer.github.io/
[VS Code]: https://code.visualstudio.com/
[Emacs]: https://rust-analyzer.github.io/manual.html#emacs
[Vim/Neovim]: https://rust-analyzer.github.io/manual.html#vimneovim
[RustRover]: https://www.jetbrains.com/rust/
[Rust formatter]: https://github.com/rust-lang/rustfmt



================================================
FILE: src/chromium.md
================================================
---
course: Chromium
session: Chromium
---

# Welcome to Rust in Chromium

Rust is supported for third-party libraries in Chromium, with first-party glue
code to connect between Rust and existing Chromium C++ code.

> Today, we'll call into Rust to do something silly with strings. If you've got
> a corner of the code where you're displaying a UTF-8 string to the user, feel
> free to follow this recipe in your part of the codebase instead of the exact
> part we talk about.



================================================
FILE: src/closures.md
================================================
# Closures

{{%segment outline}}



================================================
FILE: src/control-flow-basics.md
================================================
# Control Flow Basics

{{%segment outline}}

<details>

- We will now cover the many kinds of flow control found in Rust.

- Most of this will be very familiar to what you have seen in other programming
  languages.

</details>



================================================
FILE: src/credits.md
================================================
# Credits

The material here builds on top of the many great sources of Rust documentation.
See the page on [other resources](other-resources.md) for a full list of useful
resources.

The material of Comprehensive Rust is licensed under the terms of the Apache 2.0
license, please see
[`LICENSE`](https://github.com/google/comprehensive-rust/blob/main/LICENSE) for
details.

## Rust by Example

Some examples and exercises have been copied and adapted from
[Rust by Example](https://doc.rust-lang.org/rust-by-example/). Please see the
`third_party/rust-by-example/` directory for details, including the license
terms.

## Rust on Exercism

Some exercises have been copied and adapted from
[Rust on Exercism](https://exercism.org/tracks/rust). Please see the
`third_party/rust-on-exercism/` directory for details, including the license
terms.

## CXX

The [Interoperability with C++](android/interoperability/cpp.md) section uses an
image from [CXX](https://cxx.rs/). Please see the `third_party/cxx/` directory
for details, including the license terms.



================================================
FILE: src/error-handling.md
================================================
# Error Handling

{{%segment outline}}



================================================
FILE: src/generics.md
================================================
# Generics

{{%segment outline}}



================================================
FILE: src/glossary.md
================================================
<!-- i18n:comment Please keep { #glossary } untranslated. -->

# Glossary { #glossary }

The following is a glossary which aims to give a short definition of many Rust
terms. For translations, this also serves to connect the term back to the
English original.

<style>
h1#glossary ~ ul {
    list-style: none;
    padding-inline-start: 0;
}

h1#glossary ~ ul > li {
    /* Simplify with "text-indent: 2em hanging" when supported:
       https://caniuse.com/mdn-css_properties_text-indent_hanging */
    padding-left: 2em;
    text-indent: -2em;
}

h1#glossary ~ ul > li:first-line {
    font-weight: bold;
}
</style>

<!-- i18n:comment Please add the English term in italic after your -->
<!-- i18n:comment translated term. Also, please keep the hard line -->
<!-- i18n:comment breaks to ensure a nice formatting. -->

- allocate:\
  Dynamic memory allocation on [the heap](memory-management/review.md).
- argument:\
  Information that is passed into a [function](control-flow-basics/functions.md)
  or method.
- associated type:\
  A type associated with a specific trait. Useful for defining the relationship
  between types.
- Bare-metal Rust:\
  Low-level Rust development, often deployed to a system without an operating
  system. See [Bare-metal Rust](bare-metal.md).
- block:\
  See [Blocks](control-flow-basics/blocks-and-scopes.md) and _scope_.
- borrow:\
  See [Borrowing](borrowing/shared.md).
- borrow checker:\
  The part of the Rust compiler which checks that all
  [borrows](borrowing/borrowck.md) are valid.
- brace:\
  `{` and `}`. Also called _curly brace_, they delimit
  [_blocks_](control-flow-basics/blocks-and-scopes.md).
- build:\
  The process of converting source code into executable code or a usable
  program. See [Running Code Locally with Cargo](cargo/running-locally.md).
- call:\
  To invoke or execute a [function or method](control-flow-basics/functions.md).
- channel:\
  Used to safely pass messages [between threads](concurrency/channels.md).
- Comprehensive Rust 🦀:\
  The courses here are jointly called Comprehensive Rust 🦀.
- concurrency:\
  The execution of multiple tasks or processes at the same time. See
  [Welcome to Concurrency in Rust](concurrency/welcome.md).
- Concurrency in Rust:\
  See [Concurrency in Rust](concurrency/welcome.md).
- constant:\
  A value that does not change during the execution of a program. See
  [const](user-defined-types/const.md).
- control flow:\
  The order in which the individual statements or instructions are executed in a
  program. See [Control Flow Basics](control-flow-basics.md).
- crash:\
  An unexpected and unhandled failure or termination of a program. See
  [panic](error-handling/panics.md).
- enumeration:\
  A data type that holds one of several named constants, possibly with an
  associated tuple or struct. See [enum](user-defined-types/enums.md).
- error:\
  An unexpected condition or result that deviates from the expected behavior.
  See [Error Handling](error-handling.md).
- error handling:\
  The process of managing and responding to [errors](error-handling.md) that
  occur during program execution.
- exercise:\
  A task or problem designed to practice and test programming skills.
- function:\
  A reusable block of code that performs a specific task. See
  [Functions](control-flow-basics/functions.md).
- garbage collector:\
  A mechanism that automatically frees up memory occupied by objects that are no
  longer in use. See
  [Approaches to Memory Management](memory-management/approaches.md).
- generics:\
  A feature that allows writing code with placeholders for types, enabling code
  reuse with different data types. See [Generics](generics.md).
- immutable:\
  Unable to be changed after creation. See
  [Variables](types-and-values/variables.md).
- integration test:\
  A type of test that verifies the interactions between different parts or
  components of a system. See [Other Types of Tests](testing/other.md).
- keyword:\
  A reserved word in a programming language that has a specific meaning and
  cannot be used as an identifier.
- library:\
  A collection of precompiled routines or code that can be used by programs. See
  [Modules](modules.md).
- macro:\
  Rust [macros](control-flow-basics/macros.md) can be recognized by a `!` in the
  name. Macros are used when normal functions are not enough. A typical example
  is `format!`, which takes a variable number of arguments, which isn't
  supported by Rust functions.
- `main` function:\
  Rust programs start executing with the
  [`main` function](types-and-values/hello-world.md).
- match:\
  A control flow construct in Rust that allows for
  [pattern matching](pattern-matching.md) on the value of an expression.
- memory leak:\
  A situation where a program fails to release memory that is no longer needed,
  leading to a gradual increase in memory usage. See
  [Approaches to Memory Management](memory-management/approaches.md).
- method:\
  A function associated with an object or a type in Rust. See
  [Methods](methods-and-traits/methods.md).
- module:\
  A namespace that contains definitions, such as functions, types, or traits, to
  organize code in Rust. See [Modules](modules.md).
- move:\
  The transfer of ownership of a value from one variable to another in Rust. See
  [Move Semantics](memory-management/move.md).
- mutable:\
  A property in Rust that allows [variables](types-and-values/variables.md) to
  be modified after they have been declared.
- ownership:\
  The concept in Rust that defines which part of the code is responsible for
  managing the memory associated with a value. See
  [Ownership](memory-management/ownership.md).
- panic:\
  An unrecoverable error condition in Rust that results in the termination of
  the program. See [Panics](error-handling/panics.md).
- parameter:\
  A value that is passed into a
  [function or method](control-flow-basics/functions.md) when it is called.
- pattern:\
  A combination of values, literals, or structures that can be matched against
  an expression in Rust. See [Pattern Matching](pattern-matching.md).
- payload:\
  The data or information carried by a message, event, or data structure.
- program:\
  A set of instructions that a computer can execute to perform a specific task
  or solve a particular problem. See
  [Hello, World](types-and-values/hello-world.md).
- programming language:\
  A formal system used to communicate instructions to a computer, such as
  [Rust](hello-world/what-is-rust.md).
- receiver:\
  The first parameter in a Rust [method](methods-and-traits/methods.md) that
  represents the instance on which the method is called.
- reference counting:\
  A memory management technique in which the number of references to an object
  is tracked, and the object is deallocated when the count reaches zero. See
  [Rc](smart-pointers/rc.md).
- return:\
  A keyword in Rust used to indicate the value to be returned from a
  [function](control-flow-basics/functions.md).
- Rust:\
  A systems programming language that focuses on safety, performance, and
  concurrency. See [What is Rust?](hello-world/what-is-rust.md).
- Rust Fundamentals:\
  Days 1 to 4 of this course. See [Welcome to Day 1](welcome-day-1.md).
- Rust in Android:\
  See [Rust in Android](android.md).
- Rust in Chromium:\
  See [Rust in Chromium](chromium.md).
- safe:\
  Refers to code that adheres to Rust's ownership and borrowing rules,
  preventing memory-related errors. See [Unsafe Rust](unsafe-rust.md).
- scope:\
  The region of a program where a variable is valid and can be used. See
  [Blocks and Scopes](control-flow-basics/blocks-and-scopes.md).
- standard library:\
  A collection of modules providing essential functionality in Rust. See
  [Standard Library](std-types/std.md).
- static:\
  A keyword in Rust used to define static variables or items with a `'static`
  lifetime. See [static](user-defined-types/static.md).
- string:\
  A data type storing textual data. See [Strings](references/strings.md).
- struct:\
  A composite data type in Rust that groups together variables of different
  types under a single name. See [Structs](user-defined-types/named-structs.md).
- test:\
  A function that tests the correctness of other code. Rust has a built-in test
  runner. See [Testing](testing.md).
- thread:\
  A separate sequence of execution in a program, allowing concurrent execution.
  See [Threads](concurrency/threads.md).
- thread safety:\
  The property of a program that ensures correct behavior in a multithreaded
  environment. See [Send and Sync](concurrency/send-sync.md).
- trait:\
  A collection of methods defined for an unknown type, providing a way to
  achieve polymorphism in Rust. See [Traits](methods-and-traits/traits.md).
- trait bound:\
  An abstraction where you can require types to implement some traits of your
  interest. See [Trait Bounds](generics/trait-bounds.md).
- tuple:\
  A composite data type that contains variables of different types. Tuple fields
  have no names, and are accessed by their ordinal numbers. See
  [Tuples](tuples-and-arrays/tuples.md).
- type:\
  A classification that specifies which operations can be performed on values of
  a particular kind in Rust. See [Types and Values](types-and-values.md).
- type inference:\
  The ability of the Rust compiler to deduce the type of a variable or
  expression. See [Type Inference](types-and-values/inference.md).
- undefined behavior:\
  Actions or conditions in Rust that have no specified result, often leading to
  unpredictable program behavior. See [Unsafe Rust](unsafe-rust.md).
- union:\
  A data type that can hold values of different types but only one at a time.
  See [Unions](unsafe-rust/unions.md).
- unit test:\
  Rust comes with built-in support for running small unit tests and larger
  integration tests. See [Unit Tests](testing/unit-tests.md).
- unit type:\
  Type that holds no data, written as a tuple with no members. See speaker notes
  on [Functions](control-flow-basics/functions.html).
- unsafe:\
  The subset of Rust which allows you to trigger _undefined behavior_. See
  [Unsafe Rust](unsafe-rust/unsafe.md).
- variable:\
  A memory location storing data. Variables are valid in a _scope_. See
  [Variables](types-and-values/variables.md).



================================================
FILE: src/hello-world.md
================================================
# Hello, World

{{%segment outline}}



================================================
FILE: src/index.md
================================================
# Welcome to Comprehensive Rust 🦀

[![Build workflow](https://img.shields.io/github/actions/workflow/status/google/comprehensive-rust/build.yml?style=flat-square)](https://github.com/google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain)
[![GitHub contributors](https://img.shields.io/github/contributors/google/comprehensive-rust?style=flat-square)](https://github.com/google/comprehensive-rust/graphs/contributors)
[![GitHub stars](https://img.shields.io/github/stars/google/comprehensive-rust?style=flat-square)](https://github.com/google/comprehensive-rust/stargazers)

This is a free Rust course developed by the Android team at Google. The course
covers the full spectrum of Rust, from basic syntax to advanced topics like
generics and error handling.

> The latest version of the course can be found at
> <https://google.github.io/comprehensive-rust/>. If you are reading somewhere
> else, please check there for updates.
>
> The course is available in other languages. Select your preferred language in
> the top right corner of the page or check the
> [Translations](running-the-course/translations.md) page for a list of all
> available translations.
>
> The course is also available [as a PDF](comprehensive-rust.pdf).

The goal of the course is to teach you Rust. We assume you don't know anything
about Rust and hope to:

- Give you a comprehensive understanding of the Rust syntax and language.
- Enable you to modify existing programs and write new programs in Rust.
- Show you common Rust idioms.

We call the first four course days Rust Fundamentals.

Building on this, you're invited to dive into one or more specialized topics:

- [Android](android.md): a half-day course on using Rust for Android platform
  development (AOSP). This includes interoperability with C, C++, and Java.
- [Chromium](chromium.md): a half-day course on using Rust in Chromium-based
  browsers. This includes interoperability with C++ and how to include
  third-party crates in Chromium.
- [Bare-metal](bare-metal.md): a whole-day class on using Rust for bare-metal
  (embedded) development. Both microcontrollers and application processors are
  covered.
- [Concurrency](concurrency/welcome.md): a whole-day class on concurrency in
  Rust. We cover both classical concurrency (preemptively scheduling using
  threads and mutexes) and async/await concurrency (cooperative multitasking
  using futures).

## Non-Goals

Rust is a large language and we won't be able to cover all of it in a few days.
Some non-goals of this course are:

- Learning how to develop macros: please see
  [the Rust Book](https://doc.rust-lang.org/book/) and
  [Rust by Example](https://doc.rust-lang.org/rust-by-example/macros.html)
  instead.

## Assumptions

The course assumes that you already know how to program. Rust is a
statically-typed language and we will sometimes make comparisons with C and C++
to better explain or contrast the Rust approach.

If you know how to program in a dynamically-typed language such as Python or
JavaScript, then you will be able to follow along just fine too.

<details>

This is an example of a _speaker note_. We will use these to add additional
information to the slides. This could be key points which the instructor should
cover as well as answers to typical questions which come up in class.

</details>



================================================
FILE: src/iterators.md
================================================
# Iterators

{{%segment outline}}



================================================
FILE: src/lifetimes.md
================================================
# Lifetimes

{{%segment outline}}



================================================
FILE: src/memory-management.md
================================================
# Memory Management

{{%segment outline}}



================================================
FILE: src/methods-and-traits.md
================================================
# Methods and Traits

{{%segment outline}}



================================================
FILE: src/modules.md
================================================
# Modules

{{%segment outline}}



================================================
FILE: src/other-resources.md
================================================
# Other Rust Resources

The Rust community has created a wealth of high-quality and free resources
online.

## Official Documentation

The Rust project hosts many resources. These cover Rust in general:

- [The Rust Programming Language](https://doc.rust-lang.org/book/): the
  canonical free book about Rust. Covers the language in detail and includes a
  few projects for people to build.
- [Rust By Example](https://doc.rust-lang.org/rust-by-example/): covers the Rust
  syntax via a series of examples which showcase different constructs. Sometimes
  includes small exercises where you are asked to expand on the code in the
  examples.
- [Rust Standard Library](https://doc.rust-lang.org/std/): full documentation of
  the standard library for Rust.
- [The Rust Reference](https://doc.rust-lang.org/reference/): an incomplete book
  which describes the Rust grammar and memory model.
- [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/):
  recommendations on how to design APIs.

More specialized guides hosted on the official Rust site:

- [The Rustonomicon](https://doc.rust-lang.org/nomicon/): covers unsafe Rust,
  including working with raw pointers and interfacing with other languages
  (FFI).
- [Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/):
  covers the new asynchronous programming model which was introduced after the
  Rust Book was written.
- [The Embedded Rust Book](https://doc.rust-lang.org/stable/embedded-book/): an
  introduction to using Rust on embedded devices without an operating system.

## Unofficial Learning Material

A small selection of other guides and tutorial for Rust:

- [Learn Rust the Dangerous Way](http://cliffle.com/p/dangerust/): covers Rust
  from the perspective of low-level C programmers.
- [Rust for Embedded C Programmers](https://opentitan.org/book/doc/rust_for_c_devs.html):
  covers Rust from the perspective of developers who write firmware in C.
- [Rust for professionals](https://overexact.com/rust-for-professionals/):
  covers the syntax of Rust using side-by-side comparisons with other languages
  such as C, C++, Java, JavaScript, and Python.
- [Rust on Exercism](https://exercism.org/tracks/rust): 100+ exercises to help
  you learn Rust.
- [Ferrous Teaching Material](https://ferrous-systems.github.io/teaching-material/index.html):
  a series of small presentations covering both basic and advanced part of the
  Rust language. Other topics such as WebAssembly, and async/await are also
  covered.
- [Advanced testing for Rust applications](https://rust-exercises.com/advanced-testing/):
  a self-paced workshop that goes beyond Rust's built-in testing framework. It
  covers `googletest`, snapshot testing, mocking as well as how to write your
  own custom test harness.
- [Beginner's Series to Rust](https://docs.microsoft.com/en-us/shows/beginners-series-to-rust/)
  and
  [Take your first steps with Rust](https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/):
  two Rust guides aimed at new developers. The first is a set of 35 videos and
  the second is a set of 11 modules which covers Rust syntax and basic
  constructs.
- [Learn Rust With Entirely Too Many Linked
  Lists](https://rust-unofficial.github.io/too-many-lists/): in-depth
  exploration of Rust's memory management rules, through implementing a few
  different types of list structures.
- [The Little Book of Rust Macros](https://danielkeep.github.io/tlborm/): covers
  many details on Rust macros with practical examples.

Please see the [Little Book of Rust Books](https://lborb.github.io/book/) for
even more Rust books.



================================================
FILE: src/pattern-matching.md
================================================
# Pattern Matching

{{%segment outline}}



================================================
FILE: src/references.md
================================================
# References

{{%segment outline}}



================================================
FILE: src/running-the-course.md
================================================
# Running the Course

> This page is for the course instructor.

Here is a bit of background information about how we've been running the course
internally at Google.

We typically run classes from 9:00 am to 4:00 pm, with a 1 hour lunch break in
the middle. This leaves 3 hours for the morning class and 3 hours for the
afternoon class. Both sessions contain multiple breaks and time for students to
work on exercises.

Before you run the course, you will want to:

1. Make yourself familiar with the course material. We've included speaker notes
   to help highlight the key points (please help us by contributing more speaker
   notes!). When presenting, you should make sure to open the speaker notes in a
   popup (click the link with a little arrow next to "Speaker Notes"). This way
   you have a clean screen to present to the class.

1. Decide on the dates. Since the course takes four days, we recommend that you
   schedule the days over two weeks. Course participants have said that they
   find it helpful to have a gap in the course since it helps them process all
   the information we give them.

1. Find a room large enough for your in-person participants. We recommend a
   class size of 15-25 people. That's small enough that people are comfortable
   asking questions --- it's also small enough that one instructor will have
   time to answer the questions. Make sure the room has _desks_ for yourself and
   for the students: you will all need to be able to sit and work with your
   laptops. In particular, you will be doing a lot of live-coding as an
   instructor, so a lectern won't be very helpful for you.

1. On the day of your course, show up to the room a little early to set things
   up. We recommend presenting directly using `mdbook serve` running on your
   laptop (see the [installation instructions][3]). This ensures optimal
   performance with no lag as you change pages. Using your laptop will also
   allow you to fix typos as you or the course participants spot them.

1. Let people solve the exercises by themselves or in small groups. We typically
   spend 30-45 minutes on exercises in the morning and in the afternoon
   (including time to review the solutions). Make sure to ask people if they're
   stuck or if there is anything you can help with. When you see that several
   people have the same problem, call it out to the class and offer a solution,
   e.g., by showing people where to find the relevant information in the
   standard library.

That is all, good luck running the course! We hope it will be as much fun for
you as it has been for us!

Please [provide feedback][1] afterwards so that we can keep improving the
course. We would love to hear what worked well for you and what can be made
better. Your students are also very welcome to [send us feedback][2]!

[1]: https://github.com/google/comprehensive-rust/discussions/86
[2]: https://github.com/google/comprehensive-rust/discussions/100
[3]: https://github.com/google/comprehensive-rust#building

<details>

### Instructor Preparation

- **Go through all the material:** Before teaching the course, make sure you
  have gone through all the slides and exercises yourself. This will help you
  anticipate questions and potential difficulties.
- **Prepare for live coding:** The course involves a lot of live coding.
  Practice the examples and exercises beforehand to ensure you can type them out
  smoothly during the class. Have the solutions ready in case you get stuck.
- **Familiarize yourself with `mdbook`:** The course is presented using
  `mdbook`. Knowing how to navigate, search, and use its features will make the
  presentation smoother.

### Creating a Good Learning Environment

- **Encourage questions:** Reiterate that there are no "stupid" questions. A
  welcoming atmosphere for questions is crucial for learning.
- **Manage time effectively:** Keep an eye on the schedule, but be flexible.
  It's more important that students understand the concepts than sticking
  rigidly to the timeline.
- **Facilitate group work:** During exercises, encourage students to work
  together. This can help them learn from each other and feel less stuck.

</details>



================================================
FILE: src/smart-pointers.md
================================================
# Smart Pointers

{{%segment outline}}



================================================
FILE: src/std-traits.md
================================================
# Standard Library Traits

{{%segment outline}}

<details>

As with the standard library types, spend time reviewing the documentation for
each trait.

This section is long. Take a break midway through.

</details>



================================================
FILE: src/std-types.md
================================================
# Standard Library Types

{{%segment outline}}

<details>

For each of the slides in this section, spend some time reviewing the
documentation pages, highlighting some of the more common methods.

</details>



================================================
FILE: src/SUMMARY.md
================================================
<!-- Keep first page as index.md to avoid giving it two names. -->

[Welcome to Comprehensive Rust 🦀](index.md)

- [Running the Course](running-the-course.md)
  - [Course Structure](running-the-course/course-structure.md)
  - [Keyboard Shortcuts](running-the-course/keyboard-shortcuts.md)
  - [Translations](running-the-course/translations.md)
- [Using Cargo](cargo.md)
  - [Rust Ecosystem](cargo/rust-ecosystem.md)
  - [Code Samples](cargo/code-samples.md)
  - [Running Cargo Locally](cargo/running-locally.md)

---

# Day 1: Morning

- [Welcome](welcome-day-1.md)
- [Hello, World](hello-world.md)
  - [What is Rust?](hello-world/what-is-rust.md)
  - [Benefits of Rust](hello-world/benefits.md)
  - [Playground](hello-world/playground.md)
- [Types and Values](types-and-values.md)
  - [Hello, World](types-and-values/hello-world.md)
  - [Variables](types-and-values/variables.md)
  - [Values](types-and-values/values.md)
  - [Arithmetic](types-and-values/arithmetic.md)
  - [Type Inference](types-and-values/inference.md)
  - [Exercise: Fibonacci](types-and-values/exercise.md)
    - [Solution](types-and-values/solution.md)
- [Control Flow Basics](control-flow-basics.md)
  - [Blocks and Scopes](control-flow-basics/blocks-and-scopes.md)
  - [`if` Expressions](control-flow-basics/if.md)
  - [`match` Expressions](control-flow-basics/match.md)
  - [Loops](control-flow-basics/loops.md)
    - [`for`](control-flow-basics/loops/for.md)
    - [`loop`](control-flow-basics/loops/loop.md)
  - [`break` and `continue`](control-flow-basics/break-continue.md)
    - [Labels](control-flow-basics/break-continue/labels.md)
  - [Functions](control-flow-basics/functions.md)
  - [Macros](control-flow-basics/macros.md)
  - [Exercise: Collatz Sequence](control-flow-basics/exercise.md)
    - [Solution](control-flow-basics/solution.md)

# Day 1: Afternoon

- [Welcome](welcome-day-1-afternoon.md)
- [Tuples and Arrays](tuples-and-arrays.md)
  - [Arrays](tuples-and-arrays/arrays.md)
  - [Tuples](tuples-and-arrays/tuples.md)
  - [Array Iteration](tuples-and-arrays/iteration.md)
  - [Patterns and Destructuring](tuples-and-arrays/destructuring.md)
  - [Exercise: Nested Arrays](tuples-and-arrays/exercise.md)
    - [Solution](tuples-and-arrays/solution.md)
- [References](references.md)
  - [Shared References](references/shared.md)
  - [Exclusive References](references/exclusive.md)
  - [Slices](references/slices.md)
  - [Strings](references/strings.md)
  - [Reference Validity](references/dangling.md)
  - [Exercise: Geometry](references/exercise.md)
    - [Solution](references/solution.md)
- [User-Defined Types](user-defined-types.md)
  - [Named Structs](user-defined-types/named-structs.md)
  - [Tuple Structs](user-defined-types/tuple-structs.md)
  - [Enums](user-defined-types/enums.md)
  - [Type Aliases](user-defined-types/aliases.md)
  - [Const](user-defined-types/const.md)
  - [Static](user-defined-types/static.md)
  - [Exercise: Elevator Events](user-defined-types/exercise.md)
    - [Solution](user-defined-types/solution.md)

---

# Day 2: Morning

- [Welcome](welcome-day-2.md)
- [Pattern Matching](pattern-matching.md)
  - [Irrefutable Patterns](pattern-matching/infallible.md)
  - [Matching Values](pattern-matching/match.md)
  - [Destructuring Structs](pattern-matching/destructuring-structs.md)
  - [Destructuring Enums](pattern-matching/destructuring-enums.md)
  - [Let Control Flow](pattern-matching/let-control-flow.md)
    - [`if let` Expressions](pattern-matching/let-control-flow/if-let.md)
    - [`while let` Statements](pattern-matching/let-control-flow/while-let.md)
    - [`let else`](pattern-matching/let-control-flow/let-else.md)
  - [Exercise: Expression Evaluation](pattern-matching/exercise.md)
    - [Solution](pattern-matching/solution.md)
- [Methods and Traits](methods-and-traits.md)
  - [Methods](methods-and-traits/methods.md)
  - [Traits](methods-and-traits/traits.md)
    - [Implementing Traits](methods-and-traits/traits/implementing.md)
    - [Supertraits](methods-and-traits/traits/supertraits.md)
    - [Associated Types](methods-and-traits/traits/associated-types.md)
  - [Deriving](methods-and-traits/deriving.md)
  - [Exercise: Generic Logger](methods-and-traits/exercise.md)
    - [Solution](methods-and-traits/solution.md)
- [Generics](generics.md)
  - [Generic Functions](generics/generic-functions.md)
  - [Trait Bounds](generics/trait-bounds.md)
  - [Generic Data Types](generics/generic-data.md)
  - [Generic Traits](generics/generic-traits.md)
  - [`impl Trait`](generics/impl-trait.md)
  - [`dyn Trait`](generics/dyn-trait.md)
  - [Exercise: Generic `min`](generics/exercise.md)
    - [Solution](generics/solution.md)

# Day 2: Afternoon

- [Welcome](welcome-day-2-afternoon.md)
- [Closures](closures.md)
  - [Closure Syntax](closures/syntax.md)
  - [Capturing](closures/capturing.md)
  - [Closure Traits](closures/traits.md)
  - [Exercise: Log Filter](closures/exercise.md)
    - [Solution](closures/solution.md)
- [Standard Library Types](std-types.md)
  - [Standard Library](std-types/std.md)
  - [Documentation](std-types/docs.md)
  - [`Option`](std-types/option.md)
  - [`Result`](std-types/result.md)
  - [`String`](std-types/string.md)
  - [`Vec`](std-types/vec.md)
  - [`HashMap`](std-types/hashmap.md)
  - [Exercise: Counter](std-types/exercise.md)
    - [Solution](std-types/solution.md)
- [Standard Library Traits](std-traits.md)
  - [Comparisons](std-traits/comparisons.md)
  - [Operators](std-traits/operators.md)
  - [`From` and `Into`](std-traits/from-and-into.md)
  - [Casting](std-traits/casting.md)
  - [`Read` and `Write`](std-traits/read-and-write.md)
  - [`Default`, struct update syntax](std-traits/default.md)
  - [Exercise: ROT13](std-traits/exercise.md)
    - [Solution](std-traits/solution.md)

---

# Day 3: Morning

- [Welcome](welcome-day-3.md)
- [Memory Management](memory-management.md)
  - [Review of Program Memory](memory-management/review.md)
  - [Approaches to Memory Management](memory-management/approaches.md)
  - [Ownership](memory-management/ownership.md)
  - [Move Semantics](memory-management/move.md)
  - [`Clone`](memory-management/clone.md)
  - [Copy Types](memory-management/copy-types.md)
  - [`Drop`](memory-management/drop.md)
  - [Exercise: Builder Type](memory-management/exercise.md)
    - [Solution](memory-management/solution.md)
- [Smart Pointers](smart-pointers.md)
  - [`Box<T>`](smart-pointers/box.md)
  - [`Rc`](smart-pointers/rc.md)
  - [Owned Trait Objects](smart-pointers/trait-objects.md)
  - [Exercise: Binary Tree](smart-pointers/exercise.md)
    - [Solution](smart-pointers/solution.md)

# Day 3: Afternoon

- [Welcome](welcome-day-3-afternoon.md)
- [Borrowing](borrowing.md)
  - [Borrowing a Value](borrowing/shared.md)
  - [Borrow Checking](borrowing/borrowck.md)
  - [Borrow Errors](borrowing/examples.md)
  - [Interior Mutability](borrowing/interior-mutability.md)
    - [`Cell`](borrowing/interior-mutability/cell.md)
    - [`RefCell`](borrowing/interior-mutability/refcell.md)
  - [Exercise: Health Statistics](borrowing/exercise.md)
    - [Solution](borrowing/solution.md)
- [Lifetimes](lifetimes.md)
  - [Lifetime Annotations](lifetimes/lifetime-annotations.md)
  - [Lifetime Elision](lifetimes/lifetime-elision.md)
  - [Lifetimes in Data Structures](lifetimes/struct-lifetimes.md)
  - [Exercise: Protobuf Parsing](lifetimes/exercise.md)
    - [Solution](lifetimes/solution.md)

---

# Day 4: Morning

- [Welcome](welcome-day-4.md)
- [Iterators](iterators.md)
  - [Motivation](iterators/motivation.md)
  - [`Iterator` Trait](iterators/iterator.md)
  - [`Iterator` Helper Methods](iterators/helpers.md)
  - [`collect`](iterators/collect.md)
  - [`IntoIterator`](iterators/intoiterator.md)
  - [Exercise: Iterator Method Chaining](iterators/exercise.md)
    - [Solution](iterators/solution.md)
- [Modules](modules.md)
  - [Modules](modules/modules.md)
  - [Filesystem Hierarchy](modules/filesystem.md)
  - [Visibility](modules/visibility.md)
  - [Encapsulation](modules/encapsulation.md)
  - [`use`, `super`, `self`](modules/paths.md)
  - [Exercise: Modules for a GUI Library](modules/exercise.md)
    - [Solution](modules/solution.md)
- [Testing](testing.md)
  - [Unit Tests](testing/unit-tests.md)
  - [Other Types of Tests](testing/other.md)
  - [Compiler Lints and Clippy](testing/lints.md)
  - [Exercise: Luhn Algorithm](testing/exercise.md)
    - [Solution](testing/solution.md)

# Day 4: Afternoon

- [Welcome](welcome-day-4-afternoon.md)
- [Error Handling](error-handling.md)
  - [Panics](error-handling/panics.md)
  - [`Result`](error-handling/result.md)
  - [Try Operator](error-handling/try.md)
  - [Try Conversions](error-handling/try-conversions.md)
  - [`Error` Trait](error-handling/error.md)
  - [`thiserror`](error-handling/thiserror.md)
  - [`anyhow`](error-handling/anyhow.md)
  - [Exercise: Rewriting with `Result`](error-handling/exercise.md)
    - [Solution](error-handling/solution.md)
- [Unsafe Rust](unsafe-rust.md)
  - [Unsafe](unsafe-rust/unsafe.md)
  - [Dereferencing Raw Pointers](unsafe-rust/dereferencing.md)
  - [Mutable Static Variables](unsafe-rust/mutable-static.md)
  - [Unions](unsafe-rust/unions.md)
  - [Unsafe Functions](unsafe-rust/unsafe-functions.md)
    - [Unsafe Rust Functions](unsafe-rust/unsafe-functions/rust.md)
    - [Unsafe External Functions](unsafe-rust/unsafe-functions/extern-c.md)
    - [Calling Unsafe Functions](unsafe-rust/unsafe-functions/calling.md)
  - [Unsafe Traits](unsafe-rust/unsafe-traits.md)
  - [Exercise: FFI Wrapper](unsafe-rust/exercise.md)
    - [Solution](unsafe-rust/solution.md)

---

# Android

- [Welcome](android.md)
- [Setup](android/setup.md)
- [Build Rules](android/build-rules.md)
  - [Binary](android/build-rules/binary.md)
  - [Library](android/build-rules/library.md)
- [AIDL](android/aidl.md)
  - [Birthday Service Tutorial](android/aidl/birthday-service.md)
    - [Interface](android/aidl/example-service/interface.md)
    - [Service API](android/aidl/example-service/service-bindings.md)
    - [Service](android/aidl/example-service/service.md)
    - [Server](android/aidl/example-service/server.md)
    - [Deploy](android/aidl/example-service/deploy.md)
    - [Client](android/aidl/example-service/client.md)
    - [Changing API](android/aidl/example-service/changing-definition.md)
    - [Updating Implementations](android/aidl/example-service/changing-implementation.md)
  - [AIDL Types](android/aidl/types.md)
    - [Primitive Types](android/aidl/types/primitives.md)
    - [Array Types](android/aidl/types/arrays.md)
    - [Sending Objects](android/aidl/types/objects.md)
    - [Parcelables](android/aidl/types/parcelables.md)
    - [Sending Files](android/aidl/types/file-descriptor.md)
- [Testing](android/testing.md)
  - [GoogleTest](android/testing/googletest.md)
  - [Mocking](android/testing/mocking.md)
- [Logging](android/logging.md)
- [Interoperability](android/interoperability.md)
  - [With C](android/interoperability/with-c.md)
    - [A Simple C Library](android/interoperability/with-c/c-library.md)
    - [Bindgen](android/interoperability/with-c/bindgen.md)
    - [Running Our Binary](android/interoperability/with-c/run-our-binary.md)
    - [A Simple Rust Library](android/interoperability/with-c/rust-library.md)
    - [Calling Rust from C](android/interoperability/with-c/rust.md)
  - [With C++](android/interoperability/cpp.md)
    - [The Bridge Module](android/interoperability/cpp/bridge.md)
    - [Rust Bridge](android/interoperability/cpp/rust-bridge.md)
    - [Generated C++](android/interoperability/cpp/generated-cpp.md)
    - [C++ Bridge](android/interoperability/cpp/cpp-bridge.md)
    - [Shared Types](android/interoperability/cpp/shared-types.md)
    - [Shared Enums](android/interoperability/cpp/shared-enums.md)
    - [Rust Error Handling](android/interoperability/cpp/rust-result.md)
    - [C++ Error Handling](android/interoperability/cpp/cpp-exception.md)
    - [Additional Types](android/interoperability/cpp/type-mapping.md)
    - [Building for Android: Genrules](android/interoperability/cpp/android-cpp-genrules.md)
    - [Building for Android: C++](android/interoperability/cpp/android-build-cpp.md)
    - [Building for Android: Rust](android/interoperability/cpp/android-build-rust.md)
  - [With Java](android/interoperability/java.md)

---

# Chromium

- [Welcome](chromium.md)
- [Setup](chromium/setup.md)
- [Comparing Chromium and Cargo Ecosystems](chromium/cargo.md)
- [Policy](chromium/policy.md)
- [Build Rules](chromium/build-rules.md)
  - [Unsafe Code](chromium/build-rules/unsafe.md)
  - [Depending on Rust Code from Chromium C++](chromium/build-rules/depending.md)
  - [Visual Studio Code](chromium/build-rules/vscode.md)
  - [Exercise](exercises/chromium/build-rules.md)
- [Testing](chromium/testing.md)
  - [`rust_gtest_interop` Library](chromium/testing/rust-gtest-interop.md)
  - [GN Rules for Rust Tests](chromium/testing/build-gn.md)
  - [`chromium::import!` Macro](chromium/testing/chromium-import-macro.md)
  - [Exercise](exercises/chromium/testing.md)
- [Interoperability with C++](chromium/interoperability-with-cpp.md)
  - [Example Bindings](chromium/interoperability-with-cpp/example-bindings.md)
  - [Limitations of CXX](chromium/interoperability-with-cpp/limitations-of-cxx.md)
  - [CXX Error Handling](chromium/interoperability-with-cpp/error-handling.md)
    - [Error Handling: QR Example](chromium/interoperability-with-cpp/error-handling-qr.md)
    - [Error Handling: PNG Example](chromium/interoperability-with-cpp/error-handling-png.md)
  - [Using CXX in Chromium](chromium/interoperability-with-cpp/using-cxx-in-chromium.md)
  - [Exercise](exercises/chromium/interoperability-with-cpp.md)
- [Adding Third Party Crates](chromium/adding-third-party-crates.md)
  - [Configuring Cargo.toml](chromium/adding-third-party-crates/configuring-cargo-toml.md)
  - [Configuring `gnrt_config.toml`](chromium/adding-third-party-crates/configuring-gnrt-config-toml.md)
  - [Downloading Crates](chromium/adding-third-party-crates/downloading-crates.md)
  - [Generating `gn` Build Rules](chromium/adding-third-party-crates/generating-gn-build-rules.md)
  - [Resolving Problems](chromium/adding-third-party-crates/resolving-problems.md)
    - [Build Scripts Which Generate Code](chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md)
    - [Build Scripts Which Build C++ or Take Arbitrary Actions](chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md)
  - [Depending on a Crate](chromium/adding-third-party-crates/depending-on-a-crate.md)
  - [Reviews and Audits](chromium/adding-third-party-crates/reviews-and-audits.md)
  - [Checking into Chromium Source Code](chromium/adding-third-party-crates/checking-in.md)
  - [Keeping Crates Up to Date](chromium/adding-third-party-crates/keeping-up-to-date.md)
  - [Exercise](exercises/chromium/third-party.md)
- [Bringing It Together - Exercise](exercises/chromium/bringing-it-together.md)
- [Exercise Solutions](exercises/chromium/solutions.md)

---

# Bare Metal: Morning

- [Welcome](bare-metal.md)
- [`no_std`](bare-metal/no_std.md)
  - [A Minimal Example](bare-metal/minimal.md)
  - [`alloc`](bare-metal/alloc.md)
- [Microcontrollers](bare-metal/microcontrollers.md)
  - [Raw MMIO](bare-metal/microcontrollers/mmio.md)
  - [PACs](bare-metal/microcontrollers/pacs.md)
  - [HAL Crates](bare-metal/microcontrollers/hals.md)
  - [Board Support Crates](bare-metal/microcontrollers/board-support.md)
  - [The Type State Pattern](bare-metal/microcontrollers/type-state.md)
  - [`embedded-hal`](bare-metal/microcontrollers/embedded-hal.md)
  - [`probe-rs` and `cargo-embed`](bare-metal/microcontrollers/probe-rs.md)
    - [Debugging](bare-metal/microcontrollers/debugging.md)
  - [Other Projects](bare-metal/microcontrollers/other-projects.md)
- [Exercises](exercises/bare-metal/morning.md)
  - [Compass](exercises/bare-metal/compass.md)
  - [Solutions](exercises/bare-metal/solutions-morning.md)

# Bare Metal: Afternoon

- [Application Processors](bare-metal/aps.md)
  - [Getting Ready to Rust](bare-metal/aps/entry-point.md)
  - [Inline Assembly](bare-metal/aps/inline-assembly.md)
  - [MMIO](bare-metal/aps/mmio.md)
  - [Let's Write a UART Driver](bare-metal/aps/uart.md)
    - [More Traits](bare-metal/aps/uart/traits.md)
    - [Using It](bare-metal/aps/uart/using.md)
  - [A Better UART Driver](bare-metal/aps/better-uart.md)
    - [Bitflags](bare-metal/aps/better-uart/bitflags.md)
    - [Multiple Registers](bare-metal/aps/better-uart/registers.md)
    - [Driver](bare-metal/aps/better-uart/driver.md)
  - [safe-mmio](bare-metal/aps/safemmio/registers.md)
    - [Driver](bare-metal/aps/safemmio/driver.md)
    - [Using It](bare-metal/aps/safemmio/using.md)
  - [Logging](bare-metal/aps/logging.md)
    - [Using It](bare-metal/aps/logging/using.md)
  - [Exceptions](bare-metal/aps/exceptions.md)
  - [aarch64-rt](bare-metal/aps/aarch64-rt.md)
  - [Other Projects](bare-metal/aps/other-projects.md)
- [Useful Crates](bare-metal/useful-crates.md)
  - [`zerocopy`](bare-metal/useful-crates/zerocopy.md)
  - [`aarch64-paging`](bare-metal/useful-crates/aarch64-paging.md)
  - [`buddy_system_allocator`](bare-metal/useful-crates/buddy_system_allocator.md)
  - [`tinyvec`](bare-metal/useful-crates/tinyvec.md)
  - [`spin`](bare-metal/useful-crates/spin.md)
- [Bare-Metal on Android](bare-metal/android.md)
  - [`vmbase`](bare-metal/android/vmbase.md)
- [Exercises](exercises/bare-metal/afternoon.md)
  - [RTC Driver](exercises/bare-metal/rtc.md)
  - [Solutions](exercises/bare-metal/solutions-afternoon.md)

---

# Concurrency: Morning

- [Welcome](concurrency/welcome.md)
- [Threads](concurrency/threads.md)
  - [Plain Threads](concurrency/threads/plain.md)
  - [Scoped Threads](concurrency/threads/scoped.md)
- [Channels](concurrency/channels.md)
  - [Senders and Receivers](concurrency/channels/senders-receivers.md)
  - [Unbounded Channels](concurrency/channels/unbounded.md)
  - [Bounded Channels](concurrency/channels/bounded.md)
- [`Send` and `Sync`](concurrency/send-sync.md)
  - [Marker Traits](concurrency/send-sync/marker-traits.md)
  - [`Send`](concurrency/send-sync/send.md)
  - [`Sync`](concurrency/send-sync/sync.md)
  - [Examples](concurrency/send-sync/examples.md)
- [Shared State](concurrency/shared-state.md)
  - [`Arc`](concurrency/shared-state/arc.md)
  - [`Mutex`](concurrency/shared-state/mutex.md)
  - [Example](concurrency/shared-state/example.md)
- [Exercises](concurrency/sync-exercises.md)
  - [Dining Philosophers](concurrency/sync-exercises/dining-philosophers.md)
  - [Multi-threaded Link Checker](concurrency/sync-exercises/link-checker.md)
  - [Solutions](concurrency/sync-exercises/solutions.md)

# Concurrency: Afternoon

- [Welcome](concurrency/welcome-async.md)
- [Async Basics](concurrency/async.md)
  - [`async`/`await`](concurrency/async/async-await.md)
  - [Futures](concurrency/async/futures.md)
  - [State Machine](concurrency/async/state-machine.md)
  - [Runtimes](concurrency/async/runtimes.md)
    - [Tokio](concurrency/async/runtimes/tokio.md)
  - [Tasks](concurrency/async/tasks.md)
- [Channels and Control Flow](concurrency/async-control-flow.md)
  - [Async Channels](concurrency/async-control-flow/channels.md)
  - [Join](concurrency/async-control-flow/join.md)
  - [Select](concurrency/async-control-flow/select.md)
- [Pitfalls](concurrency/async-pitfalls.md)
  - [Blocking the Executor](concurrency/async-pitfalls/blocking-executor.md)
  - [`Pin`](concurrency/async-pitfalls/pin.md)
  - [Async Traits](concurrency/async-pitfalls/async-traits.md)
  - [Cancellation](concurrency/async-pitfalls/cancellation.md)
- [Exercises](concurrency/async-exercises.md)
  - [Dining Philosophers](concurrency/async-exercises/dining-philosophers.md)
  - [Broadcast Chat Application](concurrency/async-exercises/chat-app.md)
  - [Solutions](concurrency/async-exercises/solutions.md)

---

# Idiomatic Rust

- [Welcome](idiomatic/welcome.md)
- [Leveraging the Type System](idiomatic/leveraging-the-type-system.md)
  - [Newtype Pattern](idiomatic/leveraging-the-type-system/newtype-pattern.md)
    - [Semantic Confusion](idiomatic/leveraging-the-type-system/newtype-pattern/semantic-confusion.md)
    - [Parse, Don't Validate](idiomatic/leveraging-the-type-system/newtype-pattern/parse-don-t-validate.md)
    - [Is It Encapsulated?](idiomatic/leveraging-the-type-system/newtype-pattern/is-it-encapsulated.md)
  - [Typestate Pattern](idiomatic/leveraging-the-type-system/typestate-pattern.md)
    - [Typestate Pattern Example](idiomatic/leveraging-the-type-system/typestate-pattern/typestate-example.md)
    - [Beyond Simple Typestate](idiomatic/leveraging-the-type-system/typestate-pattern/typestate-advanced.md)
    - [Typestate Pattern with Generics](idiomatic/leveraging-the-type-system/typestate-pattern/typestate-generics.md)
      - [Serializer: implement Root](idiomatic/leveraging-the-type-system/typestate-pattern/typestate-generics/root.md)
      - [Serializer: implement Struct](idiomatic/leveraging-the-type-system/typestate-pattern/typestate-generics/struct.md)
      - [Serializer: implement Property](idiomatic/leveraging-the-type-system/typestate-pattern/typestate-generics/property.md)
      - [Serializer: Complete implementation](idiomatic/leveraging-the-type-system/typestate-pattern/typestate-generics/complete.md)

---

# Unsafe

- [Welcome](unsafe-deep-dive/welcome.md)
- [Setup](unsafe-deep-dive/setup.md)
- [Motivations](unsafe-deep-dive/motivations.md)
  - [Interoperability](unsafe-deep-dive/motivations/interop.md)
  - [Data Structures](unsafe-deep-dive/motivations/data-structures.md)
  - [Performance](unsafe-deep-dive/motivations/performance.md)
- [Foundations](unsafe-deep-dive/foundations.md)
  - [What is unsafe?](unsafe-deep-dive/foundations/what-is-unsafe.md)
  - [When is unsafe used?](unsafe-deep-dive/foundations/when-is-unsafe-used.md)
  - [Data structures are safe](unsafe-deep-dive/foundations/data-structures-are-safe.md)
  - [Actions might not be](unsafe-deep-dive/foundations/actions-might-not-be.md)
  - [Less powerful than it seems](unsafe-deep-dive/foundations/less-powerful.md)

---

# Final Words

- [Thanks!](thanks.md)
- [Glossary](glossary.md)
- [Other Resources](other-resources.md)
- [Credits](credits.md)



================================================
FILE: src/testing.md
================================================
# Testing

{{%segment outline}}



================================================
FILE: src/thanks.md
================================================
---
course: none
---

# Thanks!

_Thank you for taking Comprehensive Rust 🦀!_ We hope you enjoyed it and that it
was useful.

We've had a lot of fun putting the course together. The course is not perfect,
so if you spotted any mistakes or have ideas for improvements, please get in
[contact with us on GitHub](https://github.com/google/comprehensive-rust/discussions).
We would love to hear from you.

<details>

- Thank you for reading the speaker notes! We hope they have been useful. If you
  find pages without notes, please send us a PR and link it to [issue #1083]. We
  are also very grateful for fixes and improvements to the existing notes.

</details>

[issue #1083]: https://github.com/google/comprehensive-rust/issues/1083



================================================
FILE: src/tuples-and-arrays.md
================================================
# Tuples and Arrays

{{%segment outline}}

<details>

- We have seen how primitive types work in Rust. Now it's time for you to start
  building new composite types.

</details>



================================================
FILE: src/types-and-values.md
================================================
# Types and Values

{{%segment outline}}



================================================
FILE: src/unsafe-rust.md
================================================
# Unsafe Rust

{{%segment outline}}



================================================
FILE: src/user-defined-types.md
================================================
# User-Defined Types

{{%segment outline}}



================================================
FILE: src/welcome-day-1-afternoon.md
================================================
---
session: Day 1 Afternoon
target_minutes: 180
---

# Welcome Back

{{%session outline}}



================================================
FILE: src/welcome-day-1.md
================================================
---
minutes: 5
course: Fundamentals
session: Day 1 Morning
target_minutes: 180
---

# Welcome to Day 1

This is the first day of Rust Fundamentals. We will cover a lot of ground today:

- Basic Rust syntax: variables, scalar and compound types, enums, structs,
  references, functions, and methods.
- Types and type inference.
- Control flow constructs: loops, conditionals, and so on.
- User-defined types: structs and enums.

## Schedule

{{%session outline}}

<details>

Please remind the students that:

- They should ask questions when they get them, don't save them to the end.
- The class is meant to be interactive and discussions are very much encouraged!
  - As an instructor, you should try to keep the discussions relevant, i.e.,
    keep the discussions related to how Rust does things vs. some other
    language. It can be hard to find the right balance, but err on the side of
    allowing discussions since they engage people much more than one-way
    communication.
- The questions will likely mean that we talk about things ahead of the slides.
  - This is perfectly okay! Repetition is an important part of learning.
    Remember that the slides are just a support and you are free to skip them as
    you like.

The idea for the first day is to show the "basic" things in Rust that should
have immediate parallels in other languages. The more advanced parts of Rust
come on the subsequent days.

If you're teaching this in a classroom, this is a good place to go over the
schedule. Note that there is an exercise at the end of each segment, followed by
a break. Plan to cover the exercise solution after the break. The times listed
here are a suggestion in order to keep the course on schedule. Feel free to be
flexible and adjust as necessary!

</details>



================================================
FILE: src/welcome-day-2-afternoon.md
================================================
---
session: Day 2 Afternoon
target_minutes: 180
---

# Welcome Back

{{%session outline}}



================================================
FILE: src/welcome-day-2.md
================================================
---
minutes: 3
course: Fundamentals
session: Day 2 Morning
target_minutes: 180
---

# Welcome to Day 2

Now that we have seen a fair amount of Rust, today will focus on Rust's type
system:

- Pattern matching: extracting data from structures.
- Methods: associating functions with types.
- Traits: behaviors shared by multiple types.
- Generics: parameterizing types on other types.
- Standard library types and traits: a tour of Rust's rich standard library.
- Closures: function pointers with data.

## Schedule

{{%session outline}}



================================================
FILE: src/welcome-day-3-afternoon.md
================================================
---
session: Day 3 Afternoon
target_minutes: 180
---

# Welcome Back

{{%session outline}}



================================================
FILE: src/welcome-day-3.md
================================================
---
minutes: 3
course: Fundamentals
session: Day 3 Morning
target_minutes: 180
---

# Welcome to Day 3

Today, we will cover:

- Memory management, lifetimes, and the borrow checker: how Rust ensures memory
  safety.
- Smart pointers: standard library pointer types.

## Schedule

{{%session outline}}



================================================
FILE: src/welcome-day-4-afternoon.md
================================================
---
session: Day 4 Afternoon
target_minutes: 180
---

# Welcome Back

{{%session outline}}



================================================
FILE: src/welcome-day-4.md
================================================
---
minutes: 3
course: Fundamentals
session: Day 4 Morning
target_minutes: 180
---

# Welcome to Day 4

Today we will cover topics relating to building large-scale software in Rust:

- Iterators: a deep dive on the `Iterator` trait.
- Modules and visibility.
- Testing.
- Error handling: panics, `Result`, and the try operator `?`.
- Unsafe Rust: the escape hatch when you can't express yourself in safe Rust.

## Schedule

{{%session outline}}



================================================
FILE: src/android/aidl.md
================================================
# AIDL

Rust supports the
[Android Interface Definition Language (AIDL)](https://developer.android.com/guide/components/aidl):

- Rust code can call existing AIDL servers.
- You can create new AIDL servers in Rust.

<details>

- AIDL enables Android apps to interact with each other.

- Since Rust is a first-class citizen in this ecosystem, other processes on the
  device can call Rust services.

</details>



================================================
FILE: src/android/bpfmt.sh
================================================
#!/bin/zsh
# Copyright 2022 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Simple wrapper for bpfmt which will remove unnecessary newlines before the
# mdbook anchors.

if ! type bpfmt > /dev/null; then
  echo 'Can not find bpfmt, do you need to run "m bpfmt"?'
  exit 1
fi

for f in comprehensive_rust/**/Android.bp; do
  bpfmt -s -w $f
  sed -zi 's|\n// ANCHOR_END|// ANCHOR_END|g' $f
done



================================================
FILE: src/android/build-rules.md
================================================
# Build Rules

The Android build system (Soong) supports Rust through several modules:

| Module Type       | Description                                                                                        |
| ----------------- | -------------------------------------------------------------------------------------------------- |
| `rust_binary`     | Produces a Rust binary.                                                                            |
| `rust_library`    | Produces a Rust library, and provides both `rlib` and `dylib` variants.                            |
| `rust_ffi`        | Produces a Rust C library usable by `cc` modules, and provides both static and shared variants.    |
| `rust_proc_macro` | Produces a `proc-macro` Rust library. These are analogous to compiler plugins.                     |
| `rust_test`       | Produces a Rust test binary that uses the standard Rust test harness.                              |
| `rust_fuzz`       | Produces a Rust fuzz binary leveraging `libfuzzer`.                                                |
| `rust_protobuf`   | Generates source and produces a Rust library that provides an interface for a particular protobuf. |
| `rust_bindgen`    | Generates source and produces a Rust library containing Rust bindings to C libraries.              |

We will look at `rust_binary` and `rust_library` next.

<details>

Additional items the speaker may mention:

- Cargo is not optimized for multi-language repositories, and also downloads
  packages from the internet.

- For compliance and performance, Android must have crates in-tree. It must also
  interoperate with C/C++/Java code. Soong fills that gap.

- Soong has many similarities to [Bazel](https://bazel.build/), which is the
  open-source variant of Blaze (used in google3).

- Fun fact: Data from Star Trek is a Soong-type Android.

</details>



================================================
FILE: src/android/build_all.sh
================================================
#!/bin/bash
# Copyright 2022 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# How to use
#
# This script will build all the Android examples in the course. It
# does that with a series of
#
# m hello_rust
# m hello_rust_with_dep
#
# etc commands. The script must be executed from an AOSP checkout and
# you must already have a working `adb` setup.
#
# To make the new build targets visible to your AOSP checkout, you
# should either close the course repository into the AOSP checkout or
# you can use a bind mount:
#
# cd "$ANDROID_BUILD_TOP"
# mkdir comprehensive-rust
# sudo mount -o bind ../path/to/comprehensive-rust/src comprehensive-rust
#
# This will let `m` see all the new build targets, try `m hello_rust`
# by hand to verify.
#
# Make sure to add commands to execute new Android.bp files here. This
# way we have a chance to fight bit-rot by automatically executing the
# build commands once in a while (executing them in GitHub CI seems
# hard since an AOSP checkout is huge).

set -e

function run_example() {
  while read -r line; do
    if [[ "$line" != \#* ]]; then
      echo "$line"
      eval "${line#$ }"
    fi
  done
}

cd "$ANDROID_BUILD_TOP"
source build/envsetup.sh
lunch aosp_cf_x86_64_phone-userdebug
#acloud reconnect --autoconnect adb

adb shell rm -rf '/data/local/tmp/*'

run_example <<EOF
# ANCHOR: hello_rust
m hello_rust
adb push "$ANDROID_PRODUCT_OUT/system/bin/hello_rust" /data/local/tmp
adb shell /data/local/tmp/hello_rust
# ANCHOR_END: hello_rust
EOF

run_example <<EOF
# ANCHOR: hello_rust_with_dep
m hello_rust_with_dep
adb push "$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep" /data/local/tmp
adb shell /data/local/tmp/hello_rust_with_dep
# ANCHOR_END: hello_rust_with_dep
EOF

function birthday_server() {
  run_example <<EOF
# ANCHOR: birthday_server
m birthday_server
adb push "$ANDROID_PRODUCT_OUT/system/bin/birthday_server" /data/local/tmp
adb root
adb shell /data/local/tmp/birthday_server
# ANCHOR_END: birthday_server
EOF
}

pkill -f birthday_server || true
birthday_server &
BIRTHDAY_SERVER_PID=$!

while adb shell service check birthdayservice | grep -q 'not found'; do
  echo "Waiting on birthdayservice..."
  sleep 3
done
echo "Found birthdayservice..."

run_example <<EOF
# ANCHOR: service_check_birthday_server
adb shell service check birthdayservice
# ANCHOR_END: service_check_birthday_server
EOF

run_example <<EOF
# ANCHOR: service_call_birthday_server
adb shell service call birthdayservice 1 s16 Bob i32 24
# ANCHOR_END: service_call_birthday_server
EOF

run_example <<EOF
# ANCHOR: birthday_client
m birthday_client
adb push "$ANDROID_PRODUCT_OUT/system/bin/birthday_client" /data/local/tmp
adb shell /data/local/tmp/birthday_client Charlie 60
# ANCHOR_END: birthday_client
EOF

pkill -f birthday_server

run_example <<EOF
# ANCHOR: libleftpad_test
atest --host libleftpad_test
# ANCHOR_END: libleftpad_test
EOF

run_example <<EOF
# ANCHOR: hello_rust_logs
m hello_rust_logs
adb push "$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs" /data/local/tmp
adb shell /data/local/tmp/hello_rust_logs
# ANCHOR_END: hello_rust_logs
EOF

run_example <<EOF
# ANCHOR: print_birthday_card
m print_birthday_card
adb push "$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card" /data/local/tmp
adb shell /data/local/tmp/print_birthday_card
# ANCHOR_END: print_birthday_card
EOF

run_example <<EOF
# ANCHOR: libbirthday_bindgen_test
atest libbirthday_bindgen_test
# ANCHOR_END: libbirthday_bindgen_test
EOF

run_example <<EOF
# ANCHOR: analyze_numbers
m analyze_numbers
adb push "$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers" /data/local/tmp
adb shell /data/local/tmp/analyze_numbers
# ANCHOR_END: analyze_numbers
EOF

run_example <<EOF
# ANCHOR: helloworld_jni
m helloworld_jni
adb sync  # requires adb root && adb remount
adb shell /system/bin/helloworld_jni
# ANCHOR_END: helloworld_jni
EOF



================================================
FILE: src/android/interoperability.md
================================================
# Interoperability

Rust has excellent support for interoperability with other languages. This means
that you can:

- Call Rust functions from other languages.
- Call functions written in other languages from Rust.

When you call functions in a foreign language, you're using a _foreign function
interface_, also known as FFI.

<details>

- This is a key ability of Rust: compiled code becomes indistinguishable from
  compiled C or C++ code.

- Technically, we say that Rust can be compiled to the same [ABI] (application
  binary interface) as C code.

</details>

[ABI]: https://en.wikipedia.org/wiki/Application_binary_interface



================================================
FILE: src/android/logging.md
================================================
# Logging

You should use the `log` crate to automatically log to `logcat` (on-device) or
`stdout` (on-host):

_hello_rust_logs/Android.bp_:

```javascript
{{#include logging/Android.bp}}
```

_hello_rust_logs/src/main.rs_:

```rust,ignore
{{#include logging/src/main.rs:main}}
```

Build, push, and run the binary on your device:

```shell
{{#include build_all.sh:hello_rust_logs}}
```

The logs show up in `adb logcat`:

```shell
adb logcat -s rust
```

```text
09-08 08:38:32.454  2420  2420 D rust: hello_rust_logs: Starting program.
09-08 08:38:32.454  2420  2420 I rust: hello_rust_logs: Things are going fine.
09-08 08:38:32.454  2420  2420 E rust: hello_rust_logs: Something went wrong!
```

<details>

- The logger implementation in `liblogger` is only needed in the final binary,
  if you're logging from a library you only need the `log` facade crate.

</details>



================================================
FILE: src/android/setup.md
================================================
# Setup

We will be using a Cuttlefish Android Virtual Device to test our code. Make sure
you have access to one or create a new one with:

```shell
source build/envsetup.sh
lunch aosp_cf_x86_64_phone-trunk_staging-userdebug
acloud create
```

Please see the
[Android Developer Codelab](https://source.android.com/docs/setup/start) for
details.

The code on the following pages can be found in the
[`src/android/` directory](https://github.com/google/comprehensive-rust/tree/main/src/android)
of the course material. Please `git clone` the repository to follow along.

<details>

Key points:

- Cuttlefish is a reference Android device designed to work on generic Linux
  desktops. MacOS support is also planned.

- The Cuttlefish system image maintains high fidelity to real devices, and is
  the ideal emulator to run many Rust use cases.

</details>



================================================
FILE: src/android/testing.md
================================================
# Testing in Android

Building on [Testing](../testing.md), we will now look at how unit tests work in
AOSP. Use the `rust_test` module for your unit tests:

_testing/Android.bp_:

```javascript
{{#include testing/Android.bp}}
```

_testing/src/lib.rs_:

```rust
{{#include testing/src/lib.rs:leftpad}}
```

You can now run the test with

```shell
{{#include build_all.sh:libleftpad_test}}
```

The output looks like this:

```text
INFO: Elapsed time: 2.666s, Critical Path: 2.40s
INFO: 3 processes: 2 internal, 1 linux-sandbox.
INFO: Build completed successfully, 3 total actions
//comprehensive-rust-android/testing:libleftpad_test_host            PASSED in 2.3s
    PASSED  libleftpad_test.tests::long_string (0.0s)
    PASSED  libleftpad_test.tests::short_string (0.0s)
Test cases: finished with 2 passing and 0 failing out of 2 test cases
```

Notice how you only mention the root of the library crate. Tests are found
recursively in nested modules.



================================================
FILE: src/android/aidl/birthday-service.md
================================================
# Birthday Service Tutorial

To illustrate using Rust with Binder, we will create a Binder interface. Then,
we'll implement the service and write a client that talks to it.



================================================
FILE: src/android/aidl/types.md
================================================
# Working With AIDL Types

AIDL types translate into the appropriate idiomatic Rust type:

- Primitive types map (mostly) to idiomatic Rust types.
- Collection types like slices, `Vec`s and string types are supported.
- References to AIDL objects and file handles can be sent between clients and
  services.
- File handles and parcelables are fully supported.



================================================
FILE: src/android/aidl/birthday_service/Android.bp
================================================
// ANCHOR: libbirthdayservice
rust_library {
    name: "libbirthdayservice",
    crate_name: "birthdayservice",
    srcs: ["src/lib.rs"],
    rustlibs: [
        "com.example.birthdayservice-rust",
    ],
}
// ANCHOR_END: libbirthdayservice

// ANCHOR: birthday_server
rust_binary {
    name: "birthday_server",
    crate_name: "birthday_server",
    srcs: ["src/server.rs"],
    rustlibs: [
        "com.example.birthdayservice-rust",
        "libbirthdayservice",
    ],
    prefer_rlib: true, // To avoid dynamic link error.
}
// ANCHOR_END: birthday_server

// ANCHOR: birthday_client
rust_binary {
    name: "birthday_client",
    crate_name: "birthday_client",
    srcs: ["src/client.rs"],
    rustlibs: [
        "com.example.birthdayservice-rust",
    ],
    prefer_rlib: true, // To avoid dynamic link error.
}
// ANCHOR_END: birthday_client



================================================
FILE: src/android/aidl/birthday_service/aidl/Android.bp
================================================
aidl_interface {
    name: "com.example.birthdayservice",
    srcs: ["com/example/birthdayservice/*.aidl"],
    unstable: true,
    backend: {
        rust: { // Rust is not enabled by default
            enabled: true,
        },
    },
}



================================================
FILE: src/android/aidl/birthday_service/aidl/com/example/birthdayservice/BirthdayInfo.aidl
================================================
package com.example.birthdayservice;

parcelable BirthdayInfo {
    String name;
    int years;
}



================================================
FILE: src/android/aidl/birthday_service/aidl/com/example/birthdayservice/IBirthdayInfoProvider.aidl
================================================
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: IBirthdayInfoProvider
package com.example.birthdayservice;

interface IBirthdayInfoProvider {
    String name();
    int years();
}



================================================
FILE: src/android/aidl/birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: package
package com.example.birthdayservice;
// ANCHOR_END: package

import com.example.birthdayservice.IBirthdayInfoProvider;
import com.example.birthdayservice.BirthdayInfo;

// ANCHOR: IBirthdayService
/** Birthday service interface. */
interface IBirthdayService {
    /** Generate a Happy Birthday message. */
    String wishHappyBirthday(String name, int years);
    // ANCHOR_END: IBirthdayService

    // ANCHOR: with_info
    /** The same thing, but with a parcelable. */
    String wishWithInfo(in BirthdayInfo info);
    // ANCHOR_END: with_info

    // ANCHOR: with_info_provider
    /** The same thing, but using a binder object. */
    String wishWithProvider(IBirthdayInfoProvider provider);

    /** The same thing, but using `IBinder`. */
    String wishWithErasedProvider(IBinder provider);
    // ANCHOR_END: with_info_provider

    // ANCHOR: with_file
    /** The same thing, but loads info from a file. */
    String wishFromFile(in ParcelFileDescriptor infoFile);
    // ANCHOR_END: with_file
}



================================================
FILE: src/android/aidl/birthday_service/src/client.rs
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Birthday service.
use com_example_birthdayservice::aidl::com::example::birthdayservice::BirthdayInfo::BirthdayInfo;
use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayInfoProvider::{
    BnBirthdayInfoProvider, IBirthdayInfoProvider,
};
use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;
use com_example_birthdayservice::binder::{self, BinderFeatures, ParcelFileDescriptor};
use std::error::Error;
use std::fs::File;
use std::io::prelude::*;

// ANCHOR: main
const SERVICE_IDENTIFIER: &str = "birthdayservice";

/// Call the birthday service.
fn main() -> Result<(), Box<dyn Error>> {
    let name = std::env::args().nth(1).unwrap_or_else(|| String::from("Bob"));
    let years = std::env::args()
        .nth(2)
        .and_then(|arg| arg.parse::<i32>().ok())
        .unwrap_or(42);

    binder::ProcessState::start_thread_pool();
    let service = binder::get_interface::<dyn IBirthdayService>(SERVICE_IDENTIFIER)
        .map_err(|_| "Failed to connect to BirthdayService")?;

    // Call the service.
    let msg = service.wishHappyBirthday(&name, years)?;
    println!("{msg}");
    // ANCHOR_END: main

    service.wishWithInfo(&BirthdayInfo { name: name.clone(), years })?;

    // ANCHOR: wish_with_provider

    // Create a binder object for the `IBirthdayInfoProvider` interface.
    let provider = BnBirthdayInfoProvider::new_binder(
        InfoProvider { name: name.clone(), age: years as u8 },
        BinderFeatures::default(),
    );

    // Send the binder object to the service.
    service.wishWithProvider(&provider)?;

    // Perform the same operation but passing the provider as an `SpIBinder`.
    service.wishWithErasedProvider(&provider.as_binder())?;
    // ANCHOR_END: wish_with_provider

    // ANCHOR: wish_with_file

    // Open a file and put the birthday info in it.
    let mut file = File::create("/data/local/tmp/birthday.info").unwrap();
    writeln!(file, "{name}")?;
    writeln!(file, "{years}")?;

    // Create a `ParcelFileDescriptor` from the file and send it.
    let file = ParcelFileDescriptor::new(file);
    service.wishFromFile(&file)?;
    // ANCHOR_END: wish_with_file

    Ok(())
}

// ANCHOR: InfoProvider
/// Rust struct implementing the `IBirthdayInfoProvider` interface.
struct InfoProvider {
    name: String,
    age: u8,
}

impl binder::Interface for InfoProvider {}

impl IBirthdayInfoProvider for InfoProvider {
    fn name(&self) -> binder::Result<String> {
        Ok(self.name.clone())
    }

    fn years(&self) -> binder::Result<i32> {
        Ok(self.age as i32)
    }
}
// ANCHOR_END: InfoProvider



================================================
FILE: src/android/aidl/birthday_service/src/lib.rs
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Implementation of the `IBirthdayService` AIDL interface.
use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayInfoProvider::IBirthdayInfoProvider;
use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;
use com_example_birthdayservice::aidl::com::example::birthdayservice::BirthdayInfo::BirthdayInfo;
use com_example_birthdayservice::binder::{self, ParcelFileDescriptor, SpIBinder, Strong};
use std::fs::File;
use std::io::Read;

// ANCHOR: IBirthdayService
/// The `IBirthdayService` implementation.
pub struct BirthdayService;

impl binder::Interface for BirthdayService {}

impl IBirthdayService for BirthdayService {
    fn wishHappyBirthday(&self, name: &str, years: i32) -> binder::Result<String> {
        Ok(format!("Happy Birthday {name}, congratulations with the {years} years!"))
    }
    // ANCHOR_END: IBirthdayService

    fn wishWithInfo(&self, info: &BirthdayInfo) -> binder::Result<String> {
        Ok(format!(
            "Happy Birthday {}, congratulations with the {} years!",
            info.name, info.years,
        ))
    }

    fn wishWithProvider(
        &self,
        provider: &Strong<dyn IBirthdayInfoProvider>,
    ) -> binder::Result<String> {
        Ok(format!(
            "Happy Birthday {}, congratulations with the {} years!",
            provider.name()?,
            provider.years()?,
        ))
    }

    fn wishWithErasedProvider(
        &self,
        provider: &SpIBinder,
    ) -> binder::Result<String> {
        // Convert the `SpIBinder` to a concrete interface.
        let provider =
            provider.clone().into_interface::<dyn IBirthdayInfoProvider>()?;

        Ok(format!(
            "Happy Birthday {}, congratulations with the {} years!",
            provider.name()?,
            provider.years()?,
        ))
    }

    // ANCHOR: wishFromFile
    fn wishFromFile(
        &self,
        info_file: &ParcelFileDescriptor,
    ) -> binder::Result<String> {
        // Convert the file descriptor to a `File`. `ParcelFileDescriptor` wraps
        // an `OwnedFd`, which can be cloned and then used to create a `File`
        // object.
        let mut info_file = info_file
            .as_ref()
            .try_clone()
            .map(File::from)
            .expect("Invalid file handle");

        let mut contents = String::new();
        info_file.read_to_string(&mut contents).unwrap();

        let mut lines = contents.lines();
        let name = lines.next().unwrap();
        let years: i32 = lines.next().unwrap().parse().unwrap();

        Ok(format!("Happy Birthday {name}, congratulations with the {years} years!"))
    }
    // ANCHOR_END: wishFromFile
}



================================================
FILE: src/android/aidl/birthday_service/src/server.rs
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: main
//! Birthday service.
use birthdayservice::BirthdayService;
use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::BnBirthdayService;
use com_example_birthdayservice::binder;

const SERVICE_IDENTIFIER: &str = "birthdayservice";

/// Entry point for birthday service.
fn main() {
    let birthday_service = BirthdayService;
    let birthday_service_binder = BnBirthdayService::new_binder(
        birthday_service,
        binder::BinderFeatures::default(),
    );
    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder.as_binder())
        .expect("Failed to register service");
    binder::ProcessState::join_thread_pool();
}



================================================
FILE: src/android/aidl/example-service/changing-definition.md
================================================
# Changing API

Let's extend the API: we'll let clients specify a list of lines for the birthday
card:

```java
package com.example.birthdayservice;

/** Birthday service interface. */
interface IBirthdayService {
    /** Generate a Happy Birthday message. */
    String wishHappyBirthday(String name, int years, in String[] text);
}
```

This results in an updated trait definition for `IBirthdayService`:

```rust,ignore
trait IBirthdayService {
    fn wishHappyBirthday(
        &self,
        name: &str,
        years: i32,
        text: &[String],
    ) -> binder::Result<String>;
}
```

<details>

- Note how the `String[]` in the AIDL definition is translated as a `&[String]`
  in Rust, i.e. that idiomatic Rust types are used in the generated bindings
  wherever possible:
  - `in` array arguments are translated to slices.
  - `out` and `inout` args are translated to `&mut Vec<T>`.
  - Return values are translated to returning a `Vec<T>`.

</details>



================================================
FILE: src/android/aidl/example-service/changing-implementation.md
================================================
# Updating Client and Service

Update the client and server code to account for the new API.

_birthday_service/src/lib.rs_:

```rust,ignore
impl IBirthdayService for BirthdayService {
    fn wishHappyBirthday(
        &self,
        name: &str,
        years: i32,
        text: &[String],
    ) -> binder::Result<String> {
        let mut msg = format!(
            "Happy Birthday {name}, congratulations with the {years} years!",
        );

        for line in text {
            msg.push('\n');
            msg.push_str(line);
        }

        Ok(msg)
    }
}
```

_birthday_service/src/client.rs_:

```rust,ignore
let msg = service.wishHappyBirthday(
    &name,
    years,
    &[
        String::from("Habby birfday to yuuuuu"),
        String::from("And also: many more"),
    ],
)?;
```

<details>

- TODO: Move code snippets into project files where they'll actually be built?

</details>



================================================
FILE: src/android/aidl/example-service/client.md
================================================
# AIDL Client

Finally, we can create a Rust client for our new service.

_birthday_service/src/client.rs_:

```rust,ignore
use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;
use com_example_birthdayservice::binder;

{{#include ../birthday_service/src/client.rs:main}}
}
```

_birthday_service/Android.bp_:

```javascript
{{#include ../birthday_service/Android.bp:birthday_client}}
```

Notice that the client does not depend on `libbirthdayservice`.

Build, push, and run the client on your device:

```shell
{{#include ../../build_all.sh:birthday_client}}
```

```text
Happy Birthday Charlie, congratulations with the 60 years!
```

<details>

- `Strong<dyn IBirthdayService>` is the trait object representing the service
  that the client has connected to.
  - `Strong` is a custom smart pointer type for Binder. It handles both an
    in-process ref count for the service trait object, and the global Binder ref
    count that tracks how many processes have a reference to the object.
  - Note that the trait object that the client uses to talk to the service uses
    the exact same trait that the server implements. For a given Binder
    interface, there is a single Rust trait generated that both client and
    server use.
- Use the same service identifier used when registering the service. This should
  ideally be defined in a common crate that both the client and server can
  depend on.

</details>



================================================
FILE: src/android/aidl/example-service/deploy.md
================================================
# Deploy

We can now build, push, and start the service:

```shell
{{#include ../../build_all.sh:birthday_server}}
```

In another terminal, check that the service runs:

```shell
{{#include ../../build_all.sh:service_check_birthday_server}}
```

```text
Service birthdayservice: found
```

You can also call the service with `service call`:

```shell
{{#include ../../build_all.sh:service_call_birthday_server}}
```

```text
Result: Parcel(
  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'
  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'
  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'
  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'
  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'
  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .t.h.e.'
  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'
  0x00000070: 00210073 00000000                   's.!.....        ')
```



================================================
FILE: src/android/aidl/example-service/implementation.md
================================================
# Implementation



================================================
FILE: src/android/aidl/example-service/interface.md
================================================
# AIDL Interfaces

You declare the API of your service using an AIDL interface:

_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:

```java
{{#include ../birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl:package}}

{{#include ../birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl:IBirthdayService}}
}
```

_birthday_service/aidl/Android.bp_:

```javascript
{{#include ../birthday_service/aidl/Android.bp}}
```

<details>

- Note that the directory structure under the `aidl/` directory needs to match
  the package name used in the AIDL file, i.e. the package is
  `com.example.birthdayservice` and the file is at
  `aidl/com/example/IBirthdayService.aidl`.

</details>



================================================
FILE: src/android/aidl/example-service/server.md
================================================
# AIDL Server

Finally, we can create a server which exposes the service:

_birthday_service/src/server.rs_:

```rust,ignore
{{#include ../birthday_service/src/server.rs:main}}
```

_birthday_service/Android.bp_:

```javascript
{{#include ../birthday_service/Android.bp:birthday_server}}
```

<details>

The process for taking a user-defined service implementation (in this case, the
`BirthdayService` type, which implements the `IBirthdayService`) and starting it
as a Binder service has multiple steps. This may appear more complicated than
students are used to if they've used Binder from C++ or another language.
Explain to students why each step is necessary.

1. Create an instance of your service type (`BirthdayService`).
2. Wrap the service object in the corresponding `Bn*` type (`BnBirthdayService`
   in this case). This type is generated by Binder and provides common Binder
   functionality, similar to the `BnBinder` base class in C++. Since Rust
   doesn't have inheritance, we use composition, putting our `BirthdayService`
   within the generated `BnBinderService`.
3. Call `add_service`, giving it a service identifier and your service object
   (the `BnBirthdayService` object in the example).
4. Call `join_thread_pool` to add the current thread to Binder's thread pool and
   start listening for connections.

</details>



================================================
FILE: src/android/aidl/example-service/service-bindings.md
================================================
# Generated Service API

Binder generates a trait for each interface definition.

_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:

```java
{{#include ../birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl:IBirthdayService}}
}
```

_out/soong/.intermediates/.../com_example_birthdayservice.rs_:

<!-- The example below is a cleaned up and simplified version of the real code. -->

```rust,ignore
trait IBirthdayService {
    fn wishHappyBirthday(&self, name: &str, years: i32) -> binder::Result<String>;
}
```

Your service will need to implement this trait, and your client will use this
trait to talk to the service.

<details>

- Point out how the generated function signature, specifically the argument and
  return types, correspond to the interface definition.
  - `String` for an argument results in a different Rust type than `String` as a
    return type.

</details>



================================================
FILE: src/android/aidl/example-service/service.md
================================================
# Service Implementation

We can now implement the AIDL service:

_birthday_service/src/lib.rs_:

```rust,ignore
//! Implementation of the `IBirthdayService` AIDL interface.
use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;
use com_example_birthdayservice::binder;

{{#include ../birthday_service/src/lib.rs:IBirthdayService}}
}
```

_birthday_service/Android.bp_:

```javascript
{{#include ../birthday_service/Android.bp:libbirthdayservice}}
```

<details>

- Point out the path to the generated `IBirthdayService` trait, and explain why
  each of the segments is necessary.
- Note that `wishHappyBirthday` and other AIDL IPC methods take `&self` (instead
  of `&mut self`).
  - This is necessary because Binder responds to incoming requests on a thread
    pool, allowing for multiple requests to be processed in parallel. This
    requires that the service methods only get a shared reference to `self`.
  - Any state that needs to be modified by the service will have to be put in
    something like a `Mutex` to allow for safe mutation.
  - The correct approach for managing service state depends heavily on the
    details of your service.
- TODO: What does the `binder::Interface` trait do? Are there methods to
  override? Where is the source?

</details>



================================================
FILE: src/android/aidl/types/arrays.md
================================================
# Array Types

The array types (`T[]`, `byte[]`, and `List<T>`) are translated to the
appropriate Rust array type depending on how they are used in the function
signature:

| Position               | Rust Type     |
| ---------------------- | ------------- |
| `in` argument          | `&[T]`        |
| `out`/`inout` argument | `&mut Vec<T>` |
| Return                 | `Vec<T>`      |

<details>

- In Android 13 or higher, fixed-size arrays are supported, i.e. `T[N]` becomes
  `[T; N]`. Fixed-size arrays can have multiple dimensions (e.g. `int[3][4]`).
  In the Java backend, fixed-size arrays are represented as array types.
- Arrays in parcelable fields always get translated to `Vec<T>`.

</details>



================================================
FILE: src/android/aidl/types/file-descriptor.md
================================================
# Sending Files

Files can be sent between Binder clients/servers using the
`ParcelFileDescriptor` type:

_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:

```java
interface IBirthdayService {
{{#include ../birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl:with_file}}
}
```

_birthday_service/src/client.rs_:

```rust,ignore
fn main() {
    binder::ProcessState::start_thread_pool();
    let service = connect().expect("Failed to connect to BirthdayService");
{{#include ../birthday_service/src/client.rs:wish_with_file}}
}
```

_birthday_service/src/lib.rs_:

```rust,ignore
impl IBirthdayService for BirthdayService {
{{#include ../birthday_service/src/lib.rs:wishFromFile}}
}
```

<details>

- `ParcelFileDescriptor` wraps an `OwnedFd`, and so can be created from a `File`
  (or any other type that wraps an `OwnedFd`), and can be used to create a new
  `File` handle on the other side.
- Other types of file descriptors can be wrapped and sent, e.g. TCP, UDP, and
  UNIX sockets.

</details>



================================================
FILE: src/android/aidl/types/objects.md
================================================
# Sending Objects

AIDL objects can be sent either as a concrete AIDL type or as the type-erased
`IBinder` interface:

_birthday_service/aidl/com/example/birthdayservice/IBirthdayInfoProvider.aidl_:

```java
{{#include ../birthday_service/aidl/com/example/birthdayservice/IBirthdayInfoProvider.aidl:IBirthdayInfoProvider}}
```

_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:

```java
import com.example.birthdayservice.IBirthdayInfoProvider;

interface IBirthdayService {
{{#include ../birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl:with_info_provider}}
}
```

_birthday_service/src/client.rs_:

```rust,ignore
{{#include ../birthday_service/src/client.rs:InfoProvider}}

fn main() {
    binder::ProcessState::start_thread_pool();
    let service = connect().expect("Failed to connect to BirthdayService");
{{#include ../birthday_service/src/client.rs:wish_with_provider}}
}
```

<details>

- Note the usage of `BnBirthdayInfoProvider`. This serves the same purpose as
  `BnBirthdayService` that we saw previously.

</details>



================================================
FILE: src/android/aidl/types/parcelables.md
================================================
# Parcelables

Binder for Rust supports sending parcelables directly:

_birthday_service/aidl/com/example/birthdayservice/BirthdayInfo.aidl_:

```java
{{#include ../birthday_service/aidl/com/example/birthdayservice/BirthdayInfo.aidl}}
```

_birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl_:

```java
import com.example.birthdayservice.BirthdayInfo;

interface IBirthdayService {
{{#include ../birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl:with_info}}
}
```

_birthday_service/src/client.rs_:

```rust,ignore
fn main() {
    binder::ProcessState::start_thread_pool();
    let service = connect().expect("Failed to connect to BirthdayService");

    let info = BirthdayInfo { name: "Alice".into(), years: 123 };
    service.wishWithInfo(&info)?;
}
```



================================================
FILE: src/android/aidl/types/primitives.md
================================================
# Primitive Types

Primitive types map (mostly) idiomatically:

| AIDL Type | Rust Type | Note                                |
| --------- | --------- | ----------------------------------- |
| `boolean` | `bool`    |                                     |
| `byte`    | `i8`      | Note that bytes are signed.         |
| `char`    | `u16`     | Note the usage of `u16`, NOT `u32`. |
| `int`     | `i32`     |                                     |
| `long`    | `i64`     |                                     |
| `float`   | `f32`     |                                     |
| `double`  | `f64`     |                                     |
| `String`  | `String`  |                                     |



================================================
FILE: src/android/build-rules/binary.md
================================================
# Rust Binaries

Let's start with a simple application. At the root of an AOSP checkout, create
the following files:

_hello_rust/Android.bp_:

```javascript
{{#include binary/Android.bp}}
```

_hello_rust/src/main.rs_:

```rust
{{#include binary/src/main.rs:main}}
```

You can now build, push, and run the binary:

```shell
{{#include ../build_all.sh:hello_rust}}
```

```text
Hello from Rust!
```

<details>

- Go through the build steps and demonstrate them running in your emulator.

- Notice the extensive documentation comments? The Android build rules enforce
  that all modules have documentation. Try removing it and see what error you
  get.

- Stress that the Rust build rules look like the other Soong rules. This is by
  design, to make using Rust as easy as C++ or Java.

</details>



================================================
FILE: src/android/build-rules/library.md
================================================
# Rust Libraries

You use `rust_library` to create a new Rust library for Android.

Here we declare a dependency on two libraries:

- `libgreeting`, which we define below,
- `libtextwrap`, which is a crate already vendored in
  [`external/rust/android-crates-io/crates/`][crates].

[crates]: https://cs.android.com/android/platform/superproject/main/+/main:external/rust/android-crates-io/crates/

_hello_rust/Android.bp_:

```javascript
{{#include library/Android.bp}}
```

_hello_rust/src/main.rs_:

```rust,ignore
{{#include library/src/main.rs:main}}
```

_hello_rust/src/lib.rs_:

```rust,ignore
{{#include library/src/lib.rs:greeting}}
```

You build, push, and run the binary like before:

```shell
{{#include ../build_all.sh:hello_rust_with_dep}}
```

```text
Hello Bob, it is very
nice to meet you!
```

<details>

- Go through the build steps and demonstrate them running in your emulator.

- A Rust crate named `greetings` must be built by a rule called `libgreetings`.
  Note how the Rust code uses the crate name, as is normal in Rust.

- Again, the build rules enforce that we add documentation comments to all
  public items.

</details>



================================================
FILE: src/android/build-rules/binary/Android.bp
================================================
rust_binary {
    name: "hello_rust",
    crate_name: "hello_rust",
    srcs: ["src/main.rs"],
}



================================================
FILE: src/android/build-rules/binary/src/main.rs
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: main
//! Rust demo.

/// Prints a greeting to standard output.
fn main() {
    println!("Hello from Rust!");
}



================================================
FILE: src/android/build-rules/library/Android.bp
================================================
rust_binary {
    name: "hello_rust_with_dep",
    crate_name: "hello_rust_with_dep",
    srcs: ["src/main.rs"],
    rustlibs: [
        "libgreetings",
        "libtextwrap",
    ],
    prefer_rlib: true, // Need this to avoid dynamic link error.
}

rust_library {
    name: "libgreetings",
    crate_name: "greetings",
    srcs: ["src/lib.rs"],
}



================================================
FILE: src/android/build-rules/library/src/lib.rs
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: greeting
//! Greeting library.

/// Greet `name`.
pub fn greeting(name: &str) -> String {
    format!("Hello {name}, it is very nice to meet you!")
}



================================================
FILE: src/android/build-rules/library/src/main.rs
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: main
//! Rust demo.

use greetings::greeting;
use textwrap::fill;

/// Prints a greeting to standard output.
fn main() {
    println!("{}", fill(&greeting("Bob"), 24));
}



================================================
FILE: src/android/interoperability/cpp.md
================================================
# With C++

The [CXX crate][1] enables safe interoperability between Rust and C++.

The overall approach looks like this:

<img src="cpp/overview.svg">

[1]: https://cxx.rs/



================================================
FILE: src/android/interoperability/java.md
================================================
# Interoperability with Java

Java can load shared objects via
[Java Native Interface (JNI)](https://en.wikipedia.org/wiki/Java_Native_Interface).
The [`jni` crate](https://docs.rs/jni/) allows you to create a compatible
library.

First, we create a Rust function to export to Java:

_interoperability/java/src/lib.rs_:

```rust,compile_fail
{{#include java/src/lib.rs:hello}}
```

_interoperability/java/Android.bp_:

```javascript
{{#include java/Android.bp:libhello_jni}}
```

We then call this function from Java:

_interoperability/java/HelloWorld.java_:

```java
{{#include java/HelloWorld.java:HelloWorld}}
```

_interoperability/java/Android.bp_:

```javascript
{{#include java/Android.bp:helloworld_jni}}
```

Finally, you can build, sync, and run the binary:

```shell
{{#include ../build_all.sh:helloworld_jni}}
```

<details>

- The `unsafe(no_mangle)` attribute instructs Rust to emit the
  `Java_HelloWorld_hello` symbol exactly as written. This is important so that
  Java can recognize the symbol as a `hello` method on the `HelloWorld` class.

  - By default, Rust will mangle (rename) symbols so that a binary can link in
    two versions of the same Rust crate.

</details>



================================================
FILE: src/android/interoperability/with-c.md
================================================
# Interoperability with C

Rust has full support for linking object files with a C calling convention.
Similarly, you can export Rust functions and call them from C.

You can do it by hand if you want:

```rust
unsafe extern "C" {
    safe fn abs(x: i32) -> i32;
}

fn main() {
    let x = -42;
    let abs_x = abs(x);
    println!("{x}, {abs_x}");
}
```

We already saw this in the
[Safe FFI Wrapper exercise](../../unsafe-rust/exercise.md).

> This assumes full knowledge of the target platform. Not recommended for
> production.

We will look at better options next.

<details>

- The [`"C"` part][extern-abi] of the `extern` block tells Rust that `abs` can
  be called using the C [ABI] (application binary interface).

- The `safe fn abs` part tells Rust that `abs` is a safe function. By default,
  extern functions are unsafe, but since `abs(x)` can't trigger undefined
  behavior with any `x`, we can declare it safe.

</details>

[extern-abi]: https://doc.rust-lang.org/reference/items/external-blocks.html#abi
[ABI]: https://en.wikipedia.org/wiki/Application_binary_interface



================================================
FILE: src/android/interoperability/cpp/android-build-cpp.md
================================================
# Building in Android

Create a `cc_library_static` to build the C++ library, including the CXX
generated header and source file.

```javascript
cc_library_static {
    name: "libcxx_test_cpp",
    srcs: ["cxx_test.cpp"],
    generated_headers: [
        "cxx-bridge-header",
        "libcxx_test_bridge_header"
    ],
    generated_sources: ["libcxx_test_bridge_code"],
}
```

<details>

- Point out that `libcxx_test_bridge_header` and `libcxx_test_bridge_code` are
  the dependencies for the CXX-generated C++ bindings. We'll show how these are
  setup on the next slide.
- Note that you also need to depend on the `cxx-bridge-header` library in order
  to pull in common CXX definitions.
- Full docs for using CXX in Android can be found in [the Android docs]. You may
  want to share that link with the class so that students know where they can
  find these instructions again in the future.

[the Android docs]: https://source.android.com/docs/setup/build/rust/building-rust-modules/android-rust-patterns#rust-cpp-interop-using-cxx

</details>



================================================
FILE: src/android/interoperability/cpp/android-build-rust.md
================================================
# Building in Android

Create a `rust_binary` that depends on `libcxx` and your `cc_library_static`.

```javascript
rust_binary {
    name: "cxx_test",
    srcs: ["lib.rs"],
    rustlibs: ["libcxx"],
    static_libs: ["libcxx_test_cpp"],
}
```



================================================
FILE: src/android/interoperability/cpp/android-cpp-genrules.md
================================================
# Building in Android

Create two genrules: One to generate the CXX header, and one to generate the CXX
source file. These are then used as inputs to the `cc_library_static`.

```javascript
// Generate a C++ header containing the C++ bindings
// to the Rust exported functions in lib.rs.
genrule {
    name: "libcxx_test_bridge_header",
    tools: ["cxxbridge"],
    cmd: "$(location cxxbridge) $(in) --header > $(out)",
    srcs: ["lib.rs"],
    out: ["lib.rs.h"],
}

// Generate the C++ code that Rust calls into.
genrule {
    name: "libcxx_test_bridge_code",
    tools: ["cxxbridge"],
    cmd: "$(location cxxbridge) $(in) > $(out)",
    srcs: ["lib.rs"],
    out: ["lib.rs.cc"],
}
```

<details>

- The `cxxbridge` tool is a standalone tool that generates the C++ side of the
  bridge module. It is included in Android and available as a Soong tool.
- By convention, if your Rust source file is `lib.rs` your header file will be
  named `lib.rs.h` and your source file will be named `lib.rs.cc`. This naming
  convention isn't enforced, though.

</details>



================================================
FILE: src/android/interoperability/cpp/bridge.md
================================================
# The Bridge Module

CXX relies on a description of the function signatures that will be exposed from
each language to the other. You provide this description using extern blocks in
a Rust module annotated with the `#[cxx::bridge]` attribute macro.

```rust,ignore
{{#include ../../../../third_party/cxx/blobstore/src/main.rs:bridge}}
```

<details>

- The bridge is generally declared in an `ffi` module within your crate.
- From the declarations made in the bridge module, CXX will generate matching
  Rust and C++ type/function definitions in order to expose those items to both
  languages.
- To view the generated Rust code, use [cargo-expand] to view the expanded proc
  macro. For most of the examples you would use `cargo expand ::ffi` to expand
  just the `ffi` module (though this doesn't apply for Android projects).
- To view the generated C++ code, look in `target/cxxbridge`.

[cargo-expand]: https://github.com/dtolnay/cargo-expand

</details>



================================================
FILE: src/android/interoperability/cpp/cpp-bridge.md
================================================
# C++ Bridge Declarations

```rust,ignore
#[cxx::bridge]
mod ffi {
{{#include ../../../../third_party/cxx/blobstore/src/main.rs:cpp_bridge}}
}
```

Results in (roughly) the following Rust:

```rust,ignore
#[repr(C)]
pub struct BlobstoreClient {
    _private: ::cxx::private::Opaque,
}

pub fn new_blobstore_client() -> ::cxx::UniquePtr<BlobstoreClient> {
    extern "C" {
        #[link_name = "org$blobstore$cxxbridge1$new_blobstore_client"]
        fn __new_blobstore_client() -> *mut BlobstoreClient;
    }
    unsafe { ::cxx::UniquePtr::from_raw(__new_blobstore_client()) }
}

impl BlobstoreClient {
    pub fn put(&self, parts: &mut MultiBuf) -> u64 {
        extern "C" {
            #[link_name = "org$blobstore$cxxbridge1$BlobstoreClient$put"]
            fn __put(
                _: &BlobstoreClient,
                parts: *mut ::cxx::core::ffi::c_void,
            ) -> u64;
        }
        unsafe {
            __put(self, parts as *mut MultiBuf as *mut ::cxx::core::ffi::c_void)
        }
    }
}

// ...
```

<details>

- The programmer does not need to promise that the signatures they have typed in
  are accurate. CXX performs static assertions that the signatures exactly
  correspond with what is declared in C++.
- `unsafe extern` blocks allow you to declare C++ functions that are safe to
  call from Rust.

</details>



================================================
FILE: src/android/interoperability/cpp/cpp-exception.md
================================================
# C++ Error Handling

```rust,ignore
{{#include ../../../../third_party/cxx/book/snippets.rs:cpp_exception}}
```

<details>

- C++ functions declared to return a `Result` will catch any thrown exception on
  the C++ side and return it as an `Err` value to the calling Rust function.
- If an exception is thrown from an extern "C++" function that is not declared
  by the CXX bridge to return `Result`, the program calls C++'s
  `std::terminate`. The behavior is equivalent to the same exception being
  thrown through a `noexcept` C++ function.

</details>



================================================
FILE: src/android/interoperability/cpp/generated-cpp.md
================================================
# Generated C++

```rust,ignore
#[cxx::bridge]
mod ffi {
{{#include ../../../../third_party/cxx/blobstore/src/main.rs:rust_bridge}}
}
```

Results in (roughly) the following C++:

```cpp
struct MultiBuf final : public ::rust::Opaque {
  ~MultiBuf() = delete;

private:
  friend ::rust::layout;
  struct layout {
    static ::std::size_t size() noexcept;
    static ::std::size_t align() noexcept;
  };
};

::rust::Slice<::std::uint8_t const> next_chunk(::org::blobstore::MultiBuf &buf) noexcept;
```



================================================
FILE: src/android/interoperability/cpp/rust-bridge.md
================================================
# Rust Bridge Declarations

```rust,ignore
{{#include ../../../../third_party/cxx/book/snippets.rs:rust_bridge}}
```

<details>

- Items declared in the `extern "Rust"` reference items that are in scope in the
  parent module.
- The CXX code generator uses your `extern "Rust"` section(s) to produce a C++
  header file containing the corresponding C++ declarations. The generated
  header has the same path as the Rust source file containing the bridge, except
  with a .rs.h file extension.

</details>



================================================
FILE: src/android/interoperability/cpp/rust-result.md
================================================
# Rust Error Handling

```rust,ignore
{{#include ../../../../third_party/cxx/book/snippets.rs:rust_result}}
```

<details>

- Rust functions that return `Result` are translated to exceptions on the C++
  side.
- The exception thrown will always be of type `rust::Error`, which primarily
  exposes a way to get the error message string. The error message will come
  from the error type's `Display` impl.
- A panic unwinding from Rust to C++ will always cause the process to
  immediately terminate.

</details>



================================================
FILE: src/android/interoperability/cpp/shared-enums.md
================================================
# Shared Enums

```rust,ignore
{{#include ../../../../third_party/cxx/book/snippets.rs:shared_enums_bridge}}
```

Generated Rust:

```rust
{{#include ../../../../third_party/cxx/book/snippets.rs:shared_enums_rust}}
```

Generated C++:

```c++
{{#include ../../../../third_party/cxx/book/snippets.cc:shared_enums_cpp}}
```

<details>

- On the Rust side, the code generated for shared enums is actually a struct
  wrapping a numeric value. This is because it is not UB in C++ for an enum
  class to hold a value different from all of the listed variants, and our Rust
  representation needs to have the same behavior.

</details>



================================================
FILE: src/android/interoperability/cpp/shared-types.md
================================================
# Shared Types

```rust,ignore
{{#include ../../../../third_party/cxx/book/snippets.rs:shared_types}}
```

<details>

- Only C-like (unit) enums are supported.
- A limited number of traits are supported for `#[derive()]` on shared types.
  Corresponding functionality is also generated for the C++ code, e.g. if you
  derive `Hash` also generates an implementation of `std::hash` for the
  corresponding C++ type.

</details>



================================================
FILE: src/android/interoperability/cpp/type-mapping.md
================================================
# Additional Types

| Rust Type         | C++ Type             |
| ----------------- | -------------------- |
| `String`          | `rust::String`       |
| `&str`            | `rust::Str`          |
| `CxxString`       | `std::string`        |
| `&[T]`/`&mut [T]` | `rust::Slice`        |
| `Box<T>`          | `rust::Box<T>`       |
| `UniquePtr<T>`    | `std::unique_ptr<T>` |
| `Vec<T>`          | `rust::Vec<T>`       |
| `CxxVector<T>`    | `std::vector<T>`     |

<details>

- These types can be used in the fields of shared structs and the arguments and
  returns of extern functions.
- Note that Rust's `String` does not map directly to `std::string`. There are a
  few reasons for this:
  - `std::string` does not uphold the UTF-8 invariant that `String` requires.
  - The two types have different layouts in memory and so can't be passed
    directly between languages.
  - `std::string` requires move constructors that don't match Rust's move
    semantics, so a `std::string` can't be passed by value to Rust.

</details>



================================================
FILE: src/android/interoperability/java/Android.bp
================================================
// ANCHOR: libhello_jni
rust_ffi_shared {
    name: "libhello_jni",
    crate_name: "hello_jni",
    srcs: ["src/lib.rs"],
    rustlibs: ["libjni"],
}
// ANCHOR_END: libhello_jni

// ANCHOR: helloworld_jni
java_binary {
    name: "helloworld_jni",
    srcs: ["HelloWorld.java"],
    main_class: "HelloWorld",
    jni_libs: ["libhello_jni"],
}
// ANCHOR_END: helloworld_jni



================================================
FILE: src/android/interoperability/java/HelloWorld.java
================================================
/*
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// ANCHOR: HelloWorld
class HelloWorld {
    private static native String hello(String name);

    static {
        System.loadLibrary("hello_jni");
    }

    public static void main(String[] args) {
        String output = HelloWorld.hello("Alice");
        System.out.println(output);
    }
}



================================================
FILE: src/android/interoperability/java/src/lib.rs
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: hello
//! Rust <-> Java FFI demo.

use jni::JNIEnv;
use jni::objects::{JClass, JString};
use jni::sys::jstring;

/// HelloWorld::hello method implementation.
// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
pub extern "system" fn Java_HelloWorld_hello(
    mut env: JNIEnv,
    _class: JClass,
    name: JString,
) -> jstring {
    let input: String = env.get_string(&name).unwrap().into();
    let greeting = format!("Hello, {input}!");
    let output = env.new_string(greeting).unwrap();
    output.into_raw()
}



================================================
FILE: src/android/interoperability/with-c/bindgen.md
================================================
# Using Bindgen

The [bindgen](https://rust-lang.github.io/rust-bindgen/introduction.html) tool
can auto-generate bindings from a C header file.

Create a wrapper header file for the library (not strictly needed in this
example):

_interoperability/bindgen/libbirthday_wrapper.h_:

```c
{{#include bindgen/libbirthday_wrapper.h:include}}
```

_interoperability/bindgen/Android.bp_:

```javascript
{{#include bindgen/Android.bp:libbirthday_bindgen}}
```

Finally, we can use the bindings in our Rust program:

_interoperability/bindgen/Android.bp_:

```javascript
{{#include bindgen/Android.bp:print_birthday_card}}
```

_interoperability/bindgen/main.rs_:

```rust,compile_fail
{{#include bindgen/main.rs:main}}
```

<details>

- The Android build rules will automatically call `bindgen` for you behind the
  scenes.

- Notice that the Rust code in `main` is still hard to write. It is good
  practice to encapsulate the output of `bindgen` in a Rust library which
  exposes a safe interface to caller.

</details>



================================================
FILE: src/android/interoperability/with-c/c-library.md
================================================
# A Simple C Library

Let's first create a small C library:

_interoperability/bindgen/libbirthday.h_:

```c
{{#include bindgen/libbirthday.h:card}}
```

_interoperability/bindgen/libbirthday.c_:

```c
{{#include bindgen/libbirthday.c:print_card}}
```

Add this to your `Android.bp` file:

_interoperability/bindgen/Android.bp_:

```javascript
{{#include bindgen/Android.bp:libbirthday}}
```



================================================
FILE: src/android/interoperability/with-c/hand-written.md
================================================
# Handwritten FFI

We can declare external functions by hand:

```rust
unsafe extern "C" {
    safe fn abs(x: i32) -> i32;
}

fn main() {
    let x = -42;
    let abs_x = abs(x);
    println!("{x}, {abs_x}");
}
```

We already saw this in the
[Safe FFI Wrapper exercise](../../exercises/day-3/safe-ffi-wrapper.md).

> This assumes full knowledge of the target platform. Not recommended for
> production.

<details>

- This is just a motivating example. For a real library, you want to use
  `bindgen` as shown on the next slide.

</details>



================================================
FILE: src/android/interoperability/with-c/run-our-binary.md
================================================
# Running Our Binary

Build, push, and run the binary on your device:

```shell
{{#include ../../build_all.sh:print_birthday_card}}
```

Finally, we can run auto-generated tests to ensure the bindings work:

_interoperability/bindgen/Android.bp_:

```javascript
{{#include bindgen/Android.bp:libbirthday_bindgen_test}}
```

```shell
{{#include ../../build_all.sh:libbirthday_bindgen_test}}
```



================================================
FILE: src/android/interoperability/with-c/rust-library.md
================================================
# A Simple Rust Library

Exporting Rust functions and types to C is easy. Here's a simple Rust library:

_interoperability/rust/libanalyze/analyze.rs_

```rust,editable
{{#include rust/libanalyze/analyze.rs:analyze_numbers}}
```

_interoperability/rust/libanalyze/Android.bp_

```javascript
{{#include rust/libanalyze/Android.bp}}
```

<details>

`#[unsafe(no_mangle)]` disables Rust's usual name mangling, so the exported
symbol will just be the name of the function. You can also use
`#[unsafe(export_name = "some_name")]` to specify whatever name you want.

</details>



================================================
FILE: src/android/interoperability/with-c/rust.md
================================================
# Calling Rust

We can now call this from a C binary:

_interoperability/rust/libanalyze/analyze.h_

```c
{{#include rust/libanalyze/analyze.h:analyze_numbers}}
```

_interoperability/rust/analyze/main.c_

```c
{{#include rust/analyze/main.c:main}}
```

_interoperability/rust/analyze/Android.bp_

```javascript
{{#include rust/analyze/Android.bp}}
```

Build, push, and run the binary on your device:

```shell
{{#include ../../build_all.sh:analyze_numbers}}
```



================================================
FILE: src/android/interoperability/with-c/bindgen/Android.bp
================================================
// ANCHOR: libbirthday
cc_library {
    name: "libbirthday",
    srcs: ["libbirthday.c"],
}
// ANCHOR_END: libbirthday

// ANCHOR: libbirthday_bindgen
rust_bindgen {
    name: "libbirthday_bindgen",
    crate_name: "birthday_bindgen",
    wrapper_src: "libbirthday_wrapper.h",
    source_stem: "bindings",
    static_libs: ["libbirthday"],
}
// ANCHOR_END: libbirthday_bindgen

// ANCHOR: libbirthday_bindgen_test
rust_test {
    name: "libbirthday_bindgen_test",
    srcs: [":libbirthday_bindgen"],
    crate_name: "libbirthday_bindgen_test",
    test_suites: ["general-tests"],
    auto_gen_config: true,
    clippy_lints: "none", // Generated file, skip linting
    lints: "none",
}
// ANCHOR_END: libbirthday_bindgen_test

// ANCHOR: print_birthday_card
rust_binary {
    name: "print_birthday_card",
    srcs: ["main.rs"],
    rustlibs: ["libbirthday_bindgen"],
    static_libs: ["libbirthday"],
}
// ANCHOR_END: print_birthday_card



================================================
FILE: src/android/interoperability/with-c/bindgen/c-library.md
================================================
# Create a C library

_interoperability/c/libbirthday/Android.bp_:

```javascript
{{#include c/libbirthday/Android.bp:libbirthday}}
```

_interoperability/c/libbirthday/libbirthday.h_:

```c
{{#include c/libbirthday/libbirthday.h}}
```

_interoperability/c/libbirthday/libbirthday.c_:

```c
{{#include c/libbirthday/libbirthday.c}}
```



================================================
FILE: src/android/interoperability/with-c/bindgen/libbirthday.c
================================================
/*
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// ANCHOR: print_card
#include <stdio.h>
#include "libbirthday.h"

void print_card(const card* card) {
  printf("+--------------\n");
  printf("| Happy Birthday %s!\n", card->name);
  printf("| Congratulations with the %i years!\n", card->years);
  printf("+--------------\n");
}



================================================
FILE: src/android/interoperability/with-c/bindgen/libbirthday.h
================================================
/*
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// ANCHOR: card
typedef struct card {
  const char* name;
  int years;
} card;

void print_card(const card* card);



================================================
FILE: src/android/interoperability/with-c/bindgen/libbirthday_wrapper.h
================================================
/*
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// ANCHOR: include
#include "libbirthday.h"



================================================
FILE: src/android/interoperability/with-c/bindgen/main.rs
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: main
//! Bindgen demo.

use birthday_bindgen::{card, print_card};

fn main() {
    let name = std::ffi::CString::new("Peter").unwrap();
    let card = card { name: name.as_ptr(), years: 42 };
    // SAFETY: The pointer we pass is valid because it came from a Rust
    // reference, and the `name` it contains refers to `name` above which also
    // remains valid. `print_card` doesn't store either pointer to use later
    // after it returns.
    unsafe {
        print_card(&card);
    }
}



================================================
FILE: src/android/interoperability/with-c/rust/analyze/Android.bp
================================================
cc_binary {
    name: "analyze_numbers",
    srcs: ["main.c"],
    static_libs: ["libanalyze_ffi"],
}



================================================
FILE: src/android/interoperability/with-c/rust/analyze/main.c
================================================
/*
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// ANCHOR: main
#include "analyze.h"

int main() {
  analyze_numbers(10, 20);
  analyze_numbers(123, 123);
  return 0;
}



================================================
FILE: src/android/interoperability/with-c/rust/libanalyze/analyze.h
================================================
/*
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// ANCHOR: analyze_numbers
#ifndef ANALYZE_H
#define ANALYZE_H

void analyze_numbers(int x, int y);

#endif



================================================
FILE: src/android/interoperability/with-c/rust/libanalyze/analyze.rs
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: analyze_numbers
//! Rust FFI demo.
#![deny(improper_ctypes_definitions)]

use std::os::raw::c_int;

/// Analyze the numbers.
// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
pub extern "C" fn analyze_numbers(x: c_int, y: c_int) {
    if x < y {
        println!("x ({x}) is smallest!");
    } else {
        println!("y ({y}) is probably larger than x ({x})");
    }
}



================================================
FILE: src/android/interoperability/with-c/rust/libanalyze/Android.bp
================================================
rust_ffi {
    name: "libanalyze_ffi",
    crate_name: "analyze_ffi",
    srcs: ["analyze.rs"],
    include_dirs: ["."],
}



================================================
FILE: src/android/logging/Android.bp
================================================
rust_binary {
    name: "hello_rust_logs",
    crate_name: "hello_rust_logs",
    srcs: ["src/main.rs"],
    rustlibs: [
        "liblog_rust",
        "liblogger",
    ],
    host_supported: true,
}



================================================
FILE: src/android/logging/src/main.rs
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: main
//! Rust logging demo.

use log::{debug, error, info};

/// Logs a greeting.
fn main() {
    logger::init(
        logger::Config::default()
            .with_tag_on_device("rust")
            .with_max_level(log::LevelFilter::Trace),
    );
    debug!("Starting program.");
    info!("Things are going fine.");
    error!("Something went wrong!");
}



================================================
FILE: src/android/testing/Android.bp
================================================
rust_library {
    name: "libleftpad",
    crate_name: "leftpad",
    srcs: ["src/lib.rs"],
}

rust_test {
    name: "libleftpad_test",
    crate_name: "leftpad_test",
    srcs: ["src/lib.rs"],
    host_supported: true,
    test_suites: ["general-tests"],
}

rust_test {
    name: "libgoogletest_example",
    crate_name: "googletest_example",
    srcs: ["googletest.rs"],
    rustlibs: ["libgoogletest_rust"],
    host_supported: true,
}

rust_test {
    name: "libmockall_example",
    crate_name: "mockall_example",
    srcs: ["mockall.rs"],
    rustlibs: ["libmockall"],
    host_supported: true,
}



================================================
FILE: src/android/testing/Cargo.toml
================================================
[package]
name = "android-testing"
version = "0.1.0"
edition = "2024"
publish = false

[[example]]
name = "googletest-example"
crate-type = ["staticlib"]
path = "googletest.rs"
test = true

[[example]]
name = "mockall-example"
crate-type = ["staticlib"]
path = "mockall.rs"
test = true

[dependencies]
googletest = "0.14.2"
mockall = "0.13.1"



================================================
FILE: src/android/testing/googletest.md
================================================
---
minutes: 5
---

# GoogleTest

The [GoogleTest](https://docs.rs/googletest/) crate allows for flexible test
assertions using _matchers_:

```rust,ignore
{{#include googletest.rs:test_elements_are}}
```

If we change the last element to `"!"`, the test fails with a structured error
message pin-pointing the error:

<!-- mdbook-xgettext: skip -->

```text
---- test_elements_are stdout ----
Value of: value
Expected: has elements:
  0. is equal to "foo"
  1. is less than "xyz"
  2. starts with prefix "!"
Actual: ["foo", "bar", "baz"],
  where element #2 is "baz", which does not start with "!"
  at src/testing/googletest.rs:6:5
Error: See failure output above
```

<details>

- GoogleTest is not part of the Rust Playground, so you need to run this example
  in a local environment. Use `cargo add googletest` to quickly add it to an
  existing Cargo project.

- The `use googletest::prelude::*;` line imports a number of
  [commonly used macros and types][prelude].

- This just scratches the surface, there are many builtin matchers. Consider
  going through the first chapter of
  ["Advanced testing for Rust applications"](https://rust-exercises.com/advanced-testing/),
  a self-guided Rust course: it provides a guided introduction to the library,
  with exercises to help you get comfortable with `googletest` macros, its
  matchers and its overall philosophy.

- A particularly nice feature is that mismatches in multi-line strings are shown
  as a diff:

```rust,ignore
{{#include googletest.rs:test_multiline_string_diff}}
```

shows a color-coded diff (colors not shown here):

<!-- mdbook-xgettext: skip -->

```text
    Value of: haiku
Expected: is equal to "Memory safety found,\nRust's silly humor guides the way,\nSecure code you'll write."
Actual: "Memory safety found,\nRust's strong typing guides the way,\nSecure code you'll write.",
  which isn't equal to "Memory safety found,\nRust's silly humor guides the way,\nSecure code you'll write."
Difference(-actual / +expected):
 Memory safety found,
-Rust's strong typing guides the way,
+Rust's silly humor guides the way,
 Secure code you'll write.
  at src/testing/googletest.rs:17:5
```

- The crate is a Rust port of
  [GoogleTest for C++](https://google.github.io/googletest/).

[prelude]: https://docs.rs/googletest/latest/googletest/prelude/index.html

</details>



================================================
FILE: src/android/testing/googletest.rs
================================================
// ANCHOR: test_elements_are
use googletest::prelude::*;

#[googletest::test]
fn test_elements_are() {
    let value = vec!["foo", "bar", "baz"];
    expect_that!(value, elements_are!(eq(&"foo"), lt(&"xyz"), starts_with("b")));
}
// ANCHOR_END: test_elements_are

#[should_panic]
// ANCHOR: test_multiline_string_diff
#[test]
fn test_multiline_string_diff() {
    let haiku = "Memory safety found,\n\
                 Rust's strong typing guides the way,\n\
                 Secure code you'll write.";
    assert_that!(
        haiku,
        eq("Memory safety found,\n\
            Rust's silly humor guides the way,\n\
            Secure code you'll write.")
    );
}
// ANCHOR_END: test_multiline_string_diff



================================================
FILE: src/android/testing/mockall.rs
================================================
// ANCHOR: simple_example
use std::time::Duration;

#[mockall::automock]
pub trait Pet {
    fn is_hungry(&self, since_last_meal: Duration) -> bool;
}

#[test]
fn test_robot_dog() {
    let mut mock_dog = MockPet::new();
    mock_dog.expect_is_hungry().return_const(true);
    assert!(mock_dog.is_hungry(Duration::from_secs(10)));
}
// ANCHOR_END: simple_example

// ANCHOR: extended_example
#[test]
fn test_robot_cat() {
    let mut mock_cat = MockPet::new();
    mock_cat
        .expect_is_hungry()
        .with(mockall::predicate::gt(Duration::from_secs(3 * 3600)))
        .return_const(true);
    mock_cat.expect_is_hungry().return_const(false);
    assert!(mock_cat.is_hungry(Duration::from_secs(5 * 3600)));
    assert!(!mock_cat.is_hungry(Duration::from_secs(5)));
}
// ANCHOR_END: extended_example



================================================
FILE: src/android/testing/mocking.md
================================================
---
minutes: 5
---

# Mocking

For mocking, [Mockall] is a widely used library. You need to refactor your code
to use traits, which you can then quickly mock:

```rust,ignore
{{#include mockall.rs:simple_example}}
```

[Mockall]: https://docs.rs/mockall/

<details>

- Mockall is the recommended mocking library in Android (AOSP). There are other
  [mocking libraries available on crates.io](https://crates.io/keywords/mock),
  in particular in the area of mocking HTTP services. The other mocking
  libraries work in a similar fashion as Mockall, meaning that they make it easy
  to get a mock implementation of a given trait.

- Note that mocking is somewhat _controversial_: mocks allow you to completely
  isolate a test from its dependencies. The immediate result is faster and more
  stable test execution. On the other hand, the mocks can be configured wrongly
  and return output different from what the real dependencies would do.

  If at all possible, it is recommended that you use the real dependencies. As
  an example, many databases allow you to configure an in-memory backend. This
  means that you get the correct behavior in your tests, plus they are fast and
  will automatically clean up after themselves.

  Similarly, many web frameworks allow you to start an in-process server which
  binds to a random port on `localhost`. Always prefer this over mocking away
  the framework since it helps you test your code in the real environment.

- Mockall is not part of the Rust Playground, so you need to run this example in
  a local environment. Use `cargo add mockall` to quickly add Mockall to an
  existing Cargo project.

- Mockall has a lot more functionality. In particular, you can set up
  expectations which depend on the arguments passed. Here we use this to mock a
  cat which becomes hungry 3 hours after the last time it was fed:

```rust,ignore
{{#include mockall.rs:extended_example}}
```

- You can use `.times(n)` to limit the number of times a mock method can be
  called to `n` --- the mock will automatically panic when dropped if this isn't
  satisfied.

</details>



================================================
FILE: src/android/testing/src/lib.rs
================================================
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: leftpad
//! Left-padding library.

/// Left-pad `s` to `width`.
pub fn leftpad(s: &str, width: usize) -> String {
    format!("{s:>width$}")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn short_string() {
        assert_eq!(leftpad("foo", 5), "  foo");
    }

    #[test]
    fn long_string() {
        assert_eq!(leftpad("foobar", 6), "foobar");
    }
}



================================================
FILE: src/bare-metal/alloc.md
================================================
# `alloc`

To use `alloc` you must implement a
[global (heap) allocator](https://doc.rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html).

```rust,editable,compile_fail
{{#include alloc-example/src/main.rs:Alloc}}
```

<details>

- `buddy_system_allocator` is a crate implementing a basic buddy system
  allocator. Other crates are available, or you can write your own or hook into
  your existing allocator.
- The const parameter of `LockedHeap` is the max order of the allocator; i.e. in
  this case it can allocate regions of up to 2**32 bytes.
- If any crate in your dependency tree depends on `alloc` then you must have
  exactly one global allocator defined in your binary. Usually this is done in
  the top-level binary crate.
- `extern crate panic_halt as _` is necessary to ensure that the `panic_halt`
  crate is linked in so we get its panic handler.
- This example will build but not run, as it doesn't have an entry point.

</details>



================================================
FILE: src/bare-metal/android.md
================================================
# Bare-Metal on Android

To build a bare-metal Rust binary in AOSP, you need to use a `rust_ffi_static`
Soong rule to build your Rust code, then a `cc_binary` with a linker script to
produce the binary itself, and then a `raw_binary` to convert the ELF to a raw
binary ready to be run.

<!-- mdbook-xgettext: skip -->

```soong
rust_ffi_static {
    name: "libvmbase_example",
    defaults: ["vmbase_ffi_defaults"],
    crate_name: "vmbase_example",
    srcs: ["src/main.rs"],
    rustlibs: [
        "libvmbase",
    ],
}

cc_binary {
    name: "vmbase_example",
    defaults: ["vmbase_elf_defaults"],
    srcs: [
        "idmap.S",
    ],
    static_libs: [
        "libvmbase_example",
    ],
    linker_scripts: [
        "image.ld",
        ":vmbase_sections",
    ],
}

raw_binary {
    name: "vmbase_example_bin",
    stem: "vmbase_example.bin",
    src: ":vmbase_example",
    enabled: false,
    target: {
        android_arm64: {
            enabled: true,
        },
    },
}
```



================================================
FILE: src/bare-metal/aps.md
================================================
---
session: Afternoon
---

# Application processors

So far we've talked about microcontrollers, such as the Arm Cortex-M series.
These are typically small systems with very limited resources.

Larger systems with more resources are typically called application processors,
built around processors such as the ARM Cortex-A or Intel Atom.

For simplicity we'll just work with QEMU's aarch64
['virt'](https://qemu-project.gitlab.io/qemu/system/arm/virt.html) board.

<details>

- Broadly speaking, microcontrollers don't have an MMU or multiple levels of
  privilege (exception levels on Arm CPUs, rings on x86).
- Application processors have more resources, and often run an operating system,
  instead of directly executing the target application on startup.
- QEMU supports emulating various different machines or board models for each
  architecture. The 'virt' board doesn't correspond to any particular real
  hardware, but is designed purely for virtual machines.
- We will still address this board as bare-metal, as if we were writing an
  operating system.

</details>



================================================
FILE: src/bare-metal/microcontrollers.md
================================================
# Microcontrollers

The `cortex_m_rt` crate provides (among other things) a reset handler for Cortex
M microcontrollers.

<!-- mdbook-xgettext: skip -->

```rust,editable,compile_fail
{{#include microcontrollers/examples/src/bin/minimal.rs:Example}}
```

Next we'll look at how to access peripherals, with increasing levels of
abstraction.

<details>

- The `cortex_m_rt::entry` macro requires that the function have type
  `fn() -> !`, because returning to the reset handler doesn't make sense.
- Run the example with `cargo embed --bin minimal`

</details>



================================================
FILE: src/bare-metal/minimal.md
================================================
# A minimal `no_std` program

<!-- mdbook-xgettext: skip -->

```rust,editable,compile_fail
#![no_main]
#![no_std]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_panic: &PanicInfo) -> ! {
    loop {}
}
```

<details>

- This will compile to an empty binary.
- `std` provides a panic handler; without it we must provide our own.
- It can also be provided by another crate, such as `panic-halt`.
- Depending on the target, you may need to compile with `panic = "abort"` to
  avoid an error about `eh_personality`.
- Note that there is no `main` or any other entry point; it's up to you to
  define your own entry point. This will typically involve a linker script and
  some assembly code to set things up ready for Rust code to run.

</details>



================================================
FILE: src/bare-metal/no_std.md
================================================
# `no_std`

<table>
<tr>
<th>

`core`

</th>
<th>

`alloc`

</th>
<th>

`std`

</th>
</tr>
<tr valign="top">
<td>

- Slices, `&str`, `CStr`
- `NonZeroU8`...
- `Option`, `Result`
- `Display`, `Debug`, `write!`...
- `Iterator`
- `Error`
- `panic!`, `assert_eq!`...
- `NonNull` and all the usual pointer-related functions
- `Future` and `async`/`await`
- `fence`, `AtomicBool`, `AtomicPtr`, `AtomicU32`...
- `Duration`

</td>
<td>

- `Box`, `Cow`, `Arc`, `Rc`
- `Vec`, `BinaryHeap`, `BtreeMap`, `LinkedList`, `VecDeque`
- `String`, `CString`, `format!`

</td>
<td>

- `HashMap`
- `Mutex`, `Condvar`, `Barrier`, `Once`, `RwLock`, `mpsc`
- `File` and the rest of `fs`
- `println!`, `Read`, `Write`, `Stdin`, `Stdout` and the rest of `io`
- `Path`, `OsString`
- `net`
- `Command`, `Child`, `ExitCode`
- `spawn`, `sleep` and the rest of `thread`
- `SystemTime`, `Instant`

</td>
</tr>
</table>

<details>

- `HashMap` depends on RNG.
- `std` re-exports the contents of both `core` and `alloc`.

</details>



================================================
FILE: src/bare-metal/useful-crates.md
================================================
# Useful crates

We'll look at a few crates that solve some common problems in bare-metal
programming.



================================================
FILE: src/bare-metal/alloc-example/Cargo.toml
================================================
[workspace]

[package]
name = "alloc-example"
version = "0.1.0"
edition = "2024"
publish = false

[dependencies]
buddy_system_allocator = "0.11.0"
panic-halt = "1.0.0"

[profile.dev]
panic = "abort"

[profile.release]
panic = "abort"



================================================
FILE: src/bare-metal/alloc-example/src/main.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: Alloc
#![no_main]
#![no_std]

extern crate alloc;
extern crate panic_halt as _;

use alloc::string::ToString;
use alloc::vec::Vec;
use buddy_system_allocator::LockedHeap;

#[global_allocator]
static HEAP_ALLOCATOR: LockedHeap<32> = LockedHeap::<32>::new();

const HEAP_SIZE: usize = 65536;
static mut HEAP: [u8; HEAP_SIZE] = [0; HEAP_SIZE];

pub fn entry() {
    // SAFETY: `HEAP` is only used here and `entry` is only called once.
    unsafe {
        // Give the allocator some memory to allocate.
        HEAP_ALLOCATOR.lock().init(&raw mut HEAP as usize, HEAP_SIZE);
    }

    // Now we can do things that require heap allocation.
    let mut v = Vec::new();
    v.push("A string".to_string());
}



================================================
FILE: src/bare-metal/alloc-example/.cargo/config.toml
================================================
[build]
target = "aarch64-unknown-none"



================================================
FILE: src/bare-metal/android/vmbase.md
================================================
# vmbase

For VMs running under crosvm on aarch64, the [vmbase][1] library provides a
linker script and useful defaults for the build rules, along with an entry
point, UART console logging and more.

<!-- mdbook-xgettext: skip -->

```rust,compile_fail
#![no_main]
#![no_std]

use vmbase::{main, println};

main!(main);

pub fn main(arg0: u64, arg1: u64, arg2: u64, arg3: u64) {
    println!("Hello world");
}
```

<details>

- The `main!` macro marks your main function, to be called from the `vmbase`
  entry point.
- The `vmbase` entry point handles console initialisation, and issues a
  PSCI_SYSTEM_OFF to shutdown the VM if your main function returns.

</details>

[1]: https://android.googlesource.com/platform/packages/modules/Virtualization/+/refs/heads/main/libs/libvmbase/



================================================
FILE: src/bare-metal/aps/aarch64-rt.md
================================================
# aarch64-rt

The `aarch64-rt` crate provides the assembly entry point and exception vector
that we implemented before. We just need to mark our main function with the
`entry!` macro.

It also provides the `initial_pagetable!` macro to let us define an initial
static pagetable in Rust, rather than in assembly code like we did before.

We can also use the UART driver from the `arm-pl011-uart` crate rather than
writing our own.

```rust,editable,compile_fail
{{#include examples/src/main_rt.rs:main}}
```

<details>

- Run the example in QEMU with `make qemu_rt` under
  `src/bare-metal/aps/examples`.

</details>



================================================
FILE: src/bare-metal/aps/better-uart.md
================================================
# A better UART driver

The PL011 actually has [more registers][1], and adding offsets to construct
pointers to access them is error-prone and hard to read. Additionally, some of
them are bit fields, which would be nice to access in a structured way.

| Offset | Register name | Width |
| ------ | ------------- | ----- |
| 0x00   | DR            | 12    |
| 0x04   | RSR           | 4     |
| 0x18   | FR            | 9     |
| 0x20   | ILPR          | 8     |
| 0x24   | IBRD          | 16    |
| 0x28   | FBRD          | 6     |
| 0x2c   | LCR_H         | 8     |
| 0x30   | CR            | 16    |
| 0x34   | IFLS          | 6     |
| 0x38   | IMSC          | 11    |
| 0x3c   | RIS           | 11    |
| 0x40   | MIS           | 11    |
| 0x44   | ICR           | 11    |
| 0x48   | DMACR         | 3     |

<details>

- There are also some ID registers that have been omitted for brevity.

</details>

[1]: https://developer.arm.com/documentation/ddi0183/g/programmers-model/summary-of-registers



================================================
FILE: src/bare-metal/aps/entry-point.md
================================================
# Getting Ready to Rust

Before we can start running Rust code, we need to do some initialization.

```armasm
{{#include examples/src/entry.S:entry}}
```

<details>

This code is in `src/bare-metal/aps/examples/src/entry.S`. It's not necessary to
understand this in detail -- the takeaway is that typically some low-level setup
is needed to meet Rust's expectations of the system.

- This is the same as it would be for C: initializing the processor state,
  zeroing the BSS, and setting up the stack pointer.
  - The BSS (block starting symbol, for historical reasons) is the part of the
    object file that contains statically allocated variables that are
    initialized to zero. They are omitted from the image, to avoid wasting space
    on zeroes. The compiler assumes that the loader will take care of zeroing
    them.
- The BSS may already be zeroed, depending on how memory is initialized and the
  image is loaded, but we zero it to be sure.
- We need to enable the MMU and cache before reading or writing any memory. If
  we don't:
  - Unaligned accesses will fault. We build the Rust code for the
    `aarch64-unknown-none` target that sets `+strict-align` to prevent the
    compiler from generating unaligned accesses, so it should be fine in this
    case, but this is not necessarily the case in general.
  - If it were running in a VM, this can lead to cache coherency issues. The
    problem is that the VM is accessing memory directly with the cache disabled,
    while the host has cacheable aliases to the same memory. Even if the host
    doesn't explicitly access the memory, speculative accesses can lead to cache
    fills, and then changes from one or the other will get lost when the cache
    is cleaned or the VM enables the cache. (Cache is keyed by physical address,
    not VA or IPA.)
- For simplicity, we just use a hardcoded pagetable (see `idmap.S`) that
  identity maps the first 1 GiB of address space for devices, the next 1 GiB for
  DRAM, and another 1 GiB higher up for more devices. This matches the memory
  layout that QEMU uses.
- We also set up the exception vector (`vbar_el1`), which we'll see more about
  later.
- All examples this afternoon assume we will be running at exception level 1
  (EL1). If you need to run at a different exception level, you'll need to
  modify `entry.S` accordingly.

</details>



================================================
FILE: src/bare-metal/aps/exceptions.md
================================================
# Exceptions

AArch64 defines an exception vector table with 16 entries, for 4 types of
exceptions (synchronous, IRQ, FIQ, SError) from 4 states (current EL with SP0,
current EL with SPx, lower EL using AArch64, lower EL using AArch32). We
implement this in assembly to save volatile registers to the stack before
calling into Rust code:

<!-- mdbook-xgettext: skip -->

```rust,editable,compile_fail
{{#include examples/src/exceptions.rs:exceptions}}
```

<details>

- EL is exception level; all our examples this afternoon run in EL1.
- For simplicity we aren't distinguishing between SP0 and SPx for the current EL
  exceptions, or between AArch32 and AArch64 for the lower EL exceptions.
- For this example we just log the exception and power down, as we don't expect
  any of them to actually happen.
- We can think of exception handlers and our main execution context more or less
  like different threads. [`Send` and `Sync`][1] will control what we can share
  between them, just like with threads. For example, if we want to share some
  value between exception handlers and the rest of the program, and it's `Send`
  but not `Sync`, then we'll need to wrap it in something like a `Mutex` and put
  it in a static.

</details>

[1]: ../../concurrency/send-sync.md



================================================
FILE: src/bare-metal/aps/inline-assembly.md
================================================
# Inline assembly

Sometimes we need to use assembly to do things that aren't possible with Rust
code. For example, to make an HVC (hypervisor call) to tell the firmware to
power off the system:

```rust,editable,compile_fail
{{#include examples/src/main_psci.rs:main}}
```

(If you actually want to do this, use the [`smccc`][1] crate which has wrappers
for all these functions.)

<details>

- PSCI is the Arm Power State Coordination Interface, a standard set of
  functions to manage system and CPU power states, among other things. It is
  implemented by EL3 firmware and hypervisors on many systems.
- The `0 => _` syntax means initialize the register to 0 before running the
  inline assembly code, and ignore its contents afterwards. We need to use
  `inout` rather than `in` because the call could potentially clobber the
  contents of the registers.
- This `main` function needs to be `#[unsafe(no_mangle)]` and `extern "C"`
  because it is called from our entry point in `entry.S`.
  - Just `#[no_mangle]` would be sufficient but
    [RFC3325](https://rust-lang.github.io/rfcs/3325-unsafe-attributes.html) uses
    this notation to draw reviewer attention to attributes that might cause
    undefined behavior if used incorrectly.
- `_x0`–`_x3` are the values of registers `x0`–`x3`, which are conventionally
  used by the bootloader to pass things like a pointer to the device tree.
  According to the standard aarch64 calling convention (which is what
  `extern "C"` specifies to use), registers `x0`–`x7` are used for the first 8
  arguments passed to a function, so `entry.S` doesn't need to do anything
  special except make sure it doesn't change these registers.
- Run the example in QEMU with `make qemu_psci` under
  `src/bare-metal/aps/examples`.

</details>

[1]: https://crates.io/crates/smccc



================================================
FILE: src/bare-metal/aps/logging.md
================================================
# Logging

It would be nice to be able to use the logging macros from the [`log`][1] crate.
We can do this by implementing the `Log` trait.

```rust,editable,compile_fail
{{#include examples/src/logger.rs:main}}
```

<details>

- The first unwrap in `log` will succeed because we initialize `LOGGER` before
  calling `set_logger`. The second will succeed because `Uart::write_str` always
  returns `Ok`.

</details>

[1]: https://crates.io/crates/log



================================================
FILE: src/bare-metal/aps/mmio.md
================================================
# Volatile memory access for MMIO

- Use [`pointer::read_volatile`] and [`pointer::write_volatile`].
- Never hold a reference to a location being accessed with these methods. Rust
  may read from (or write to, for `&mut`) a reference at any time.
- Use `&raw` to get fields of structs without creating an intermediate
  reference.

```rust,editable,ignore
const SOME_DEVICE_REGISTER: *mut u64 = 0x800_0000 as _;
// SAFETY: Some device is mapped at this address.
unsafe {
    SOME_DEVICE_REGISTER.write_volatile(0xff);
    SOME_DEVICE_REGISTER.write_volatile(0x80);
    assert_eq!(SOME_DEVICE_REGISTER.read_volatile(), 0xaa);
}
```

[`pointer::read_volatile`]: https://doc.rust-lang.org/stable/core/primitive.pointer.html#method.read_volatile
[`pointer::write_volatile`]: https://doc.rust-lang.org/stable/core/primitive.pointer.html#method.write_volatile
[`addr_of!`]: https://doc.rust-lang.org/stable/core/ptr/macro.addr_of.html

<details>

- Volatile access: read or write operations may have side-effects, so prevent
  the compiler or hardware from reordering, duplicating or eliding them.
  - Usually if you write and then read, e.g. via a mutable reference, the
    compiler may assume that the value read is the same as the value just
    written, and not bother actually reading memory.
- Some existing crates for volatile access to hardware do hold references, but
  this is unsound. Whenever a reference exists, the compiler may choose to
  dereference it.
- Use `&raw` to get struct field pointers from a pointer to the struct.
- For compatibility with old versions of Rust you can use the [`addr_of!`] macro
  instead.

</details>



================================================
FILE: src/bare-metal/aps/other-projects.md
================================================
# Other projects

- [oreboot](https://github.com/oreboot/oreboot)
  - "coreboot without the C".
  - Supports x86, aarch64 and RISC-V.
  - Relies on LinuxBoot rather than having many drivers itself.
- [Rust RaspberryPi OS tutorial](https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials)
  - Initialization, UART driver, simple bootloader, JTAG, exception levels,
    exception handling, page tables.
  - Some caveats around cache maintenance and initialization in Rust, not
    necessarily a good example to copy for production code.
- [`cargo-call-stack`](https://crates.io/crates/cargo-call-stack)
  - Static analysis to determine maximum stack usage.

<details>

- The RaspberryPi OS tutorial runs Rust code before the MMU and caches are
  enabled. This will read and write memory (e.g. the stack). However, this has
  the problems mentioned at the beginning of this session regarding unaligned
  access and cache coherency.

</details>



================================================
FILE: src/bare-metal/aps/uart.md
================================================
# Let's write a UART driver

The QEMU 'virt' machine has a [PL011][1] UART, so let's write a driver for that.

```rust,editable
{{#include examples/src/pl011_minimal.rs:Example}}
```

<details>

- Note that `Uart::new` is unsafe while the other methods are safe. This is
  because as long as the caller of `Uart::new` guarantees that its safety
  requirements are met (i.e. that there is only ever one instance of the driver
  for a given UART, and nothing else aliasing its address space), then it is
  always safe to call `write_byte` later because we can assume the necessary
  preconditions.
- We could have done it the other way around (making `new` safe but `write_byte`
  unsafe), but that would be much less convenient to use as every place that
  calls `write_byte` would need to reason about the safety
- This is a common pattern for writing safe wrappers of unsafe code: moving the
  burden of proof for soundness from a large number of places to a smaller
  number of places.

</details>

[1]: https://developer.arm.com/documentation/ddi0183/g



================================================
FILE: src/bare-metal/aps/better-uart/bitflags.md
================================================
# Bitflags

The [`bitflags`](https://crates.io/crates/bitflags) crate is useful for working
with bitflags.

```rust,editable,compile_fail
{{#include ../examples/src/pl011_struct.rs:Flags}}
```

<details>

- The `bitflags!` macro creates a newtype something like `struct Flags(u16)`,
  along with a bunch of method implementations to get and set flags.

</details>



================================================
FILE: src/bare-metal/aps/better-uart/driver.md
================================================
# Driver

Now let's use the new `Registers` struct in our driver.

```rust,editable,compile_fail
{{#include ../examples/src/pl011_struct.rs:Uart}}
```

<details>

- Note the use of `&raw const` / `&raw mut` to get pointers to individual fields
  without creating an intermediate reference, which would be unsound.
- The example isn't included in the slides because it is very similar to the
  `safe-mmio` example which comes next. You can run it in QEMU with `make qemu`
  under `src/bare-metal/aps/examples` if you need to.

</details>



================================================
FILE: src/bare-metal/aps/better-uart/registers.md
================================================
# Multiple registers

We can use a struct to represent the memory layout of the UART's registers.

<!-- mdbook-xgettext: skip -->

```rust,editable,compile_fail
{{#include ../examples/src/pl011_struct.rs:Registers}}
```

<details>

- [`#[repr(C)]`](https://doc.rust-lang.org/reference/type-layout.html#the-c-representation)
  tells the compiler to lay the struct fields out in order, following the same
  rules as C. This is necessary for our struct to have a predictable layout, as
  default Rust representation allows the compiler to (among other things)
  reorder fields however it sees fit.

</details>



================================================
FILE: src/bare-metal/aps/examples/Cargo.toml
================================================
[workspace]

[package]
name = "ap-examples"
version = "0.1.0"
edition = "2024"
publish = false

[dependencies]
aarch64-paging = { version = "0.10.0", default-features = false }
aarch64-rt = "0.2.2"
arm-pl011-uart = "0.3.2"
bitflags = "2.9.3"
log = "0.4.27"
safe-mmio = "0.2.5"
smccc = "0.2.0"
spin = "0.10.0"
zerocopy = "0.8.26"

[[bin]]
name = "improved"
path = "src/main_improved.rs"

[[bin]]
name = "logger"
path = "src/main_logger.rs"

[[bin]]
name = "minimal"
path = "src/main_minimal.rs"

[[bin]]
name = "psci"
path = "src/main_psci.rs"

[[bin]]
name = "rt"
path = "src/main_rt.rs"

[[bin]]
name = "safemmio"
path = "src/main_safemmio.rs"



================================================
FILE: src/bare-metal/aps/examples/image.ld
================================================
/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Code will start running at this symbol which is placed at the start
 * of the image.
 */
ENTRY(entry)

MEMORY
{
	image : ORIGIN = 0x40080000, LENGTH = 2M
}

SECTIONS
{
	/*
	 * Collect together the code.
	 */
	.init : ALIGN(4096) {
		text_begin = .;
		*(.init.entry)
		*(.init.*)
	} >image
	.text : {
		*(.text.*)
	} >image
	text_end = .;

	/*
	 * Collect together read-only data.
	 */
	.rodata : ALIGN(4096) {
		rodata_begin = .;
		*(.rodata.*)
	} >image
	.got : {
		*(.got)
	} >image
	rodata_end = .;

	/*
	 * Collect together the read-write data including .bss at the end
	 * which will be zero'd by the entry code.
	 */
	.data : ALIGN(4096) {
		data_begin = .;
		*(.data.*)
		/*
		 * The entry point code assumes that .data is a multiple of 32
		 * bytes long.
		 */
		. = ALIGN(32);
		data_end = .;
	} >image

	/*
	 * Everything beyond this point will not be included in the
	 * binary.
	 */
	bin_end = .;

	/* The entry point code assumes that .bss is 16-byte aligned. */
	.bss : ALIGN(16)  {
		bss_begin = .;
		*(.bss.*)
		*(COMMON)
		. = ALIGN(16);
		bss_end = .;
	} >image

	.stack (NOLOAD) : ALIGN(4096) {
		boot_stack_begin = .;
		. += 40 * 4096;
		. = ALIGN(4096);
		boot_stack_end = .;
	} >image

	. = ALIGN(4K);
	PROVIDE(dma_region = .);

	/*
	 * Remove unused sections from the image.
	 */
	/DISCARD/ : {
		/* The image loads itself so doesn't need these sections. */
		*(.gnu.hash)
		*(.hash)
		*(.interp)
		*(.eh_frame_hdr)
		*(.eh_frame)
		*(.note.gnu.build-id)
	}
}



================================================
FILE: src/bare-metal/aps/examples/Makefile
================================================
# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

.PHONY: build qemu qemu_logger qemu_minimal qemu_psci

all: minimal.bin improved.bin logger.bin

build:
	cargo build

improved.bin: build
	cargo objcopy --bin improved -- -O binary $@
logger.bin: build
	cargo objcopy --bin logger -- -O binary $@
minimal.bin: build
	cargo objcopy --bin minimal -- -O binary $@
psci.bin: build
	cargo objcopy --bin psci -- -O binary $@
rt.bin: build
	cargo objcopy --bin rt -- -O binary $@
safemmio.bin: build
	cargo objcopy --bin safemmio -- -O binary $@

qemu: improved.bin
	qemu-system-aarch64 -machine virt -cpu max -serial mon:stdio -display none -kernel $< -s
qemu_logger: logger.bin
	qemu-system-aarch64 -machine virt -cpu max -serial mon:stdio -display none -kernel $< -s
qemu_minimal: minimal.bin
	qemu-system-aarch64 -machine virt -cpu max -serial mon:stdio -display none -kernel $< -s
qemu_psci: psci.bin
	qemu-system-aarch64 -machine virt -cpu max -serial mon:stdio -display none -kernel $< -s
qemu_rt: rt.bin
	qemu-system-aarch64 -machine virt -cpu max -serial mon:stdio -display none -kernel $< -s
qemu_safemmio: safemmio.bin
	qemu-system-aarch64 -machine virt -cpu max -serial mon:stdio -display none -kernel $< -s

clean:
	cargo clean
	rm -f *.bin



================================================
FILE: src/bare-metal/aps/examples/src/asm.rs
================================================
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use core::arch::global_asm;

global_asm!(include_str!("entry.S"));
global_asm!(include_str!("exceptions.S"));
global_asm!(include_str!("idmap.S"));



================================================
FILE: src/bare-metal/aps/examples/src/entry.S
================================================
/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

.macro adr_l, reg:req, sym:req
    adrp \reg, \sym
    add \reg, \reg, :lo12:\sym
.endm

.macro mov_i, reg:req, imm:req
    movz \reg, :abs_g3:\imm
    movk \reg, :abs_g2_nc:\imm
    movk \reg, :abs_g1_nc:\imm
    movk \reg, :abs_g0_nc:\imm
.endm

.set .L_MAIR_DEV_nGnRE, 0x04
.set .L_MAIR_MEM_WBWA, 0xff
.set .Lmairval, .L_MAIR_DEV_nGnRE | (.L_MAIR_MEM_WBWA << 8)

/* 4 KiB granule size for TTBR0_EL1. */
.set .L_TCR_TG0_4KB, 0x0 << 14
/* 4 KiB granule size for TTBR1_EL1. */
.set .L_TCR_TG1_4KB, 0x2 << 30

/*
 * Disable translation table walk for TTBR1_EL1, generating a
 * translation fault instead.
 */
.set .L_TCR_EPD1, 0x1 << 23
/* Translation table walks for TTBR0_EL1 are inner sharable. */
.set .L_TCR_SH_INNER, 0x3 << 12
/*
 * Translation table walks for TTBR0_EL1 are outer write-back
 * read-allocate write-allocate cacheable.
 */
.set .L_TCR_RGN_OWB, 0x1 << 10
/*
 * Translation table walks for TTBR0_EL1 are inner write-back
 * read-allocate write-allocate cacheable.
 */
.set .L_TCR_RGN_IWB, 0x1 << 8
/* Size offset for TTBR0_EL1 is 2**39 bytes (512 GiB). */
.set .L_TCR_T0SZ_512, 64 - 39
.set .Ltcrval, .L_TCR_TG0_4KB | .L_TCR_TG1_4KB | .L_TCR_EPD1 | .L_TCR_RGN_OWB
.set .Ltcrval, .Ltcrval | .L_TCR_RGN_IWB | .L_TCR_SH_INNER | .L_TCR_T0SZ_512

/* Stage 1 instruction access cacheability is unaffected. */
.set .L_SCTLR_ELx_I, 0x1 << 12
/* SP alignment fault if SP is not aligned to a 16 byte boundary. */
.set .L_SCTLR_ELx_SA, 0x1 << 3
/* Stage 1 data access cacheability is unaffected. */
.set .L_SCTLR_ELx_C, 0x1 << 2
/* EL0 and EL1 stage 1 MMU enabled. */
.set .L_SCTLR_ELx_M, 0x1 << 0
/*
 * Privileged Access Never is unchanged on taking an exception to EL1.
 */
.set .L_SCTLR_EL1_SPAN, 0x1 << 23
/* SETEND instruction disabled at EL0 in aarch32 mode. */
.set .L_SCTLR_EL1_SED, 0x1 << 8
/* Various IT instructions are disabled at EL0 in aarch32 mode. */
.set .L_SCTLR_EL1_ITD, 0x1 << 7
.set .L_SCTLR_EL1_RES1, (0x1 << 11) | (0x1 << 20) | (0x1 << 22) | (0x1 << 28) | (0x1 << 29)
.set .Lsctlrval, .L_SCTLR_ELx_M | .L_SCTLR_ELx_C | .L_SCTLR_ELx_SA | .L_SCTLR_EL1_ITD | .L_SCTLR_EL1_SED
.set .Lsctlrval, .Lsctlrval | .L_SCTLR_ELx_I | .L_SCTLR_EL1_SPAN | .L_SCTLR_EL1_RES1

// ANCHOR: entry
/**
 * This is a generic entry point for an image. It carries out the
 * operations required to prepare the loaded image to be run.
 * Specifically, it
 *
 * - sets up the MMU with an identity map of virtual to physical
 *   addresses, and enables caching
 * - enables floating point
 * - zeroes the bss section using registers x25 and above
 * - prepares the stack, pointing to a section within the image
 * - sets up the exception vector
 * - branches to the Rust `main` function
 *
 * It preserves x0-x3 for the Rust entry point, as these may contain
 * boot parameters.
 */
.section .init.entry, "ax"
.global entry
entry:
    /*
     * Load and apply the memory management configuration, ready to
     * enable MMU and caches.
     */
    adrp x30, idmap
    msr ttbr0_el1, x30

    mov_i x30, .Lmairval
    msr mair_el1, x30

    mov_i x30, .Ltcrval
    /* Copy the supported PA range into TCR_EL1.IPS. */
    mrs x29, id_aa64mmfr0_el1
    bfi x30, x29, #32, #4

    msr tcr_el1, x30

    mov_i x30, .Lsctlrval

    /*
     * Ensure everything before this point has completed, then
     * invalidate any potentially stale local TLB entries before they
     * start being used.
     */
    isb
    tlbi vmalle1
    ic iallu
    dsb nsh
    isb

    /*
     * Configure sctlr_el1 to enable MMU and cache and don't proceed
     * until this has completed.
     */
    msr sctlr_el1, x30
    isb

    /* Disable trapping floating point access in EL1. */
    mrs x30, cpacr_el1
    orr x30, x30, #(0x3 << 20)
    msr cpacr_el1, x30
    isb

    /* Zero out the bss section. */
    adr_l x29, bss_begin
    adr_l x30, bss_end
0:  cmp x29, x30
    b.hs 1f
    stp xzr, xzr, [x29], #16
    b 0b

1:  /* Prepare the stack. */
    adr_l x30, boot_stack_end
    mov sp, x30

    /* Set up exception vector. */
    adr x30, vector_table_el1
    msr vbar_el1, x30

    /* Call into Rust code. */
    bl main

    /* Loop forever waiting for interrupts. */
2:  wfi
    b 2b



================================================
FILE: src/bare-metal/aps/examples/src/exceptions.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: exceptions
use log::error;
use smccc::Hvc;
use smccc::psci::system_off;

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern "C" fn sync_exception_current(_elr: u64, _spsr: u64) {
    error!("sync_exception_current");
    system_off::<Hvc>().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern "C" fn irq_current(_elr: u64, _spsr: u64) {
    error!("irq_current");
    system_off::<Hvc>().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern "C" fn fiq_current(_elr: u64, _spsr: u64) {
    error!("fiq_current");
    system_off::<Hvc>().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern "C" fn serr_current(_elr: u64, _spsr: u64) {
    error!("serr_current");
    system_off::<Hvc>().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern "C" fn sync_lower(_elr: u64, _spsr: u64) {
    error!("sync_lower");
    system_off::<Hvc>().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern "C" fn irq_lower(_elr: u64, _spsr: u64) {
    error!("irq_lower");
    system_off::<Hvc>().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern "C" fn fiq_lower(_elr: u64, _spsr: u64) {
    error!("fiq_lower");
    system_off::<Hvc>().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern "C" fn serr_lower(_elr: u64, _spsr: u64) {
    error!("serr_lower");
    system_off::<Hvc>().unwrap();
}



================================================
FILE: src/bare-metal/aps/examples/src/exceptions.S
================================================
/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Saves the volatile registers onto the stack. This currently takes
 * 14 instructions, so it can be used in exception handlers with 18
 * instructions left.
 *
 * On return, x0 and x1 are initialised to elr_el2 and spsr_el2
 * respectively, which can be used as the first and second arguments
 * of a subsequent call.
 */
.macro save_volatile_to_stack
	/* Reserve stack space and save registers x0-x18, x29 & x30. */
	stp x0, x1, [sp, #-(8 * 24)]!
	stp x2, x3, [sp, #8 * 2]
	stp x4, x5, [sp, #8 * 4]
	stp x6, x7, [sp, #8 * 6]
	stp x8, x9, [sp, #8 * 8]
	stp x10, x11, [sp, #8 * 10]
	stp x12, x13, [sp, #8 * 12]
	stp x14, x15, [sp, #8 * 14]
	stp x16, x17, [sp, #8 * 16]
	str x18, [sp, #8 * 18]
	stp x29, x30, [sp, #8 * 20]

	/*
	 * Save elr_el1 & spsr_el1. This such that we can take nested
	 * exception and still be able to unwind.
	 */
	mrs x0, elr_el1
	mrs x1, spsr_el1
	stp x0, x1, [sp, #8 * 22]
.endm

/**
 * Restores the volatile registers from the stack. This currently
 * takes 14 instructions, so it can be used in exception handlers
 * while still leaving 18 instructions left; if paired with
 * save_volatile_to_stack, there are 4 instructions to spare.
 */
.macro restore_volatile_from_stack
	/* Restore registers x2-x18, x29 & x30. */
	ldp x2, x3, [sp, #8 * 2]
	ldp x4, x5, [sp, #8 * 4]
	ldp x6, x7, [sp, #8 * 6]
	ldp x8, x9, [sp, #8 * 8]
	ldp x10, x11, [sp, #8 * 10]
	ldp x12, x13, [sp, #8 * 12]
	ldp x14, x15, [sp, #8 * 14]
	ldp x16, x17, [sp, #8 * 16]
	ldr x18, [sp, #8 * 18]
	ldp x29, x30, [sp, #8 * 20]

	/*
	 * Restore registers elr_el1 & spsr_el1, using x0 & x1 as scratch.
	 */
	ldp x0, x1, [sp, #8 * 22]
	msr elr_el1, x0
	msr spsr_el1, x1

	/* Restore x0 & x1, and release stack space. */
	ldp x0, x1, [sp], #8 * 24
.endm

/**
 * This is a generic handler for exceptions taken at the current EL
 * while using SP0. It behaves similarly to the SPx case by first
 * switching to SPx, doing the work, then switching back to SP0 before
 * returning.
 *
 * Switching to SPx and calling the Rust handler takes 16
 * instructions. To restore and return we need an additional 16
 * instructions, so we can implement the whole handler within the
 * allotted 32 instructions.
 *
 */
.macro current_exception_sp0 handler:req
	msr spsel, #1
	save_volatile_to_stack
	bl \handler
	restore_volatile_from_stack
	msr spsel, #0
	eret
.endm

/**
 * This is a generic handler for exceptions taken at the current EL
 * while using SPx. It saves volatile registers, calls the Rust
 * handler, restores volatile registers, then returns.
 *
 * This also works for exceptions taken from EL0, if we don't care
 * about non-volatile registers.
 *
 * Saving state and jumping to the Rust handler takes 15 instructions,
 * and restoring and returning also takes 15 instructions, so we can
 * fit the whole handler in 30 instructions, under the limit of 32.
 */
.macro current_exception_spx handler:req
	save_volatile_to_stack
	bl \handler
	restore_volatile_from_stack
	eret
.endm

.section .text.vector_table_el1, "ax"
.global vector_table_el1
.balign 0x800
vector_table_el1:
sync_cur_sp0:
	current_exception_sp0 sync_exception_current

.balign 0x80
irq_cur_sp0:
	current_exception_sp0 irq_current

.balign 0x80
fiq_cur_sp0:
	current_exception_sp0 fiq_current

.balign 0x80
serr_cur_sp0:
	current_exception_sp0 serr_current

.balign 0x80
sync_cur_spx:
	current_exception_spx sync_exception_current

.balign 0x80
irq_cur_spx:
	current_exception_spx irq_current

.balign 0x80
fiq_cur_spx:
	current_exception_spx fiq_current

.balign 0x80
serr_cur_spx:
	current_exception_spx serr_current

.balign 0x80
sync_lower_64:
	current_exception_spx sync_lower

.balign 0x80
irq_lower_64:
	current_exception_spx irq_lower

.balign 0x80
fiq_lower_64:
	current_exception_spx fiq_lower

.balign 0x80
serr_lower_64:
	current_exception_spx serr_lower

.balign 0x80
sync_lower_32:
	current_exception_spx sync_lower

.balign 0x80
irq_lower_32:
	current_exception_spx irq_lower

.balign 0x80
fiq_lower_32:
	current_exception_spx fiq_lower

.balign 0x80
serr_lower_32:
	current_exception_spx serr_lower



================================================
FILE: src/bare-metal/aps/examples/src/idmap.S
================================================
/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

.set .L_TT_TYPE_BLOCK, 0x1
.set .L_TT_TYPE_PAGE,  0x3
.set .L_TT_TYPE_TABLE, 0x3

/* Access flag. */
.set .L_TT_AF, 0x1 << 10
/* Not global. */
.set .L_TT_NG, 0x1 << 11
.set .L_TT_XN, 0x3 << 53

.set .L_TT_MT_DEV, 0x0 << 2			// MAIR #0 (DEV_nGnRE)
.set .L_TT_MT_MEM, (0x1 << 2) | (0x3 << 8)	// MAIR #1 (MEM_WBWA), inner shareable

.set .L_BLOCK_DEV, .L_TT_TYPE_BLOCK | .L_TT_MT_DEV | .L_TT_AF | .L_TT_XN
.set .L_BLOCK_MEM, .L_TT_TYPE_BLOCK | .L_TT_MT_MEM | .L_TT_AF | .L_TT_NG

.section ".rodata.idmap", "a", %progbits
.global idmap
.align 12
idmap:
	/* level 1 */
	.quad		.L_BLOCK_DEV | 0x0		    // 1 GiB of device mappings
	.quad		.L_BLOCK_MEM | 0x40000000	// 1 GiB of DRAM
	.fill		254, 8, 0x0			// 254 GiB of unmapped VA space
	.quad		.L_BLOCK_DEV | 0x4000000000 // 1 GiB of device mappings
	.fill		255, 8, 0x0			// 255 GiB of remaining VA space



================================================
FILE: src/bare-metal/aps/examples/src/logger.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: main
use crate::pl011::Uart;
use core::fmt::Write;
use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};
use spin::mutex::SpinMutex;

static LOGGER: Logger = Logger { uart: SpinMutex::new(None) };

struct Logger {
    uart: SpinMutex<Option<Uart<'static>>>,
}

impl Log for Logger {
    fn enabled(&self, _metadata: &Metadata) -> bool {
        true
    }

    fn log(&self, record: &Record) {
        writeln!(
            self.uart.lock().as_mut().unwrap(),
            "[{}] {}",
            record.level(),
            record.args()
        )
        .unwrap();
    }

    fn flush(&self) {}
}

/// Initialises UART logger.
pub fn init(
    uart: Uart<'static>,
    max_level: LevelFilter,
) -> Result<(), SetLoggerError> {
    LOGGER.uart.lock().replace(uart);

    log::set_logger(&LOGGER)?;
    log::set_max_level(max_level);
    Ok(())
}



================================================
FILE: src/bare-metal/aps/examples/src/main_improved.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: main
#![no_main]
#![no_std]

mod asm;
mod exceptions;
mod pl011_struct;

use crate::pl011_struct::Uart;
use core::fmt::Write;
use core::panic::PanicInfo;
use log::error;
use smccc::Hvc;
use smccc::psci::system_off;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut pl011_struct::Registers = 0x900_0000 as _;

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern "C" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // SAFETY: `PL011_BASE_ADDRESS` is the base address of a PL011 device, and
    // nothing else accesses that address range.
    let mut uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };

    writeln!(uart, "main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})").unwrap();

    loop {
        if let Some(byte) = uart.read_byte() {
            uart.write_byte(byte);
            match byte {
                b'\r' => uart.write_byte(b'\n'),
                b'q' => break,
                _ => continue,
            }
        }
    }

    writeln!(uart, "\n\nBye!").unwrap();
    system_off::<Hvc>().unwrap();
}
// ANCHOR_END: main

#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    error!("{info}");
    system_off::<Hvc>().unwrap();
    loop {}
}



================================================
FILE: src/bare-metal/aps/examples/src/main_logger.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: main
#![no_main]
#![no_std]

mod asm;
mod exceptions;
mod logger;
mod pl011;

use crate::pl011::Uart;
use core::panic::PanicInfo;
use core::ptr::NonNull;
use log::{LevelFilter, error, info};
use safe_mmio::UniqueMmioPointer;
use smccc::Hvc;
use smccc::psci::system_off;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: NonNull<pl011::Registers> =
    NonNull::new(0x900_0000 as _).unwrap();

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern "C" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // SAFETY: `PL011_BASE_ADDRESS` is the base address of a PL011 device, and
    // nothing else accesses that address range.
    let uart = unsafe { Uart::new(UniqueMmioPointer::new(PL011_BASE_ADDRESS)) };
    logger::init(uart, LevelFilter::Trace).unwrap();

    info!("main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})");

    assert_eq!(x1, 42);

    system_off::<Hvc>().unwrap();
}

#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    error!("{info}");
    system_off::<Hvc>().unwrap();
    loop {}
}
// ANCHOR_END: main



================================================
FILE: src/bare-metal/aps/examples/src/main_minimal.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: main
#![no_main]
#![no_std]

mod asm;
mod exceptions;
mod pl011_minimal;

use crate::pl011_minimal::Uart;
use core::fmt::Write;
use core::panic::PanicInfo;
use log::error;
use smccc::Hvc;
use smccc::psci::system_off;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u8 = 0x900_0000 as _;

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern "C" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // SAFETY: `PL011_BASE_ADDRESS` is the base address of a PL011 device, and
    // nothing else accesses that address range.
    let mut uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };

    writeln!(uart, "main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})").unwrap();

    system_off::<Hvc>().unwrap();
}
// ANCHOR_END: main

#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    error!("{}", info);
    system_off::<Hvc>().unwrap();
    loop {}
}



================================================
FILE: src/bare-metal/aps/examples/src/main_psci.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: main
#![no_main]
#![no_std]

use core::arch::asm;
use core::panic::PanicInfo;

mod asm;
mod exceptions;

const PSCI_SYSTEM_OFF: u32 = 0x84000008;

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern "C" fn main(_x0: u64, _x1: u64, _x2: u64, _x3: u64) {
    // SAFETY: this only uses the declared registers and doesn't do anything
    // with memory.
    unsafe {
        asm!("hvc #0",
            inout("w0") PSCI_SYSTEM_OFF => _,
            inout("w1") 0 => _,
            inout("w2") 0 => _,
            inout("w3") 0 => _,
            inout("w4") 0 => _,
            inout("w5") 0 => _,
            inout("w6") 0 => _,
            inout("w7") 0 => _,
            options(nomem, nostack)
        );
    }

    loop {}
}
// ANCHOR_END: main

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}



================================================
FILE: src/bare-metal/aps/examples/src/main_rt.rs
================================================
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: main
#![no_main]
#![no_std]

mod exceptions;

use aarch64_paging::paging::Attributes;
use aarch64_rt::{InitialPagetable, entry, initial_pagetable};
use arm_pl011_uart::{PL011Registers, Uart, UniqueMmioPointer};
use core::fmt::Write;
use core::panic::PanicInfo;
use core::ptr::NonNull;
use smccc::Hvc;
use smccc::psci::system_off;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: NonNull<PL011Registers> =
    NonNull::new(0x900_0000 as _).unwrap();

/// Attributes to use for device memory in the initial identity map.
const DEVICE_ATTRIBUTES: Attributes = Attributes::VALID
    .union(Attributes::ATTRIBUTE_INDEX_0)
    .union(Attributes::ACCESSED)
    .union(Attributes::UXN);

/// Attributes to use for normal memory in the initial identity map.
const MEMORY_ATTRIBUTES: Attributes = Attributes::VALID
    .union(Attributes::ATTRIBUTE_INDEX_1)
    .union(Attributes::INNER_SHAREABLE)
    .union(Attributes::ACCESSED)
    .union(Attributes::NON_GLOBAL);

initial_pagetable!({
    let mut idmap = [0; 512];
    // 1 GiB of device memory.
    idmap[0] = DEVICE_ATTRIBUTES.bits();
    // 1 GiB of normal memory.
    idmap[1] = MEMORY_ATTRIBUTES.bits() | 0x40000000;
    // Another 1 GiB of device memory starting at 256 GiB.
    idmap[256] = DEVICE_ATTRIBUTES.bits() | 0x4000000000;
    InitialPagetable(idmap)
});

entry!(main);
fn main(x0: u64, x1: u64, x2: u64, x3: u64) -> ! {
    // SAFETY: `PL011_BASE_ADDRESS` is the base address of a PL011 device, and
    // nothing else accesses that address range.
    let mut uart = unsafe { Uart::new(UniqueMmioPointer::new(PL011_BASE_ADDRESS)) };

    writeln!(uart, "main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})").unwrap();

    system_off::<Hvc>().unwrap();
    panic!("system_off returned");
}

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    system_off::<Hvc>().unwrap();
    loop {}
}



================================================
FILE: src/bare-metal/aps/examples/src/main_safemmio.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: main
#![no_main]
#![no_std]

mod asm;
mod exceptions;
mod pl011;

use crate::pl011::Uart;
use core::fmt::Write;
use core::panic::PanicInfo;
use core::ptr::NonNull;
use log::error;
use safe_mmio::UniqueMmioPointer;
use smccc::Hvc;
use smccc::psci::system_off;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: NonNull<pl011::Registers> =
    NonNull::new(0x900_0000 as _).unwrap();

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern "C" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // SAFETY: `PL011_BASE_ADDRESS` is the base address of a PL011 device, and
    // nothing else accesses that address range.
    let mut uart = Uart::new(unsafe { UniqueMmioPointer::new(PL011_BASE_ADDRESS) });

    writeln!(uart, "main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})").unwrap();

    loop {
        if let Some(byte) = uart.read_byte() {
            uart.write_byte(byte);
            match byte {
                b'\r' => uart.write_byte(b'\n'),
                b'q' => break,
                _ => continue,
            }
        }
    }

    writeln!(uart, "\n\nBye!").unwrap();
    system_off::<Hvc>().unwrap();
}
// ANCHOR_END: main

#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    error!("{info}");
    system_off::<Hvc>().unwrap();
    loop {}
}



================================================
FILE: src/bare-metal/aps/examples/src/pl011.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
#![allow(dead_code)]

use core::fmt::{self, Write};

// ANCHOR: Flags
use bitflags::bitflags;
use zerocopy::{FromBytes, IntoBytes};

/// Flags from the UART flag register.
#[repr(transparent)]
#[derive(Copy, Clone, Debug, Eq, FromBytes, IntoBytes, PartialEq)]
struct Flags(u16);

bitflags! {
    impl Flags: u16 {
        /// Clear to send.
        const CTS = 1 << 0;
        /// Data set ready.
        const DSR = 1 << 1;
        /// Data carrier detect.
        const DCD = 1 << 2;
        /// UART busy transmitting data.
        const BUSY = 1 << 3;
        /// Receive FIFO is empty.
        const RXFE = 1 << 4;
        /// Transmit FIFO is full.
        const TXFF = 1 << 5;
        /// Receive FIFO is full.
        const RXFF = 1 << 6;
        /// Transmit FIFO is empty.
        const TXFE = 1 << 7;
        /// Ring indicator.
        const RI = 1 << 8;
    }
}
// ANCHOR_END: Flags

/// Flags from the UART Receive Status Register / Error Clear Register.
#[repr(transparent)]
#[derive(Copy, Clone, Debug, Eq, FromBytes, IntoBytes, PartialEq)]
struct ReceiveStatus(u16);

bitflags! {
    impl ReceiveStatus: u16 {
        /// Framing error.
        const FE = 1 << 0;
        /// Parity error.
        const PE = 1 << 1;
        /// Break error.
        const BE = 1 << 2;
        /// Overrun error.
        const OE = 1 << 3;
    }
}

// ANCHOR: Registers
use safe_mmio::fields::{ReadPure, ReadPureWrite, ReadWrite, WriteOnly};

#[repr(C, align(4))]
pub struct Registers {
    dr: ReadWrite<u16>,
    _reserved0: [u8; 2],
    rsr: ReadPure<ReceiveStatus>,
    _reserved1: [u8; 19],
    fr: ReadPure<Flags>,
    _reserved2: [u8; 6],
    ilpr: ReadPureWrite<u8>,
    _reserved3: [u8; 3],
    ibrd: ReadPureWrite<u16>,
    _reserved4: [u8; 2],
    fbrd: ReadPureWrite<u8>,
    _reserved5: [u8; 3],
    lcr_h: ReadPureWrite<u8>,
    _reserved6: [u8; 3],
    cr: ReadPureWrite<u16>,
    _reserved7: [u8; 3],
    ifls: ReadPureWrite<u8>,
    _reserved8: [u8; 3],
    imsc: ReadPureWrite<u16>,
    _reserved9: [u8; 2],
    ris: ReadPure<u16>,
    _reserved10: [u8; 2],
    mis: ReadPure<u16>,
    _reserved11: [u8; 2],
    icr: WriteOnly<u16>,
    _reserved12: [u8; 2],
    dmacr: ReadPureWrite<u8>,
    _reserved13: [u8; 3],
}
// ANCHOR_END: Registers

// ANCHOR: Uart
use safe_mmio::{UniqueMmioPointer, field, field_shared};

/// Driver for a PL011 UART.
#[derive(Debug)]
pub struct Uart<'a> {
    registers: UniqueMmioPointer<'a, Registers>,
}

impl<'a> Uart<'a> {
    /// Constructs a new instance of the UART driver for a PL011 device with the
    /// given set of registers.
    pub fn new(registers: UniqueMmioPointer<'a, Registers>) -> Self {
        Self { registers }
    }

    /// Writes a single byte to the UART.
    pub fn write_byte(&mut self, byte: u8) {
        // Wait until there is room in the TX buffer.
        while self.read_flag_register().contains(Flags::TXFF) {}

        // Write to the TX buffer.
        field!(self.registers, dr).write(byte.into());

        // Wait until the UART is no longer busy.
        while self.read_flag_register().contains(Flags::BUSY) {}
    }

    /// Reads and returns a pending byte, or `None` if nothing has been
    /// received.
    pub fn read_byte(&mut self) -> Option<u8> {
        if self.read_flag_register().contains(Flags::RXFE) {
            None
        } else {
            let data = field!(self.registers, dr).read();
            // TODO: Check for error conditions in bits 8-11.
            Some(data as u8)
        }
    }

    fn read_flag_register(&self) -> Flags {
        field_shared!(self.registers, fr).read()
    }
}
// ANCHOR_END: Uart

impl Write for Uart<'_> {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        for c in s.as_bytes() {
            self.write_byte(*c);
        }
        Ok(())
    }
}



================================================
FILE: src/bare-metal/aps/examples/src/pl011_minimal.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: Example
const FLAG_REGISTER_OFFSET: usize = 0x18;
const FR_BUSY: u8 = 1 << 3;
const FR_TXFF: u8 = 1 << 5;

/// Minimal driver for a PL011 UART.
#[derive(Debug)]
pub struct Uart {
    base_address: *mut u8,
}

impl Uart {
    /// Constructs a new instance of the UART driver for a PL011 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the 8 MMIO control registers of a
    /// PL011 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u8) -> Self {
        Self { base_address }
    }

    /// Writes a single byte to the UART.
    pub fn write_byte(&self, byte: u8) {
        // Wait until there is room in the TX buffer.
        while self.read_flag_register() & FR_TXFF != 0 {}

        // SAFETY: We know that the base address points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe {
            // Write to the TX buffer.
            self.base_address.write_volatile(byte);
        }

        // Wait until the UART is no longer busy.
        while self.read_flag_register() & FR_BUSY != 0 {}
    }

    fn read_flag_register(&self) -> u8 {
        // SAFETY: We know that the base address points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe { self.base_address.add(FLAG_REGISTER_OFFSET).read_volatile() }
    }
}
// ANCHOR_END: Example

// ANCHOR: Traits
use core::fmt::{self, Write};

impl Write for Uart {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        for c in s.as_bytes() {
            self.write_byte(*c);
        }
        Ok(())
    }
}

// SAFETY: `Uart` just contains a pointer to device memory, which can be
// accessed from any context.
unsafe impl Send for Uart {}
// ANCHOR_END: Traits



================================================
FILE: src/bare-metal/aps/examples/src/pl011_struct.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
#![allow(dead_code)]

use core::fmt::{self, Write};

// ANCHOR: Flags
use bitflags::bitflags;

bitflags! {
    /// Flags from the UART flag register.
    #[repr(transparent)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    struct Flags: u16 {
        /// Clear to send.
        const CTS = 1 << 0;
        /// Data set ready.
        const DSR = 1 << 1;
        /// Data carrier detect.
        const DCD = 1 << 2;
        /// UART busy transmitting data.
        const BUSY = 1 << 3;
        /// Receive FIFO is empty.
        const RXFE = 1 << 4;
        /// Transmit FIFO is full.
        const TXFF = 1 << 5;
        /// Receive FIFO is full.
        const RXFF = 1 << 6;
        /// Transmit FIFO is empty.
        const TXFE = 1 << 7;
        /// Ring indicator.
        const RI = 1 << 8;
    }
}
// ANCHOR_END: Flags

bitflags! {
    /// Flags from the UART Receive Status Register / Error Clear Register.
    #[repr(transparent)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    struct ReceiveStatus: u16 {
        /// Framing error.
        const FE = 1 << 0;
        /// Parity error.
        const PE = 1 << 1;
        /// Break error.
        const BE = 1 << 2;
        /// Overrun error.
        const OE = 1 << 3;
    }
}

// ANCHOR: Registers
#[repr(C, align(4))]
pub struct Registers {
    dr: u16,
    _reserved0: [u8; 2],
    rsr: ReceiveStatus,
    _reserved1: [u8; 19],
    fr: Flags,
    _reserved2: [u8; 6],
    ilpr: u8,
    _reserved3: [u8; 3],
    ibrd: u16,
    _reserved4: [u8; 2],
    fbrd: u8,
    _reserved5: [u8; 3],
    lcr_h: u8,
    _reserved6: [u8; 3],
    cr: u16,
    _reserved7: [u8; 3],
    ifls: u8,
    _reserved8: [u8; 3],
    imsc: u16,
    _reserved9: [u8; 2],
    ris: u16,
    _reserved10: [u8; 2],
    mis: u16,
    _reserved11: [u8; 2],
    icr: u16,
    _reserved12: [u8; 2],
    dmacr: u8,
    _reserved13: [u8; 3],
}
// ANCHOR_END: Registers

// ANCHOR: Uart
/// Driver for a PL011 UART.
#[derive(Debug)]
pub struct Uart {
    registers: *mut Registers,
}

impl Uart {
    /// Constructs a new instance of the UART driver for a PL011 device with the
    /// given set of registers.
    ///
    /// # Safety
    ///
    /// The given pointer must point to the 8 MMIO control registers of a PL011
    /// device, which must be mapped into the address space of the process as
    /// device memory and not have any other aliases.
    pub unsafe fn new(registers: *mut Registers) -> Self {
        Self { registers }
    }

    /// Writes a single byte to the UART.
    pub fn write_byte(&mut self, byte: u8) {
        // Wait until there is room in the TX buffer.
        while self.read_flag_register().contains(Flags::TXFF) {}

        // SAFETY: We know that self.registers points to the control registers
        // of a PL011 device which is appropriately mapped.
        unsafe {
            // Write to the TX buffer.
            (&raw mut (*self.registers).dr).write_volatile(byte.into());
        }

        // Wait until the UART is no longer busy.
        while self.read_flag_register().contains(Flags::BUSY) {}
    }

    /// Reads and returns a pending byte, or `None` if nothing has been
    /// received.
    pub fn read_byte(&mut self) -> Option<u8> {
        if self.read_flag_register().contains(Flags::RXFE) {
            None
        } else {
            // SAFETY: We know that self.registers points to the control
            // registers of a PL011 device which is appropriately mapped.
            let data = unsafe { (&raw const (*self.registers).dr).read_volatile() };
            // TODO: Check for error conditions in bits 8-11.
            Some(data as u8)
        }
    }

    fn read_flag_register(&self) -> Flags {
        // SAFETY: We know that self.registers points to the control registers
        // of a PL011 device which is appropriately mapped.
        unsafe { (&raw const (*self.registers).fr).read_volatile() }
    }
}
// ANCHOR_END: Uart

impl Write for Uart {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        for c in s.as_bytes() {
            self.write_byte(*c);
        }
        Ok(())
    }
}

// Safe because it just contains a pointer to device memory, which can be
// accessed from any context.
unsafe impl Send for Uart {}



================================================
FILE: src/bare-metal/aps/examples/.cargo/config.toml
================================================
[build]
target = "aarch64-unknown-none"
rustflags = ["-C", "link-arg=-Timage.ld"]



================================================
FILE: src/bare-metal/aps/logging/using.md
================================================
# Using it

We need to initialise the logger before we use it.

```rust,editable,compile_fail
{{#include ../examples/src/main_logger.rs:main}}
```

<details>

- Note that our panic handler can now log details of panics.
- Run the example in QEMU with `make qemu_logger` under
  `src/bare-metal/aps/examples`.

</details>



================================================
FILE: src/bare-metal/aps/safemmio/driver.md
================================================
# Driver

Now let's use the new `Registers` struct in our driver.

```rust,editable,compile_fail
{{#include ../examples/src/pl011.rs:Uart}}
```

<details>

- The driver no longer needs any unsafe code!
- `UniqueMmioPointer` is a wrapper around a raw pointer to an MMIO device or
  register. The caller of `UniqueMmioPointer::new` promises that it is valid and
  unique for the given lifetime, so it can provide safe methods to read and
  write fields.
- Note that `Uart::new` is now safe; `UniqueMmioPointer::new` is unsafe instead.
- These MMIO accesses are generally a wrapper around `read_volatile` and
  `write_volatile`, though on aarch64 they are instead implemented in assembly
  to work around a bug where the compiler can emit instructions that prevent
  MMIO virtualization.
- The `field!` and `field_shared!` macros internally use `&raw mut` and
  `&raw const` to get pointers to individual fields without creating an
  intermediate reference, which would be unsound.
- `field!` needs a mutable reference to a `UniqueMmioPointer`, and returns a
  `UniqueMmioPointer` that allows reads with side effects and writes.
- `field_shared!` works with a shared reference to either a `UniqueMmioPointer`
  or a `SharedMmioPointer`. It returns a `SharedMmioPointer` that only allows
  pure reads.

</details>



================================================
FILE: src/bare-metal/aps/safemmio/registers.md
================================================
# safe-mmio

The [`safe-mmio`] crate provides types to wrap registers that can be read or
written safely.

|             | Can't read    | Read has no side-effects | Read has side-effects |
| ----------- | ------------- | ------------------------ | --------------------- |
| Can't write |               | [`ReadPure`]             | [`ReadOnly`]          |
| Can write   | [`WriteOnly`] | [`ReadPureWrite`]        | [`ReadWrite`]         |

<!-- mdbook-xgettext: skip -->

```rust,editable,compile_fail
{{#include ../examples/src/pl011.rs:Registers}}
```

- Reading `dr` has a side effect: it pops a byte from the receive FIFO.
- Reading `rsr` (and other registers) has no side-effects. It is a 'pure' read.

<details>

- There are a number of different crates providing safe abstractions around MMIO
  operations; we recommend the `safe-mmio` crate.
- The difference between `ReadPure` or `ReadOnly` (and likewise between
  `ReadPureWrite` and `ReadWrite`) is whether reading a register can have
  side-effects that change the state of the device, e.g., reading the data
  register pops a byte from the receive FIFO. `ReadPure` means that reads have
  no side-effects, they are purely reading data.

</details>

[`safe-mmio`]: https://crates.io/crates/safe-mmio
[`ReadOnly`]: https://docs.rs/safe-mmio/latest/safe_mmio/fields/struct.ReadOnly.html
[`ReadPure`]: https://docs.rs/safe-mmio/latest/safe_mmio/fields/struct.ReadPure.html
[`ReadPureWrite`]: https://docs.rs/safe-mmio/latest/safe_mmio/fields/struct.ReadPureWrite.html
[`ReadWrite`]: https://docs.rs/safe-mmio/latest/safe_mmio/fields/struct.ReadWrite.html
[`WriteOnly`]: https://docs.rs/safe-mmio/latest/safe_mmio/fields/struct.WriteOnly.html



================================================
FILE: src/bare-metal/aps/safemmio/using.md
================================================
# Using It

Let's write a small program using our driver to write to the serial console, and
echo incoming bytes.

```rust,editable,compile_fail
{{#include ../examples/src/main_safemmio.rs:main}}
```

<details>

- Run the example in QEMU with `make qemu_safemmio` under
  `src/bare-metal/aps/examples`.

</details>



================================================
FILE: src/bare-metal/aps/uart/traits.md
================================================
# More traits

We derived the `Debug` trait. It would be useful to implement a few more traits
too.

```rust,editable,compile_fail
{{#include ../examples/src/pl011_minimal.rs:Traits}}
```

<details>

- Implementing `Write` lets us use the `write!` and `writeln!` macros with our
  `Uart` type.

- `Send` is an auto-trait, but not implemented automatically because it is not
  implemented for pointers.

</details>



================================================
FILE: src/bare-metal/aps/uart/using.md
================================================
# Using it

Let's write a small program using our driver to write to the serial console.

```rust,editable,compile_fail
{{#include ../examples/src/main_minimal.rs:main}}
```

<details>

- As in the [inline assembly](../inline-assembly.md) example, this `main`
  function is called from our entry point code in `entry.S`. See the speaker
  notes there for details.
- Run the example in QEMU with `make qemu_minimal` under
  `src/bare-metal/aps/examples`.

</details>



================================================
FILE: src/bare-metal/microcontrollers/board-support.md
================================================
# Board support crates

Board support crates provide a further level of wrapping for a specific board
for convenience.

<!-- mdbook-xgettext: skip -->

```rust,editable,compile_fail
{{#include examples/src/bin/board_support.rs:Example}}
```

<details>

- In this case the board support crate is just providing more useful names, and
  a bit of initialization.
- The crate may also include drivers for some on-board devices outside of the
  microcontroller itself.
  - `microbit-v2` includes a simple driver for the LED matrix.

Run the example with:

```sh
cargo embed --bin board_support
```

</details>



================================================
FILE: src/bare-metal/microcontrollers/debugging.md
================================================
# Debugging

_Embed.toml_:

<!-- mdbook-xgettext: skip -->

```toml
[default.general]
chip = "nrf52833_xxAA"

[debug.gdb]
enabled = true
```

In one terminal under `src/bare-metal/microcontrollers/examples/`:

<!-- mdbook-xgettext: skip -->

```sh
cargo embed --bin board_support debug
```

In another terminal in the same directory:

On gLinux or Debian:

<!-- mdbook-xgettext: skip -->

```sh
gdb-multiarch target/thumbv7em-none-eabihf/debug/board_support --eval-command="target remote :1338"
```

On MacOS:

<!-- mdbook-xgettext: skip -->

```sh
arm-none-eabi-gdb target/thumbv7em-none-eabihf/debug/board_support --eval-command="target remote :1338"
```

<details>

In GDB, try running:

<!-- mdbook-xgettext: skip -->

```gdb
b src/bin/board_support.rs:29
b src/bin/board_support.rs:30
b src/bin/board_support.rs:32
c
c
c
```

</details>



================================================
FILE: src/bare-metal/microcontrollers/embedded-hal.md
================================================
# `embedded-hal`

The [`embedded-hal`] crate provides a number of traits covering common
microcontroller peripherals:

- GPIO
- PWM
- Delay timers
- I2C and SPI buses and devices

Similar traits for byte streams (e.g. UARTs), CAN buses and RNGs are broken out
into [`embedded-io`], [`embedded-can`] and [`rand_core`] respectively.

Other crates then implement [drivers] in terms of these traits, e.g. an
accelerometer driver might need an I2C or SPI device instance.

<details>

- The traits cover using the peripherals but not initializing or configuring
  them, as initialization and configuration is usually highly platform-specific.
- There are implementations for many microcontrollers, as well as other
  platforms such as Linux on Raspberry Pi.
- [`embedded-hal-async`] provides async versions of the traits.
- [`embedded-hal-nb`] provides another approach to non-blocking I/O, based on
  the [`nb`] crate.

</details>

[drivers]: https://github.com/rust-embedded/awesome-embedded-rust#driver-crates
[`embedded-can`]: https://crates.io/crates/embedded-can
[`embedded-hal`]: https://crates.io/crates/embedded-hal
[`embedded-hal-async`]: https://crates.io/crates/embedded-hal-async
[`embedded-hal-nb`]: https://crates.io/crates/embedded-hal-nb
[`embedded-io`]: https://crates.io/crates/embedded-io
[`nb`]: https://crates.io/crates/nb
[`rand_core`]: https://crates.io/crates/rand_core



================================================
FILE: src/bare-metal/microcontrollers/hals.md
================================================
# HAL crates

[HAL crates](https://github.com/rust-embedded/awesome-embedded-rust#hal-implementation-crates)
for many microcontrollers provide wrappers around various peripherals. These
generally implement traits from
[`embedded-hal`](https://crates.io/crates/embedded-hal).

```rust,editable,compile_fail
{{#include examples/src/bin/hal.rs:Example}}
```

<details>

- `set_low` and `set_high` are methods on the `embedded_hal` `OutputPin` trait.
- HAL crates exist for many Cortex-M and RISC-V devices, including various
  STM32, GD32, nRF, NXP, MSP430, AVR and PIC microcontrollers.

Run the example with:

```sh
cargo embed --bin hal
```

</details>



================================================
FILE: src/bare-metal/microcontrollers/mmio.md
================================================
# Raw MMIO

Most microcontrollers access peripherals via memory-mapped IO. Let's try turning
on an LED on our micro:bit:

```rust,editable,compile_fail
{{#include examples/src/bin/mmio.rs:Example}}
```

<details>

- GPIO 0 pin 21 is connected to the first column of the LED matrix, and pin 28
  to the first row.

Run the example with:

```sh
cargo embed --bin mmio
```

</details>



================================================
FILE: src/bare-metal/microcontrollers/other-projects.md
================================================
# Other projects

- [RTIC](https://rtic.rs/)
  - "Real-Time Interrupt-driven Concurrency".
  - Shared resource management, message passing, task scheduling, timer queue.
- [Embassy](https://embassy.dev/)
  - `async` executors with priorities, timers, networking, USB.
- [TockOS](https://www.tockos.org/documentation/getting-started)
  - Security-focused RTOS with preemptive scheduling and Memory Protection Unit
    support.
- [Hubris](https://hubris.oxide.computer/)
  - Microkernel RTOS from Oxide Computer Company with memory protection,
    unprivileged drivers, IPC.
- [Bindings for FreeRTOS](https://github.com/lobaro/FreeRTOS-rust).

Some platforms have `std` implementations, e.g.
[esp-idf](https://esp-rs.github.io/book/overview/using-the-standard-library.html).

<details>

- RTIC can be considered either an RTOS or a concurrency framework.
  - It doesn't include any HALs.
  - It uses the Cortex-M NVIC (Nested Virtual Interrupt Controller) for
    scheduling rather than a proper kernel.
  - Cortex-M only.
- Google uses TockOS on the Haven microcontroller for Titan security keys.
- FreeRTOS is mostly written in C, but there are Rust bindings for writing
  applications.

</details>



================================================
FILE: src/bare-metal/microcontrollers/pacs.md
================================================
# Peripheral Access Crates

[`svd2rust`](https://crates.io/crates/svd2rust) generates mostly-safe Rust
wrappers for memory-mapped peripherals from
[CMSIS-SVD](https://www.keil.com/pack/doc/CMSIS/SVD/html/index.html) files.

```rust,editable,compile_fail
{{#include examples/src/bin/pac.rs:Example}}
```

<details>

- SVD (System View Description) files are XML files typically provided by
  silicon vendors that describe the memory map of the device.
  - They are organized by peripheral, register, field and value, with names,
    descriptions, addresses and so on.
  - SVD files are often buggy and incomplete, so there are various projects that
    patch the mistakes, add missing details, and publish the generated crates.
- `cortex-m-rt` provides the vector table, among other things.
- If you `cargo install cargo-binutils` then you can run
  `cargo objdump --bin pac -- -d --no-show-raw-insn` to see the resulting
  binary.

Run the example with:

```sh
cargo embed --bin pac
```

</details>



================================================
FILE: src/bare-metal/microcontrollers/probe-rs.md
================================================
# `probe-rs` and `cargo-embed`

[probe-rs](https://probe.rs/) is a handy toolset for embedded debugging, like
OpenOCD but better integrated.

- SWD (Serial Wire Debug) and JTAG via CMSIS-DAP, ST-Link and J-Link probes
- GDB stub and Microsoft DAP (Debug Adapter Protocol) server
- Cargo integration

`cargo-embed` is a cargo subcommand to build and flash binaries, log RTT (Real
Time Transfers) output and connect GDB. It's configured by an `Embed.toml` file
in your project directory.

<details>

- [CMSIS-DAP](https://arm-software.github.io/CMSIS_5/DAP/html/index.html) is an
  Arm standard protocol over USB for an in-circuit debugger to access the
  CoreSight Debug Access Port of various Arm Cortex processors. It's what the
  on-board debugger on the BBC micro:bit uses.
- ST-Link is a range of in-circuit debuggers from ST Microelectronics, J-Link is
  a range from SEGGER.
- The Debug Access Port is usually either a 5-pin JTAG interface or 2-pin Serial
  Wire Debug.
- probe-rs is a library that you can integrate into your own tools if you want
  to.
- The
  [Microsoft Debug Adapter Protocol](https://microsoft.github.io/debug-adapter-protocol/)
  lets VSCode and other IDEs debug code running on any supported
  microcontroller.
- cargo-embed is a binary built using the probe-rs library.
- RTT (Real Time Transfers) is a mechanism to transfer data between the debug
  host and the target through a number of ring buffers.

</details>



================================================
FILE: src/bare-metal/microcontrollers/type-state.md
================================================
# The type state pattern

```rust,editable,compile_fail
{{#include examples/src/bin/typestate.rs:Example}}
```

<details>

- Pins don't implement `Copy` or `Clone`, so only one instance of each can
  exist. Once a pin is moved out of the port struct, nobody else can take it.
- Changing the configuration of a pin consumes the old pin instance, so you
  can't use the old instance afterwards.
- The type of a value indicates the state it is in: e.g., in this case, the
  configuration state of a GPIO pin. This encodes the state machine into the
  type system and ensures that you don't try to use a pin in a certain way
  without properly configuring it first. Illegal state transitions are caught at
  compile time.
- You can call `is_high` on an input pin and `set_high` on an output pin, but
  not vice-versa.
- Many HAL crates follow this pattern.

</details>



================================================
FILE: src/bare-metal/microcontrollers/examples/Cargo.toml
================================================
[workspace]

[package]
name = "microcontroller-examples"
version = "0.1.0"
edition = "2024"
publish = false

[dependencies]
cortex-m-rt = "0.7.5"
embedded-hal = "1.0.0"
microbit-v2 = "0.15.1"
nrf52833-hal = "0.18.0"
nrf52833-pac = { version = "0.12.2", features = ["rt"] }
panic-halt = "1.0.0"

[[bin]]
name = "board_support"

[[bin]]
name = "hal"

[[bin]]
name = "minimal"

[[bin]]
name = "mmio"

[[bin]]
name = "pac"

[[bin]]
name = "typestate"



================================================
FILE: src/bare-metal/microcontrollers/examples/Embed.toml
================================================
[default.general]
chip = "nrf52833_xxAA"

[debug.gdb]
enabled = true
gdb_connection_string = "127.0.0.1:1338"

[debug.reset]
halt_afterwards = true



================================================
FILE: src/bare-metal/microcontrollers/examples/.cargo/config.toml
================================================
[build]
target = "thumbv7em-none-eabihf" # Cortex-M4F

[target.'cfg(all(target_arch = "arm", target_os = "none"))']
rustflags = ["-C", "link-arg=-Tlink.x"]



================================================
FILE: src/bare-metal/useful-crates/aarch64-paging.md
================================================
# `aarch64-paging`

The [`aarch64-paging`][1] crate lets you create page tables according to the
AArch64 Virtual Memory System Architecture.

```rust,editable,compile_fail
use aarch64_paging::{
    idmap::IdMap,
    paging::{Attributes, MemoryRegion},
};

const ASID: usize = 1;
const ROOT_LEVEL: usize = 1;

// Create a new page table with identity mapping.
let mut idmap = IdMap::new(ASID, ROOT_LEVEL);
// Map a 2 MiB region of memory as read-only.
idmap.map_range(
    &MemoryRegion::new(0x80200000, 0x80400000),
    Attributes::NORMAL | Attributes::NON_GLOBAL | Attributes::READ_ONLY,
).unwrap();
// Set `TTBR0_EL1` to activate the page table.
idmap.activate();
```

<details>

- This is used in Android for the [Protected VM Firmware][2].
- There's no easy way to run this example by itself, as it needs to run on real
  hardware or under QEMU.

</details>

[1]: https://crates.io/crates/aarch64-paging
[2]: https://cs.android.com/android/platform/superproject/main/+/main:packages/modules/Virtualization/guest/pvmfw/



================================================
FILE: src/bare-metal/useful-crates/buddy_system_allocator.md
================================================
# `buddy_system_allocator`

[`buddy_system_allocator`][1] is a crate that implements a basic buddy system
allocator. It can be used both to implement [`GlobalAlloc`][3] (using
[`LockedHeap`][2]) so you can use the standard `alloc` crate (as we saw
[before][4]), or for allocating other address space (using
[`FrameAllocator`][5]) . For example, we might want to allocate MMIO space for
PCI BARs:

<!-- mdbook-xgettext: skip -->

```rust,editable,compile_fail
{{#include allocator-example/src/main.rs:main}}
```

<details>

- PCI BARs always have alignment equal to their size.
- Run the example with `cargo run` under
  `src/bare-metal/useful-crates/allocator-example/`. (It won't run in the
  Playground because of the crate dependency.)

</details>

[1]: https://crates.io/crates/buddy_system_allocator
[2]: https://docs.rs/buddy_system_allocator/0.9.0/buddy_system_allocator/struct.LockedHeap.html
[3]: https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html
[4]: ../alloc.md
[5]: https://docs.rs/buddy_system_allocator/0.9.0/buddy_system_allocator/struct.FrameAllocator.html



================================================
FILE: src/bare-metal/useful-crates/spin.md
================================================
# `spin`

`std::sync::Mutex` and the other synchronisation primitives from `std::sync` are
not available in `core` or `alloc`. How can we manage synchronisation or
interior mutability, such as for sharing state between different CPUs?

The [`spin`][1] crate provides spinlock-based equivalents of many of these
primitives.

<!-- mdbook-xgettext: skip -->

```rust,editable,compile_fail
use spin::mutex::SpinMutex;

static COUNTER: SpinMutex<u32> = SpinMutex::new(0);

fn main() {
    dbg!(COUNTER.lock());
    *COUNTER.lock() += 2;
    dbg!(COUNTER.lock());
}
```

<details>

- Be careful to avoid deadlock if you take locks in interrupt handlers.
- `spin` also has a ticket lock mutex implementation; equivalents of `RwLock`,
  `Barrier` and `Once` from `std::sync`; and `Lazy` for lazy initialization.
- The [`once_cell`][2] crate also has some useful types for late initialization
  with a slightly different approach to `spin::once::Once`.
- The Rust Playground includes `spin`, so this example will run fine inline.

</details>

[1]: https://crates.io/crates/spin
[2]: https://crates.io/crates/once_cell



================================================
FILE: src/bare-metal/useful-crates/tinyvec.md
================================================
# `tinyvec`

Sometimes you want something that can be resized like a `Vec`, but without heap
allocation. [`tinyvec`][1] provides this: a vector backed by an array or slice,
which could be statically allocated or on the stack, that keeps track of how
many elements are used and panics if you try to use more than are allocated.

<!-- mdbook-xgettext: skip -->

```rust,editable,compile_fail
use tinyvec::{ArrayVec, array_vec};

fn main() {
    let mut numbers: ArrayVec<[u32; 5]> = array_vec!(42, 66);
    println!("{numbers:?}");
    numbers.push(7);
    println!("{numbers:?}");
    numbers.remove(1);
    println!("{numbers:?}");
}
```

<details>

- `tinyvec` requires that the element type implement `Default` for
  initialization.
- The Rust Playground includes `tinyvec`, so this example will run fine inline.

</details>

[1]: https://crates.io/crates/tinyvec



================================================
FILE: src/bare-metal/useful-crates/zerocopy.md
================================================
# `zerocopy`

The [`zerocopy`][1] crate (from Fuchsia) provides traits and macros for safely
converting between byte sequences and other types.

<!-- mdbook-xgettext: skip -->

```rust,editable,compile_fail
{{#include zerocopy-example/src/main.rs:main}}
```

This is not suitable for MMIO (as it doesn't use volatile reads and writes), but
can be useful for working with structures shared with hardware e.g. by DMA, or
sent over some external interface.

<details>

- `FromBytes` can be implemented for types for which any byte pattern is valid,
  and so can safely be converted from an untrusted sequence of bytes.
- Attempting to derive `FromBytes` for these types would fail, because
  `RequestType` doesn't use all possible u32 values as discriminants, so not all
  byte patterns are valid.
- `zerocopy::byteorder` has types for byte-order aware numeric primitives.
- Run the example with `cargo run` under
  `src/bare-metal/useful-crates/zerocopy-example/`. (It won't run in the
  Playground because of the crate dependency.)

</details>

[1]: https://docs.rs/zerocopy/



================================================
FILE: src/bare-metal/useful-crates/allocator-example/Cargo.toml
================================================
[package]
name = "allocator-example"
version = "0.1.0"
edition = "2024"
publish = false

[dependencies]
buddy_system_allocator = "0.11.0"



================================================
FILE: src/bare-metal/useful-crates/allocator-example/src/main.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: main
use buddy_system_allocator::FrameAllocator;
use core::alloc::Layout;

fn main() {
    let mut allocator = FrameAllocator::<32>::new();
    allocator.add_frame(0x200_0000, 0x400_0000);

    let layout = Layout::from_size_align(0x100, 0x100).unwrap();
    let bar = allocator
        .alloc_aligned(layout)
        .expect("Failed to allocate 0x100 byte MMIO region");
    println!("Allocated 0x100 byte MMIO region at {:#x}", bar);
}



================================================
FILE: src/bare-metal/useful-crates/zerocopy-example/Cargo.toml
================================================
[package]
name = "zerocopy-example"
version = "0.1.0"
edition = "2024"
publish = false

[dependencies]
zerocopy = { version = "0.8.26", features = ["derive"] }



================================================
FILE: src/bare-metal/useful-crates/zerocopy-example/src/main.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![allow(dead_code)]

// ANCHOR: main
use zerocopy::{Immutable, IntoBytes};

#[repr(u32)]
#[derive(Debug, Default, Immutable, IntoBytes)]
enum RequestType {
    #[default]
    In = 0,
    Out = 1,
    Flush = 4,
}

#[repr(C)]
#[derive(Debug, Default, Immutable, IntoBytes)]
struct VirtioBlockRequest {
    request_type: RequestType,
    reserved: u32,
    sector: u64,
}

fn main() {
    let request = VirtioBlockRequest {
        request_type: RequestType::Flush,
        sector: 42,
        ..Default::default()
    };

    assert_eq!(
        request.as_bytes(),
        &[4, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0]
    );
}



================================================
FILE: src/borrowing/borrowck.md
================================================
---
minutes: 10
---

# Borrow Checking

Rust's _borrow checker_ puts constraints on the ways you can borrow values.
We've already seen that a reference cannot _outlive_ the value it borrows:

<!-- mdbook-xgettext: skip -->

```rust,editable,compile_fail
fn main() {
    let x_ref = {
        let x = 10;
        &x
    };
    dbg!(x_ref);
}
```

There's also a second main rule that the borrow checker enforces: The _aliasing_
rule. For a given value, at any time:

- You can have one or more shared references to the value, _or_
- You can have exactly one exclusive reference to the value.

<!-- mdbook-xgettext: skip -->

```rust,editable,compile_fail
fn main() {
    let mut a = 10;
    let b = &a;

    {
        let c = &mut a;
        *c = 20;
    }

    dbg!(a);
    dbg!(b);
}
```

<details>

- The "outlives" rule was demonstrated previously when we first looked at
  references. We review it here to show students that the borrow checking is
  following a few different rules to validate borrowing.
- The above code does not compile because `a` is borrowed as mutable (through
  `c`) and as immutable (through `b`) at the same time.
  - Note that the requirement is that conflicting references not _exist_ at the
    same point. It does not matter where the reference is dereferenced. Try
    commenting out `*c = 20` and show that the compiler error still occurs even
    if we never use `c`.
  - Note that the intermediate reference `c` isn't necessary to trigger a borrow
    conflict. Replace `c` with a direct mutation of `a` and demonstrate that
    this produces a similar error. This is because direct mutation of a value
    effectively creates a temporary mutable reference.
- Move the `dbg!` statement for `b` before the scope that introduces `c` to make
  the code compile.
  - After that change, the compiler realizes that `b` is only ever used before
    the new mutable borrow of `a` through `c`. This is a feature of the borrow
    checker called "non-lexical lifetimes".

## More to Explore

- Technically, multiple mutable references to a piece of data can exist at the
  same time via re-borrowing. This is what allows you to pass a mutable
  reference into a function without invalidating the original reference.
  [This playground example][1] demonstrates that behavior.
- Rust uses the exclusive reference constraint to ensure that data races do not
  occur in multi-threaded code, since only one thread can have mutable access to
  a piece of data at a time.
- Rust also uses this constraint to optimize code. For example, a value behind a
  shared reference can be safely cached in a register for the lifetime of that
  reference.
- Fields of a struct can be borrowed independently of each other, but calling a
  method on a struct will borrow the whole struct, potentially invalidating
  references to individual fields. See [this playground snippet][2] for an
  example of this.

</details>

[1]: https://play.rust-lang.org/?version=stable&mode=debug&edition=2024&gist=8f5896878611566845fe3b0f4dc5af68
[2]: https://play.rust-lang.org/?version=stable&mode=debug&edition=2024&gist=f293a31f2d4d0d31770486247c2e8437



================================================
FILE: src/borrowing/Cargo.toml
================================================
[package]
name = "borrowing"
version = "0.1.0"
edition = "2024"
publish = false

[lib]
name = "borrowing"
path = "../../third_party/rust-on-exercism/health-statistics.rs"



================================================
FILE: src/borrowing/examples.md
================================================
---
minutes: 3
---

# Borrow Errors

As a concrete example of how these borrowing rules prevent memory errors,
consider the case of modifying a collection while there are references to its
elements:

```rust,editable,compile_fail
fn main() {
    let mut vec = vec![1, 2, 3, 4, 5];
    let elem = &vec[2];
    vec.push(6);
    dbg!(elem);
}
```

Similarly, consider the case of iterator invalidation:

```rust,editable,compile_fail
fn main() {
    let mut vec = vec![1, 2, 3, 4, 5];
    for elem in &vec {
        vec.push(elem * 2);
    }
}
```

<details>

- In both of these cases, modifying the collection by pushing new elements into
  it can potentially invalidate existing references to the collection's elements
  if the collection has to reallocate.

</details>



================================================
FILE: src/borrowing/exercise.md
================================================
---
minutes: 20
---

# Exercise: Health Statistics

{{#include ../../third_party/rust-on-exercism/health-statistics.md}}

Copy the code below to <https://play.rust-lang.org/> and fill in the missing
method:

```rust,editable
{{#include ../../third_party/rust-on-exercism/health-statistics.rs:setup}}

{{#include ../../third_party/rust-on-exercism/health-statistics.rs:User_visit_doctor}}
        todo!("Update a user's statistics based on measurements from a visit to the doctor")
    }
}

{{#include ../../third_party/rust-on-exercism/health-statistics.rs:tests}}
```



================================================
FILE: src/borrowing/interior-mutability.md
================================================
---
minutes: 10
---

# Interior Mutability

In some situations, it's necessary to modify data behind a shared (read-only)
reference. For example, a shared data structure might have an internal cache,
and wish to update that cache from read-only methods.

The "interior mutability" pattern allows exclusive (mutable) access behind a
shared reference. The standard library provides several ways to do this, all
while still ensuring safety, typically by performing a runtime check.

<details>

The main thing to take away from this slide is that Rust provides _safe_ ways to
modify data behind a shared reference. There are a variety of ways to ensure
that safety, and the next sub-slides present a few of them.

</details>



================================================
FILE: src/borrowing/shared.md
================================================
---
minutes: 10
---

# Borrowing a Value

As we saw before, instead of transferring ownership when calling a function, you
can let a function _borrow_ the value:

<!-- mdbook-xgettext: skip -->

```rust,editable
#[derive(Debug)]
struct Point(i32, i32);

fn add(p1: &Point, p2: &Point) -> Point {
    Point(p1.0 + p2.0, p1.1 + p2.1)
}

fn main() {
    let p1 = Point(3, 4);
    let p2 = Point(10, 20);
    let p3 = add(&p1, &p2);
    println!("{p1:?} + {p2:?} = {p3:?}");
}
```

- The `add` function _borrows_ two points and returns a new point.
- The caller retains ownership of the inputs.

<details>

This slide is a review of the material on references from day 1, expanding
slightly to include function arguments and return values.

# More to Explore

Notes on stack returns and inlining:

- Demonstrate that the return from `add` is cheap because the compiler can
  eliminate the copy operation, by inlining the call to add into main. Change
  the above code to print stack addresses and run it on the [Playground] or look
  at the assembly in [Godbolt](https://rust.godbolt.org/). In the "DEBUG"
  optimization level, the addresses should change, while they stay the same when
  changing to the "RELEASE" setting:

  <!-- mdbook-xgettext: skip -->
  ```rust,editable
  #[derive(Debug)]
  struct Point(i32, i32);

  fn add(p1: &Point, p2: &Point) -> Point {
      let p = Point(p1.0 + p2.0, p1.1 + p2.1);
      println!("&p.0: {:p}", &p.0);
      p
  }

  pub fn main() {
      let p1 = Point(3, 4);
      let p2 = Point(10, 20);
      let p3 = add(&p1, &p2);
      println!("&p3.0: {:p}", &p3.0);
      println!("{p1:?} + {p2:?} = {p3:?}");
  }
  ```
- The Rust compiler can do automatic inlining, that can be disabled on a
  function level with `#[inline(never)]`.
- Once disabled, the printed address will change on all optimization levels.
  Looking at Godbolt or Playground, one can see that in this case, the return of
  the value depends on the ABI, e.g. on amd64 the two i32 that is making up the
  point will be returned in 2 registers (eax and edx).

</details>

[Playground]: https://play.rust-lang.org/?version=stable&mode=release&edition=2024&gist=0cb13be1c05d7e3446686ad9947c4671



================================================
FILE: src/borrowing/solution.md
================================================
# Solution

```rust,editable
{{#include ../../third_party/rust-on-exercism/health-statistics.rs:solution}}
```



================================================
FILE: src/borrowing/interior-mutability/cell.md
================================================
# `Cell`

`Cell` wraps a value and allows getting or setting the value using only a shared
reference to the `Cell`. However, it does not allow any references to the inner
value. Since there are no references, borrowing rules cannot be broken.

```rust,editable
use std::cell::Cell;

fn main() {
    // Note that `cell` is NOT declared as mutable.
    let cell = Cell::new(5);

    cell.set(123);
    dbg!(cell.get());
}
```

<details>

- `Cell` is a simple means to ensure safety: it has a `set` method that takes
  `&self`. This needs no runtime check, but requires moving values, which can
  have its own cost.

</details>



================================================
FILE: src/borrowing/interior-mutability/refcell.md
================================================
# `RefCell`

`RefCell` allows accessing and mutating a wrapped value by providing alternative
types `Ref` and `RefMut` that emulate `&T`/`&mut T` without actually being Rust
references.

These types perform dynamic checks using a counter in the `RefCell` to prevent
existence of a `RefMut` alongside another `Ref`/`RefMut`.

By implementing `Deref` (and `DerefMut` for `RefMut`), these types allow calling
methods on the inner value without allowing references to escape.

```rust,editable
use std::cell::RefCell;

fn main() {
    // Note that `cell` is NOT declared as mutable.
    let cell = RefCell::new(5);

    {
        let mut cell_ref = cell.borrow_mut();
        *cell_ref = 123;

        // This triggers an error at runtime.
        // let other = cell.borrow();
        // println!("{}", other);
    }

    println!("{cell:?}");
}
```

<details>

- `RefCell` enforces Rust's usual borrowing rules (either multiple shared
  references or a single exclusive reference) with a runtime check. In this
  case, all borrows are very short and never overlap, so the checks always
  succeed.

- The extra block in the example is to end the borrow created by the call to
  `borrow_mut` before we print the cell. Trying to print a borrowed `RefCell`
  just shows the message `"{borrowed}"`.

## More to Explore

There are also `OnceCell` and `OnceLock`, which allow initialization on first
use. Making these useful requires some more knowledge than students have at this
time.

</details>



================================================
FILE: src/cargo/code-samples.md
================================================
# Code Samples in This Training

For this training, we will mostly explore the Rust language through examples
which can be executed through your browser. This makes the setup much easier and
ensures a consistent experience for everyone.

Installing Cargo is still encouraged: it will make it easier for you to do the
exercises. On the last day, we will do a larger exercise that shows you how to
work with dependencies and for that you need Cargo.

The code blocks in this course are fully interactive:

```rust,editable
fn main() {
    println!("Edit me!");
}
```

You can use <kbd>Ctrl</kbd> + <kbd>Enter</kbd> to execute the code when focus is
in the text box.

<details>

Most code samples are editable like shown above. A few code samples are not
editable for various reasons:

- The embedded playgrounds cannot execute unit tests. Copy-paste the code and
  open it in the real Playground to demonstrate unit tests.

- The embedded playgrounds lose their state the moment you navigate away from
  the page! This is the reason that the students should solve the exercises
  using a local Rust installation or via the Playground.

</details>



================================================
FILE: src/cargo/running-locally.md
================================================
# Running Code Locally with Cargo

If you want to experiment with the code on your own system, then you will need
to first install Rust. Do this by following the
[instructions in the Rust Book][1]. This should give you a working `rustc` and
`cargo`. At the time of writing, the latest stable Rust release has these
version numbers:

```shell
% rustc --version
rustc 1.69.0 (84c898d65 2023-04-16)
% cargo --version
cargo 1.69.0 (6e9a83356 2023-04-12)
```

You can use any later version too since Rust maintains backwards compatibility.

With this in place, follow these steps to build a Rust binary from one of the
examples in this training:

1. Click the "Copy to clipboard" button on the example you want to copy.

2. Use `cargo new exercise` to create a new `exercise/` directory for your code:

   ```shell
   $ cargo new exercise
        Created binary (application) `exercise` package
   ```

3. Navigate into `exercise/` and use `cargo run` to build and run your binary:

   ```shell
   $ cd exercise
   $ cargo run
      Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)
       Finished dev [unoptimized + debuginfo] target(s) in 0.75s
        Running `target/debug/exercise`
   Hello, world!
   ```

4. Replace the boilerplate code in `src/main.rs` with your own code. For
   example, using the example on the previous page, make `src/main.rs` look like

   ```rust
   fn main() {
       println!("Edit me!");
   }
   ```

5. Use `cargo run` to build and run your updated binary:

   ```shell
   $ cargo run
      Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)
       Finished dev [unoptimized + debuginfo] target(s) in 0.24s
        Running `target/debug/exercise`
   Edit me!
   ```

6. Use `cargo check` to quickly check your project for errors, use `cargo build`
   to compile it without running it. You will find the output in `target/debug/`
   for a normal debug build. Use `cargo build --release` to produce an optimized
   release build in `target/release/`.

7. You can add dependencies for your project by editing `Cargo.toml`. When you
   run `cargo` commands, it will automatically download and compile missing
   dependencies for you.

[1]: https://doc.rust-lang.org/book/ch01-01-installation.html

<details>

Try to encourage the class participants to install Cargo and use a local editor.
It will make their life easier since they will have a normal development
environment.

</details>



================================================
FILE: src/cargo/rust-ecosystem.md
================================================
# The Rust Ecosystem

The Rust ecosystem consists of a number of tools, of which the main ones are:

- `rustc`: the Rust compiler that turns `.rs` files into binaries and other
  intermediate formats.

- `cargo`: the Rust dependency manager and build tool. Cargo knows how to
  download dependencies, usually hosted on <https://crates.io>, and it will pass
  them to `rustc` when building your project. Cargo also comes with a built-in
  test runner which is used to execute unit tests.

- `rustup`: the Rust toolchain installer and updater. This tool is used to
  install and update `rustc` and `cargo` when new versions of Rust are released.
  In addition, `rustup` can also download documentation for the standard
  library. You can have multiple versions of Rust installed at once and `rustup`
  will let you switch between them as needed.

<details>

Key points:

- Rust has a rapid release schedule with a new release coming out every six
  weeks. New releases maintain backwards compatibility with old releases ---
  plus they enable new functionality.

- There are three release channels: "stable", "beta", and "nightly".

- New features are being tested on "nightly", "beta" is what becomes "stable"
  every six weeks.

- Dependencies can also be resolved from alternative [registries], git, folders,
  and more.

- Rust also has [editions]: the current edition is Rust 2024. Previous editions
  were Rust 2015, Rust 2018 and Rust 2021.

  - The editions are allowed to make backwards incompatible changes to the
    language.

  - To prevent breaking code, editions are opt-in: you select the edition for
    your crate via the `Cargo.toml` file.

  - To avoid splitting the ecosystem, Rust compilers can mix code written for
    different editions.

  - Mention that it is quite rare to ever use the compiler directly not through
    `cargo` (most users never do).

  - It might be worth alluding that Cargo itself is an extremely powerful and
    comprehensive tool. It is capable of many advanced features including but
    not limited to:
    - Project/package structure
    - [workspaces]
    - Dev Dependencies and Runtime Dependency management/caching
    - [build scripting]
    - [global installation]
    - It is also extensible with sub command plugins as well (such as
      [cargo clippy]).
  - Read more from the [official Cargo Book]

[editions]: https://doc.rust-lang.org/edition-guide/
[workspaces]: https://doc.rust-lang.org/cargo/reference/workspaces.html
[build scripting]: https://doc.rust-lang.org/cargo/reference/build-scripts.html
[global installation]: https://doc.rust-lang.org/cargo/commands/cargo-install.html
[cargo clippy]: https://github.com/rust-lang/rust-clippy
[official Cargo Book]: https://doc.rust-lang.org/cargo/
[registries]: https://doc.rust-lang.org/cargo/reference/registries.html

</details>



================================================
FILE: src/chromium/adding-third-party-crates.md
================================================
# Adding Third Party Crates

Rust libraries are called "crates" and are found at [crates.io][0]. It's _very
easy_ for Rust crates to depend upon one another. So they do!

| Property                | C++ library | Rust crate               |
| ----------------------- | ----------- | ------------------------ |
| Build system            | Lots        | Consistent: `Cargo.toml` |
| Typical library size    | Large-ish   | Small                    |
| Transitive dependencies | Few         | Lots                     |

For a Chromium engineer, this has pros and cons:

- All crates use a common build system so we can automate their inclusion into
  Chromium...
- ... but, crates typically have transitive dependencies, so you will likely
  have to bring in multiple libraries.

We'll discuss:

- How to put a crate in the Chromium source code tree
- How to make `gn` build rules for it
- How to audit its source code for sufficient safety.

[0]: https://crates.io

<details>
All of the things in the table on this slide are generalizations, and
counter-examples can be found. But in general it's important for students
to understand that most Rust code depends on other Rust libraries, because
it's easy to do so, and that this has both benefits and costs.
</details>



================================================
FILE: src/chromium/build-rules.md
================================================
# Build rules

Rust code is usually built using `cargo`. Chromium builds with `gn` and `ninja`
for efficiency --- its static rules allow maximum parallelism. Rust is no
exception.

## Adding Rust code to Chromium

In some existing Chromium `BUILD.gn` file, declare a `rust_static_library`:

```gn
import("//build/rust/rust_static_library.gni")

rust_static_library("my_rust_lib") {
  crate_root = "lib.rs"
  sources = [ "lib.rs" ]
}
```

You can also add `deps` on other Rust targets. Later we'll use this to depend
upon third party code.

<details>

You must specify _both_ the crate root, _and_ a full list of sources. The
`crate_root` is the file given to the Rust compiler representing the root file
of the compilation unit --- typically `lib.rs`. `sources` is a complete list of
all source files which `ninja` needs in order to determine when rebuilds are
necessary.

(There's no such thing as a Rust `source_set`, because in Rust, an entire crate
is a compilation unit. A `static_library` is the smallest unit.)

Students might be wondering why we need a gn template, rather than using
[gn's built-in support for Rust static libraries][0]. The answer is that this
template provides support for CXX interop, Rust features, and unit tests, some
of which we'll use later.

</details>

[0]: https://gn.googlesource.com/gn/+/main/docs/reference.md#func_static_library



================================================
FILE: src/chromium/cargo.md
================================================
# Comparing Chromium and Cargo Ecosystems

The Rust community typically uses `cargo` and libraries from [crates.io][2].
Chromium is built using `gn` and `ninja` and a curated set of dependencies.

When writing code in Rust, your choices are:

- Use `gn` and `ninja` with the help of the templates from `//build/rust/*.gni`
  (e.g. `rust_static_library` that we'll meet later). This uses Chromium's
  audited toolchain and crates.
- Use `cargo`, but
  [restrict yourself to Chromium's audited toolchain and crates][0]
- Use `cargo`, trusting a [toolchain][1] and/or
  [crates downloaded from the internet][2]

From here on we'll be focusing on `gn` and `ninja`, because this is how Rust
code can be built into the Chromium browser. At the same time, Cargo is an
important part of the Rust ecosystem and you should keep it in your toolbox.

## Mini exercise

Split into small groups and:

- Brainstorm scenarios where `cargo` may offer an advantage and assess the risk
  profile of these scenarios.
- Discuss which tools, libraries, and groups of people need to be trusted when
  using `gn` and `ninja`, offline `cargo`, etc.

<details>

Ask students to avoid peeking at the speaker notes before completing the
exercise. Assuming folks taking the course are physically together, ask them to
discuss in small groups of 3-4 people.

Notes/hints related to the first part of the exercise ("scenarios where Cargo
may offer an advantage"):

- It's fantastic that when writing a tool, or prototyping a part of Chromium,
  one has access to the rich ecosystem of crates.io libraries. There is a crate
  for almost anything and they are usually quite pleasant to use. (`clap` for
  command-line parsing, `serde` for serializing/deserializing to/from various
  formats, `itertools` for working with iterators, etc.).

  - `cargo` makes it easy to try a library (just add a single line to
    `Cargo.toml` and start writing code)
  - It may be worth comparing how CPAN helped make `perl` a popular choice. Or
    comparing with `python` + `pip`.

- Development experience is made really nice not only by core Rust tools (e.g.
  using `rustup` to switch to a different `rustc` version when testing a crate
  that needs to work on nightly, current stable, and older stable) but also by
  an ecosystem of third-party tools (e.g. Mozilla provides `cargo vet` for
  streamlining and sharing security audits; `criterion` crate gives a
  streamlined way to run benchmarks).

  - `cargo` makes it easy to add a tool via `cargo install --locked cargo-vet`.
  - It may be worth comparing with Chrome Extensions or VScode extensions.

- Broad, generic examples of projects where `cargo` may be the right choice:

  - Perhaps surprisingly, Rust is becoming increasingly popular in the industry
    for writing command line tools. The breadth and ergonomics of libraries is
    comparable to Python, while being more robust (thanks to the rich type
    system) and running faster (as a compiled, rather than interpreted
    language).
  - Participating in the Rust ecosystem requires using standard Rust tools like
    Cargo. Libraries that want to get external contributions, and want to be
    used outside of Chromium (e.g. in Bazel or Android/Soong build environments)
    should probably use Cargo.

- Examples of Chromium-related projects that are `cargo`-based:
  - `serde_json_lenient` (experimented with in other parts of Google which
    resulted in PRs with performance improvements)
  - Fontations libraries like `font-types`
  - `gnrt` tool (we will meet it later in the course) which depends on `clap`
    for command-line parsing and on `toml` for configuration files.
    - Disclaimer: a unique reason for using `cargo` was unavailability of `gn`
      when building and bootstrapping Rust standard library when building Rust
      toolchain.
    - `run_gnrt.py` uses Chromium's copy of `cargo` and `rustc`. `gnrt` depends
      on third-party libraries downloaded from the internet, but `run_gnrt.py`
      asks `cargo` that only `--locked` content is allowed via `Cargo.lock`.)

Students may identify the following items as being implicitly or explicitly
trusted:

- `rustc` (the Rust compiler) which in turn depends on the LLVM libraries, the
  Clang compiler, the `rustc` sources (fetched from GitHub, reviewed by Rust
  compiler team), binary Rust compiler downloaded for bootstrapping
- `rustup` (it may be worth pointing out that `rustup` is developed under the
  umbrella of the https://github.com/rust-lang/ organization - same as `rustc`)
- `cargo`, `rustfmt`, etc.
- Various internal infrastructure (bots that build `rustc`, system for
  distributing the prebuilt toolchain to Chromium engineers, etc.)
- Cargo tools like `cargo audit`, `cargo vet`, etc.
- Rust libraries vendored into `//third_party/rust` (audited by
  security@chromium.org)
- Other Rust libraries (some niche, some quite popular and commonly used)

</details>

[0]: https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/rust.md#Using-cargo
[1]: https://rustup.rs/
[2]: https://crates.io/



================================================
FILE: src/chromium/interoperability-with-cpp.md
================================================
# Interoperability with C++

The Rust community offers multiple options for C++/Rust interop, with new tools
being developed all the time. At the moment, Chromium uses a tool called CXX.

You describe your whole language boundary in an interface definition language
(which looks a lot like Rust) and then CXX tools generate declarations for
functions and types in both Rust and C++.

<img src="../android/interoperability/cpp/overview.svg" alt="Overview diagram of cxx, showing that the same interface definition is used to create both C++ and Rust side code which then communicate via a lowest common denominator C API">

See the [CXX tutorial][1] for a full example of using this.

[1]: https://cxx.rs/tutorial.html
[2]: https://cxx.rs/bindings.html

<details>

Talk through the diagram. Explain that behind the scenes, this is doing just the
same as you previously did. Point out that automating the process has the
following benefits:

- The tool guarantees that the C++ and Rust sides match (e.g. you get compile
  errors if the `#[cxx::bridge]` doesn't match the actual C++ or Rust
  definitions, but with out-of-sync manual bindings you'd get Undefined
  Behavior)
- The tool automates generation of FFI thunks (small, C-ABI-compatible, free
  functions) for non-C features (e.g. enabling FFI calls into Rust or C++
  methods; manual bindings would require authoring such top-level, free
  functions manually)
- The tool and the library can handle a set of core types - for example:
  - `&[T]` can be passed across the FFI boundary, even though it doesn't
    guarantee any particular ABI or memory layout. With manual bindings
    `std::span<T>` / `&[T]` have to be manually destructured and rebuilt out of
    a pointer and length - this is error-prone given that each language
    represents empty slices slightly differently)
  - Smart pointers like `std::unique_ptr<T>`, `std::shared_ptr<T>`, and/or `Box`
    are natively supported. With manual bindings, one would have to pass
    C-ABI-compatible raw pointers, which would increase lifetime and
    memory-safety risks.
  - `rust::String` and `CxxString` types understand and maintain differences in
    string representation across the languages (e.g. `rust::String::lossy` can
    build a Rust string from non-UTF-8 input and `rust::String::c_str` can
    NUL-terminate a string).

</details>



================================================
FILE: src/chromium/policy.md
================================================
# Chromium Rust policy

Chromium's Rust policy can be found
[here](https://source.chromium.org/chromium/chromium/src/+/main:docs/rust.md;l=22).
Rust can be used for both first-party and third-party code.

Using Rust for pure first-party code looks like this:

```bob
"C++"                           Rust
.- - - - - - - - - -.           .- - - - - - - - - - -.
:                   :           :                     :
: Existing Chromium :           :  Chromium Rust      :
: "C++"             :           :  code               :
: +---------------+ :           : +----------------+  :
: |               | :           : |                |  :
: |         o-----+-+-----------+-+->              |  :
: |               | : Language  : |                |  :
: +---------------+ : boundary  : +----------------+  :
:                   :           :                     :
`- - - - - - - - - -'           `- - - - - - - - - - -'
```

The third-party case is also common. It's likely that you'll also need a small
amount of first-party glue code, because very few Rust libraries directly expose
a C/C++ API.

```bob
"C++"                           Rust
.- - - - - - - - - -.           .- - - - - - - - - - - - - - - - - - - - - - -.
:                   :           :                                             :
: Existing Chromium :           :  Chromium Rust              Existing Rust   :
: "C++"             :           :  "wrapper"                  crate           :
: +---------------+ :           : +----------------+          +-------------+ :
: |               | :           : |                |          |             | :
: |         o-----+-+-----------+-+->            o-+----------+-->          | :
: |               | : Language  : |                | Crate    |             | :
: +---------------+ : boundary  : +----------------+ API      +-------------+ :
:                   :           :                                             :
`- - - - - - - - - -'           `- - - - - - - - - - - - - - - - - - - - - - -'
```

The scenario of using a third-party crate is the more complex one, so today's
course will focus on:

- Bringing in third-party Rust libraries ("crates")
- Writing glue code to be able to use those crates from Chromium C++. (The same
  techniques are used when working with first-party Rust code).



================================================
FILE: src/chromium/setup.md
================================================
# Setup

Make sure you can build and run Chromium. Any platform and set of build flags is
OK, so long as your code is relatively recent (commit position 1223636 onwards,
corresponding to November 2023):

```shell
gn gen out/Debug
autoninja -C out/Debug chrome
out/Debug/chrome # or on Mac, out/Debug/Chromium.app/Contents/MacOS/Chromium
```

(A component, debug build is recommended for quickest iteration time. This is
the default!)

See
[How to build Chromium](https://www.chromium.org/developers/how-tos/get-the-code/)
if you aren't already at that point. Be warned: setting up to build Chromium
takes time.

It's also recommended that you have Visual Studio code installed.

# About the exercises

This part of the course has a series of exercises that build on each other.
We'll be doing them spread throughout the course instead of just at the end. If
you don't have time to complete a certain part, don't worry: you can catch up in
the next slot.



================================================
FILE: src/chromium/testing.md
================================================
# Testing

Rust community typically authors unit tests in a module placed in the same
source file as the code being tested. This was covered [earlier](../testing.md)
in the course and looks like this:

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn my_test() {
        todo!()
    }
}
```

In Chromium we place unit tests in a separate source file and we continue to
follow this practice for Rust --- this makes tests consistently discoverable and
helps to avoid rebuilding `.rs` files a second time (in the `test`
configuration).

This results in the following options for testing Rust code in Chromium:

- Native Rust tests (i.e. `#[test]`). Discouraged outside of
  `//third_party/rust`.
- `gtest` tests authored in C++ and exercising Rust via FFI calls. Sufficient
  when Rust code is just a thin FFI layer and the existing unit tests provide
  sufficient coverage for the feature.
- `gtest` tests authored in Rust and using the crate under test through its
  public API (using `pub mod for_testing { ... }` if needed). This is the
  subject of the next few slides.

<details>

Mention that native Rust tests of third-party crates should eventually be
exercised by Chromium bots. (Such testing is needed rarely --- only after adding
or updating third-party crates.)

Some examples may help illustrate when C++ `gtest` vs Rust `gtest` should be
used:

- QR has very little functionality in the first-party Rust layer (it's just a
  thin FFI glue) and therefore uses the existing C++ unit tests for testing both
  the C++ and the Rust implementation (parameterizing the tests so they enable
  or disable Rust using a `ScopedFeatureList`).

- Hypothetical/WIP PNG integration may need memory-safe implementations of pixel
  transformations that are provided by `libpng` but missing in the `png` crate -
  e.g. RGBA => BGRA, or gamma correction. Such functionality may benefit from
  separate tests authored in Rust.

</details>



================================================
FILE: src/chromium/adding-third-party-crates/checking-in.md
================================================
# Checking Crates into Chromium Source Code

`git status` should reveal:

- Crate code in `//third_party/rust/chromium_crates_io`
- Metadata (`BUILD.gn` and `README.chromium`) in
  `//third_party/rust/<crate>/<version>`

Please also add an `OWNERS` file in the latter location.

You should land all this, along with your `Cargo.toml` and `gnrt_config.toml`
changes, into the Chromium repo.

**Important:** you need to use `git add -f` because otherwise `.gitignore` files
may result in some files being skipped.

As you do so, you might find presubmit checks fail because of non-inclusive
language. This is because Rust crate data tends to include names of git
branches, and many projects still use non-inclusive terminology there. So you
may need to run:

```shell
infra/update_inclusive_language_presubmit_exempt_dirs.sh > infra/inclusive_language_presubmit_exempt_dirs.txt
git add -p infra/inclusive_language_presubmit_exempt_dirs.txt # add whatever changes are yours
```



================================================
FILE: src/chromium/adding-third-party-crates/configuring-cargo-toml.md
================================================
# Configuring the `Cargo.toml` file to add crates

Chromium has a single set of centrally-managed direct crate dependencies. These
are managed through a single [`Cargo.toml`][0]:

```toml
[dependencies]
bitflags = "1"
cfg-if = "1"
cxx = "1"
# lots more...
```

As with any other `Cargo.toml`, you can specify
[more details about the dependencies][1] --- most commonly, you'll want to
specify the `features` that you wish to enable in the crate.

When adding a crate to Chromium, you'll often need to provide some extra
information in an additional file, `gnrt_config.toml`, which we'll meet next.

[0]: https://source.chromium.org/chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/Cargo.toml
[1]: https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html



================================================
FILE: src/chromium/adding-third-party-crates/configuring-gnrt-config-toml.md
================================================
# Configuring `gnrt_config.toml`

Alongside `Cargo.toml` is [`gnrt_config.toml`][0]. This contains
Chromium-specific extensions to crate handling.

If you add a new crate, you should specify at least the `group`. This is one of:

```toml
#   'safe': The library satisfies the rule-of-2 and can be used in any process.
#   'sandbox': The library does not satisfy the rule-of-2 and must be used in
#              a sandboxed process such as the renderer or a utility process.
#   'test': The library is only used in tests.
```

For instance,

```toml
[crate.my-new-crate]
group = 'test' # only used in test code
```

Depending on the crate source code layout, you may also need to use this file to
specify where its `LICENSE` file(s) can be found.

Later, we'll see some other things you will need to configure in this file to
resolve problems.

[0]: https://source.chromium.org/chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/gnrt_config.toml



================================================
FILE: src/chromium/adding-third-party-crates/depending-on-a-crate.md
================================================
# Depending on a Crate

Once you've added a third-party crate and generated build rules, depending on a
crate is simple. Find your `rust_static_library` target, and add a `dep` on the
`:lib` target within your crate.

Specifically,

```bob
                     +------------+      +----------------------+
"//third_party/rust" | crate name | "/v" | major semver version | ":lib"
                     +------------+      +----------------------+
```

For instance,

```gn
rust_static_library("my_rust_lib") {
  crate_root = "lib.rs"
  sources = [ "lib.rs" ]
  deps = [ "//third_party/rust/example_rust_crate/v1:lib" ]
}
```



================================================
FILE: src/chromium/adding-third-party-crates/downloading-crates.md
================================================
# Downloading Crates

A tool called `gnrt` knows how to download crates and how to generate `BUILD.gn`
rules.

To start, download the crate you want like this:

```shell
cd chromium/src
vpython3 tools/crates/run_gnrt.py -- vendor
```

> Although the `gnrt` tool is part of the Chromium source code, by running this
> command you will be downloading and running its dependencies from `crates.io`.
> See [the earlier section][0] discussing this security decision.

This `vendor` command may download:

- Your crate
- Direct and transitive dependencies
- New versions of other crates, as required by `cargo` to resolve the complete
  set of crates required by Chromium.

Chromium maintains patches for some crates, kept in
`//third_party/rust/chromium_crates_io/patches`. These will be reapplied
automatically, but if patching fails you may need to take manual action.

[0]: ../cargo.md



================================================
FILE: src/chromium/adding-third-party-crates/generating-gn-build-rules.md
================================================
# Generating `gn` Build Rules

Once you've downloaded the crate, generate the `BUILD.gn` files like this:

```shell
vpython3 tools/crates/run_gnrt.py -- gen
```

Now run `git status`. You should find:

- At least one new crate source code in
  `third_party/rust/chromium_crates_io/vendor`
- At least one new `BUILD.gn` in
  `third_party/rust/<crate name>/v<major semver version>`
- An appropriate `README.chromium`

The "major semver version" is a [Rust "semver" version number][0].

Take a close look, especially at the things generated in `third_party/rust`.

<details>

Talk a little about semver --- and specifically the way that in Chromium it's to
allow multiple incompatible versions of a crate, which is discouraged but
sometimes necessary in the Cargo ecosystem.

</detail>

[0]: https://doc.rust-lang.org/cargo/reference/semver.html



================================================
FILE: src/chromium/adding-third-party-crates/keeping-up-to-date.md
================================================
# Keeping Crates Up to Date

As the OWNER of any third party Chromium dependency, you are
[expected to keep it up to date with any security fixes][0]. It is hoped that we
will soon automate this for Rust crates, but for now, it's still your
responsibility just as it is for any other third party dependency.

[0]: https://chromium.googlesource.com/chromium/src/+/main/docs/adding_to_third_party.md#add-owners



================================================
FILE: src/chromium/adding-third-party-crates/resolving-problems.md
================================================
# Resolving Problems

If your build fails, it may be because of a `build.rs`: programs which do
arbitrary things at build time. This is fundamentally at odds with the design of
`gn` and `ninja` which aim for static, deterministic, build rules to maximize
parallelism and repeatability of builds.

Some `build.rs` actions are automatically supported; others require action:

| build script effect                                       | Supported by our gn templates | Work required by you                |
| --------------------------------------------------------- | ----------------------------- | ----------------------------------- |
| Checking rustc version to configure features on and off   | Yes                           | None                                |
| Checking platform or CPU to configure features on and off | Yes                           | None                                |
| Generating code                                           | Yes                           | Yes - specify in `gnrt_config.toml` |
| Building C/C++                                            | No                            | Patch around it                     |
| Arbitrary other actions                                   | No                            | Patch around it                     |

Fortunately, most crates don't contain a build script, and fortunately, most
build scripts only do the top two actions.

[0]: https://doc.rust-lang.org/cargo/reference/build-scripts.html



================================================
FILE: src/chromium/adding-third-party-crates/reviews-and-audits.md
================================================
# Auditing Third Party Crates

Adding new libraries is subject to Chromium's standard [policies][0], but of
course also subject to security review. As you may be bringing in not just a
single crate but also transitive dependencies, there may be a lot of code to
review. On the other hand, safe Rust code can have limited negative side
effects. How should you review it?

Over time Chromium aims to move to a process based around [cargo vet][1].

Meanwhile, for each new crate addition, we are checking for the following:

- Understand why each crate is used. What's the relationship between crates? If
  the build system for each crate contains a `build.rs` or procedural macros,
  work out what they're for. Are they compatible with the way Chromium is
  normally built?
- Check each crate seems to be reasonably well maintained
- Use `cd third-party/rust/chromium_crates_io; cargo audit` to check for known
  vulnerabilities (first you'll need to `cargo install cargo-audit`, which
  ironically involves downloading lots of dependencies from the internet[2])
- Ensure any `unsafe` code is good enough for the [Rule of Two][3]
- Check for any use of `fs` or `net` APIs
- Read all the code at a sufficient level to look for anything out of place that
  might have been maliciously inserted. (You can't realistically aim for 100%
  perfection here: there's often just too much code.)

These are just guidelines --- work with reviewers from `security@chromium.org`
to work out the right way to become confident of the crate.

[0]: https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/rust.md#Third_party-review
[1]: https://mozilla.github.io/cargo-vet/
[2]: ../cargo.md
[3]: https://chromium.googlesource.com/chromium/src/+/main/docs/security/rule-of-2.md#unsafe-code-in-safe-languages



================================================
FILE: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.md
================================================
# Build Scripts Which Generate Code

If `ninja` complains about missing files, check the `build.rs` to see if it
writes source code files.

If so, modify [`gnrt_config.toml`][1] to add `build-script-outputs` to the
crate. If this is a transitive dependency, that is, one on which Chromium code
should not directly depend, also add `allow-first-party-usage=false`. There are
several examples already in that file:

```toml
[crate.unicode-linebreak]
allow-first-party-usage = false
build-script-outputs = ["tables.rs"]
```

Now rerun [`gnrt.py -- gen`][2] to regenerate `BUILD.gn` files to inform ninja
that this particular output file is input to subsequent build steps.

[1]: ../configuring-gnrt-config-toml.md
[2]: ../generating-gn-build-rules.md



================================================
FILE: src/chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.md
================================================
# Build Scripts Which Build C++ or Take Arbitrary Actions

Some crates use the [`cc`][1] crate to build and link C/C++ libraries. Other
crates parse C/C++ using [`bindgen`][2] within their build scripts. These
actions can't be supported in a Chromium context --- our gn, ninja and LLVM
build system is very specific in expressing relationships between build actions.

So, your options are:

- Avoid these crates
- Apply a patch to the crate.

Patches should be kept in
`third_party/rust/chromium_crates_io/patches/<crate>` - see for example the
[patches against the `cxx` crate][3] - and will be applied automatically by
`gnrt` each time it upgrades the crate.

[1]: https://crates.io/crates/cc
[2]: https://crates.io/crates/bindgen
[3]: https://source.chromium.org/chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/patches/cxx/



================================================
FILE: src/chromium/build-rules/depending.md
================================================
# Depending on Rust Code from Chromium C++

Simply add the above target to the `deps` of some Chromium C++ target.

```gn
import("//build/rust/rust_static_library.gni")

rust_static_library("my_rust_lib") {
  crate_root = "lib.rs"
  sources = [ "lib.rs" ]
}

# or source_set, static_library etc.
component("preexisting_cpp") {
  deps = [ ":my_rust_lib" ]
}
```

<details>
We'll see that this relationship only works if the Rust code exposes plain C APIs
which can be called from C++, or if we use a C++/Rust interop tool.
</details>



================================================
FILE: src/chromium/build-rules/unsafe.md
================================================
# Including `unsafe` Rust Code

Unsafe Rust code is forbidden in `rust_static_library` by default --- it won't
compile. If you need unsafe Rust code, add `allow_unsafe = true` to the gn
target. (Later in the course we'll see circumstances where this is necessary.)

```gn
import("//build/rust/rust_static_library.gni")

rust_static_library("my_rust_lib") {
  crate_root = "lib.rs"
  sources = [
    "lib.rs",
    "hippopotamus.rs"
  ]
  allow_unsafe = true
}
```



================================================
FILE: src/chromium/build-rules/vscode.md
================================================
# Visual Studio Code

Types are elided in Rust code, which makes a good IDE even more useful than for
C++. Visual Studio code works well for Rust in Chromium. To use it,

- Ensure your VSCode has the `rust-analyzer` extension, not earlier forms of
  Rust support
- `gn gen out/Debug --export-rust-project` (or equivalent for your output
  directory)
- `ln -s out/Debug/rust-project.json rust-project.json`

<img src="vscode.png" style="border: 1px solid black;" alt="Example screenshot from VSCode">

<details>

A demo of some of the code annotation and exploration features of rust-analyzer
might be beneficial if the audience are naturally skeptical of IDEs.

The following steps may help with the demo (but feel free to instead use a piece
of Chromium-related Rust that you are most familiar with):

- Open `components/qr_code_generator/qr_code_generator_ffi_glue.rs`
- Place the cursor over the `QrCode::new` call (around line 26) in
  `qr_code_generator_ffi_glue.rs
- Demo **show documentation** (typical bindings: vscode = ctrl k i; vim/CoC =
  K).
- Demo **go to definition** (typical bindings: vscode = F12; vim/CoC = g d).
  (This will take you to `//third_party/rust/.../qr_code-.../src/lib.rs`.)
- Demo **outline** and navigate to the `QrCode::with_bits` method (around line
  164; the outline is in the file explorer pane in vscode; typical vim/CoC
  bindings = space o)
- Demo **type annotations** (there are quite a few nice examples in the
  `QrCode::with_bits` method)

It may be worth pointing out that `gn gen ... --export-rust-project` will need
to be rerun after editing `BUILD.gn` files (which we will do a few times
throughout the exercises in this session).

</details>



================================================
FILE: src/chromium/interoperability-with-cpp/error-handling-png.md
================================================
# CXX Error Handling: PNG Example

A prototype of a PNG decoder illustrates what can be done when the successful
result cannot be passed across the FFI boundary:

```rust,ignore
#[cxx::bridge(namespace = "gfx::rust_bindings")]
mod ffi {
    extern "Rust" {
        /// This returns an FFI-friendly equivalent of `Result<PngReader<'a>,
        /// ()>`.
        fn new_png_reader<'a>(input: &'a [u8]) -> Box<ResultOfPngReader<'a>>;

        /// C++ bindings for the `crate::png::ResultOfPngReader` type.
        type ResultOfPngReader<'a>;
        fn is_err(self: &ResultOfPngReader) -> bool;
        fn unwrap_as_mut<'a, 'b>(
            self: &'b mut ResultOfPngReader<'a>,
        ) -> &'b mut PngReader<'a>;

        /// C++ bindings for the `crate::png::PngReader` type.
        type PngReader<'a>;
        fn height(self: &PngReader) -> u32;
        fn width(self: &PngReader) -> u32;
        fn read_rgba8(self: &mut PngReader, output: &mut [u8]) -> bool;
    }
}
```

<details>

`PngReader` and `ResultOfPngReader` are Rust types --- objects of these types
cannot cross the FFI boundary without indirection of a `Box<T>`. We can't have
an `out_parameter: &mut PngReader`, because CXX doesn't allow C++ to store Rust
objects by value.

This example illustrates that even though CXX doesn't support arbitrary generics
nor templates, we can still pass them across the FFI boundary by manually
specializing / monomorphizing them into a non-generic type. In the example
`ResultOfPngReader` is a non-generic type that forwards into appropriate methods
of `Result<T, E>` (e.g. into `is_err`, `unwrap`, and/or `as_mut`).

</details>



================================================
FILE: src/chromium/interoperability-with-cpp/error-handling-qr.md
================================================
# CXX Error Handling: QR Example

The QR code generator is [an example][0] where a boolean is used to communicate
success vs failure, and where the successful result can be passed across the FFI
boundary:

```rust,ignore
#[cxx::bridge(namespace = "qr_code_generator")]
mod ffi {
    extern "Rust" {
        fn generate_qr_code_using_rust(
            data: &[u8],
            min_version: i16,
            out_pixels: Pin<&mut CxxVector<u8>>,
            out_qr_size: &mut usize,
        ) -> bool;
    }
}
```

<details>

Students may be curious about the semantics of the `out_qr_size` output. This is
not the size of the vector, but the size of the QR code (and admittedly it is a
bit redundant - this is the square root of the size of the vector).

It may be worth pointing out the importance of initializing `out_qr_size` before
calling into the Rust function. Creation of a Rust reference that points to
uninitialized memory results in Undefined Behavior (unlike in C++, when only the
act of dereferencing such memory results in UB).

If students ask about `Pin`, then explain why CXX needs it for mutable
references to C++ data: the answer is that C++ data can’t be moved around like
Rust data, because it may contain self-referential pointers.

</details>

[0]: https://source.chromium.org/chromium/chromium/src/+/main:components/qr_code_generator/qr_code_generator_ffi_glue.rs;l=13-18;drc=7bf1b75b910ca430501b9c6a74c1d18a0223ecca



================================================
FILE: src/chromium/interoperability-with-cpp/error-handling.md
================================================
# CXX Error Handling

CXX's [support for `Result<T,E>`][0] relies on C++ exceptions, so we can't use
that in Chromium. Alternatives:

- The `T` part of `Result<T, E>` can be:
  - Returned via out parameters (e.g. via `&mut T`). This requires that `T` can
    be passed across the FFI boundary - for example `T` has to be:
    - A primitive type (like `u32` or `usize`)
    - A type natively supported by `cxx` (like `UniquePtr<T>`) that has a
      suitable default value to use in a failure case (_unlike_ `Box<T>`).
  - Retained on the Rust side, and exposed via reference. This may be needed
    when `T` is a Rust type, which cannot be passed across the FFI boundary, and
    cannot be stored in `UniquePtr<T>`.

- The `E` part of `Result<T, E>` can be:
  - Returned as a boolean (e.g. `true` representing success, and `false`
    representing failure)
  - Preserving error details is in theory possible, but so far hasn't been
    needed in practice.

[0]: https://cxx.rs/binding/result.html



================================================
FILE: src/chromium/interoperability-with-cpp/example-bindings.md
================================================
# Example Bindings

CXX requires that the whole C++/Rust boundary is declared in `cxx::bridge`
modules inside `.rs` source code.

```rust,ignore
{{#include ../../../third_party/cxx/book/snippets.rs:cxx_overview}}
```

<details>

Point out:

- Although this looks like a regular Rust `mod`, the `#[cxx::bridge]` procedural
  macro does complex things to it. The generated code is quite a bit more
  sophisticated - though this does still result in a `mod` called `ffi` in your
  code.
- Native support for C++'s `std::unique_ptr` in Rust
- Native support for Rust slices in C++
- Calls from C++ to Rust, and Rust types (in the top part)
- Calls from Rust to C++, and C++ types (in the bottom part)

**Common misconception:** It _looks_ like a C++ header is being parsed by Rust,
but this is misleading. This header is never interpreted by Rust, but simply
`#include`d in the generated C++ code for the benefit of C++ compilers.

</details>



================================================
FILE: src/chromium/interoperability-with-cpp/limitations-of-cxx.md
================================================
## Limitations of CXX

By far the most useful page when using CXX is the [type reference][1].

CXX fundamentally suits cases where:

- Your Rust-C++ interface is sufficiently simple that you can declare all of it.
- You're using only the types natively supported by CXX already, for example
  `std::unique_ptr`, `std::string`, `&[u8]` etc.

It has many limitations --- for example lack of support for Rust's `Option`
type.

These limitations constrain us to using Rust in Chromium only for well isolated
"leaf nodes" rather than for arbitrary Rust-C++ interop. When considering a
use-case for Rust in Chromium, a good starting point is to draft the CXX
bindings for the language boundary to see if it appears simple enough.

[1]: https://cxx.rs/bindings.html

<details>
In addition, right now, Rust code in one component cannot depend on Rust
code in another, due to linking details in our component build. That's another
reason to restrict Rust to use in leaf nodes.

You should also discuss some of the other sticky points with CXX, for example:

- Its error handling is based around C++ exceptions (given on the next slide)
- Function pointers are awkward to use.

</details>



================================================
FILE: src/chromium/interoperability-with-cpp/using-cxx-in-chromium.md
================================================
## Using cxx in Chromium

In Chromium, we define an independent `#[cxx::bridge] mod` for each leaf-node
where we want to use Rust. You'd typically have one for each
`rust_static_library`. Just add

```gn
cxx_bindings = [ "my_rust_file.rs" ]
   # list of files containing #[cxx::bridge], not all source files
allow_unsafe = true
```

to your existing `rust_static_library` target alongside `crate_root` and
`sources`.

C++ headers will be generated at a sensible location, so you can just

```cpp
#include "ui/base/my_rust_file.rs.h"
```

You will find some utility functions in `//base` to convert to/from Chromium C++
types to CXX Rust types --- for example [`SpanToRustSlice`][0].

<details>

Students may ask --- why do we still need `allow_unsafe = true`?

The broad answer is that no C/C++ code is "safe" by the normal Rust standards.
Calling back and forth to C/C++ from Rust may do arbitrary things to memory, and
compromise the safety of Rust's own data layouts. Presence of _too many_
`unsafe` keywords in C/C++ interop can harm the signal-to-noise ratio of such a
keyword, and is [controversial][1], but strictly, bringing any foreign code into
a Rust binary can cause unexpected behavior from Rust's perspective.

The narrow answer lies in the diagram at the top of [this page][2] --- behind
the scenes, CXX generates Rust `unsafe` and `extern "C"` functions just like we
did manually in the previous section.

</details>

[0]: https://source.chromium.org/chromium/chromium/src/+/main:base/containers/span_rust.h;l=21
[1]: https://steveklabnik.com/writing/the-cxx-debate
[2]: ../interoperability-with-cpp.md



================================================
FILE: src/chromium/testing/build-gn.md
================================================
# GN Rules for Rust Tests

The simplest way to build Rust `gtest` tests is to add them to an existing test
binary that already contains tests authored in C++. For example:

```gn
test("ui_base_unittests") {
  ...
  sources += [ "my_rust_lib_unittest.rs" ]
  deps += [ ":my_rust_lib" ]
}
```

Authoring Rust tests in a separate `static_library` also works, but requires
manually declaring the dependency on the support libraries:

```gn
rust_static_library("my_rust_lib_unittests") {
  testonly = true
  is_gtest_unittests = true
  crate_root = "my_rust_lib_unittest.rs"
  sources = [ "my_rust_lib_unittest.rs" ]
  deps = [
    ":my_rust_lib",
    "//testing/rust_gtest_interop",
  ]
}

test("ui_base_unittests") {
  ...
  deps += [ ":my_rust_lib_unittests" ]
}
```



================================================
FILE: src/chromium/testing/chromium-import-macro.md
================================================
# `chromium::import!` Macro

After adding `:my_rust_lib` to GN `deps`, we still need to learn how to import
and use `my_rust_lib` from `my_rust_lib_unittest.rs`. We haven't provided an
explicit `crate_name` for `my_rust_lib` so its crate name is computed based on
the full target path and name. Fortunately we can avoid working with such an
unwieldy name by using the `chromium::import!` macro from the
automatically-imported `chromium` crate:

```rust,ignore
chromium::import! {
    "//ui/base:my_rust_lib";
}

use my_rust_lib::my_function_under_test;
```

Under the covers the macro expands to something similar to:

```rust,ignore
extern crate ui_sbase_cmy_urust_ulib as my_rust_lib;

use my_rust_lib::my_function_under_test;
```

More information can be found in [the doc comment][0] of the `chromium::import`
macro.

<details>

`rust_static_library` supports specifying an explicit name via `crate_name`
property, but doing this is discouraged. And it is discouraged because the crate
name has to be globally unique. crates.io guarantees uniqueness of its crate
names so `cargo_crate` GN targets (generated by the `gnrt` tool covered in a
later section) use short crate names.

</details>

[0]: https://source.chromium.org/chromium/chromium/src/+/main:build/rust/chromium_prelude/chromium_prelude.rs?q=f:chromium_prelude.rs%20pub.use.*%5Cbimport%5Cb;%20-f:third_party&ss=chromium%2Fchromium%2Fsrc



================================================
FILE: src/chromium/testing/rust-gtest-interop.md
================================================
# `rust_gtest_interop` Library

The [`rust_gtest_interop`][0] library provides a way to:

- Use a Rust function as a `gtest` testcase (using the `#[gtest(...)]`
  attribute)
- Use `expect_eq!` and similar macros (similar to `assert_eq!` but not panicking
  and not terminating the test when the assertion fails).

Example:

```rust,ignore
use rust_gtest_interop::prelude::*;

#[gtest(MyRustTestSuite, MyAdditionTest)]
fn test_addition() {
    expect_eq!(2 + 2, 4);
}
```

[0]: https://chromium.googlesource.com/chromium/src/+/main/testing/rust_gtest_interop/README.md



================================================
FILE: src/closures/capturing.md
================================================
---
minutes: 5
---

# Capturing

A closure can capture variables from the environment where it was defined.

```rust,editable
fn main() {
    let max_value = 5;
    let clamp = |v| {
        if v > max_value { max_value } else { v }
    };

    dbg!(clamp(1));
    dbg!(clamp(3));
    dbg!(clamp(5));
    dbg!(clamp(7));
    dbg!(clamp(10));
}
```

<details>

- By default, a closure captures values by reference. Here `max_value` is
  captured by `clamp`, but still available to `main` for printing. Try making
  `max_value` mutable, changing it, and printing the clamped values again. Why
  doesn't this work?

- If a closure mutates values, it will capture them by mutable reference. Try
  adding `max_value += 1` to `clamp`.

- You can force a closure to move values instead of referencing them with the
  `move` keyword. This can help with lifetimes, for example if the closure must
  outlive the captured values (more on lifetimes later).

  This looks like `move |v| ..`. Try adding this keyword and see if `main` can
  still access `max_value` after defining `clamp`.

- By default, closures will capture each variable from an outer scope by the
  least demanding form of access they can (by shared reference if possible, then
  exclusive reference, then by move). The `move` keyword forces capture by
  value.

</details>



================================================
FILE: src/closures/exercise.md
================================================
---
minutes: 10
---

# Exercise: Log Filter

Building on the generic logger from this morning, implement a `Filter` that uses
a closure to filter log messages, sending those that pass the filtering
predicate to an inner logger.

```rust,compile_fail,editable
{{#include exercise.rs:setup}}

// TODO: Define and implement `Filter`.

{{#include exercise.rs:main}}
```



================================================
FILE: src/closures/exercise.rs
================================================
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: solution
// ANCHOR: setup
pub trait Logger {
    /// Log a message at the given verbosity level.
    fn log(&self, verbosity: u8, message: &str);
}

struct StderrLogger;

impl Logger for StderrLogger {
    fn log(&self, verbosity: u8, message: &str) {
        eprintln!("verbosity={verbosity}: {message}");
    }
}
// ANCHOR_END: setup

/// Only log messages matching a filtering predicate.
struct Filter<L, P> {
    inner: L,
    predicate: P,
}

impl<L, P> Filter<L, P>
where
    L: Logger,
    P: Fn(u8, &str) -> bool,
{
    fn new(inner: L, predicate: P) -> Self {
        Self { inner, predicate }
    }
}
impl<L, P> Logger for Filter<L, P>
where
    L: Logger,
    P: Fn(u8, &str) -> bool,
{
    fn log(&self, verbosity: u8, message: &str) {
        if (self.predicate)(verbosity, message) {
            self.inner.log(verbosity, message);
        }
    }
}

// ANCHOR: main
fn main() {
    let logger = Filter::new(StderrLogger, |_verbosity, msg| msg.contains("yikes"));
    logger.log(5, "FYI");
    logger.log(1, "yikes, something went wrong");
    logger.log(2, "uhoh");
}
// ANCHOR_END: main



================================================
FILE: src/closures/solution.md
================================================
# Solution

```rust,editable
{{#include exercise.rs:solution}}
```

<details>

- Note that the `P: Fn(u8, &str) -> bool` bound on the first `Filter` impl block
  isn't strictly necessary, but it helps with type inference when calling `new`.
  Demonstrate removing it and showing how the compiler now needs type
  annotations for the closure passed to `new`.

</details>



================================================
FILE: src/closures/syntax.md
================================================
---
minutes: 3
---

# Closure Syntax

Closures are created with vertical bars: `|..| ..`.

```rust,editable
fn main() {
    // Argument and return type can be inferred for lightweight syntax:
    let double_it = |n| n * 2;
    dbg!(double_it(50));

    // Or we can specify types and bracket the body to be fully explicit:
    let add_1f32 = |x: f32| -> f32 { x + 1.0 };
    dbg!(add_1f32(50.));
}
```

<details>

- The arguments go between the `|..|`. The body can be surrounded by `{ .. }`,
  but if it is a single expression these can be omitted.

- Argument types are optional, and are inferred if not given. The return type is
  also optional, but can only be written if using `{ .. }` around the body.

- The examples can both be written as mere nested functions instead -- they do
  not capture any variables from their lexical environment. We will see captures
  next.

## More to Explore

- The ability to store functions in variables doesn't just apply to closures,
  regular functions can be put in variables and then invoked the same way that
  closures can: [Example in the playground][fn-ptr].

  - The linked example also demonstrates that closures that don't capture
    anything can also coerce to a regular function pointer.

</details>

[fn-ptr]: https://play.rust-lang.org/?version=stable&mode=debug&edition=2024&gist=817cbeeefc49f3d0d180a3d6d54c8bda



================================================
FILE: src/closures/traits.md
================================================
---
minutes: 10
---

# Closure traits

Closures or lambda expressions have types that cannot be named. However, they
implement special [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html),
[`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html), and
[`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) traits:

The special types `fn(..) -> T` refer to function pointers - either the address
of a function, or a closure that captures nothing.

```rust,editable
fn apply_and_log(
    func: impl FnOnce(&'static str) -> String,
    func_name: &'static str,
    input: &'static str,
) {
    println!("Calling {func_name}({input}): {}", func(input))
}

fn main() {
    let suffix = "-itis";
    let add_suffix = |x| format!("{x}{suffix}");
    apply_and_log(&add_suffix, "add_suffix", "senior");
    apply_and_log(&add_suffix, "add_suffix", "appendix");

    let mut v = Vec::new();
    let mut accumulate = |x| {
        v.push(x);
        v.join("/")
    };
    apply_and_log(&mut accumulate, "accumulate", "red");
    apply_and_log(&mut accumulate, "accumulate", "green");
    apply_and_log(&mut accumulate, "accumulate", "blue");

    let take_and_reverse = |prefix| {
        let mut acc = String::from(prefix);
        acc.push_str(&v.into_iter().rev().collect::<Vec<_>>().join("/"));
        acc
    };
    apply_and_log(take_and_reverse, "take_and_reverse", "reversed: ");
}
```

<details>

An `Fn` (e.g. `add_suffix`) neither consumes nor mutates captured values. It can
be called needing only a shared reference to the closure, which means the
closure can be executed repeatedly and even concurrently.

An `FnMut` (e.g. `accumulate`) might mutate captured values. The closure object
is accessed via exclusive reference, so it can be called repeatedly but not
concurrently.

If you have an `FnOnce` (e.g. `take_and_reverse`), you may only call it once.
Doing so consumes the closure and any values captured by move.

`FnMut` is a subtype of `FnOnce`. `Fn` is a subtype of `FnMut` and `FnOnce`.
I.e. you can use an `FnMut` wherever an `FnOnce` is called for, and you can use
an `Fn` wherever an `FnMut` or `FnOnce` is called for.

When you define a function that takes a closure, you should take `FnOnce` if you
can (i.e. you call it once), or `FnMut` else, and last `Fn`. This allows the
most flexibility for the caller.

In contrast, when you have a closure, the most flexible you can have is `Fn`
(which can be passed to a consumer of any of the three closure traits), then
`FnMut`, and lastly `FnOnce`.

The compiler also infers `Copy` (e.g. for `add_suffix`) and `Clone` (e.g.
`take_and_reverse`), depending on what the closure captures. Function pointers
(references to `fn` items) implement `Copy` and `Fn`.

</details>



================================================
FILE: src/concurrency/async-control-flow.md
================================================
# Channels and Control Flow

{{%segment outline}}



================================================
FILE: src/concurrency/async-exercises.md
================================================
# Exercises

{{%segment outline}}



================================================
FILE: src/concurrency/async-pitfalls.md
================================================
# Pitfalls

Async / await provides convenient and efficient abstraction for concurrent
asynchronous programming. However, the async/await model in Rust also comes with
its share of pitfalls and footguns. We illustrate some of them in this chapter.

{{%segment outline}}



================================================
FILE: src/concurrency/async.md
================================================
# Async Basics

{{%segment outline}}



================================================
FILE: src/concurrency/channels.md
================================================
# Channels

{{%segment outline}}



================================================
FILE: src/concurrency/send-sync.md
================================================
# `Send` and `Sync`

{{%segment outline}}



================================================
FILE: src/concurrency/shared-state.md
================================================
# Shared State

{{%segment outline}}



================================================
FILE: src/concurrency/sync-exercises.md
================================================
# Exercises

{{%segment outline}}



================================================
FILE: src/concurrency/threads.md
================================================
# Threads

{{%segment outline}}



================================================
FILE: src/concurrency/welcome-async.md
================================================
---
session: Afternoon
target_minutes: 180
---

# Welcome

"Async" is a concurrency model where multiple tasks are executed concurrently by
executing each task until it would block, then switching to another task that is
ready to make progress. The model allows running a larger number of tasks on a
limited number of threads. This is because the per-task overhead is typically
very low and operating systems provide primitives for efficiently identifying
I/O that is able to proceed.

Rust's asynchronous operation is based on "futures", which represent work that
may be completed in the future. Futures are "polled" until they signal that they
are complete.

Futures are polled by an async runtime, and several different runtimes are
available.

## Comparisons

- Python has a similar model in its `asyncio`. However, its `Future` type is
  callback-based, and not polled. Async Python programs require a "loop",
  similar to a runtime in Rust.

- JavaScript's `Promise` is similar, but again callback-based. The language
  runtime implements the event loop, so many of the details of Promise
  resolution are hidden.

## Schedule

{{%session outline}}



================================================
FILE: src/concurrency/welcome.md
================================================
---
course: Concurrency
session: Morning
target_minutes: 180
---

# Welcome to Concurrency in Rust

Rust has full support for concurrency using OS threads with mutexes and
channels.

The Rust type system plays an important role in making many concurrency bugs
compile time bugs. This is often referred to as _fearless concurrency_ since you
can rely on the compiler to ensure correctness at runtime.

## Schedule

{{%session outline}}

<details>

- Rust lets us access OS concurrency toolkit: threads, sync. primitives, etc.
- The type system gives us safety for concurrency without any special features.
- The same tools that help with "concurrent" access in a single thread (e.g., a
  called function that might mutate an argument or save references to it to read
  later) save us from multi-threading issues.

</details>



================================================
FILE: src/concurrency/async/async-await.md
================================================
---
minutes: 6
---

# `async`/`await`

At a high level, async Rust code looks very much like "normal" sequential code:

```rust,editable,compile_fail
use futures::executor::block_on;

async fn count_to(count: i32) {
    for i in 0..count {
        println!("Count is: {i}!");
    }
}

async fn async_main(count: i32) {
    count_to(count).await;
}

fn main() {
    block_on(async_main(10));
}
```

<details>

Key points:

- Note that this is a simplified example to show the syntax. There is no long
  running operation or any real concurrency in it!

- The "async" keyword is syntactic sugar. The compiler replaces the return type
  with a future.

- You cannot make `main` async, without additional instructions to the compiler
  on how to use the returned future.

- You need an executor to run async code. `block_on` blocks the current thread
  until the provided future has run to completion.

- `.await` asynchronously waits for the completion of another operation. Unlike
  `block_on`, `.await` doesn't block the current thread.

- `.await` can only be used inside an `async` function (or block; these are
  introduced later).

</details>



================================================
FILE: src/concurrency/async/futures.md
================================================
---
minutes: 4
---

# Futures

[`Future`](https://doc.rust-lang.org/std/future/trait.Future.html) is a trait,
implemented by objects that represent an operation that may not be complete yet.
A future can be polled, and `poll` returns a
[`Poll`](https://doc.rust-lang.org/std/task/enum.Poll.html).

```rust
use std::pin::Pin;
use std::task::Context;

pub trait Future {
    type Output;
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}

pub enum Poll<T> {
    Ready(T),
    Pending,
}
```

An async function returns an `impl Future`. It's also possible (but uncommon) to
implement `Future` for your own types. For example, the `JoinHandle` returned
from `tokio::spawn` implements `Future` to allow joining to it.

The `.await` keyword, applied to a Future, causes the current async function to
pause until that Future is ready, and then evaluates to its output.

<details>

- The `Future` and `Poll` types are implemented exactly as shown; click the
  links to show the implementations in the docs.

- `Context` allows a Future to schedule itself to be polled again when an event
  such as a timeout occurs.

- `Pin` ensures that the Future isn't moved in memory, so that pointers into
  that future remain valid. This is required to allow references to remain valid
  after an `.await`. We will address `Pin` in the "Pitfalls" segment.

</details>



================================================
FILE: src/concurrency/async/runtimes.md
================================================
---
minutes: 10
---

# Runtimes

A _runtime_ provides support for performing operations asynchronously (a
_reactor_) and is responsible for executing futures (an _executor_). Rust does
not have a "built-in" runtime, but several options are available:

- [Tokio](https://tokio.rs/): performant, with a well-developed ecosystem of
  functionality like [Hyper](https://hyper.rs/) for HTTP or
  [Tonic](https://github.com/hyperium/tonic) for gRPC.
- [smol](https://docs.rs/smol/latest/smol/): simple and lightweight

Several larger applications have their own runtimes. For example,
[Fuchsia](https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/fuchsia-async/src/lib.rs)
already has one.

<details>

- Note that of the listed runtimes, only Tokio is supported in the Rust
  playground. The playground also does not permit any I/O, so most interesting
  async things can't run in the playground.

- Futures are "inert" in that they do not do anything (not even start an I/O
  operation) unless there is an executor polling them. This differs from JS
  Promises, for example, which will run to completion even if they are never
  used.

</details>



================================================
FILE: src/concurrency/async/state-machine.md
================================================
---
minutes: 10
---

# State Machine

Rust transforms an async function or block to a hidden type that implements
`Future`, using a state machine to track the function's progress. The details of
this transform are complex, but it helps to have a schematic understanding of
what is happening. The following function

```rust,compile_fail
/// Sum two D10 rolls plus a modifier.
async fn two_d10(modifier: u32) -> u32 {
    let first_roll = roll_d10().await;
    let second_roll = roll_d10().await;
    first_roll + second_roll + modifier
}
```

is transformed to something like

```rust,editable,compile_fail
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

/// Sum two D10 rolls plus a modifier.
fn two_d10(modifier: u32) -> TwoD10 {
    TwoD10::Init { modifier }
}

enum TwoD10 {
    // Function has not begun yet.
    Init { modifier: u32 },
    // Waiting for first `.await` to complete.
    FirstRoll { modifier: u32, fut: RollD10Future },
    // Waiting for second `.await` to complete.
    SecondRoll { modifier: u32, first_roll: u32, fut: RollD10Future },
}

impl Future for TwoD10 {
    type Output = u32;
    fn poll(mut self: Pin<&mut Self>, ctx: &mut Context) -> Poll<Self::Output> {
        loop {
            match *self {
                TwoD10::Init { modifier } => {
                    // Create future for first dice roll.
                    let fut = roll_d10();
                    *self = TwoD10::FirstRoll { modifier, fut };
                }
                TwoD10::FirstRoll { modifier, ref mut fut } => {
                    // Poll sub-future for first dice roll.
                    if let Poll::Ready(first_roll) = fut.poll(ctx) {
                        // Create future for second roll.
                        let fut = roll_d10();
                        *self = TwoD10::SecondRoll { modifier, first_roll, fut };
                    } else {
                        return Poll::Pending;
                    }
                }
                TwoD10::SecondRoll { modifier, first_roll, ref mut fut } => {
                    // Poll sub-future for second dice roll.
                    if let Poll::Ready(second_roll) = fut.poll(ctx) {
                        return Poll::Ready(first_roll + second_roll + modifier);
                    } else {
                        return Poll::Pending;
                    }
                }
            }
        }
    }
}
```

<details>

This example is illustrative, and isn't an accurate representation of the Rust
compiler's transformation. The important things to notice here are:

- Calling an async function does nothing but construct and return a future.
- All local variables are stored in the function's future, using an enum to
  identify where execution is currently suspended.
- An `.await` in the async function is translated into an a new state containing
  all live variables and the awaited future. The `loop` then handles that
  updated state, polling the future until it returns `Poll::Ready`.
- Execution continues eagerly until a `Poll::Pending` occurs. In this simple
  example, every future is ready immediately.
- `main` contains a naïve executor, which just busy-loops until the future is
  ready. We will discuss real executors shortly.

# More to Explore

Imagine the `Future` data structure for a deeply nested stack of async
functions. Each function's `Future` contains the `Future` structures for the
functions it calls. This can result in unexpectedly large compiler-generated
`Future` types.

This also means that recursive async functions are challenging. Compare to the
common error of building recursive type, such as

```rust,compile_fail
enum LinkedList<T> {
    Node { value: T, next: LinkedList<T> },
    Nil,
}
```

The fix for a recursive type is to add a layer of indrection, such as with
`Box`. Similarly, a recursive async function must box the recursive future:

```rust,editable
async fn count_to(n: u32) {
    if n > 0 {
        Box::pin(count_to(n - 1)).await;
        println!("{n}");
    }
}
```

</details>



================================================
FILE: src/concurrency/async/tasks.md
================================================
---
minutes: 6
---

# Tasks

Rust has a task system, which is a form of lightweight threading.

A task has a single top-level future which the executor polls to make progress.
That future may have one or more nested futures that its `poll` method polls,
corresponding loosely to a call stack. Concurrency within a task is possible by
polling multiple child futures, such as racing a timer and an I/O operation.

```rust,compile_fail
use tokio::io::{self, AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpListener;

#[tokio::main]
async fn main() -> io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:0").await?;
    println!("listening on port {}", listener.local_addr()?.port());

    loop {
        let (mut socket, addr) = listener.accept().await?;

        println!("connection from {addr:?}");

        tokio::spawn(async move {
            socket.write_all(b"Who are you?\n").await.expect("socket error");

            let mut buf = vec![0; 1024];
            let name_size = socket.read(&mut buf).await.expect("socket error");
            let name = std::str::from_utf8(&buf[..name_size]).unwrap().trim();
            let reply = format!("Thanks for dialing in, {name}!\n");
            socket.write_all(reply.as_bytes()).await.expect("socket error");
        });
    }
}
```

<details>

Copy this example into your prepared `src/main.rs` and run it from there.

Try connecting to it with a TCP connection tool like
[nc](https://www.unix.com/man-page/linux/1/nc/) or
[telnet](https://www.unix.com/man-page/linux/1/telnet/).

- Ask students to visualize what the state of the example server would be with a
  few connected clients. What tasks exist? What are their Futures?

- This is the first time we've seen an `async` block. This is similar to a
  closure, but does not take any arguments. Its return value is a Future,
  similar to an `async fn`.

- Refactor the async block into a function, and improve the error handling using
  `?`.

</details>



================================================
FILE: src/concurrency/async/runtimes/tokio.md
================================================
# Tokio

Tokio provides:

- A multi-threaded runtime for executing asynchronous code.
- An asynchronous version of the standard library.
- A large ecosystem of libraries.

```rust,editable,compile_fail
use tokio::time;

async fn count_to(count: i32) {
    for i in 0..count {
        println!("Count in task: {i}!");
        time::sleep(time::Duration::from_millis(5)).await;
    }
}

#[tokio::main]
async fn main() {
    tokio::spawn(count_to(10));

    for i in 0..5 {
        println!("Main task: {i}");
        time::sleep(time::Duration::from_millis(5)).await;
    }
}
```

<details>

- With the `tokio::main` macro we can now make `main` async.

- The `spawn` function creates a new, concurrent "task".

- Note: `spawn` takes a `Future`, you don't call `.await` on `count_to`.

**Further exploration:**

- Why does `count_to` not (usually) get to 10? This is an example of async
  cancellation. `tokio::spawn` returns a handle which can be awaited to wait
  until it finishes.

- Try `count_to(10).await` instead of spawning.

- Try awaiting the task returned from `tokio::spawn`.

</details>



================================================
FILE: src/concurrency/async-control-flow/channels.md
================================================
---
minutes: 8
---

# Async Channels

Several crates have support for asynchronous channels. For instance `tokio`:

```rust,editable,compile_fail
use tokio::sync::mpsc;

async fn ping_handler(mut input: mpsc::Receiver<()>) {
    let mut count: usize = 0;

    while let Some(_) = input.recv().await {
        count += 1;
        println!("Received {count} pings so far.");
    }

    println!("ping_handler complete");
}

#[tokio::main]
async fn main() {
    let (sender, receiver) = mpsc::channel(32);
    let ping_handler_task = tokio::spawn(ping_handler(receiver));
    for i in 0..10 {
        sender.send(()).await.expect("Failed to send ping.");
        println!("Sent {} pings so far.", i + 1);
    }

    drop(sender);
    ping_handler_task.await.expect("Something went wrong in ping handler task.");
}
```

<details>

- Change the channel size to `3` and see how it affects the execution.

- Overall, the interface is similar to the `sync` channels as seen in the
  [morning class](../channels.md).

- Try removing the `std::mem::drop` call. What happens? Why?

- The [Flume](https://docs.rs/flume/latest/flume/) crate has channels that
  implement both `sync` and `async` `send` and `recv`. This can be convenient
  for complex applications with both IO and heavy CPU processing tasks.

- What makes working with `async` channels preferable is the ability to combine
  them with other `future`s to combine them and create complex control flow.

</details>



================================================
FILE: src/concurrency/async-control-flow/join.md
================================================
---
minutes: 4
---

# Join

A join operation waits until all of a set of futures are ready, and returns a
collection of their results. This is similar to `Promise.all` in JavaScript or
`asyncio.gather` in Python.

```rust,editable,compile_fail
use anyhow::Result;
use futures::future;
use reqwest;
use std::collections::HashMap;

async fn size_of_page(url: &str) -> Result<usize> {
    let resp = reqwest::get(url).await?;
    Ok(resp.text().await?.len())
}

#[tokio::main]
async fn main() {
    let urls: [&str; 4] = [
        "https://google.com",
        "https://httpbin.org/ip",
        "https://play.rust-lang.org/",
        "BAD_URL",
    ];
    let futures_iter = urls.into_iter().map(size_of_page);
    let results = future::join_all(futures_iter).await;
    let page_sizes_dict: HashMap<&str, Result<usize>> =
        urls.into_iter().zip(results.into_iter()).collect();
    println!("{page_sizes_dict:?}");
}
```

<details>

Copy this example into your prepared `src/main.rs` and run it from there.

- For multiple futures of disjoint types, you can use `std::future::join!` but
  you must know how many futures you will have at compile time. This is
  currently in the `futures` crate, soon to be stabilised in `std::future`.

- The risk of `join` is that one of the futures may never resolve, this would
  cause your program to stall.

- You can also combine `join_all` with `join!` for instance to join all requests
  to an http service as well as a database query. Try adding a
  `tokio::time::sleep` to the future, using `futures::join!`. This is not a
  timeout (that requires `select!`, explained in the next chapter), but
  demonstrates `join!`.

</details>



================================================
FILE: src/concurrency/async-control-flow/select.md
================================================
---
minutes: 5
---

# Select

A select operation waits until any of a set of futures is ready, and responds to
that future's result. In JavaScript, this is similar to `Promise.race`. In
Python, it compares to
`asyncio.wait(task_set, return_when=asyncio.FIRST_COMPLETED)`.

Similar to a match statement, the body of `select!` has a number of arms, each
of the form `pattern = future => statement`. When a `future` is ready, its
return value is destructured by the `pattern`. The `statement` is then run with
the resulting variables. The `statement` result becomes the result of the
`select!` macro.

```rust,editable,compile_fail
use tokio::sync::mpsc;
use tokio::time::{Duration, sleep};

#[tokio::main]
async fn main() {
    let (tx, mut rx) = mpsc::channel(32);
    let listener = tokio::spawn(async move {
        tokio::select! {
            Some(msg) = rx.recv() => println!("got: {msg}"),
            _ = sleep(Duration::from_millis(50)) => println!("timeout"),
        };
    });
    sleep(Duration::from_millis(10)).await;
    tx.send(String::from("Hello!")).await.expect("Failed to send greeting");

    listener.await.expect("Listener failed");
}
```

<details>

- The `listener` async block here is a common form: wait for some async event,
  or for a timeout. Change the `sleep` to sleep longer to see it fail. Why does
  the `send` also fail in this situation?

- `select!` is also often used in a loop in "actor" architectures, where a task
  reacts to events in a loop. That has some pitfalls, which will be discussed in
  the next segment.

</details>



================================================
FILE: src/concurrency/async-exercises/afternoon.md
================================================
# Exercises



================================================
FILE: src/concurrency/async-exercises/chat-app.md
================================================
---
minutes: 30
---

# Broadcast Chat Application

In this exercise, we want to use our new knowledge to implement a broadcast chat
application. We have a chat server that the clients connect to and publish their
messages. The client reads user messages from the standard input, and sends them
to the server. The chat server broadcasts each message that it receives to all
the clients.

For this, we use [a broadcast channel][1] on the server, and
[`tokio_websockets`][2] for the communication between the client and the server.

Create a new Cargo project and add the following dependencies:

_Cargo.toml_:

<!-- File Cargo.toml -->

```toml
{{#include chat-async/Cargo.toml}}
```

## The required APIs

You are going to need the following functions from `tokio` and
[`tokio_websockets`][2]. Spend a few minutes to familiarize yourself with the
API.

- [StreamExt::next()][3] implemented by `WebSocketStream`: for asynchronously
  reading messages from a Websocket Stream.
- [SinkExt::send()][4] implemented by `WebSocketStream`: for asynchronously
  sending messages on a Websocket Stream.
- [Lines::next_line()][5]: for asynchronously reading user messages from the
  standard input.
- [Sender::subscribe()][6]: for subscribing to a broadcast channel.

## Two binaries

Normally in a Cargo project, you can have only one binary, and one `src/main.rs`
file. In this project, we need two binaries. One for the client, and one for the
server. You could potentially make them two separate Cargo projects, but we are
going to put them in a single Cargo project with two binaries. For this to work,
the client and the server code should go under `src/bin` (see the
[documentation][7]).

Copy the following server and client code into `src/bin/server.rs` and
`src/bin/client.rs`, respectively. Your task is to complete these files as
described below.

_src/bin/server.rs_:

<!-- File src/bin/server.rs -->

```rust,compile_fail
{{#include chat-async/src/bin/server.rs:setup}}

{{#include chat-async/src/bin/server.rs:handle_connection}}

    // TODO: For a hint, see the description of the task below.

{{#include chat-async/src/bin/server.rs:main}}
```

_src/bin/client.rs_:

<!-- File src/bin/client.rs -->

```rust,compile_fail
{{#include chat-async/src/bin/client.rs:setup}}

    // TODO: For a hint, see the description of the task below.

}
```

## Running the binaries

Run the server with:

```shell
cargo run --bin server
```

and the client with:

```shell
cargo run --bin client
```

## Tasks

- Implement the `handle_connection` function in `src/bin/server.rs`.
  - Hint: Use `tokio::select!` for concurrently performing two tasks in a
    continuous loop. One task receives messages from the client and broadcasts
    them. The other sends messages received by the server to the client.
- Complete the main function in `src/bin/client.rs`.
  - Hint: As before, use `tokio::select!` in a continuous loop for concurrently
    performing two tasks: (1) reading user messages from standard input and
    sending them to the server, and (2) receiving messages from the server, and
    displaying them for the user.
- Optional: Once you are done, change the code to broadcast messages to all
  clients, but the sender of the message.

[1]: https://docs.rs/tokio/latest/tokio/sync/broadcast/fn.channel.html
[2]: https://docs.rs/tokio-websockets/
[3]: https://docs.rs/futures-util/0.3.28/futures_util/stream/trait.StreamExt.html#method.next
[4]: https://docs.rs/futures-util/0.3.28/futures_util/sink/trait.SinkExt.html#method.send
[5]: https://docs.rs/tokio/latest/tokio/io/struct.Lines.html#method.next_line
[6]: https://docs.rs/tokio/latest/tokio/sync/broadcast/struct.Sender.html#method.subscribe
[7]: https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries



================================================
FILE: src/concurrency/async-exercises/dining-philosophers.md
================================================
---
minutes: 20
---

# Dining Philosophers --- Async

See [dining philosophers](../sync-exercises/dining-philosophers.md) for a
description of the problem.

As before, you will need a local
[Cargo installation](../../cargo/running-locally.md) for this exercise. Copy the
code below to a file called `src/main.rs`, fill out the blanks, and test that
`cargo run` does not deadlock:

<!-- File src/main.rs -->

```rust,compile_fail
{{#include dining-philosophers.rs:Philosopher}}
    // left_chopstick: ...
    // right_chopstick: ...
    // thoughts: ...
}

{{#include dining-philosophers.rs:Philosopher-think}}

{{#include dining-philosophers.rs:Philosopher-eat}}
{{#include dining-philosophers.rs:Philosopher-eat-body}}
{{#include dining-philosophers.rs:Philosopher-eat-end}}
    // Create chopsticks

    // Create philosophers

    // Make them think and eat

    // Output their thoughts
}
```

Since this time you are using Async Rust, you'll need a `tokio` dependency. You
can use the following `Cargo.toml`:

<!-- File Cargo.toml -->

```toml
[package]
name = "dining-philosophers-async-dine"
version = "0.1.0"
edition = "2024"

[dependencies]
tokio = { version = "1.26.0", features = ["sync", "time", "macros", "rt-multi-thread"] }
```

Also note that this time you have to use the `Mutex` and the `mpsc` module from
the `tokio` crate.

<details>

- Can you make your implementation single-threaded?

</details>



================================================
FILE: src/concurrency/async-exercises/dining-philosophers.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: solution
// ANCHOR: Philosopher
use std::sync::Arc;
use tokio::sync::{Mutex, mpsc};
use tokio::time;

struct Chopstick;

struct Philosopher {
    name: String,
    // ANCHOR_END: Philosopher
    left_chopstick: Arc<Mutex<Chopstick>>,
    right_chopstick: Arc<Mutex<Chopstick>>,
    thoughts: mpsc::Sender<String>,
}

// ANCHOR: Philosopher-think
impl Philosopher {
    async fn think(&self) {
        self.thoughts
            .send(format!("Eureka! {} has a new idea!", &self.name))
            .await
            .unwrap();
    }
    // ANCHOR_END: Philosopher-think

    // ANCHOR: Philosopher-eat
    async fn eat(&self) {
        // Keep trying until we have both chopsticks
        // ANCHOR_END: Philosopher-eat
        // Pick up chopsticks...
        let _left_chopstick = self.left_chopstick.lock().await;
        let _right_chopstick = self.right_chopstick.lock().await;

        // ANCHOR: Philosopher-eat-body
        println!("{} is eating...", &self.name);
        time::sleep(time::Duration::from_millis(5)).await;
        // ANCHOR_END: Philosopher-eat-body

        // The locks are dropped here
        // ANCHOR: Philosopher-eat-end
    }
}

// tokio scheduler doesn't deadlock with 5 philosophers, so have 2.
static PHILOSOPHERS: &[&str] = &["Socrates", "Hypatia"];

#[tokio::main]
async fn main() {
    // ANCHOR_END: Philosopher-eat-end
    // Create chopsticks
    let mut chopsticks = vec![];
    PHILOSOPHERS
        .iter()
        .for_each(|_| chopsticks.push(Arc::new(Mutex::new(Chopstick))));

    // Create philosophers
    let (philosophers, mut rx) = {
        let mut philosophers = vec![];
        let (tx, rx) = mpsc::channel(10);
        for (i, name) in PHILOSOPHERS.iter().enumerate() {
            let mut left_chopstick = Arc::clone(&chopsticks[i]);
            let mut right_chopstick =
                Arc::clone(&chopsticks[(i + 1) % PHILOSOPHERS.len()]);
            if i == PHILOSOPHERS.len() - 1 {
                std::mem::swap(&mut left_chopstick, &mut right_chopstick);
            }
            philosophers.push(Philosopher {
                name: name.to_string(),
                left_chopstick,
                right_chopstick,
                thoughts: tx.clone(),
            });
        }
        (philosophers, rx)
        // tx is dropped here, so we don't need to explicitly drop it later
    };

    // Make them think and eat
    for phil in philosophers {
        tokio::spawn(async move {
            for _ in 0..100 {
                phil.think().await;
                phil.eat().await;
            }
        });
    }

    // Output their thoughts
    while let Some(thought) = rx.recv().await {
        println!("Here is a thought: {thought}");
    }
}



================================================
FILE: src/concurrency/async-exercises/solutions.md
================================================
---
minutes: 20
---

# Solutions

## Dining Philosophers --- Async

```rust,compile_fail
{{#include dining-philosophers.rs:solution}}
```

## Broadcast Chat Application

_src/bin/server.rs_:

```rust,compile_fail
{{#include chat-async/src/bin/server.rs:solution}}
```

_src/bin/client.rs_:

```rust,compile_fail
{{#include chat-async/src/bin/client.rs:solution}}
```



================================================
FILE: src/concurrency/async-exercises/chat-async/Cargo.toml
================================================
[package]
name = "chat-async"
version = "0.1.0"
edition = "2024"

[dependencies]
futures-util = { version = "0.3.31", features = ["sink"] }
http = "1.3.1"
tokio = { version = "1.47.1", features = ["full"] }
tokio-websockets = { version = "0.12.1", features = ["client", "fastrand", "server", "sha1_smol"] }



================================================
FILE: src/concurrency/async-pitfalls/async-traits.md
================================================
---
minutes: 5
---

# Async Traits

Async methods in traits were stabilized in the 1.75 release. This required
support for using return-position `impl Trait` in traits, as the desugaring for
`async fn` includes `-> impl Future<Output = ...>`.

However, even with the native support, there are some pitfalls around
`async fn`:

- Return-position `impl Trait` captures all in-scope lifetimes (so some patterns
  of borrowing cannot be expressed).

- Async traits cannot be used with [trait objects] (`dyn Trait` support).

The [async_trait] crate provides a workaround for `dyn` support through a macro,
with some caveats:

```rust,editable,compile_fail
use async_trait::async_trait;
use std::time::Instant;
use tokio::time::{Duration, sleep};

#[async_trait]
trait Sleeper {
    async fn sleep(&self);
}

struct FixedSleeper {
    sleep_ms: u64,
}

#[async_trait]
impl Sleeper for FixedSleeper {
    async fn sleep(&self) {
        sleep(Duration::from_millis(self.sleep_ms)).await;
    }
}

async fn run_all_sleepers_multiple_times(
    sleepers: Vec<Box<dyn Sleeper>>,
    n_times: usize,
) {
    for _ in 0..n_times {
        println!("Running all sleepers...");
        for sleeper in &sleepers {
            let start = Instant::now();
            sleeper.sleep().await;
            println!("Slept for {} ms", start.elapsed().as_millis());
        }
    }
}

#[tokio::main]
async fn main() {
    let sleepers: Vec<Box<dyn Sleeper>> = vec![
        Box::new(FixedSleeper { sleep_ms: 50 }),
        Box::new(FixedSleeper { sleep_ms: 100 }),
    ];
    run_all_sleepers_multiple_times(sleepers, 5).await;
}
```

<details>

- `async_trait` is easy to use, but note that it's using heap allocations to
  achieve this. This heap allocation has performance overhead.

- The challenges in language support for `async trait` are too deep to describe
  in-depth in this class. See [this blog post] by Niko Matsakis if you are
  interested in digging deeper. See also these keywords:

  - [RPIT]: short for
    [return-position `impl Trait`](../../generics/impl-trait.md).
  - [RPITIT]: short for return-position `impl Trait` in trait (RPIT in trait).

- Try creating a new sleeper struct that will sleep for a random amount of time
  and adding it to the `Vec`.

</details>

[async_trait]: https://docs.rs/async-trait/
[trait objects]: ../../smart-pointers/trait-objects.md
[this blog post]: https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/
[RPIT]: https://doc.rust-lang.org/reference/types/impl-trait.html#abstract-return-types
[RPITIT]: https://blog.rust-lang.org/2023/12/21/async-fn-rpit-in-traits.html



================================================
FILE: src/concurrency/async-pitfalls/blocking-executor.md
================================================
---
minutes: 10
---

# Blocking the executor

Most async runtimes only allow IO tasks to run concurrently. This means that CPU
blocking tasks will block the executor and prevent other tasks from being
executed. An easy workaround is to use async equivalent methods where possible.

```rust,editable,compile_fail
use futures::future::join_all;
use std::time::Instant;

async fn sleep_ms(start: &Instant, id: u64, duration_ms: u64) {
    std::thread::sleep(std::time::Duration::from_millis(duration_ms));
    println!(
        "future {id} slept for {duration_ms}ms, finished after {}ms",
        start.elapsed().as_millis()
    );
}

#[tokio::main(flavor = "current_thread")]
async fn main() {
    let start = Instant::now();
    let sleep_futures = (1..=10).map(|t| sleep_ms(&start, t, t * 10));
    join_all(sleep_futures).await;
}
```

<details>

- Run the code and see that the sleeps happen consecutively rather than
  concurrently.

- The `"current_thread"` flavor puts all tasks on a single thread. This makes
  the effect more obvious, but the bug is still present in the multi-threaded
  flavor.

- Switch the `std::thread::sleep` to `tokio::time::sleep` and await its result.

- Another fix would be to `tokio::task::spawn_blocking` which spawns an actual
  thread and transforms its handle into a future without blocking the executor.

- You should not think of tasks as OS threads. They do not map 1 to 1 and most
  executors will allow many tasks to run on a single OS thread. This is
  particularly problematic when interacting with other libraries via FFI, where
  that library might depend on thread-local storage or map to specific OS
  threads (e.g., CUDA). Prefer `tokio::task::spawn_blocking` in such situations.

- Use sync mutexes with care. Holding a mutex over an `.await` may cause another
  task to block, and that task may be running on the same thread.

</details>



================================================
FILE: src/concurrency/async-pitfalls/cancellation.md
================================================
---
minutes: 18
---

# Cancellation

Dropping a future implies it can never be polled again. This is called
_cancellation_ and it can occur at any `await` point. Care is needed to ensure
the system works correctly even when futures are cancelled. For example, it
shouldn't deadlock or lose data.

```rust,editable,compile_fail
use std::io;
use std::time::Duration;
use tokio::io::{AsyncReadExt, AsyncWriteExt, DuplexStream};

struct LinesReader {
    stream: DuplexStream,
}

impl LinesReader {
    fn new(stream: DuplexStream) -> Self {
        Self { stream }
    }

    async fn next(&mut self) -> io::Result<Option<String>> {
        let mut bytes = Vec::new();
        let mut buf = [0];
        while self.stream.read(&mut buf[..]).await? != 0 {
            bytes.push(buf[0]);
            if buf[0] == b'\n' {
                break;
            }
        }
        if bytes.is_empty() {
            return Ok(None);
        }
        let s = String::from_utf8(bytes)
            .map_err(|_| io::Error::new(io::ErrorKind::InvalidData, "not UTF-8"))?;
        Ok(Some(s))
    }
}

async fn slow_copy(source: String, mut dest: DuplexStream) -> io::Result<()> {
    for b in source.bytes() {
        dest.write_u8(b).await?;
        tokio::time::sleep(Duration::from_millis(10)).await
    }
    Ok(())
}

#[tokio::main]
async fn main() -> io::Result<()> {
    let (client, server) = tokio::io::duplex(5);
    let handle = tokio::spawn(slow_copy("hi\nthere\n".to_owned(), client));

    let mut lines = LinesReader::new(server);
    let mut interval = tokio::time::interval(Duration::from_millis(60));
    loop {
        tokio::select! {
            _ = interval.tick() => println!("tick!"),
            line = lines.next() => if let Some(l) = line? {
                print!("{}", l)
            } else {
                break
            },
        }
    }
    handle.await.unwrap()?;
    Ok(())
}
```

<details>

- The compiler doesn't help with cancellation-safety. You need to read API
  documentation and consider what state your `async fn` holds.

- Unlike `panic` and `?`, cancellation is part of normal control flow (vs
  error-handling).

- The example loses parts of the string.

  - Whenever the `tick()` branch finishes first, `next()` and its `buf` are
    dropped.

  - `LinesReader` can be made cancellation-safe by making `buf` part of the
    struct:
    ```rust,compile_fail
    struct LinesReader {
        stream: DuplexStream,
        bytes: Vec<u8>,
        buf: [u8; 1],
    }

    impl LinesReader {
        fn new(stream: DuplexStream) -> Self {
            Self { stream, bytes: Vec::new(), buf: [0] }
        }
        async fn next(&mut self) -> io::Result<Option<String>> {
            // prefix buf and bytes with self.
            // ...
            let raw = std::mem::take(&mut self.bytes);
            let s = String::from_utf8(raw)
                .map_err(|_| io::Error::new(io::ErrorKind::InvalidData, "not UTF-8"))?;
            // ...
        }
    }
    ```

- [`Interval::tick`](https://docs.rs/tokio/latest/tokio/time/struct.Interval.html#method.tick)
  is cancellation-safe because it keeps track of whether a tick has been
  'delivered'.

- [`AsyncReadExt::read`](https://docs.rs/tokio/latest/tokio/io/trait.AsyncReadExt.html#method.read)
  is cancellation-safe because it either returns or doesn't read data.

- [`AsyncBufReadExt::read_line`](https://docs.rs/tokio/latest/tokio/io/trait.AsyncBufReadExt.html#method.read_line)
  is similar to the example and _isn't_ cancellation-safe. See its documentation
  for details and alternatives.

</details>



================================================
FILE: src/concurrency/async-pitfalls/pin.md
================================================
---
minutes: 20
---

# `Pin`

Recall an async function or block creates a type implementing `Future` and
containing all of the local variables. Some of those variables can hold
references (pointers) to other local variables. To ensure those remain valid,
the future can never be moved to a different memory location.

To prevent moving the future type in memory, it can only be polled through a
pinned pointer. `Pin` is a wrapper around a reference that disallows all
operations that would move the instance it points to into a different memory
location.

```rust,editable,compile_fail
use tokio::sync::{mpsc, oneshot};
use tokio::task::spawn;
use tokio::time::{Duration, sleep};

// A work item. In this case, just sleep for the given time and respond
// with a message on the `respond_on` channel.
#[derive(Debug)]
struct Work {
    input: u32,
    respond_on: oneshot::Sender<u32>,
}

// A worker which listens for work on a queue and performs it.
async fn worker(mut work_queue: mpsc::Receiver<Work>) {
    let mut iterations = 0;
    loop {
        tokio::select! {
            Some(work) = work_queue.recv() => {
                sleep(Duration::from_millis(10)).await; // Pretend to work.
                work.respond_on
                    .send(work.input * 1000)
                    .expect("failed to send response");
                iterations += 1;
            }
            // TODO: report number of iterations every 100ms
        }
    }
}

// A requester which requests work and waits for it to complete.
async fn do_work(work_queue: &mpsc::Sender<Work>, input: u32) -> u32 {
    let (tx, rx) = oneshot::channel();
    work_queue
        .send(Work { input, respond_on: tx })
        .await
        .expect("failed to send on work queue");
    rx.await.expect("failed waiting for response")
}

#[tokio::main]
async fn main() {
    let (tx, rx) = mpsc::channel(10);
    spawn(worker(rx));
    for i in 0..100 {
        let resp = do_work(&tx, i).await;
        println!("work result for iteration {i}: {resp}");
    }
}
```

<details>

- You may recognize this as an example of the actor pattern. Actors typically
  call `select!` in a loop.

- This serves as a summation of a few of the previous lessons, so take your time
  with it.

  - Naively add a `_ = sleep(Duration::from_millis(100)) => { println!(..) }` to
    the `select!`. This will never execute. Why?

  - Instead, add a `timeout_fut` containing that future outside of the `loop`:

    ```rust,compile_fail
    let timeout_fut = sleep(Duration::from_millis(100));
    loop {
        select! {
            ..,
            _ = timeout_fut => { println!(..); },
        }
    }
    ```
  - This still doesn't work. Follow the compiler errors, adding `&mut` to the
    `timeout_fut` in the `select!` to work around the move, then using
    `Box::pin`:

    ```rust,compile_fail
    let mut timeout_fut = Box::pin(sleep(Duration::from_millis(100)));
    loop {
        select! {
            ..,
            _ = &mut timeout_fut => { println!(..); },
        }
    }
    ```

  - This compiles, but once the timeout expires it is `Poll::Ready` on every
    iteration (a fused future would help with this). Update to reset
    `timeout_fut` every time it expires:
    ```rust,compile_fail
    let mut timeout_fut = Box::pin(sleep(Duration::from_millis(100)));
    loop {
        select! {
            _ = &mut timeout_fut => {
                println!(..);
                timeout_fut = Box::pin(sleep(Duration::from_millis(100)));
            },
        }
    }
    ```

- Box allocates on the heap. In some cases, `std::pin::pin!` (only recently
  stabilized, with older code often using `tokio::pin!`) is also an option, but
  that is difficult to use for a future that is reassigned.

- Another alternative is to not use `pin` at all but spawn another task that
  will send to a `oneshot` channel every 100ms.

- Data that contains pointers to itself is called self-referential. Normally,
  the Rust borrow checker would prevent self-referential data from being moved,
  as the references cannot outlive the data they point to. However, the code
  transformation for async blocks and functions is not verified by the borrow
  checker.

- `Pin` is a wrapper around a reference. An object cannot be moved from its
  place using a pinned pointer. However, it can still be moved through an
  unpinned pointer.

- The `poll` method of the `Future` trait uses `Pin<&mut Self>` instead of
  `&mut Self` to refer to the instance. That's why it can only be called on a
  pinned pointer.

</details>



================================================
FILE: src/concurrency/channels/bounded.md
================================================
---
minutes: 8
---

# Bounded Channels

With bounded (synchronous) channels, [`send()`] can block the current thread:

```rust,editable
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::sync_channel(3);

    thread::spawn(move || {
        let thread_id = thread::current().id();
        for i in 0..10 {
            tx.send(format!("Message {i}")).unwrap();
            println!("{thread_id:?}: sent Message {i}");
        }
        println!("{thread_id:?}: done");
    });
    thread::sleep(Duration::from_millis(100));

    for msg in rx.iter() {
        println!("Main: got {msg}");
    }
}
```

<details>

- Calling `send()` will block the current thread until there is space in the
  channel for the new message. The thread can be blocked indefinitely if there
  is nobody who reads from the channel.
- Like unbounded channels, a call to `send()` will abort with an error if the
  channel is closed.
- A bounded channel with a size of zero is called a "rendezvous channel". Every
  send will block the current thread until another thread calls [`recv()`].

</details>

[`send()`]: https://doc.rust-lang.org/std/sync/mpsc/struct.SyncSender.html#method.send
[`recv()`]: https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html#method.recv



================================================
FILE: src/concurrency/channels/senders-receivers.md
================================================
---
minutes: 9
---

# Senders and Receivers

Rust channels have two parts: a [`Sender<T>`] and a [`Receiver<T>`]. The two
parts are connected via the channel, but you only see the end-points.

```rust,editable
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    tx.send(10).unwrap();
    tx.send(20).unwrap();

    println!("Received: {:?}", rx.recv());
    println!("Received: {:?}", rx.recv());

    let tx2 = tx.clone();
    tx2.send(30).unwrap();
    println!("Received: {:?}", rx.recv());
}
```

<details>

- [`mpsc`] stands for Multi-Producer, Single-Consumer. `Sender` and `SyncSender`
  implement `Clone` (so you can make multiple producers) but `Receiver` does
  not.
- [`send()`] and [`recv()`] return `Result`. If they return `Err`, it means the
  counterpart `Sender` or `Receiver` is dropped and the channel is closed.

</details>

[`Sender<T>`]: https://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html
[`Receiver<T>`]: https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html
[`send()`]: https://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html#method.send
[`recv()`]: https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html#method.recv
[`mpsc`]: https://doc.rust-lang.org/std/sync/mpsc/index.html



================================================
FILE: src/concurrency/channels/unbounded.md
================================================
---
minutes: 2
---

# Unbounded Channels

You get an unbounded and asynchronous channel with [`mpsc::channel()`]:

```rust,editable
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let thread_id = thread::current().id();
        for i in 0..10 {
            tx.send(format!("Message {i}")).unwrap();
            println!("{thread_id:?}: sent Message {i}");
        }
        println!("{thread_id:?}: done");
    });
    thread::sleep(Duration::from_millis(100));

    for msg in rx.iter() {
        println!("Main: got {msg}");
    }
}
```

[`mpsc::channel()`]: https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html

<details>

- An unbounded channel will allocate as much space as is necessary to store
  pending messages. The `send()` method will not block the calling thread.
- A call to `send()` will abort with an error (that is why it returns `Result`)
  if the channel is closed. A channel is closed when the receiver is dropped.

</details>



================================================
FILE: src/concurrency/send-sync/examples.md
================================================
---
minutes: 6
---

# Examples

## `Send + Sync`

Most types you come across are `Send + Sync`:

- `i8`, `f32`, `bool`, `char`, `&str`, ...
- `(T1, T2)`, `[T; N]`, `&[T]`, `struct { x: T }`, ...
- `String`, `Option<T>`, `Vec<T>`, `Box<T>`, ...
- `Arc<T>`: Explicitly thread-safe via atomic reference count.
- `Mutex<T>`: Explicitly thread-safe via internal locking.
- `mpsc::Sender<T>`: As of 1.72.0.
- `AtomicBool`, `AtomicU8`, ...: Uses special atomic instructions.

The generic types are typically `Send + Sync` when the type parameters are
`Send + Sync`.

## `Send + !Sync`

These types can be moved to other threads, but they're not thread-safe.
Typically because of interior mutability:

- `mpsc::Receiver<T>`
- `Cell<T>`
- `RefCell<T>`

## `!Send + Sync`

These types are safe to access (via shared references) from multiple threads,
but they cannot be moved to another thread:

- `MutexGuard<T: Sync>`: Uses OS level primitives which must be deallocated on
  the thread which created them. However, an already-locked mutex can have its
  guarded variable read by any thread with which the guard is shared.

## `!Send + !Sync`

These types are not thread-safe and cannot be moved to other threads:

- `Rc<T>`: each `Rc<T>` has a reference to an `RcBox<T>`, which contains a
  non-atomic reference count.
- `*const T`, `*mut T`: Rust assumes raw pointers may have special concurrency
  considerations.



================================================
FILE: src/concurrency/send-sync/marker-traits.md
================================================
---
minutes: 2
---

# Marker Traits

How does Rust know to forbid shared access across threads? The answer is in two
traits:

- [`Send`][1]: a type `T` is `Send` if it is safe to move a `T` across a thread
  boundary.
- [`Sync`][2]: a type `T` is `Sync` if it is safe to move a `&T` across a thread
  boundary.

`Send` and `Sync` are [unsafe traits][3]. The compiler will automatically derive
them for your types as long as they only contain `Send` and `Sync` types. You
can also implement them manually when you know it is valid.

[1]: https://doc.rust-lang.org/std/marker/trait.Send.html
[2]: https://doc.rust-lang.org/std/marker/trait.Sync.html
[3]: ../../unsafe-rust/unsafe-traits.md

<details>

- One can think of these traits as markers that the type has certain
  thread-safety properties.
- They can be used in the generic constraints as normal traits.

</details>



================================================
FILE: src/concurrency/send-sync/send.md
================================================
---
minutes: 2
---

# `Send`

> A type `T` is [`Send`][1] if it is safe to move a `T` value to another thread.

The effect of moving ownership to another thread is that _destructors_ will run
in that thread. So the question is when you can allocate a value in one thread
and deallocate it in another.

[1]: https://doc.rust-lang.org/std/marker/trait.Send.html

<details>

As an example, a connection to the SQLite library must only be accessed from a
single thread.

</details>



================================================
FILE: src/concurrency/send-sync/sync.md
================================================
---
minutes: 2
---

# `Sync`

> A type `T` is [`Sync`][1] if it is safe to access a `T` value from multiple
> threads at the same time.

More precisely, the definition is:

> `T` is `Sync` if and only if `&T` is `Send`

[1]: https://doc.rust-lang.org/std/marker/trait.Sync.html

<details>

This statement is essentially a shorthand way of saying that if a type is
thread-safe for shared use, it is also thread-safe to pass references of it
across threads.

This is because if a type is Sync it means that it can be shared across multiple
threads without the risk of data races or other synchronization issues, so it is
safe to move it to another thread. A reference to the type is also safe to move
to another thread, because the data it references can be accessed from any
thread safely.

</details>



================================================
FILE: src/concurrency/shared-state/arc.md
================================================
---
minutes: 5
---

# `Arc`

[`Arc<T>`][1] allows shared, read-only ownership via `Arc::clone`:

```rust,editable
use std::sync::Arc;
use std::thread;

/// A struct that prints which thread drops it.
#[derive(Debug)]
struct WhereDropped(Vec<i32>);

impl Drop for WhereDropped {
    fn drop(&mut self) {
        println!("Dropped by {:?}", thread::current().id())
    }
}

fn main() {
    let v = Arc::new(WhereDropped(vec![10, 20, 30]));
    let mut handles = Vec::new();
    for i in 0..5 {
        let v = Arc::clone(&v);
        handles.push(thread::spawn(move || {
            // Sleep for 0-500ms.
            std::thread::sleep(std::time::Duration::from_millis(500 - i * 100));
            let thread_id = thread::current().id();
            println!("{thread_id:?}: {v:?}");
        }));
    }

    // Now only the spawned threads will hold clones of `v`.
    drop(v);

    // When the last spawned thread finishes, it will drop `v`'s contents.
    handles.into_iter().for_each(|h| h.join().unwrap());
}
```

[1]: https://doc.rust-lang.org/std/sync/struct.Arc.html

<details>

- `Arc` stands for "Atomic Reference Counted", a thread safe version of `Rc`
  that uses atomic operations.
- `Arc<T>` implements `Clone` whether or not `T` does. It implements `Send` and
  `Sync` if and only if `T` implements them both.
- `Arc::clone()` has the cost of atomic operations that get executed, but after
  that the use of the `T` is free.
- Beware of reference cycles, `Arc` does not use a garbage collector to detect
  them.
  - `std::sync::Weak` can help.

</details>



================================================
FILE: src/concurrency/shared-state/example.md
================================================
---
minutes: 8
---

# Example

Let us see `Arc` and `Mutex` in action:

```rust,editable,compile_fail
use std::thread;
// use std::sync::{Arc, Mutex};

fn main() {
    let v = vec![10, 20, 30];
    let mut handles = Vec::new();
    for i in 0..5 {
        handles.push(thread::spawn(|| {
            v.push(10 * i);
            println!("v: {v:?}");
        }));
    }

    handles.into_iter().for_each(|h| h.join().unwrap());
}
```

<details>

Possible solution:

```rust,editable
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let v = Arc::new(Mutex::new(vec![10, 20, 30]));
    let mut handles = Vec::new();
    for i in 0..5 {
        let v = Arc::clone(&v);
        handles.push(thread::spawn(move || {
            let mut v = v.lock().unwrap();
            v.push(10 * i);
            println!("v: {v:?}");
        }));
    }

    handles.into_iter().for_each(|h| h.join().unwrap());
}
```

Notable parts:

- `v` is wrapped in both `Arc` and `Mutex`, because their concerns are
  orthogonal.
  - Wrapping a `Mutex` in an `Arc` is a common pattern to share mutable state
    between threads.
- `v: Arc<_>` needs to be cloned to make a new reference for each new spawned
  thread. Note `move` was added to the lambda signature.
- Blocks are introduced to narrow the scope of the `LockGuard` as much as
  possible.

</details>



================================================
FILE: src/concurrency/shared-state/mutex.md
================================================
---
minutes: 14
---

# `Mutex`

[`Mutex<T>`][1] ensures mutual exclusion _and_ allows mutable access to `T`
behind a read-only interface (another form of
[interior mutability](../../borrowing/interior-mutability.md)):

```rust,editable
use std::sync::Mutex;

fn main() {
    let v = Mutex::new(vec![10, 20, 30]);
    println!("v: {:?}", v.lock().unwrap());

    {
        let mut guard = v.lock().unwrap();
        guard.push(40);
    }

    println!("v: {:?}", v.lock().unwrap());
}
```

Notice how we have a [`impl<T: Send> Sync for Mutex<T>`][2] blanket
implementation.

[1]: https://doc.rust-lang.org/std/sync/struct.Mutex.html
[2]: https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E
[3]: https://doc.rust-lang.org/std/sync/struct.Arc.html

<details>

- `Mutex` in Rust looks like a collection with just one element --- the
  protected data.
  - It is not possible to forget to acquire the mutex before accessing the
    protected data.
- You can get an `&mut T` from an `&Mutex<T>` by taking the lock. The
  `MutexGuard` ensures that the `&mut T` doesn't outlive the lock being held.
- `Mutex<T>` implements both `Send` and `Sync` if and only if `T` implements
  `Send`.
- A read-write lock counterpart: `RwLock`.
- Why does `lock()` return a `Result`?
  - If the thread that held the `Mutex` panicked, the `Mutex` becomes "poisoned"
    to signal that the data it protected might be in an inconsistent state.
    Calling `lock()` on a poisoned mutex fails with a [`PoisonError`]. You can
    call `into_inner()` on the error to recover the data regardless.

[`PoisonError`]: https://doc.rust-lang.org/std/sync/struct.PoisonError.html

</details>



================================================
FILE: src/concurrency/sync-exercises/Cargo.toml
================================================
[package]
name = "sync-exercises"
version = "0.1.0"
edition = "2024"
publish = false

[[bin]]
name = "dining-philosophers"
path = "dining-philosophers.rs"

[[bin]]
name = "link-checker"
path = "link-checker.rs"

[dependencies]
reqwest = { version = "0.12.23", features = ["blocking"] }
scraper = "0.24.0"
thiserror = "2.0.16"

[dev-dependencies]
tempfile = "3.21.0"



================================================
FILE: src/concurrency/sync-exercises/dining-philosophers.md
================================================
---
minutes: 20
---

# Dining Philosophers

The dining philosophers problem is a classic problem in concurrency:

> Five philosophers dine together at the same table. Each philosopher has their
> own place at the table. There is a chopstick between each plate. The dish
> served is spaghetti which requires two chopsticks to eat. Each philosopher can
> only alternately think and eat. Moreover, a philosopher can only eat their
> spaghetti when they have both a left and right chopstick. Thus two chopsticks
> will only be available when their two nearest neighbors are thinking, not
> eating. After an individual philosopher finishes eating, they will put down
> both chopsticks.

You will need a local [Cargo installation](../../cargo/running-locally.md) for
this exercise. Copy the code below to a file called `src/main.rs`, fill out the
blanks, and test that `cargo run` does not deadlock:

<!-- File src/main.rs -->

```rust,compile_fail
{{#include dining-philosophers.rs:Philosopher}}
    // left_chopstick: ...
    // right_chopstick: ...
    // thoughts: ...
}

{{#include dining-philosophers.rs:Philosopher-think}}

{{#include dining-philosophers.rs:Philosopher-eat}}
        // Pick up chopsticks...
{{#include dining-philosophers.rs:Philosopher-eat-end}}
    // Create chopsticks

    // Create philosophers

    // Make each of them think and eat 100 times

    // Output their thoughts
}
```

You can use the following `Cargo.toml`:

<!-- File Cargo.toml -->

```toml
[package]
name = "dining-philosophers"
version = "0.1.0"
edition = "2024"
```

<details>

- Encourage students to focus first on implementing a solution that "mostly"
  works.
- The deadlock in the simplest solution is a general concurrency problem and
  highlights that Rust does not automatically prevent this sort of bug.

</details>



================================================
FILE: src/concurrency/sync-exercises/dining-philosophers.rs
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: solution
// ANCHOR: Philosopher
use std::sync::{Arc, Mutex, mpsc};
use std::thread;
use std::time::Duration;

struct Chopstick;

struct Philosopher {
    name: String,
    // ANCHOR_END: Philosopher
    left_chopstick: Arc<Mutex<Chopstick>>,
    right_chopstick: Arc<Mutex<Chopstick>>,
    thoughts: mpsc::SyncSender<String>,
}

// ANCHOR: Philosopher-think
impl Philosopher {
    fn think(&self) {
        self.thoughts
            .send(format!("Eureka! {} has a new idea!", &self.name))
            .unwrap();
    }
    // ANCHOR_END: Philosopher-think

    // ANCHOR: Philosopher-eat
    fn eat(&self) {
        // ANCHOR_END: Philosopher-eat
        println!("{} is trying to eat", &self.name);
        let _left = self.left_chopstick.lock().unwrap();
        let _right = self.right_chopstick.lock().unwrap();

        // ANCHOR: Philosopher-eat-end
        println!("{} is eating...", &self.name);
        thread::sleep(Duration::from_millis(10));
    }
}

static PHILOSOPHERS: &[&str] =
    &["Socrates", "Hypatia", "Plato", "Aristotle", "Pythagoras"];

fn main() {
    // ANCHOR_END: Philosopher-eat-end
    let (tx, rx) = mpsc::sync_channel(10);

    let chopsticks = PHILOSOPHERS
        .iter()
        .map(|_| Arc::new(Mutex::new(Chopstick)))
        .collect::<Vec<_>>();

    for i in 0..chopsticks.len() {
        let tx = tx.clone();
        let mut left_chopstick = Arc::clone(&chopsticks[i]);
        let mut right_chopstick =
            Arc::clone(&chopsticks[(i + 1) % chopsticks.len()]);

        // To avoid a deadlock, we have to break the symmetry
        // somewhere. This will swap the chopsticks without deinitializing
        // either of them.
        if i == chopsticks.len() - 1 {
            std::mem::swap(&mut left_chopstick, &mut right_chopstick);
        }

        let philosopher = Philosopher {
            name: PHILOSOPHERS[i].to_string(),
            thoughts: tx,
            left_chopstick,
            right_chopstick,
        };

        thread::spawn(move || {
            for _ in 0..100 {
                philosopher.eat();
                philosopher.think();
            }
        });
    }

    drop(tx);
    for thought in rx {
        println!("{thought}");
    }
}



================================================
FILE: src/concurrency/sync-exercises/link-checker.md
================================================
---
minutes: 20
---

# Multi-threaded Link Checker

Let us use our new knowledge to create a multi-threaded link checker. It should
start at a webpage and check that links on the page are valid. It should
recursively check other pages on the same domain and keep doing this until all
pages have been validated.

For this, you will need an HTTP client such as [`reqwest`][1]. You will also
need a way to find links, we can use [`scraper`][2]. Finally, we'll need some
way of handling errors, we will use [`thiserror`][3].

Create a new Cargo project and `reqwest` it as a dependency with:

```shell
cargo new link-checker
cd link-checker
cargo add --features blocking,rustls-tls reqwest
cargo add scraper
cargo add thiserror
```

> If `cargo add` fails with `error: no such subcommand`, then please edit the
> `Cargo.toml` file by hand. Add the dependencies listed below.

The `cargo add` calls will update the `Cargo.toml` file to look like this:

<!-- File Cargo.toml -->

```toml
[package]
name = "link-checker"
version = "0.1.0"
edition = "2024"
publish = false

[dependencies]
reqwest = { version = "0.11.12", features = ["blocking", "rustls-tls"] }
scraper = "0.13.0"
thiserror = "1.0.37"
```

You can now download the start page. Try with a small site such as
`https://www.google.org/`.

Your `src/main.rs` file should look something like this:

<!-- File src/main.rs -->

```rust,compile_fail
{{#include link-checker.rs:setup}}

{{#include link-checker.rs:visit_page}}

fn main() {
    let client = Client::new();
    let start_url = Url::parse("https://www.google.org").unwrap();
    let crawl_command = CrawlCommand{ url: start_url, extract_links: true };
    match visit_page(&client, &crawl_command) {
        Ok(links) => println!("Links: {links:#?}"),
        Err(err) => println!("Could not extract links: {err:#}"),
    }
}
```

Run the code in `src/main.rs` with

```shell
cargo run
```

## Tasks

- Use threads to check the links in parallel: send the URLs to be checked to a
  channel and let a few threads check the URLs in parallel.
- Extend this to recursively extract links from all pages on the
  `www.google.org` domain. Put an upper limit of 100 pages or so so that you
  don't end up being blocked by the site.

<details>

- This is a complex exercise and intended to give students an opportunity to
  work on a larger project than others. A success condition for this exercise is
  to get stuck on some "real" issue and work through it with the support of
  other students or the instructor.

</details>

[1]: https://docs.rs/reqwest/
[2]: https://docs.rs/scraper/
[3]: https://docs.rs/thiserror/



================================================
FILE: src/concurrency/sync-exercises/link-checker.rs
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: solution
use std::sync::{Arc, Mutex, mpsc};
use std::thread;

// ANCHOR: setup
use reqwest::Url;
use reqwest::blocking::Client;
use scraper::{Html, Selector};
use thiserror::Error;

#[derive(Error, Debug)]
enum Error {
    #[error("request error: {0}")]
    ReqwestError(#[from] reqwest::Error),
    #[error("bad http response: {0}")]
    BadResponse(String),
}
// ANCHOR_END: setup

// ANCHOR: visit_page
#[derive(Debug)]
struct CrawlCommand {
    url: Url,
    extract_links: bool,
}

fn visit_page(client: &Client, command: &CrawlCommand) -> Result<Vec<Url>, Error> {
    println!("Checking {:#}", command.url);
    let response = client.get(command.url.clone()).send()?;
    if !response.status().is_success() {
        return Err(Error::BadResponse(response.status().to_string()));
    }

    let mut link_urls = Vec::new();
    if !command.extract_links {
        return Ok(link_urls);
    }

    let base_url = response.url().to_owned();
    let body_text = response.text()?;
    let document = Html::parse_document(&body_text);

    let selector = Selector::parse("a").unwrap();
    let href_values = document
        .select(&selector)
        .filter_map(|element| element.value().attr("href"));
    for href in href_values {
        match base_url.join(href) {
            Ok(link_url) => {
                link_urls.push(link_url);
            }
            Err(err) => {
                println!("On {base_url:#}: ignored unparsable {href:?}: {err}");
            }
        }
    }
    Ok(link_urls)
}
// ANCHOR_END: visit_page

struct CrawlState {
    domain: String,
    visited_pages: std::collections::HashSet<String>,
}

impl CrawlState {
    fn new(start_url: &Url) -> CrawlState {
        let mut visited_pages = std::collections::HashSet::new();
        visited_pages.insert(start_url.as_str().to_string());
        CrawlState { domain: start_url.domain().unwrap().to_string(), visited_pages }
    }

    /// Determine whether links within the given page should be extracted.
    fn should_extract_links(&self, url: &Url) -> bool {
        let Some(url_domain) = url.domain() else {
            return false;
        };
        url_domain == self.domain
    }

    /// Mark the given page as visited, returning false if it had already
    /// been visited.
    fn mark_visited(&mut self, url: &Url) -> bool {
        self.visited_pages.insert(url.as_str().to_string())
    }
}

type CrawlResult = Result<Vec<Url>, (Url, Error)>;
fn spawn_crawler_threads(
    command_receiver: mpsc::Receiver<CrawlCommand>,
    result_sender: mpsc::Sender<CrawlResult>,
    thread_count: u32,
) {
    // To multiplex the non-cloneable Receiver, wrap it in Arc<Mutex<_>>.
    let command_receiver = Arc::new(Mutex::new(command_receiver));

    for _ in 0..thread_count {
        let result_sender = result_sender.clone();
        let command_receiver = Arc::clone(&command_receiver);
        thread::spawn(move || {
            let client = Client::new();
            loop {
                let command_result = {
                    let receiver_guard = command_receiver.lock().unwrap();
                    receiver_guard.recv()
                };
                let Ok(crawl_command) = command_result else {
                    // The sender got dropped. No more commands coming in.
                    break;
                };
                let crawl_result = match visit_page(&client, &crawl_command) {
                    Ok(link_urls) => Ok(link_urls),
                    Err(error) => Err((crawl_command.url, error)),
                };
                result_sender.send(crawl_result).unwrap();
            }
        });
    }
}

fn control_crawl(
    start_url: Url,
    command_sender: mpsc::Sender<CrawlCommand>,
    result_receiver: mpsc::Receiver<CrawlResult>,
) -> Vec<Url> {
    let mut crawl_state = CrawlState::new(&start_url);
    let start_command = CrawlCommand { url: start_url, extract_links: true };
    command_sender.send(start_command).unwrap();
    let mut pending_urls = 1;

    let mut bad_urls = Vec::new();
    while pending_urls > 0 {
        let crawl_result = result_receiver.recv().unwrap();
        pending_urls -= 1;

        match crawl_result {
            Ok(link_urls) => {
                for url in link_urls {
                    if crawl_state.mark_visited(&url) {
                        let extract_links = crawl_state.should_extract_links(&url);
                        let crawl_command = CrawlCommand { url, extract_links };
                        command_sender.send(crawl_command).unwrap();
                        pending_urls += 1;
                    }
                }
            }
            Err((url, error)) => {
                bad_urls.push(url);
                println!("Got crawling error: {:#}", error);
                continue;
            }
        }
    }
    bad_urls
}

fn check_links(start_url: Url) -> Vec<Url> {
    let (result_sender, result_receiver) = mpsc::channel::<CrawlResult>();
    let (command_sender, command_receiver) = mpsc::channel::<CrawlCommand>();
    spawn_crawler_threads(command_receiver, result_sender, 16);
    control_crawl(start_url, command_sender, result_receiver)
}

fn main() {
    let start_url = reqwest::Url::parse("https://www.google.org").unwrap();
    let bad_urls = check_links(start_url);
    println!("Bad URLs: {:#?}", bad_urls);
}



================================================
FILE: src/concurrency/sync-exercises/solutions.md
================================================
---
minutes: 30
---

# Solutions

## Dining Philosophers

```rust
{{#include dining-philosophers.rs:solution}}
```

## Link Checker

```rust,compile_fail
{{#include link-checker.rs:solution}}
```



================================================
FILE: src/concurrency/threads/plain.md
================================================
---
minutes: 15
---

# Plain Threads

Rust threads work similarly to threads in other languages:

```rust,editable
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 0..10 {
            println!("Count in thread: {i}!");
            thread::sleep(Duration::from_millis(5));
        }
    });

    for i in 0..5 {
        println!("Main thread: {i}");
        thread::sleep(Duration::from_millis(5));
    }
}
```

- Spawning new threads does not automatically delay program termination at the
  end of `main`.
- Thread panics are independent of each other.
  - Panics can carry a payload, which can be unpacked with
    [`Any::downcast_ref`].

<details>

- Run the example.
  - 5ms timing is loose enough that main and spawned threads stay mostly in
    lockstep.
  - Notice that the program ends before the spawned thread reaches 10!
  - This is because `main` ends the program and spawned threads do not make it
    persist.
    - Compare to `pthreads`/C++ `std::thread`/`boost::thread` if desired.

- How do we wait around for the spawned thread to complete?
- [`thread::spawn`] returns a `JoinHandle`. Look at the docs.
  - `JoinHandle` has a [`.join()`] method that blocks.

- Use `let handle = thread::spawn(...)` and later `handle.join()` to wait for
  the thread to finish and have the program count all the way to 10.

- Now what if we want to return a value?
- Look at docs again:
  - [`thread::spawn`]'s closure returns `T`
  - `JoinHandle` [`.join()`] returns `thread::Result<T>`

- Use the `Result` return value from `handle.join()` to get access to the
  returned value.

- Ok, what about the other case?
  - Trigger a panic in the thread. Note that this doesn't panic `main`.
  - Access the panic payload. This is a good time to talk about [`Any`].

- Now we can return values from threads! What about taking inputs?
  - Capture something by reference in the thread closure.
  - An error message indicates we must move it.
  - Move it in, see we can compute and then return a derived value.

- If we want to borrow?
  - Main kills child threads when it returns, but another function would just
    return and leave them running.
  - That would be stack use-after-return, which violates memory safety!
  - How do we avoid this? See next slide.

[`Any`]: https://doc.rust-lang.org/std/any/index.html
[`Any::downcast_ref`]: https://doc.rust-lang.org/std/any/trait.Any.html#method.downcast_ref
[`thread::spawn`]: https://doc.rust-lang.org/std/thread/fn.spawn.html
[`.join()`]: https://doc.rust-lang.org/std/thread/struct.JoinHandle.html#method.join

</details>



================================================
FILE: src/concurrency/threads/scoped.md
================================================
---
minutes: 13
---

# Scoped Threads

Normal threads cannot borrow from their environment:

```rust,editable,compile_fail
use std::thread;

fn foo() {
    let s = String::from("Hello");
    thread::spawn(|| {
        dbg!(s.len());
    });
}

fn main() {
    foo();
}
```

However, you can use a [scoped thread][1] for this:

```rust,editable
use std::thread;

fn foo() {
    let s = String::from("Hello");
    thread::scope(|scope| {
        scope.spawn(|| {
            dbg!(s.len());
        });
    });
}

fn main() {
    foo();
}
```

[1]: https://doc.rust-lang.org/std/thread/fn.scope.html

<details>

- The reason for that is that when the `thread::scope` function completes, all
  the threads are guaranteed to be joined, so they can return borrowed data.
- Normal Rust borrowing rules apply: you can either borrow mutably by one
  thread, or immutably by any number of threads.

</details>



================================================
FILE: src/control-flow-basics/blocks-and-scopes.md
================================================
---
minutes: 5
---

# Blocks and Scopes

- A block in Rust contains a sequence of expressions, enclosed by braces `{}`.
- The final expression of a block determines the value and type of the whole
  block.

```rust,editable
fn main() {
    let z = 13;
    let x = {
        let y = 10;
        dbg!(y);
        z - y
    };
    dbg!(x);
    // dbg!(y);
}
```

If the last expression ends with `;`, then the resulting value and type is `()`.

A variable's scope is limited to the enclosing block.

<details>

- You can explain that dbg! is a Rust macro that prints and returns the value of
  a given expression for quick and dirty debugging.

- You can show how the value of the block changes by changing the last line in
  the block. For instance, adding/removing a semicolon or using a `return`.

- Demonstrate that attempting to access `y` outside of its scope won't compile.

- Values are effectively "deallocated" when they go out of their scope, even if
  their data on the stack is still there.

</details>



================================================
FILE: src/control-flow-basics/break-continue.md
================================================
---
minutes: 4
---

# `break` and `continue`

If you want to immediately start the next iteration use
[`continue`](https://doc.rust-lang.org/reference/expressions/loop-expr.html#continue-expressions).

If you want to exit any kind of loop early, use
[`break`](https://doc.rust-lang.org/reference/expressions/loop-expr.html#break-expressions).
With `loop`, this can take an optional expression that becomes the value of the
`loop` expression.

```rust,editable
fn main() {
    let mut i = 0;
    loop {
        i += 1;
        if i > 5 {
            break;
        }
        if i % 2 == 0 {
            continue;
        }
        dbg!(i);
    }
}
```

<details>

Note that `loop` is the only looping construct that can return a non-trivial
value. This is because it's guaranteed to only return at a `break` statement
(unlike `while` and `for` loops, which can also return when the condition
fails).

</details>



================================================
FILE: src/control-flow-basics/Cargo.toml
================================================
[package]
name = "control-flow-basics"
version = "0.1.0"
edition = "2024"
publish = false

[[bin]]
name = "collatz"
path = "exercise.rs"



================================================
FILE: src/control-flow-basics/exercise.md
================================================
---
minutes: 15
---

# Exercise: Collatz Sequence

The [Collatz Sequence](https://en.wikipedia.org/wiki/Collatz_conjecture) is
defined as follows, for an arbitrary n<sub>1</sub> greater than zero:

- If _n<sub>i</sub>_ is 1, then the sequence terminates at _n<sub>i</sub>_.
- If _n<sub>i</sub>_ is even, then _n<sub>i+1</sub> = n<sub>i</sub> / 2_.
- If _n<sub>i</sub>_ is odd, then _n<sub>i+1</sub> = 3 * n<sub>i</sub> + 1_.

For example, beginning with _n<sub>1</sub>_ = 3:

- 3 is odd, so _n<sub>2</sub>_ = 3 * 3 + 1 = 10;
- 10 is even, so _n<sub>3</sub>_ = 10 / 2 = 5;
- 5 is odd, so _n<sub>4</sub>_ = 3 * 5 + 1 = 16;
- 16 is even, so _n<sub>5</sub>_ = 16 / 2 = 8;
- 8 is even, so _n<sub>6</sub>_ = 8 / 2 = 4;
- 4 is even, so _n<sub>7</sub>_ = 4 / 2 = 2;
- 2 is even, so _n<sub>8</sub>_ = 1; and
- the sequence terminates.

Write a function to calculate the length of the Collatz sequence for a given
initial `n`.

```rust,editable,should_panic
{{#include exercise.rs:collatz_length}}
  todo!("Implement this")
}

{{#include exercise.rs:main}}
```



================================================
FILE: src/control-flow-basics/exercise.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: solution
// ANCHOR: collatz_length
/// Determine the length of the collatz sequence beginning at `n`.
fn collatz_length(mut n: i32) -> u32 {
    // ANCHOR_END: collatz_length
    let mut len = 1;
    while n > 1 {
        n = if n % 2 == 0 { n / 2 } else { 3 * n + 1 };
        len += 1;
    }
    len
}

// ANCHOR: main
fn main() {
    println!("Length: {}", collatz_length(11)); // should be 15
}
// ANCHOR_END: main
// ANCHOR_END: solution

#[test]
fn test_collatz_length() {
    assert_eq!(collatz_length(11), 15);
}



================================================
FILE: src/control-flow-basics/functions.md
================================================
---
minutes: 3
---

# Functions

<!-- mdbook-xgettext: skip -->

```rust,editable
fn gcd(a: u32, b: u32) -> u32 {
    if b > 0 { gcd(b, a % b) } else { a }
}

fn main() {
    dbg!(gcd(143, 52));
}
```

<details>

- Declaration parameters are followed by a type (the reverse of some programming
  languages), then a return type.
- The last expression in a function body (or any block) becomes the return
  value. Simply omit the `;` at the end of the expression. The `return` keyword
  can be used for early return, but the "bare value" form is idiomatic at the
  end of a function (refactor `gcd` to use a `return`).
- Some functions have no return value, and return the 'unit type', `()`. The
  compiler will infer this if the return type is omitted.
- Overloading is not supported -- each function has a single implementation.
  - Always takes a fixed number of parameters. Default arguments are not
    supported. Macros can be used to support variadic functions.
  - Always takes a single set of parameter types. These types can be generic,
    which will be covered later.

</details>



================================================
FILE: src/control-flow-basics/if.md
================================================
---
minutes: 4
---

# `if` expressions

You use
[`if` expressions](https://doc.rust-lang.org/reference/expressions/if-expr.html#if-expressions)
exactly like `if` statements in other languages:

```rust,editable
fn main() {
    let x = 10;
    if x == 0 {
        println!("zero!");
    } else if x < 100 {
        println!("biggish");
    } else {
        println!("huge");
    }
}
```

In addition, you can use `if` as an expression. The last expression of each
block becomes the value of the `if` expression:

```rust,editable
fn main() {
    let x = 10;
    let size = if x < 20 { "small" } else { "large" };
    println!("number size: {}", size);
}
```

<details>

Because `if` is an expression and must have a particular type, both of its
branch blocks must have the same type. Show what happens if you add `;` after
`"small"` in the second example.

An `if` expression should be used in the same way as the other expressions. For
example, when it is used in a `let` statement, the statement must be terminated
with a `;` as well. Remove the `;` before `println!` to see the compiler error.

</details>



================================================
FILE: src/control-flow-basics/loops.md
================================================
---
minutes: 5
---

# Loops

There are three looping keywords in Rust: `while`, `loop`, and `for`:

## `while`

The
[`while` keyword](https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-loops)
works much like in other languages, executing the loop body as long as the
condition is true.

```rust,editable
fn main() {
    let mut x = 200;
    while x >= 10 {
        x = x / 2;
    }
    dbg!(x);
}
```



================================================
FILE: src/control-flow-basics/macros.md
================================================
---
minutes: 2
---

# Macros

Macros are expanded into Rust code during compilation, and can take a variable
number of arguments. They are distinguished by a `!` at the end. The Rust
standard library includes an assortment of useful macros.

- `println!(format, ..)` prints a line to standard output, applying formatting
  described in [`std::fmt`](https://doc.rust-lang.org/std/fmt/index.html).
- `format!(format, ..)` works just like `println!` but returns the result as a
  string.
- `dbg!(expression)` logs the value of the expression and returns it.
- `todo!()` marks a bit of code as not-yet-implemented. If executed, it will
  panic.

```rust,editable
fn factorial(n: u32) -> u32 {
    let mut product = 1;
    for i in 1..=n {
        product *= dbg!(i);
    }
    product
}

fn fizzbuzz(n: u32) -> u32 {
    todo!()
}

fn main() {
    let n = 4;
    println!("{n}! = {}", factorial(n));
}
```

<details>

The takeaway from this section is that these common conveniences exist, and how
to use them. Why they are defined as macros, and what they expand to, is not
especially critical.

The course does not cover defining macros, but a later section will describe use
of derive macros.

## More To Explore

There are a number of other useful macros provided by the standard library. Some
other examples you can share with students if they want to know more:

- [`assert!`] and related macros can be used to add assertions to your code.
  These are used heavily in writing tests.
- [`unreachable!`] is used to mark a branch of control flow that should never be
  hit.
- [`eprintln!`] allows you to print to stderr.

</details>

[`assert!`]: https://doc.rust-lang.org/stable/std/macro.assert.html
[`unreachable!`]: https://doc.rust-lang.org/stable/std/macro.unreachable.html
[`eprintln!`]: https://doc.rust-lang.org/stable/std/macro.eprintln.html



================================================
FILE: src/control-flow-basics/match.md
================================================
---
minutes: 5
---

# `match` Expressions

`match` can be used to check a value against one or more options:

```rust,editable
fn main() {
    let val = 1;
    match val {
        1 => println!("one"),
        10 => println!("ten"),
        100 => println!("one hundred"),
        _ => {
            println!("something else");
        }
    }
}
```

Like `if` expressions, `match` can also return a value;

```rust,editable
fn main() {
    let flag = true;
    let val = match flag {
        true => 1,
        false => 0,
    };
    println!("The value of {flag} is {val}");
}
```

<details>

- `match` arms are evaluated from top to bottom, and the first one that matches
  has its corresponding body executed.

- There is no fall-through between cases the way that `switch` works in other
  languages.

- The body of a `match` arm can be a single expression or a block. Technically
  this is the same thing, since blocks are also expressions, but students may
  not fully understand that symmetry at this point.

- `match` expressions need to be exhaustive, meaning they either need to cover
  all possible values or they need to have a default case such as `_`.
  Exhaustiveness is easiest to demonstrate with enums, but enums haven't been
  introduced yet. Instead we demonstrate matching on a `bool`, which is the
  simplest primitive type.

- This slide introduces `match` without talking about pattern matching, giving
  students a chance to get familiar with the syntax without front-loading too
  much information. We'll be talking about pattern matching in more detail
  tomorrow, so try not to go into too much detail here.

## More to Explore

- To further motivate the usage of `match`, you can compare the examples to
  their equivalents written with `if`. In the second case, matching on a `bool`,
  an `if {} else {}` block is pretty similar. But in the first example that
  checks multiple cases, a `match` expression can be more concise than
  `if {} else if {} else if {} else`.

- `match` also supports match guards, which allow you to add an arbitrary
  logical condition that will get evaluated to determine if the match arm should
  be taken. However talking about match guards requires explaining about pattern
  matching, which we're trying to avoid on this slide.

</details>



================================================
FILE: src/control-flow-basics/solution.md
================================================
# Solution

```rust,editable
{{#include exercise.rs:solution}}
```

<details>

- Note that the argument `n` is marked as `mut`, allowing you to change the
  value of `n` in the function. Like variables, function arguments are immutable
  by default and you must add `mut` if you want to modify their value. This does
  not affect how the function is called or how the argument is passed in.

</details>



================================================
FILE: src/control-flow-basics/break-continue/labels.md
================================================
# Labels

Both `continue` and `break` can optionally take a label argument that is used to
break out of nested loops:

```rust,editable
fn main() {
    let s = [[5, 6, 7], [8, 9, 10], [21, 15, 32]];
    let mut elements_searched = 0;
    let target_value = 10;
    'outer: for i in 0..=2 {
        for j in 0..=2 {
            elements_searched += 1;
            if s[i][j] == target_value {
                break 'outer;
            }
        }
    }
    dbg!(elements_searched);
}
```

<details>

- Labeled break also works on arbitrary blocks, e.g.
  ```rust
  'label: {
      break 'label;
      println!("This line gets skipped");
  }
  ```

</details>



================================================
FILE: src/control-flow-basics/loops/for.md
================================================
# `for`

The [`for` loop](https://doc.rust-lang.org/std/keyword.for.html) iterates over
ranges of values or the items in a collection:

```rust,editable
fn main() {
    for x in 1..5 {
        dbg!(x);
    }

    for elem in [2, 4, 8, 16, 32] {
        dbg!(elem);
    }
}
```

<details>

- Under the hood `for` loops use a concept called "iterators" to handle
  iterating over different kinds of ranges/collections. Iterators will be
  discussed in more detail later.
- Note that the first `for` loop only iterates to `4`. Show the `1..=5` syntax
  for an inclusive range.

</details>



================================================
FILE: src/control-flow-basics/loops/loop.md
================================================
# `loop`

The [`loop` statement](https://doc.rust-lang.org/std/keyword.loop.html) just
loops forever, until a `break`.

```rust,editable
fn main() {
    let mut i = 0;
    loop {
        i += 1;
        dbg!(i);
        if i > 100 {
            break;
        }
    }
}
```

<details>

- The `loop` statement works like a `while true` loop. Use it for things like
  servers that will serve connections forever.

</details>



================================================
FILE: src/error-handling/anyhow.md
================================================
---
minutes: 5
---

# `anyhow`

The [`anyhow`] crate provides a rich error type with support for carrying
additional contextual information, which can be used to provide a semantic trace
of what the program was doing leading up to the error.

This can be combined with the convenience macros from [`thiserror`] to avoid
writing out trait impls explicitly for custom error types.

[`anyhow`]: https://docs.rs/anyhow/
[`thiserror`]: https://docs.rs/thiserror/

```rust,editable,compile_fail
use anyhow::{Context, Result, bail};
use std::fs;
use std::io::Read;
use thiserror::Error;

#[derive(Clone, Debug, Eq, Error, PartialEq)]
#[error("Found no username in {0}")]
struct EmptyUsernameError(String);

fn read_username(path: &str) -> Result<String> {
    let mut username = String::with_capacity(100);
    fs::File::open(path)
        .with_context(|| format!("Failed to open {path}"))?
        .read_to_string(&mut username)
        .context("Failed to read")?;
    if username.is_empty() {
        bail!(EmptyUsernameError(path.to_string()));
    }
    Ok(username)
}

fn main() {
    //fs::write("config.dat", "").unwrap();
    match read_username("config.dat") {
        Ok(username) => println!("Username: {username}"),
        Err(err) => println!("Error: {err:?}"),
    }
}
```

<details>

- `anyhow::Error` is essentially a wrapper around `Box<dyn Error>`. As such it's
  again generally not a good choice for the public API of a library, but is
  widely used in applications.
- `anyhow::Result<V>` is a type alias for `Result<V, anyhow::Error>`.
- Functionality provided by `anyhow::Error` may be familiar to Go developers, as
  it provides similar behavior to the Go `error` type and
  `Result<T, anyhow::Error>` is much like a Go `(T, error)` (with the convention
  that only one element of the pair is meaningful).
- `anyhow::Context` is a trait implemented for the standard `Result` and
  `Option` types. `use anyhow::Context` is necessary to enable `.context()` and
  `.with_context()` on those types.

# More to Explore

- `anyhow::Error` has support for downcasting, much like `std::any::Any`; the
  specific error type stored inside can be extracted for examination if desired
  with
  [`Error::downcast`](https://docs.rs/anyhow/latest/anyhow/struct.Error.html#method.downcast).

</details>



================================================
FILE: src/error-handling/Cargo.toml
================================================
[package]
name = "error-handling"
version = "0.1.0"
edition = "2024"
publish = false

[dependencies]
anyhow = "*"
thiserror = "*"

[lib]
name = "parser"
path = "exercise.rs"



================================================
FILE: src/error-handling/error.md
================================================
---
minutes: 5
---

# Dynamic Error Types

Sometimes we want to allow any type of error to be returned without writing our
own enum covering all the different possibilities. The `std::error::Error` trait
makes it easy to create a trait object that can contain any error.

```rust,editable
use std::error::Error;
use std::fs;
use std::io::Read;

fn read_count(path: &str) -> Result<i32, Box<dyn Error>> {
    let mut count_str = String::new();
    fs::File::open(path)?.read_to_string(&mut count_str)?;
    let count: i32 = count_str.parse()?;
    Ok(count)
}

fn main() {
    fs::write("count.dat", "1i3").unwrap();
    match read_count("count.dat") {
        Ok(count) => println!("Count: {count}"),
        Err(err) => println!("Error: {err}"),
    }
}
```

<details>

The `read_count` function can return `std::io::Error` (from file operations) or
`std::num::ParseIntError` (from `String::parse`).

Boxing errors saves on code, but gives up the ability to cleanly handle
different error cases differently in the program. As such it's generally not a
good idea to use `Box<dyn Error>` in the public API of a library, but it can be
a good option in a program where you just want to display the error message
somewhere.

Make sure to implement the `std::error::Error` trait when defining a custom
error type so it can be boxed.

</details>



================================================
FILE: src/error-handling/exercise.md
================================================
---
minutes: 20
---

# Exercise: Rewriting with Result

In this exercise we're revisiting the expression evaluator exercise that we did
in day 2. Our initial solution ignores a possible error case: Dividing by zero!
Rewrite `eval` to instead use idiomatic error handling to handle this error case
and return an error when it occurs. We provide a simple `DivideByZeroError` type
to use as the error type for `eval`.

```rust,editable
{{#include exercise.rs:types}}

{{#include exercise.rs:eval}}

{{#include exercise.rs:tests}}
```

<details>

- The starting code here isn't exactly the same as the previous exercise's
  solution: We've added in an explicit panic to show students where the error
  case is. Point this out if students get confused.

</details>



================================================
FILE: src/error-handling/exercise.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![allow(dead_code)]
// ANCHOR: types
/// An operation to perform on two subexpressions.
#[derive(Debug)]
enum Operation {
    Add,
    Sub,
    Mul,
    Div,
}

/// An expression, in tree form.
#[derive(Debug)]
enum Expression {
    /// An operation on two subexpressions.
    Op { op: Operation, left: Box<Expression>, right: Box<Expression> },

    /// A literal value
    Value(i64),
}

#[derive(PartialEq, Eq, Debug)]
struct DivideByZeroError;
// ANCHOR_END: types

/*
// ANCHOR: eval
// The original implementation of the expression evaluator. Update this to
// return a `Result` and produce an error when dividing by 0.
fn eval(e: Expression) -> i64 {
    match e {
        Expression::Op { op, left, right } => {
            let left = eval(*left);
            let right = eval(*right);
            match op {
                Operation::Add => left + right,
                Operation::Sub => left - right,
                Operation::Mul => left * right,
                Operation::Div => if right != 0 {
                    left / right
                } else {
                    panic!("Cannot divide by zero!");
                },
            }
        }
        Expression::Value(v) => v,
    }
}
// ANCHOR_END: eval
*/

// ANCHOR: solution
fn eval(e: Expression) -> Result<i64, DivideByZeroError> {
    match e {
        Expression::Op { op, left, right } => {
            let left = eval(*left)?;
            let right = eval(*right)?;
            Ok(match op {
                Operation::Add => left + right,
                Operation::Sub => left - right,
                Operation::Mul => left * right,
                Operation::Div => {
                    if right == 0 {
                        return Err(DivideByZeroError);
                    } else {
                        left / right
                    }
                }
            })
        }
        Expression::Value(v) => Ok(v),
    }
}
// ANCHOR_END: solution

// ANCHOR: tests
#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_error() {
        assert_eq!(
            eval(Expression::Op {
                op: Operation::Div,
                left: Box::new(Expression::Value(99)),
                right: Box::new(Expression::Value(0)),
            }),
            Err(DivideByZeroError)
        );
    }

    #[test]
    fn test_ok() {
        let expr = Expression::Op {
            op: Operation::Sub,
            left: Box::new(Expression::Value(20)),
            right: Box::new(Expression::Value(10)),
        };
        assert_eq!(eval(expr), Ok(10));
    }
}
// ANCHOR_END: tests



================================================
FILE: src/error-handling/panics.md
================================================
---
minutes: 3
---

# Panics

In case of a fatal runtime error, Rust triggers a "panic":

```rust,editable,should_panic
fn main() {
    let v = vec![10, 20, 30];
    dbg!(v[100]);
}
```

- Panics are for unrecoverable and unexpected errors.
  - Panics are symptoms of bugs in the program.
  - Runtime failures like failed bounds checks can panic.
  - Assertions (such as `assert!`) panic on failure.
  - Purpose-specific panics can use the `panic!` macro.
- A panic will "unwind" the stack, dropping values just as if the functions had
  returned.
- Use non-panicking APIs (such as `Vec::get`) if crashing is not acceptable.

<details>

By default, a panic will cause the stack to unwind. The unwinding can be caught:

```rust,editable
use std::panic;

fn main() {
    let result = panic::catch_unwind(|| "No problem here!");
    dbg!(result);

    let result = panic::catch_unwind(|| {
        panic!("oh no!");
    });
    dbg!(result);
}
```

- Catching is unusual; do not attempt to implement exceptions with
  `catch_unwind`!
- This can be useful in servers which should keep running even if a single
  request crashes.
- This does not work if `panic = 'abort'` is set in your `Cargo.toml`.

</details>



================================================
FILE: src/error-handling/result.md
================================================
---
minutes: 5
---

# `Result`

Our primary mechanism for error handling in Rust is the [`Result`] enum, which
we briefly saw when discussing standard library types.

```rust,editable
use std::fs::File;
use std::io::Read;

fn main() {
    let file: Result<File, std::io::Error> = File::open("diary.txt");
    match file {
        Ok(mut file) => {
            let mut contents = String::new();
            if let Ok(bytes) = file.read_to_string(&mut contents) {
                println!("Dear diary: {contents} ({bytes} bytes)");
            } else {
                println!("Could not read file content");
            }
        }
        Err(err) => {
            println!("The diary could not be opened: {err}");
        }
    }
}
```

[`Result`]: https://doc.rust-lang.org/stable/std/result/enum.Result.html

<details>

- `Result` has two variants: `Ok` which contains the success value, and `Err`
  which contains an error value of some kind.

- Whether or not a function can produce an error is encoded in the function's
  type signature by having the function return a `Result` value.

- Like with `Option`, there is no way to forget to handle an error: You cannot
  access either the success value or the error value without first pattern
  matching on the `Result` to check which variant you have. Methods like
  `unwrap` make it easier to write quick-and-dirty code that doesn't do robust
  error handling, but means that you can always see in your source code where
  proper error handling is being skipped.

# More to Explore

It may be helpful to compare error handling in Rust to error handling
conventions that students may be familiar with from other programming languages.

## Exceptions

- Many languages use exceptions, e.g. C++, Java, Python.

- In most languages with exceptions, whether or not a function can throw an
  exception is not visible as part of its type signature. This generally means
  that you can't tell when calling a function if it may throw an exception or
  not.

- Exceptions generally unwind the call stack, propagating upward until a `try`
  block is reached. An error originating deep in the call stack may impact an
  unrelated function further up.

## Error Numbers

- Some languages have functions return an error number (or some other error
  value) separately from the successful return value of the function. Examples
  include C and Go.

- Depending on the language it may be possible to forget to check the error
  value, in which case you may be accessing an uninitialized or otherwise
  invalid success value.

</details>



================================================
FILE: src/error-handling/solution.md
================================================
# Solution

```rust,editable
{{#include exercise.rs:types}}

{{#include exercise.rs:solution}}

{{#include exercise.rs:tests}}
```



================================================
FILE: src/error-handling/thiserror.md
================================================
---
minutes: 5
---

# `thiserror`

The [`thiserror`](https://docs.rs/thiserror/) crate provides macros to help
avoid boilerplate when defining error types. It provides derive macros that
assist in implementing `From<T>`, `Display`, and the `Error` trait.

```rust,editable,compile_fail
use std::io::Read;
use std::{fs, io};
use thiserror::Error;

#[derive(Debug, Error)]
enum ReadUsernameError {
    #[error("I/O error: {0}")]
    IoError(#[from] io::Error),
    #[error("Found no username in {0}")]
    EmptyUsername(String),
}

fn read_username(path: &str) -> Result<String, ReadUsernameError> {
    let mut username = String::with_capacity(100);
    fs::File::open(path)?.read_to_string(&mut username)?;
    if username.is_empty() {
        return Err(ReadUsernameError::EmptyUsername(String::from(path)));
    }
    Ok(username)
}

fn main() {
    //fs::write("config.dat", "").unwrap();
    match read_username("config.dat") {
        Ok(username) => println!("Username: {username}"),
        Err(err) => println!("Error: {err:?}"),
    }
}
```

<details>

- The `Error` derive macro is provided by `thiserror`, and has lots of useful
  attributes to help define error types in a compact way.
- The message from `#[error]` is used to derive the `Display` trait.
- Note that the (`thiserror::`)`Error` derive macro, while it has the effect of
  implementing the (`std::error::`)`Error` trait, is not the same this; traits
  and macros do not share a namespace.

</details>



================================================
FILE: src/error-handling/try-conversions.md
================================================
---
minutes: 5
---

# Try Conversions

The effective expansion of `?` is a little more complicated than previously
indicated:

```rust,ignore
expression?
```

works the same as

```rust,ignore
match expression {
    Ok(value) => value,
    Err(err)  => return Err(From::from(err)),
}
```

The `From::from` call here means we attempt to convert the error type to the
type returned by the function. This makes it easy to encapsulate errors into
higher-level errors.

## Example

```rust,editable
use std::error::Error;
use std::io::Read;
use std::{fmt, fs, io};

#[derive(Debug)]
enum ReadUsernameError {
    IoError(io::Error),
    EmptyUsername(String),
}

impl Error for ReadUsernameError {}

impl fmt::Display for ReadUsernameError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::IoError(e) => write!(f, "I/O error: {e}"),
            Self::EmptyUsername(path) => write!(f, "Found no username in {path}"),
        }
    }
}

impl From<io::Error> for ReadUsernameError {
    fn from(err: io::Error) -> Self {
        Self::IoError(err)
    }
}

fn read_username(path: &str) -> Result<String, ReadUsernameError> {
    let mut username = String::with_capacity(100);
    fs::File::open(path)?.read_to_string(&mut username)?;
    if username.is_empty() {
        return Err(ReadUsernameError::EmptyUsername(String::from(path)));
    }
    Ok(username)
}

fn main() {
    //std::fs::write("config.dat", "").unwrap();
    let username = read_username("config.dat");
    println!("username or error: {username:?}");
}
```

<details>

The `?` operator must return a value compatible with the return type of the
function. For `Result`, it means that the error types have to be compatible. A
function that returns `Result<T, ErrorOuter>` can only use `?` on a value of
type `Result<U, ErrorInner>` if `ErrorOuter` and `ErrorInner` are the same type
or if `ErrorOuter` implements `From<ErrorInner>`.

A common alternative to a `From` implementation is `Result::map_err`, especially
when the conversion only happens in one place.

There is no compatibility requirement for `Option`. A function returning
`Option<T>` can use the `?` operator on `Option<U>` for arbitrary `T` and `U`
types.

A function that returns `Result` cannot use `?` on `Option` and vice versa.
However, `Option::ok_or` converts `Option` to `Result` whereas `Result::ok`
turns `Result` into `Option`.

</details>



================================================
FILE: src/error-handling/try.md
================================================
---
minutes: 5
---

# Try Operator

Runtime errors like connection-refused or file-not-found are handled with the
`Result` type, but matching this type on every call can be cumbersome. The
try-operator `?` is used to return errors to the caller. It lets you turn the
common

```rust,ignore
match some_expression {
    Ok(value) => value,
    Err(err) => return Err(err),
}
```

into the much simpler

```rust,ignore
some_expression?
```

We can use this to simplify our error handling code:

```rust,editable
use std::io::Read;
use std::{fs, io};

fn read_username(path: &str) -> Result<String, io::Error> {
    let username_file_result = fs::File::open(path);
    let mut username_file = match username_file_result {
        Ok(file) => file,
        Err(err) => return Err(err),
    };

    let mut username = String::new();
    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(err) => Err(err),
    }
}

fn main() {
    //fs::write("config.dat", "alice").unwrap();
    let username = read_username("config.dat");
    println!("username or error: {username:?}");
}
```

<details>

Simplify the `read_username` function to use `?`.

Key points:

- The `username` variable can be either `Ok(string)` or `Err(error)`.
- Use the `fs::write` call to test out the different scenarios: no file, empty
  file, file with username.
- Note that `main` can return a `Result<(), E>` as long as it implements
  `std::process::Termination`. In practice, this means that `E` implements
  `Debug`. The executable will print the `Err` variant and return a nonzero exit
  status on error.

</details>



================================================
FILE: src/exercises/bare-metal/afternoon.md
================================================
# Exercises

We will write a driver for the PL031 real-time clock device.

<details>

After looking at the exercises, you can look at the [solutions] provided.

[solutions]: solutions-afternoon.md

</details>



================================================
FILE: src/exercises/bare-metal/compass.md
================================================
# Compass

We will read the direction from an I2C compass, and log the readings to a serial
port. If you have time, try displaying it on the LEDs somehow too, or use the
buttons somehow.

Hints:

- Check the documentation for the
  [`lsm303agr`](https://docs.rs/lsm303agr/latest/lsm303agr/) and
  [`microbit-v2`](https://docs.rs/microbit-v2/latest/microbit/) crates, as well
  as the [micro:bit hardware](https://tech.microbit.org/hardware/).
- The LSM303AGR Inertial Measurement Unit is connected to the internal I2C bus.
- TWI is another name for I2C, so the I2C master peripheral is called TWIM.
- The LSM303AGR driver needs something implementing the `embedded_hal::i2c::I2c`
  trait. The
  [`microbit::hal::Twim`](https://docs.rs/microbit-v2/latest/microbit/hal/struct.Twim.html)
  struct implements this.
- You have a
  [`microbit::Board`](https://docs.rs/microbit-v2/latest/microbit/struct.Board.html)
  struct with fields for the various pins and peripherals.
- You can also look at the
  [nRF52833 datasheet](https://infocenter.nordicsemi.com/pdf/nRF52833_PS_v1.5.pdf)
  if you want, but it shouldn't be necessary for this exercise.

Download the [exercise template](../../comprehensive-rust-exercises.zip) and
look in the `compass` directory for the following files.

_src/main.rs_:

<!-- File src/main.rs -->
<!-- mdbook-xgettext: skip -->

```rust,compile_fail
{{#include compass/src/main.rs:top}}
use microbit::{hal::{Delay, uarte::{Baudrate, Parity, Uarte}}, Board};

{{#include compass/src/main.rs:main}}
    // TODO

{{#include compass/src/main.rs:loop}}
        // TODO
    }
}
```

_Cargo.toml_ (you shouldn't need to change this):

<!-- File Cargo.toml -->
<!-- mdbook-xgettext: skip -->

```toml
{{#include compass/Cargo.toml}}
```

_Embed.toml_ (you shouldn't need to change this):

<!-- File Embed.toml -->
<!-- mdbook-xgettext: skip -->

```toml
{{#include compass/Embed.toml}}
```

_.cargo/config.toml_ (you shouldn't need to change this):

<!-- File .cargo/config.toml -->
<!-- mdbook-xgettext: skip -->

```toml
{{#include compass/.cargo/config.toml}}
```

See the serial output on Linux with:

<!-- mdbook-xgettext: skip -->

```sh
picocom --baud 115200 --imap lfcrlf /dev/ttyACM0
```

Or on Mac OS something like (the device name may be slightly different):

<!-- mdbook-xgettext: skip -->

```sh
picocom --baud 115200 --imap lfcrlf /dev/tty.usbmodem14502
```

Use Ctrl+A Ctrl+Q to quit picocom.



================================================
FILE: src/exercises/bare-metal/morning.md
================================================
# Exercises

We will read the direction from an I2C compass, and log the readings to a serial
port.

<details>

After looking at the exercises, you can look at the [solutions] provided.

[solutions]: solutions-morning.md

</details>



================================================
FILE: src/exercises/bare-metal/rtc.md
================================================
# RTC driver

The QEMU aarch64 virt machine has a [PL031][1] real-time clock at 0x9010000. For
this exercise, you should write a driver for it.

1. Use it to print the current time to the serial console. You can use the
   [`chrono`][2] crate for date/time formatting.
2. Use the match register and raw interrupt status to busy-wait until a given
   time, e.g. 3 seconds in the future. (Call [`core::hint::spin_loop`][3] inside
   the loop.)
3. _Extension if you have time:_ Enable and handle the interrupt generated by
   the RTC match. You can use the driver provided in the [`arm-gic`][4] crate to
   configure the Arm Generic Interrupt Controller.
   - Use the RTC interrupt, which is wired to the GIC as `IntId::spi(2)`.
   - Once the interrupt is enabled, you can put the core to sleep via
     `arm_gic::wfi()`, which will cause the core to sleep until it receives an
     interrupt.

Download the [exercise template](../../comprehensive-rust-exercises.zip) and
look in the `rtc` directory for the following files.

_src/main.rs_:

<!-- File src/main.rs -->
<!-- mdbook-xgettext: skip -->

```rust,compile_fail
{{#include rtc/src/main.rs:top}}

{{#include rtc/src/main.rs:imports}}

{{#include rtc/src/main.rs:main}}

    // TODO: Create instance of RTC driver and print current time.

    // TODO: Wait for 3 seconds.

{{#include rtc/src/main.rs:main_end}}
```

_src/exceptions.rs_ (you should only need to change this for the 3rd part of the
exercise):

<!-- File src/exceptions.rs -->
<!-- mdbook-xgettext: skip -->

```rust,compile_fail
{{#include rtc/src/exceptions.rs}}
```

_src/logger.rs_ (you shouldn't need to change this):

<!-- File src/logger.rs -->
<!-- mdbook-xgettext: skip -->

```rust,compile_fail
{{#include rtc/src/logger.rs}}
```

_Cargo.toml_ (you shouldn't need to change this):

<!-- File Cargo.toml -->
<!-- mdbook-xgettext: skip -->

```toml
{{#include rtc/Cargo.toml}}
```

_build.rs_ (you shouldn't need to change this):

<!-- File build.rs -->
<!-- mdbook-xgettext: skip -->

```ld
{{#include rtc/build.rs}}
```

_memory.ld_ (you shouldn't need to change this):

<!-- File memory.ld -->
<!-- mdbook-xgettext: skip -->

```ld
{{#include rtc/memory.ld}}
```

_Makefile_ (you shouldn't need to change this):

<!-- File Makefile -->
<!-- mdbook-xgettext: skip -->

```makefile
{{#include rtc/Makefile}}
```

_.cargo/config.toml_ (you shouldn't need to change this):

<!-- File .cargo/config.toml -->
<!-- mdbook-xgettext: skip -->

```toml
{{#include rtc/.cargo/config.toml}}
```

Run the code in QEMU with `make qemu`.

[1]: https://developer.arm.com/documentation/ddi0224/c
[2]: https://crates.io/crates/chrono
[3]: https://doc.rust-lang.org/core/hint/fn.spin_loop.html
[4]: https://docs.rs/arm-gic/



================================================
FILE: src/exercises/bare-metal/solutions-afternoon.md
================================================
# Bare Metal Rust Afternoon

## RTC driver

([back to exercise](rtc.md))

_main.rs_:

```rust,compile_fail
{{#include rtc/src/main.rs:solution}}
```

_pl031.rs_:

```rust,compile_fail
{{#include rtc/src/pl031.rs:solution}}
```



================================================
FILE: src/exercises/bare-metal/solutions-morning.md
================================================
# Bare Metal Rust Morning Exercise

## Compass

([back to exercise](compass.md))

```rust,compile_fail
{{#include compass/src/main.rs:solution}}
```



================================================
FILE: src/exercises/bare-metal/compass/Cargo.toml
================================================
[workspace]

[package]
name = "compass"
version = "0.1.0"
edition = "2024"
publish = false

[dependencies]
cortex-m-rt = "0.7.5"
embedded-hal = "1.0.0"
lsm303agr = "1.1.0"
microbit-v2 = "0.15.1"
panic-halt = "1.0.0"



================================================
FILE: src/exercises/bare-metal/compass/Embed.toml
================================================
[default.general]
chip = "nrf52833_xxAA"

[debug.gdb]
enabled = true

[debug.reset]
halt_afterwards = true



================================================
FILE: src/exercises/bare-metal/compass/src/main.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: solution
// ANCHOR: top
#![no_main]
#![no_std]

extern crate panic_halt as _;

use core::fmt::Write;
use cortex_m_rt::entry;
// ANCHOR_END: top
use embedded_hal::digital::InputPin;
use lsm303agr::{
    AccelMode, AccelOutputDataRate, Lsm303agr, MagMode, MagOutputDataRate,
};
use microbit::Board;
use microbit::display::blocking::Display;
use microbit::hal::twim::Twim;
use microbit::hal::uarte::{Baudrate, Parity, Uarte};
use microbit::hal::{Delay, Timer};
use microbit::pac::twim0::frequency::FREQUENCY_A;

const COMPASS_SCALE: i32 = 30000;
const ACCELEROMETER_SCALE: i32 = 700;

// ANCHOR: main
#[entry]
fn main() -> ! {
    let mut board = Board::take().unwrap();

    // Configure serial port.
    let mut serial = Uarte::new(
        board.UARTE0,
        board.uart.into(),
        Parity::EXCLUDED,
        Baudrate::BAUD115200,
    );

    // Use the system timer as a delay provider.
    let mut delay = Delay::new(board.SYST);

    // Set up the I2C controller and Inertial Measurement Unit.
    // ANCHOR_END: main
    writeln!(serial, "Setting up IMU...").unwrap();
    let i2c = Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100);
    let mut imu = Lsm303agr::new_with_i2c(i2c);
    imu.init().unwrap();
    imu.set_mag_mode_and_odr(
        &mut delay,
        MagMode::HighResolution,
        MagOutputDataRate::Hz50,
    )
    .unwrap();
    imu.set_accel_mode_and_odr(
        &mut delay,
        AccelMode::Normal,
        AccelOutputDataRate::Hz50,
    )
    .unwrap();
    let mut imu = imu.into_mag_continuous().ok().unwrap();

    // Set up display and timer.
    let mut timer = Timer::new(board.TIMER0);
    let mut display = Display::new(board.display_pins);

    let mut mode = Mode::Compass;
    let mut button_pressed = false;

    // ANCHOR: loop
    writeln!(serial, "Ready.").unwrap();

    loop {
        // Read compass data and log it to the serial port.
        // ANCHOR_END: loop
        while !(imu.mag_status().unwrap().xyz_new_data()
            && imu.accel_status().unwrap().xyz_new_data())
        {}
        let compass_reading = imu.magnetic_field().unwrap();
        let accelerometer_reading = imu.acceleration().unwrap();
        writeln!(
            serial,
            "{},{},{}\t{},{},{}",
            compass_reading.x_nt(),
            compass_reading.y_nt(),
            compass_reading.z_nt(),
            accelerometer_reading.x_mg(),
            accelerometer_reading.y_mg(),
            accelerometer_reading.z_mg(),
        )
        .unwrap();

        let mut image = [[0; 5]; 5];
        let (x, y) = match mode {
            Mode::Compass => (
                scale(-compass_reading.x_nt(), -COMPASS_SCALE, COMPASS_SCALE, 0, 4)
                    as usize,
                scale(compass_reading.y_nt(), -COMPASS_SCALE, COMPASS_SCALE, 0, 4)
                    as usize,
            ),
            Mode::Accelerometer => (
                scale(
                    accelerometer_reading.x_mg(),
                    -ACCELEROMETER_SCALE,
                    ACCELEROMETER_SCALE,
                    0,
                    4,
                ) as usize,
                scale(
                    -accelerometer_reading.y_mg(),
                    -ACCELEROMETER_SCALE,
                    ACCELEROMETER_SCALE,
                    0,
                    4,
                ) as usize,
            ),
        };
        image[y][x] = 255;
        display.show(&mut timer, image, 100);

        // If button A is pressed, switch to the next mode and briefly blink all LEDs
        // on.
        if board.buttons.button_a.is_low().unwrap() {
            if !button_pressed {
                mode = mode.next();
                display.show(&mut timer, [[255; 5]; 5], 200);
            }
            button_pressed = true;
        } else {
            button_pressed = false;
        }
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
enum Mode {
    Compass,
    Accelerometer,
}

impl Mode {
    fn next(self) -> Self {
        match self {
            Self::Compass => Self::Accelerometer,
            Self::Accelerometer => Self::Compass,
        }
    }
}

fn scale(value: i32, min_in: i32, max_in: i32, min_out: i32, max_out: i32) -> i32 {
    let range_in = max_in - min_in;
    let range_out = max_out - min_out;
    let scaled = min_out + range_out * (value - min_in) / range_in;
    scaled.clamp(min_out, max_out)
}



================================================
FILE: src/exercises/bare-metal/compass/.cargo/config.toml
================================================
[build]
target = "thumbv7em-none-eabihf" # Cortex-M4F

[target.'cfg(all(target_arch = "arm", target_os = "none"))']
rustflags = ["-C", "link-arg=-Tlink.x"]



================================================
FILE: src/exercises/bare-metal/rtc/build.rs
================================================
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

fn main() {
    println!("cargo:rustc-link-arg=-Timage.ld");
    println!("cargo:rustc-link-arg=-Tmemory.ld");
    println!("cargo:rerun-if-changed=memory.ld");
}



================================================
FILE: src/exercises/bare-metal/rtc/Cargo.toml
================================================
[workspace]

[package]
name = "rtc"
version = "0.1.0"
edition = "2024"
publish = false

[dependencies]
aarch64-paging = { version = "0.10.0", default-features = false }
aarch64-rt = "0.2.2"
arm-gic = "0.6.1"
arm-pl011-uart = "0.3.2"
bitflags = "2.9.3"
chrono = { version = "0.4.41", default-features = false }
log = "0.4.27"
safe-mmio = "0.2.5"
smccc = "0.2.2"
spin = "0.10.0"
zerocopy = "0.8.26"



================================================
FILE: src/exercises/bare-metal/rtc/Makefile
================================================
# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

.PHONY: build qemu_minimal qemu qemu_logger

all: rtc.bin

build:
	cargo build

rtc.bin: build
	cargo objcopy -- -O binary $@

qemu: rtc.bin
	qemu-system-aarch64 -machine virt,gic-version=3 -cpu max -serial mon:stdio -display none -kernel $< -s

clean:
	cargo clean
	rm -f *.bin



================================================
FILE: src/exercises/bare-metal/rtc/memory.ld
================================================
/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

MEMORY
{
	image : ORIGIN = 0x40080000, LENGTH = 2M
}



================================================
FILE: src/exercises/bare-metal/rtc/src/exceptions.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use arm_gic::gicv3::{GicV3, InterruptGroup};
use log::{error, info, trace};
use smccc::Hvc;
use smccc::psci::system_off;

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern "C" fn sync_exception_current(_elr: u64, _spsr: u64) {
    error!("sync_exception_current");
    system_off::<Hvc>().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern "C" fn irq_current(_elr: u64, _spsr: u64) {
    trace!("irq_current");
    let intid = GicV3::get_and_acknowledge_interrupt(InterruptGroup::Group1)
        .expect("No pending interrupt");
    info!("IRQ {intid:?}");
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern "C" fn fiq_current(_elr: u64, _spsr: u64) {
    error!("fiq_current");
    system_off::<Hvc>().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern "C" fn serr_current(_elr: u64, _spsr: u64) {
    error!("serr_current");
    system_off::<Hvc>().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern "C" fn sync_lower(_elr: u64, _spsr: u64) {
    error!("sync_lower");
    system_off::<Hvc>().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern "C" fn irq_lower(_elr: u64, _spsr: u64) {
    error!("irq_lower");
    system_off::<Hvc>().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern "C" fn fiq_lower(_elr: u64, _spsr: u64) {
    error!("fiq_lower");
    system_off::<Hvc>().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern "C" fn serr_lower(_elr: u64, _spsr: u64) {
    error!("serr_lower");
    system_off::<Hvc>().unwrap();
}



================================================
FILE: src/exercises/bare-metal/rtc/src/logger.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use arm_pl011_uart::Uart;
use core::fmt::Write;
use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};
use spin::mutex::SpinMutex;

static LOGGER: Logger = Logger { uart: SpinMutex::new(None) };

struct Logger {
    uart: SpinMutex<Option<Uart<'static>>>,
}

impl Log for Logger {
    fn enabled(&self, _metadata: &Metadata) -> bool {
        true
    }

    fn log(&self, record: &Record) {
        writeln!(
            self.uart.lock().as_mut().unwrap(),
            "[{}] {}",
            record.level(),
            record.args()
        )
        .unwrap();
    }

    fn flush(&self) {}
}

/// Initialises UART logger.
pub fn init(
    uart: Uart<'static>,
    max_level: LevelFilter,
) -> Result<(), SetLoggerError> {
    LOGGER.uart.lock().replace(uart);

    log::set_logger(&LOGGER)?;
    log::set_max_level(max_level);
    Ok(())
}



================================================
FILE: src/exercises/bare-metal/rtc/src/main.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: solution
// ANCHOR: top
#![no_main]
#![no_std]

mod exceptions;
mod logger;
// ANCHOR_END: top
mod pl031;

use crate::pl031::Rtc;
use arm_gic::{IntId, Trigger, irq_enable, wfi};
use chrono::{TimeZone, Utc};
use core::hint::spin_loop;
// ANCHOR: imports
use aarch64_paging::paging::Attributes;
use aarch64_rt::{InitialPagetable, entry, initial_pagetable};
use arm_gic::gicv3::GicV3;
use arm_gic::gicv3::registers::{Gicd, GicrSgi};
use arm_pl011_uart::{PL011Registers, Uart, UniqueMmioPointer};
use core::panic::PanicInfo;
use core::ptr::NonNull;
use log::{LevelFilter, error, info, trace};
use smccc::Hvc;
use smccc::psci::system_off;

/// Base addresses of the GICv3.
const GICD_BASE_ADDRESS: *mut Gicd = 0x800_0000 as _;
const GICR_BASE_ADDRESS: *mut GicrSgi = 0x80A_0000 as _;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: NonNull<PL011Registers> =
    NonNull::new(0x900_0000 as _).unwrap();

/// Attributes to use for device memory in the initial identity map.
const DEVICE_ATTRIBUTES: Attributes = Attributes::VALID
    .union(Attributes::ATTRIBUTE_INDEX_0)
    .union(Attributes::ACCESSED)
    .union(Attributes::UXN);

/// Attributes to use for normal memory in the initial identity map.
const MEMORY_ATTRIBUTES: Attributes = Attributes::VALID
    .union(Attributes::ATTRIBUTE_INDEX_1)
    .union(Attributes::INNER_SHAREABLE)
    .union(Attributes::ACCESSED)
    .union(Attributes::NON_GLOBAL);

initial_pagetable!({
    let mut idmap = [0; 512];
    // 1 GiB of device memory.
    idmap[0] = DEVICE_ATTRIBUTES.bits();
    // 1 GiB of normal memory.
    idmap[1] = MEMORY_ATTRIBUTES.bits() | 0x40000000;
    // Another 1 GiB of device memory starting at 256 GiB.
    idmap[256] = DEVICE_ATTRIBUTES.bits() | 0x4000000000;
    InitialPagetable(idmap)
});
// ANCHOR_END: imports

/// Base address of the PL031 RTC.
const PL031_BASE_ADDRESS: NonNull<pl031::Registers> =
    NonNull::new(0x901_0000 as _).unwrap();
/// The IRQ used by the PL031 RTC.
const PL031_IRQ: IntId = IntId::spi(2);

// ANCHOR: main
entry!(main);
fn main(x0: u64, x1: u64, x2: u64, x3: u64) -> ! {
    // SAFETY: `PL011_BASE_ADDRESS` is the base address of a PL011 device, and
    // nothing else accesses that address range.
    let uart = unsafe { Uart::new(UniqueMmioPointer::new(PL011_BASE_ADDRESS)) };
    logger::init(uart, LevelFilter::Trace).unwrap();

    info!("main({:#x}, {:#x}, {:#x}, {:#x})", x0, x1, x2, x3);

    // SAFETY: `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base
    // addresses of a GICv3 distributor and redistributor respectively, and
    // nothing else accesses those address ranges.
    let mut gic =
        unsafe { GicV3::new(GICD_BASE_ADDRESS, GICR_BASE_ADDRESS, 1, false) };
    gic.setup(0);
    // ANCHOR_END: main

    // SAFETY: `PL031_BASE_ADDRESS` is the base address of a PL031 device, and
    // nothing else accesses that address range.
    let mut rtc = unsafe { Rtc::new(UniqueMmioPointer::new(PL031_BASE_ADDRESS)) };
    let timestamp = rtc.read();
    let time = Utc.timestamp_opt(timestamp.into(), 0).unwrap();
    info!("RTC: {time}");

    GicV3::set_priority_mask(0xff);
    gic.set_interrupt_priority(PL031_IRQ, None, 0x80);
    gic.set_trigger(PL031_IRQ, None, Trigger::Level);
    irq_enable();
    gic.enable_interrupt(PL031_IRQ, None, true);

    // Wait for 3 seconds, without interrupts.
    let target = timestamp + 3;
    rtc.set_match(target);
    info!("Waiting for {}", Utc.timestamp_opt(target.into(), 0).unwrap());
    trace!(
        "matched={}, interrupt_pending={}",
        rtc.matched(),
        rtc.interrupt_pending()
    );
    while !rtc.matched() {
        spin_loop();
    }
    trace!(
        "matched={}, interrupt_pending={}",
        rtc.matched(),
        rtc.interrupt_pending()
    );
    info!("Finished waiting");

    // Wait another 3 seconds for an interrupt.
    let target = timestamp + 6;
    info!("Waiting for {}", Utc.timestamp_opt(target.into(), 0).unwrap());
    rtc.set_match(target);
    rtc.clear_interrupt();
    rtc.enable_interrupt(true);
    trace!(
        "matched={}, interrupt_pending={}",
        rtc.matched(),
        rtc.interrupt_pending()
    );
    while !rtc.interrupt_pending() {
        wfi();
    }
    trace!(
        "matched={}, interrupt_pending={}",
        rtc.matched(),
        rtc.interrupt_pending()
    );
    info!("Finished waiting");

    // ANCHOR: main_end
    system_off::<Hvc>().unwrap();
    panic!("system_off returned");
}

#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    error!("{info}");
    system_off::<Hvc>().unwrap();
    loop {}
}
// ANCHOR_END: main_end



================================================
FILE: src/exercises/bare-metal/rtc/src/pl031.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use safe_mmio::fields::{ReadPure, ReadPureWrite, WriteOnly};
use safe_mmio::{UniqueMmioPointer, field, field_shared};

// ANCHOR: solution
#[repr(C, align(4))]
pub struct Registers {
    /// Data register
    dr: ReadPure<u32>,
    /// Match register
    mr: ReadPureWrite<u32>,
    /// Load register
    lr: ReadPureWrite<u32>,
    /// Control register
    cr: ReadPureWrite<u8>,
    _reserved0: [u8; 3],
    /// Interrupt Mask Set or Clear register
    imsc: ReadPureWrite<u8>,
    _reserved1: [u8; 3],
    /// Raw Interrupt Status
    ris: ReadPure<u8>,
    _reserved2: [u8; 3],
    /// Masked Interrupt Status
    mis: ReadPure<u8>,
    _reserved3: [u8; 3],
    /// Interrupt Clear Register
    icr: WriteOnly<u8>,
    _reserved4: [u8; 3],
}

/// Driver for a PL031 real-time clock.
#[derive(Debug)]
pub struct Rtc<'a> {
    registers: UniqueMmioPointer<'a, Registers>,
}

impl<'a> Rtc<'a> {
    /// Constructs a new instance of the RTC driver for a PL031 device with the
    /// given set of registers.
    pub fn new(registers: UniqueMmioPointer<'a, Registers>) -> Self {
        Self { registers }
    }

    /// Reads the current RTC value.
    pub fn read(&self) -> u32 {
        field_shared!(self.registers, dr).read()
    }

    /// Writes a match value. When the RTC value matches this then an interrupt
    /// will be generated (if it is enabled).
    pub fn set_match(&mut self, value: u32) {
        field!(self.registers, mr).write(value);
    }

    /// Returns whether the match register matches the RTC value, whether or not
    /// the interrupt is enabled.
    pub fn matched(&self) -> bool {
        let ris = field_shared!(self.registers, ris).read();
        (ris & 0x01) != 0
    }

    /// Returns whether there is currently an interrupt pending.
    ///
    /// This should be true if and only if `matched` returns true and the
    /// interrupt is masked.
    pub fn interrupt_pending(&self) -> bool {
        let mis = field_shared!(self.registers, mis).read();
        (mis & 0x01) != 0
    }

    /// Sets or clears the interrupt mask.
    ///
    /// When the mask is true the interrupt is enabled; when it is false the
    /// interrupt is disabled.
    pub fn enable_interrupt(&mut self, mask: bool) {
        let imsc = if mask { 0x01 } else { 0x00 };
        field!(self.registers, imsc).write(imsc);
    }

    /// Clears a pending interrupt, if any.
    pub fn clear_interrupt(&mut self) {
        field!(self.registers, icr).write(0x01);
    }
}



================================================
FILE: src/exercises/bare-metal/rtc/.cargo/config.toml
================================================
[build]
target = "aarch64-unknown-none"



================================================
FILE: src/exercises/chromium/bringing-it-together.md
================================================
# Bringing It Together --- Exercise

In this exercise, you're going to add a whole new Chromium feature, bringing
together everything you already learned.

## The Brief from Product Management

A community of pixies has been discovered living in a remote rainforest. It's
important that we get Chromium for Pixies delivered to them as soon as possible.

The requirement is to translate all Chromium's UI strings into Pixie language.

There's not time to wait for proper translations, but fortunately pixie language
is very close to English, and it turns out there's a Rust crate which does the
translation.

In fact, you already [imported that crate in the previous exercise][0].

(Obviously, real translations of Chrome require incredible care and diligence.
Don't ship this!)

## Steps

Modify `ResourceBundle::MaybeMangleLocalizedString` so that it uwuifies all
strings before display. In this special build of Chromium, it should always do
this irrespective of the setting of `mangle_localized_strings_`.

If you've done everything right across all these exercises, congratulations, you
should have created Chrome for pixies!

<img src="chwomium.png" alt="Chromium UI screenshot with uwu language">

<details>
Students will likely need some hints here. Hints include:

- UTF-16 vs UTF-8. Students should be aware that Rust strings are always UTF-8,
  and will probably decide that it's better to do the conversion on the C++ side
  using `base::UTF16ToUTF8` and back again.
- If students decide to do the conversion on the Rust side, they'll need to
  consider [`String::from_utf16`][1], consider error handling, and consider
  which [CXX supported types can transfer a lot of u16s][2].
- Students may design the C++/Rust boundary in several different ways, e.g.
  taking and returning strings by value, or taking a mutable reference to a
  string. If a mutable reference is used, CXX will likely tell the student that
  they need to use [`Pin`][3]. You may need to explain what `Pin` does, and then
  explain why CXX needs it for mutable references to C++ data: the answer is
  that C++ data can't be moved around like Rust data, because it may contain
  self-referential pointers.
- The C++ target containing `ResourceBundle::MaybeMangleLocalizedString` will
  need to depend on a `rust_static_library` target. The student probably already
  did this.
- The `rust_static_library` target will need to depend on
  `//third_party/rust/uwuify/v0_2:lib`.

</details>

[0]: https://crates.io/crates/uwuify
[1]: https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf16
[2]: https://cxx.rs/binding/slice.html
[3]: https://doc.rust-lang.org/std/pin/



================================================
FILE: src/exercises/chromium/build-rules.md
================================================
# Build rules exercise

In your Chromium build, add a new Rust target to `//ui/base/BUILD.gn`
containing:

```rust
// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
pub extern "C" fn hello_from_rust() {
    println!("Hello from Rust!")
}
```

**Important:** note that `no_mangle` here is considered a type of unsafety by
the Rust compiler, so you'll need to allow unsafe code in your `gn` target.

Add this new Rust target as a dependency of `//ui/base:base`. Declare this
function at the top of `ui/base/resource/resource_bundle.cc` (later, we'll see
how this can be automated by bindings generation tools):

```cpp
extern "C" void hello_from_rust();
```

Call this function from somewhere in `ui/base/resource/resource_bundle.cc` - we
suggest the top of `ResourceBundle::MaybeMangleLocalizedString`. Build and run
Chromium, and ensure that "Hello from Rust!" is printed lots of times.

If you use VSCode, now set up Rust to work well in VSCode. It will be useful in
subsequent exercises. If you've succeeded, you will be able to use right-click
"Go to definition" on `println!`.

## Where to find help

- The options available to the [`rust_static_library` gn template][0]
- Information about [`#[unsafe(no_mangle)]`][1]
- Information about [`extern "C"`][2]
- Information about gn's [`--export-rust-project`][3] switch
- [How to install rust-analyzer in VSCode][4]

<details>
It's really important that students get this running, because future exercises
will build on it.

This example is unusual because it boils down to the lowest-common-denominator
interop language, C. Both C++ and Rust can natively declare and call C ABI
functions. Later in the course, we'll connect C++ directly to Rust.

`allow_unsafe = true` is required here because `#[unsafe(no_mangle)]` might
allow Rust to generate two functions with the same name, and Rust can no longer
guarantee that the right one is called.

If you need a pure Rust executable, you can also do that using the
`rust_executable` gn template.

</details>

[0]: https://source.chromium.org/chromium/chromium/src/+/main:build/rust/rust_static_library.gni;l=16
[1]: https://doc.rust-lang.org/beta/reference/abi.html#the-no_mangle-attribute
[2]: https://doc.rust-lang.org/std/keyword.extern.html
[3]: https://gn.googlesource.com/gn/+/main/docs/reference.md#compilation-database
[4]: https://code.visualstudio.com/docs/languages/rust



================================================
FILE: src/exercises/chromium/interoperability-with-cpp.md
================================================
# Exercise: Interoperability with C++

## Part one

- In the Rust file you previously created, add a `#[cxx::bridge]` which
  specifies a single function, to be called from C++, called `hello_from_rust`,
  taking no parameters and returning no value.
- Modify your previous `hello_from_rust` function to remove `extern "C"` and
  `#[unsafe(no_mangle)]`. This is now just a standard Rust function.
- Modify your `gn` target to build these bindings.
- In your C++ code, remove the forward-declaration of `hello_from_rust`.
  Instead, include the generated header file.
- Build and run!

## Part two

It's a good idea to play with CXX a little. It helps you think about how
flexible Rust in Chromium actually is.

Some things to try:

- Call back into C++ from Rust. You will need:
  - An additional header file which you can `include!` from your `cxx::bridge`.
    You'll need to declare your C++ function in that new header file.
  - An `unsafe` block to call such a function, or alternatively specify the
    `unsafe` keyword in your `#[cxx::bridge]` [as described here][0].
  - You may also need to
    `#include "third_party/rust/cxx/v1/crate/include/cxx.h"`
- Pass a C++ string from C++ into Rust.
- Pass a reference to a C++ object into Rust.
- Intentionally get the Rust function signatures mismatched from the
  `#[cxx::bridge]`, and get used to the errors you see.
- Intentionally get the C++ function signatures mismatched from the
  `#[cxx::bridge]`, and get used to the errors you see.
- Pass a `std::unique_ptr` of some type from C++ into Rust, so that Rust can own
  some C++ object.
- Create a Rust object and pass it into C++, so that C++ owns it. (Hint: you
  need a `Box`).
- Declare some methods on a C++ type. Call them from Rust.
- Declare some methods on a Rust type. Call them from C++.

## Part three

Now you understand the strengths and limitations of CXX interop, think of a
couple of use-cases for Rust in Chromium where the interface would be
sufficiently simple. Sketch how you might define that interface.

## Where to find help

- The [`cxx` binding reference][1]
- The [`rust_static_library` gn template][2]

<details>
As students explore Part Two, they're bound to have lots of questions about how
to achieve these things, and also how CXX works behind the scenes.

Some of the questions you may encounter:

- I'm seeing a problem initializing a variable of type X with type Y, where X
  and Y are both function types. This is because your C++ function doesn't quite
  match the declaration in your `cxx::bridge`.
- I seem to be able to freely convert C++ references into Rust references.
  Doesn't that risk UB? For CXX's _opaque_ types, no, because they are
  zero-sized. For CXX trivial types yes, it's _possible_ to cause UB, although
  CXX's design makes it quite difficult to craft such an example.

</details>

[0]: https://cxx.rs/extern-c++.html#functions-and-member-functions
[1]: https://cxx.rs/bindings.html
[2]: https://source.chromium.org/chromium/chromium/src/+/main:build/rust/rust_static_library.gni;l=16



================================================
FILE: src/exercises/chromium/solutions.md
================================================
# Exercise Solutions

Solutions to the Chromium exercises can be found in [this series of CLs][0].

[0]: https://chromium-review.googlesource.com/c/chromium/src/+/5096560



================================================
FILE: src/exercises/chromium/testing.md
================================================
# Testing exercise

Time for another exercise!

In your Chromium build:

- Add a testable function next to `hello_from_rust`. Some suggestions: adding
  two integers received as arguments, computing the nth Fibonacci number,
  summing integers in a slice, etc.
- Add a separate `..._unittest.rs` file with a test for the new function.
- Add the new tests to `BUILD.gn`.
- Build the tests, run them, and verify that the new test works.



================================================
FILE: src/exercises/chromium/third-party.md
================================================
# Exercise

Add [uwuify][0] to Chromium, turning off the crate's [default features][1].
Assume that the crate will be used in shipping Chromium, but won't be used to
handle untrustworthy input.

(In the next exercise we'll use uwuify from Chromium, but feel free to skip
ahead and do that now if you like. Or, you could create a new
[`rust_executable` target][2] which uses `uwuify`).

<details>

Students will need to download lots of transitive dependencies.

The total crates needed are:

- `instant`,
- `lock_api`,
- `parking_lot`,
- `parking_lot_core`,
- `redox_syscall`,
- `scopeguard`,
- `smallvec`, and
- `uwuify`.

If students are downloading even more than that, they probably forgot to turn
off the default features.

Thanks to [Daniel Liu][3] for this crate!

</details>

[0]: https://crates.io/crates/uwuify
[1]: https://doc.rust-lang.org/cargo/reference/features.html#the-default-feature
[2]: https://source.chromium.org/chromium/chromium/src/+/main:build/rust/rust_executable.gni
[3]: https://github.com/Daniel-Liu-c0deb0t



================================================
FILE: src/generics/Cargo.toml
================================================
[package]
name = "generics"
version = "0.1.0"
edition = "2024"
publish = false

[lib]
name = "generics"
path = "exercise.rs"



================================================
FILE: src/generics/dyn-trait.md
================================================
---
minutes: 5
---

# `dyn Trait`

In addition to using traits for static dispatch via generics, Rust also supports
using them for type-erased, dynamic dispatch via trait objects:

```rust,editable
struct Dog {
    name: String,
    age: i8,
}
struct Cat {
    lives: i8,
}

trait Pet {
    fn talk(&self) -> String;
}

impl Pet for Dog {
    fn talk(&self) -> String {
        format!("Woof, my name is {}!", self.name)
    }
}

impl Pet for Cat {
    fn talk(&self) -> String {
        String::from("Miau!")
    }
}

// Uses generics and static dispatch.
fn generic(pet: &impl Pet) {
    println!("Hello, who are you? {}", pet.talk());
}

// Uses type-erasure and dynamic dispatch.
fn dynamic(pet: &dyn Pet) {
    println!("Hello, who are you? {}", pet.talk());
}

fn main() {
    let cat = Cat { lives: 9 };
    let dog = Dog { name: String::from("Fido"), age: 5 };

    generic(&cat);
    generic(&dog);

    dynamic(&cat);
    dynamic(&dog);
}
```

<details>

- Generics, including `impl Trait`, use monomorphization to create a specialized
  instance of the function for each different type that the generic is
  instantiated with. This means that calling a trait method from within a
  generic function still uses static dispatch, as the compiler has full type
  information and can resolve that type's trait implementation to use.

- When using `dyn Trait`, it instead uses dynamic dispatch through a
  [virtual method table][vtable] (vtable). This means that there's a single
  version of `fn dynamic` that is used regardless of what type of `Pet` is
  passed in.

- When using `dyn Trait`, the trait object needs to be behind some kind of
  indirection. In this case it's a reference, though smart pointer types like
  `Box` can also be used (this will be demonstrated on day 3).

- At runtime, a `&dyn Pet` is represented as a "fat pointer", i.e. a pair of two
  pointers: One pointer points to the concrete object that implements `Pet`, and
  the other points to the vtable for the trait implementation for that type.
  When calling the `talk` method on `&dyn Pet` the compiler looks up the
  function pointer for `talk` in the vtable and then invokes the function,
  passing the pointer to the `Dog` or `Cat` into that function. The compiler
  doesn't need to know the concrete type of the `Pet` in order to do this.

- A `dyn Trait` is considered to be "type-erased", because we no longer have
  compile-time knowledge of what the concrete type is.

[vtable]: https://en.wikipedia.org/wiki/Virtual_method_table

</details>



================================================
FILE: src/generics/exercise.md
================================================
---
minutes: 10
---

# Exercise: Generic `min`

In this short exercise, you will implement a generic `min` function that
determines the minimum of two values, using the [`Ord`] trait.

```rust,editable
use std::cmp::Ordering;

// TODO: implement the `min` function used in the tests.

{{#include exercise.rs:tests}}
```

<details>

- Show students the [`Ord`] trait and [`Ordering`] enum.

</details>

[`Ord`]: https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html
[`Ordering`]: https://doc.rust-lang.org/stable/std/cmp/enum.Ordering.html



================================================
FILE: src/generics/exercise.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
#![allow(dead_code)]

// ANCHOR: solution
use std::cmp::Ordering;

fn min<T: Ord>(l: T, r: T) -> T {
    match l.cmp(&r) {
        Ordering::Less | Ordering::Equal => l,
        Ordering::Greater => r,
    }
}

// ANCHOR: tests
#[test]
fn integers() {
    assert_eq!(min(0, 10), 0);
    assert_eq!(min(500, 123), 123);
}

#[test]
fn chars() {
    assert_eq!(min('a', 'z'), 'a');
    assert_eq!(min('7', '1'), '1');
}

#[test]
fn strings() {
    assert_eq!(min("hello", "goodbye"), "goodbye");
    assert_eq!(min("bat", "armadillo"), "armadillo");
}
// ANCHOR_END: tests



================================================
FILE: src/generics/generic-data.md
================================================
---
minutes: 10
---

# Generic Data Types

You can use generics to abstract over the concrete field type. Returning to the
exercise for the previous segment:

```rust,editable
pub trait Logger {
    /// Log a message at the given verbosity level.
    fn log(&self, verbosity: u8, message: &str);
}

struct StderrLogger;

impl Logger for StderrLogger {
    fn log(&self, verbosity: u8, message: &str) {
        eprintln!("verbosity={verbosity}: {message}");
    }
}

/// Only log messages up to the given verbosity level.
struct VerbosityFilter<L> {
    max_verbosity: u8,
    inner: L,
}

impl<L: Logger> Logger for VerbosityFilter<L> {
    fn log(&self, verbosity: u8, message: &str) {
        if verbosity <= self.max_verbosity {
            self.inner.log(verbosity, message);
        }
    }
}

fn main() {
    let logger = VerbosityFilter { max_verbosity: 3, inner: StderrLogger };
    logger.log(5, "FYI");
    logger.log(2, "Uhoh");
}
```

<details>

- _Q:_ Why is `L` specified twice in `impl<L: Logger> .. VerbosityFilter<L>`?
  Isn't that redundant?
  - This is because it is a generic implementation section for generic type.
    They are independently generic.
  - It means these methods are defined for any `L`.
  - It is possible to write `impl VerbosityFilter<StderrLogger> { .. }`.
    - `VerbosityFilter` is still generic and you can use `VerbosityFilter<f64>`,
      but methods in this block will only be available for
      `VerbosityFilter<StderrLogger>`.
- Note that we don't put a trait bound on the `VerbosityFilter` type itself. You
  can put bounds there as well, but generally in Rust we only put the trait
  bounds on the impl blocks.

</details>



================================================
FILE: src/generics/generic-functions.md
================================================
---
minutes: 5
---

# Generic Functions

Rust supports generics, which lets you abstract algorithms or data structures
(such as sorting or a binary tree) over the types used or stored.

```rust,editable
fn pick<T>(cond: bool, left: T, right: T) -> T {
    if cond { left } else { right }
}

fn main() {
    println!("picked a number: {:?}", pick(true, 222, 333));
    println!("picked a string: {:?}", pick(false, 'L', 'R'));
}
```

<details>

- It can be helpful to show the monomorphized versions of `pick`, either before
  talking about the generic `pick` in order to show how generics can reduce code
  duplication, or after talking about generics to show how monomorphization
  works.

  ```rust
  fn pick_i32(cond: bool, left: i32, right: i32) -> i32 {
      if cond { left } else { right }
  }

  fn pick_char(cond: bool, left: char, right: char) -> char {
      if cond { left } else { right }
  }
  ```

- Rust infers a type for T based on the types of the arguments and return value.

- In this example we only use the primitive types `i32` and `char` for `T`, but
  we can use any type here, including user-defined types:

  ```rust,ignore
  struct Foo {
      val: u8,
  }

  pick(false, Foo { val: 7 }, Foo { val: 99 });
  ```

- This is similar to C++ templates, but Rust partially compiles the generic
  function immediately, so that function must be valid for all types matching
  the constraints. For example, try modifying `pick` to return `left + right` if
  `cond` is false. Even if only the `pick` instantiation with integers is used,
  Rust still considers it invalid. C++ would let you do this.

- Generic code is turned into non-generic code based on the call sites. This is
  a zero-cost abstraction: you get exactly the same result as if you had
  hand-coded the data structures without the abstraction.

</details>



================================================
FILE: src/generics/generic-traits.md
================================================
---
minutes: 5
---

# Generic Traits

Traits can also be generic, just like types and functions. A trait's parameters
get concrete types when it is used. For example the [`From<T>`][from] trait is
used to define type conversions:

```rust
pub trait From<T>: Sized {
    fn from(value: T) -> Self;
}
```

```rust,editable
#[derive(Debug)]
struct Foo(String);

impl From<u32> for Foo {
    fn from(from: u32) -> Foo {
        Foo(format!("Converted from integer: {from}"))
    }
}

impl From<bool> for Foo {
    fn from(from: bool) -> Foo {
        Foo(format!("Converted from bool: {from}"))
    }
}

fn main() {
    let from_int = Foo::from(123);
    let from_bool = Foo::from(true);
    dbg!(from_int);
    dbg!(from_bool);
}
```

<details>

- The `From` trait will be covered later in the course, but its
  [definition in the `std` docs][from] is simple, and copied here for reference.

- Implementations of the trait do not need to cover all possible type
  parameters. Here, `Foo::from("hello")` would not compile because there is no
  `From<&str>` implementation for `Foo`.

- Generic traits take types as "input", while associated types are a kind of
  "output" type. A trait can have multiple implementations for different input
  types.

- In fact, Rust requires that at most one implementation of a trait match for
  any type T. Unlike some other languages, Rust has no heuristic for choosing
  the "most specific" match. There is work on adding this support, called
  [specialization](https://rust-lang.github.io/rfcs/1210-impl-specialization.html).

</details>

[from]: https://doc.rust-lang.org/std/convert/trait.From.html



================================================
FILE: src/generics/impl-trait.md
================================================
---
minutes: 5
---

# `impl Trait`

Similar to trait bounds, an `impl Trait` syntax can be used in function
arguments and return values:

```rust,editable
// Syntactic sugar for:
//   fn add_42_millions<T: Into<i32>>(x: T) -> i32 {
fn add_42_millions(x: impl Into<i32>) -> i32 {
    x.into() + 42_000_000
}

fn pair_of(x: u32) -> impl std::fmt::Debug {
    (x + 1, x - 1)
}

fn main() {
    let many = add_42_millions(42_i8);
    dbg!(many);
    let many_more = add_42_millions(10_000_000);
    dbg!(many_more);
    let debuggable = pair_of(27);
    dbg!(debuggable);
}
```

<details>

`impl Trait` allows you to work with types that you cannot name. The meaning of
`impl Trait` is a bit different in the different positions.

- For a parameter, `impl Trait` is like an anonymous generic parameter with a
  trait bound.

- For a return type, it means that the return type is some concrete type that
  implements the trait, without naming the type. This can be useful when you
  don't want to expose the concrete type in a public API.

  Inference is hard in return position. A function returning `impl Foo` picks
  the concrete type it returns, without writing it out in the source. A function
  returning a generic type like `collect<B>() -> B` can return any type
  satisfying `B`, and the caller may need to choose one, such as with
  `let x: Vec<_> = foo.collect()` or with the turbofish,
  `foo.collect::<Vec<_>>()`.

What is the type of `debuggable`? Try `let debuggable: () = ..` to see what the
error message shows.

</details>



================================================
FILE: src/generics/solution.md
================================================
# Solution

```rust,editable
{{#include exercise.rs:solution}}
```



================================================
FILE: src/generics/trait-bounds.md
================================================
---
minutes: 8
---

# Trait Bounds

When working with generics, you often want to require the types to implement
some trait, so that you can call this trait's methods.

You can do this with `T: Trait`:

```rust,editable
fn duplicate<T: Clone>(a: T) -> (T, T) {
    (a.clone(), a.clone())
}

struct NotCloneable;

fn main() {
    let foo = String::from("foo");
    let pair = duplicate(foo);
    println!("{pair:?}");
}
```

<details>

- Try making a `NotCloneable` and passing it to `duplicate`.

- When multiple traits are necessary, use `+` to join them.

- Show a `where` clause, students will encounter it when reading code.

  ```rust,ignore
  fn duplicate<T>(a: T) -> (T, T)
  where
      T: Clone,
  {
      (a.clone(), a.clone())
  }
  ```

  - It declutters the function signature if you have many parameters.
  - It has additional features making it more powerful.
    - If someone asks, the extra feature is that the type on the left of ":" can
      be arbitrary, like `Option<T>`.

- Note that Rust does not (yet) support specialization. For example, given the
  original `duplicate`, it is invalid to add a specialized `duplicate(a: u32)`.

</details>



================================================
FILE: src/hello-world/benefits.md
================================================
---
minutes: 3
---

# Benefits of Rust

Some unique selling points of Rust:

- _Compile time memory safety_ - whole classes of memory bugs are prevented at
  compile time
  - No uninitialized variables.
  - No double-frees.
  - No use-after-free.
  - No `NULL` pointers.
  - No forgotten locked mutexes.
  - No data races between threads.
  - No iterator invalidation.

- _No undefined runtime behavior_ - what a Rust statement does is never left
  unspecified
  - Array access is bounds checked.
  - Integer overflow is defined (panic or wrap-around).

- _Modern language features_ - as expressive and ergonomic as higher-level
  languages
  - Enums and pattern matching.
  - Generics.
  - No overhead FFI.
  - Zero-cost abstractions.
  - Great compiler errors.
  - Built-in dependency manager.
  - Built-in support for testing.
  - Excellent Language Server Protocol support.

<details>

Do not spend much time here. All of these points will be covered in more depth
later.

Make sure to ask the class which languages they have experience with. Depending
on the answer you can highlight different features of Rust:

- Experience with C or C++: Rust eliminates a whole class of _runtime errors_
  via the borrow checker. You get performance like in C and C++, but you don't
  have the memory unsafety issues. In addition, you get a modern language with
  constructs like pattern matching and built-in dependency management.

- Experience with Java, Go, Python, JavaScript...: You get the same memory
  safety as in those languages, plus a similar high-level language feeling. In
  addition you get fast and predictable performance like C and C++ (no garbage
  collector) as well as access to low-level hardware (should you need it).

</details>



================================================
FILE: src/hello-world/playground.md
================================================
---
minutes: 2
---

# Playground

The [Rust Playground](https://play.rust-lang.org/) provides an easy way to run
short Rust programs, and is the basis for the examples and exercises in this
course. Try running the "hello-world" program it starts with. It comes with a
few handy features:

- Under "Tools", use the `rustfmt` option to format your code in the "standard"
  way.

- Rust has two main "profiles" for generating code: Debug (extra runtime checks,
  less optimization) and Release (fewer runtime checks, lots of optimization).
  These are accessible under "Debug" at the top.

- If you're interested, use "ASM" under "..." to see the generated assembly
  code.

<details>

As students head into the break, encourage them to open up the playground and
experiment a little. Encourage them to keep the tab open and try things out
during the rest of the course. This is particularly helpful for advanced
students who want to know more about Rust's optimizations or generated assembly.

</details>



================================================
FILE: src/hello-world/what-is-rust.md
================================================
---
minutes: 10
---

# What is Rust?

Rust is a new programming language that had its [1.0 release in 2015][1]:

- Rust is a statically compiled language in a similar role as C++
  - `rustc` uses LLVM as its backend.
- Rust supports many
  [platforms and architectures](https://doc.rust-lang.org/nightly/rustc/platform-support.html):
  - x86, ARM, WebAssembly, ...
  - Linux, Mac, Windows, ...
- Rust is used for a wide range of devices:
  - firmware and boot loaders,
  - smart displays,
  - mobile phones,
  - desktops,
  - servers.

<details>

Rust fits in the same area as C++:

- High flexibility.
- High level of control.
- Can be scaled down to very constrained devices such as microcontrollers.
- Has no runtime or garbage collection.
- Focuses on reliability and safety without sacrificing performance.

</details>

[1]: https://blog.rust-lang.org/2015/05/15/Rust-1.0.html



================================================
FILE: src/idiomatic/leveraging-the-type-system.md
================================================
---
minutes: 5
---

# Leveraging the Type System

Rust's type system is _expressive_: you can use types and traits to build
abstractions that make your code harder to misuse.

In some cases, you can go as far as enforcing correctness at _compile-time_,
with no runtime overhead.

Types and traits can model concepts and constraints from your business domain.
With careful design, you can improve the clarity and maintainability of the
entire codebase.

<details>

Additional items speaker may mention:

- Rust's type system borrows a lot of ideas from functional programming
  languages.

  For example, Rust's enums are known as "algebraic data types" in languages
  like Haskell and OCaml. You can take inspiration from learning material geared
  towards functional languages when looking for guidance on how to design with
  types. ["Domain Modeling Made Functional"][1] is a great resource on the
  topic, with examples written in F#.

- Despite Rust's functional roots, not all functional design patterns can be
  easily translated to Rust.

  For example, you must have a solid grasp on a broad selection of advanced
  topics to design APIs that leverage higher-order functions and higher-kinded
  types in Rust.

  Evaluate, on a case-by-case basis, whether a more imperative approach may be
  easier to implement. Consider using in-place mutation, relying on Rust's
  borrow-checker and type system to control what can be mutated, and where.

- The same caution should be applied to object-oriented design patterns. Rust
  doesn't support inheritance, and object decomposition should take into account
  the constraints introduced by the borrow checker.

- Mention that type-level programming can be often used to create "zero-cost
  abstractions", although the label can be misleading: the impact on compile
  times and code complexity may be significant.

</details>

{{%segment outline}}

[1]: https://pragprog.com/titles/swdddf/domain-modeling-made-functional/



================================================
FILE: src/idiomatic/welcome.md
================================================
---
course: Idiomatic Rust
session: Morning
target_minutes: 180
---

# Welcome to Idiomatic Rust

[Rust Fundamentals](../welcome-day-1.md) introduced Rust syntax and core
concepts. We now want to go one step further: how do you use Rust _effectively_
in your projects? What does _idiomatic_ Rust look like?

This course is opinionated: we will nudge you towards some patterns, and away
from others. Nonetheless, we do recognize that some projects may have different
needs. We always provide the necessary information to help you make informed
decisions within the context and constraints of your own projects.

> ⚠️ This course is under **active development**.
>
> The material may change frequently and there might be errors that have not yet
> been spotted. Nonetheless, we encourage you to browse through and provide
> early feedback!

## Schedule

{{%session outline}}

<details name="Course outline">

<!-- TODO: Remove this `details` section once the course material is finalized -->

The course will cover the topics listed below. Each topic may be covered in one
or more slides, depending on its complexity and relevance.

### Foundations of API design

- Golden rule: prioritize clarity and readability at the callsite. People will
  spend much more time reading the call sites than declarations of the functions
  being called.
- Make your API predictable
  - Follow naming conventions (case conventions, prefer vocabulary precedented
    in the standard library - e.g., methods should be called "push" not
    "push_back", "is_empty" not "empty" etc.)
  - Know the vocabulary types and traits in the standard library, and use them
    in your APIs. If something feels like a basic type/algorithm, check in the
    standard library first.
  - Use well-established API design patterns that we will discuss later in this
    class (e.g., newtype, owned/view type pairs, error handling)
- Write meaningful and effective doc comments (e.g., don't merely repeat the
  method name with spaces instead of underscores, don't repeat the same
  information just to fill out every markdown tag, provide usage examples)

### Leveraging the type system

- Short recap on enums, structs and type aliases
- Newtype pattern and encapsulation: parse, don't validate
- Extension traits: avoid the newtype pattern when you want to provide
  additional behaviour
- RAII, scope guards and drop bombs: using `Drop` to clean up resources, trigger
  actions or enforce invariants
- "Token" types: force users to prove they've performed a specific action
- The typestate pattern: enforce correct state transitions at compile-time
- Using the borrow checker to enforce invariants that have nothing to do with
  memory ownership
  - OwnedFd/BorrowedFd in the standard library
  - [Branded types](https://plv.mpi-sws.org/rustbelt/ghostcell/paper.pdf)

### Don't fight the borrow checker

- "Owned" types and "view" types: `&str` and `String`, `Path` and `PathBuf`,
  etc.
- Don't hide ownership requirements: avoid hidden `.clone()`, learn to love
  `Cow`
- Split types along ownership boundaries
- Structure your ownership hierarchy like a tree
- Strategies to manage circular dependencies: reference counting, using indexes
  instead of references
- Interior mutability (Cell, RefCell)
- Working with lifetime parameters on user-defined data types

### Polymorphism in Rust

- A quick refresher on traits and generic functions
- Rust has no inheritance: what are the implications?
  - Using enums for polymorphism
  - Using traits for polymorphism
  - Using composition
  - How do I pick the most appropriate pattern?
- Working with generics
  - Generic type parameter in a function or trait object as an argument?
  - Trait bounds don't have to refer to the generic parameter
  - Type parameters in traits: should it be a generic parameter or an associated
    type?
- Macros: a valuable tool to DRY up code when traits are not enough (or too
  complex)

### Error Handling

- What is the purpose of errors? Recovery vs. reporting.
- Result vs. Option
- Designing good errors:
  - Determine the error scope.
  - Capture additional context as the error flows upwards, crossing scope
    boundaries.
  - Leverage the `Error` trait to keep track of the full error chain.
  - Leverage `thiserror` to reduce boilerplate when defining error types.
  - `anyhow`
- Distinguish fatal errors from recoverable errors using
  `Result<Result<T, RecoverableError>, FatalError>`.

</details>



================================================
FILE: src/idiomatic/leveraging-the-type-system/newtype-pattern.md
================================================
---
minutes: 5
---

# Newtype Pattern

A _newtype_ is a wrapper around an existing type, often a primitive:

```rust
/// A unique user identifier, implemented as a newtype around `u64`.
pub struct UserId(u64);
```

Unlike type aliases, newtypes aren't interchangeable with the wrapped type:

```rust,compile_fail
# pub struct UserId(u64);
fn double(n: u64) -> u64 {
    n * 2
}

double(UserId(1)); // 🛠️❌
```

The Rust compiler won't let you use methods or operators defined on the
underlying type either:

```rust,compile_fail
# pub struct UserId(u64);
assert_ne!(UserId(1), UserId(2)); // 🛠️❌
```

<details>

- Students should have encountered the newtype pattern in the "Fundamentals"
  course, when they learned about
  [tuple structs](../../user-defined-types/tuple-structs.md).

- Run the example to show students the error message from the compiler.

- Modify the example to use a typealias instead of a newtype, such as
  `type MessageId = u64`. The modified example should compile, thus highlighting
  the differences between the two approaches.

- Stress that newtypes, out of the box, have no behaviour attached to them. You
  need to be intentional about which methods and operators you are willing to
  forward from the underlying type. In our `UserId` example, it is reasonable to
  allow comparisons between `UserId`s, but it wouldn't make sense to allow
  arithmetic operations like addition or subtraction.

</details>



================================================
FILE: src/idiomatic/leveraging-the-type-system/typestate-pattern.md
================================================
---
minutes: 30
---

## Typestate Pattern: Problem

How can we ensure that only valid operations are allowed on a value based on its
current state?

```rust,editable
use std::fmt::Write as _;

#[derive(Default)]
struct Serializer {
    output: String,
}

impl Serializer {
    fn serialize_struct_start(&mut self, name: &str) {
        let _ = writeln!(&mut self.output, "{name} {{");
    }

    fn serialize_struct_field(&mut self, key: &str, value: &str) {
        let _ = writeln!(&mut self.output, "  {key}={value};");
    }

    fn serialize_struct_end(&mut self) {
        self.output.push_str("}\n");
    }

    fn finish(self) -> String {
        self.output
    }
}

fn main() {
    let mut serializer = Serializer::default();
    serializer.serialize_struct_start("User");
    serializer.serialize_struct_field("id", "42");
    serializer.serialize_struct_field("name", "Alice");

    // serializer.serialize_struct_end(); // ← Oops! Forgotten

    println!("{}", serializer.finish());
}
```

<details>

- This `Serializer` is meant to write a structured value.

- However, in this example we forgot to call `serialize_struct_end()` before
  `finish()`. As a result, the serialized output is incomplete or syntactically
  incorrect.

- One approach to fix this would be to track internal state manually, and return
  a `Result` from methods like `serialize_struct_field()` or `finish()` if the
  current state is invalid.

- But this has downsides:

  - It is easy to get wrong as an implementer. Rust’s type system cannot help
    enforce the correctness of our state transitions.

  - It also adds unnecessary burden on the user, who must handle `Result` values
    for operations that are misused in source code rather than at runtime.

- A better solution is to model the valid state transitions directly in the type
  system.

  In the next slide, we will apply the **typestate pattern** to enforce correct
  usage at compile time and make it impossible to call incompatible methods or
  forget to do a required action.

</details>



================================================
FILE: src/idiomatic/leveraging-the-type-system/newtype-pattern/is-it-encapsulated.md
================================================
---
minutes: 5
---

# Is It Truly Encapsulated?

You must evaluate _the entire API surface_ exposed by a newtype to determine if
invariants are indeed bullet-proof. It is crucial to consider all possible
interactions, including trait implementations, that may allow users to bypass
validation checks.

```rust
pub struct Username(String);

impl Username {
    pub fn new(username: String) -> Result<Self, InvalidUsername> {
        // Validation checks...
        Ok(Self(username))
    }
}

impl std::ops::DerefMut for Username { // ‼️
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
# impl std::ops::Deref for Username {
#     type Target = str;
#
#     fn deref(&self) -> &Self::Target {
#         &self.0
#     }
# }
# pub struct InvalidUsername;
```

<details>

- `DerefMut` allows users to get a mutable reference to the wrapped value.

  The mutable reference can be used to modify the underlying data in ways that
  may violate the invariants enforced by `Username::new`!

- When auditing the API surface of a newtype, you can narrow down the review
  scope to methods and traits that provide mutable access to the underlying
  data.

- Remind students of privacy boundaries.

  In particular, functions and methods defined in the same module of the newtype
  can access its underlying data directly. If possible, move the newtype
  definition to its own separate module to reduce the scope of the audit.

</details>



================================================
FILE: src/idiomatic/leveraging-the-type-system/newtype-pattern/parse-don-t-validate.md
================================================
---
minutes: 5
---

# Parse, Don't Validate

The newtype pattern can be leveraged to enforce _invariants_.

```rust
pub struct Username(String);

impl Username {
    pub fn new(username: String) -> Result<Self, InvalidUsername> {
        if username.is_empty() {
            return Err(InvalidUsername::CannotBeEmpty)
        }
        if username.len() > 32 {
            return Err(InvalidUsername::TooLong { len: username.len() })
        }
        // Other validation checks...
        Ok(Self(username))
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }
}
# pub enum InvalidUsername {
#     CannotBeEmpty,
#     TooLong { len: usize },
# }
```

<details>

- The newtype pattern, combined with Rust's module and visibility system, can be
  used to _guarantee_ that instances of a given type satisfy a set of
  invariants.

  In the example above, the raw `String` stored inside the `Username` struct
  can't be accessed directly from other modules or crates, since it's not marked
  as `pub` or `pub(in ...)`. Consumers of the `Username` type are forced to use
  the `new` method to create instances. In turn, `new` performs validation, thus
  ensuring that all instances of `Username` satisfy those checks.

- The `as_str` method allows consumers to access the raw string representation
  (e.g., to store it in a database). However, consumers can't modify the
  underlying value since `&str`, the returned type, restricts them to read-only
  access.

- Type-level invariants have second-order benefits.

  The input is validated once, at the boundary, and the rest of the program can
  rely on the invariants being upheld. We can avoid redundant validation and
  "defensive programming" checks throughout the program, reducing noise and
  improving performance.

</details>



================================================
FILE: src/idiomatic/leveraging-the-type-system/newtype-pattern/semantic-confusion.md
================================================
---
minutes: 5
---

# Semantic Confusion

When a function takes multiple arguments of the same type, call sites are
unclear:

```rust
# struct LoginError;
pub fn login(username: &str, password: &str) -> Result<(), LoginError> {
    // [...]
    # Ok(())
}

# let password = "password";
# let username = "username";
// In another part of the codebase, we swap arguments by mistake.
// Bug (best case), security vulnerability (worst case)
login(password, username);
```

The newtype pattern can prevent this class of errors at compile time:

```rust,compile_fail
pub struct Username(String);
pub struct Password(String);
# struct LoginError;

pub fn login(username: &Username, password: &Password) -> Result<(), LoginError> {
    // [...]
    # Ok(())
}

# let password = Password("password".into());
# let username = Username("username".into());
login(password, username); // 🛠️❌
```

<details>

- Run both examples to show students the successful compilation for the original
  example, and the compiler error returned by the modified example.

- Stress the _semantic_ angle. The newtype pattern should be leveraged to use
  distinct types for distinct concepts, thus ruling out this class of errors
  entirely.

- Nonetheless, note that there are legitimate scenarios where a function may
  take multiple arguments of the same type. In those scenarios, if correctness
  is of paramount importance, consider using a struct with named fields as
  input:
  ```rust
  pub struct LoginArguments<'a> {
      pub username: &'a str,
      pub password: &'a str,
  }
  # fn login(i: LoginArguments) {}
  # let password = "password";
  # let username = "username";

  // No need to check the definition of the `login` function to spot the issue.
  login(LoginArguments {
      username: password,
      password: username,
  })
  ```
  Users are forced, at the callsite, to assign values to each field, thus
  increasing the likelihood of spotting bugs.
  <!-- TODO: Link to the relevant section in "Foundations of API design" when that chapter is written -->

</details>



================================================
FILE: src/idiomatic/leveraging-the-type-system/typestate-pattern/typestate-advanced.md
================================================
## Beyond Simple Typestate

How do we manage increasingly complex configuration flows with many possible
states and transitions, while still preventing incompatible operations?

```rust
struct Serializer {/* [...] */}
struct SerializeStruct {/* [...] */}
struct SerializeStructProperty {/* [...] */}
struct SerializeList {/* [...] */}

impl Serializer {
    // TODO, implement:
    //
    // fn serialize_struct(self, name: &str) -> SerializeStruct
    // fn finish(self) -> String
}

impl SerializeStruct {
    // TODO, implement:
    //
    // fn serialize_property(mut self, name: &str) -> SerializeStructProperty

    // TODO,
    // How should we finish this struct? This depends on where it appears:
    // - At the root level: return `Serializer`
    // - As a property inside another struct: return `SerializeStruct`
    // - As a value inside a list: return `SerializeList`
    //
    // fn finish(self) -> ???
}

impl SerializeStructProperty {
    // TODO, implement:
    //
    // fn serialize_string(self, value: &str) -> SerializeStruct
    // fn serialize_struct(self, name: &str) -> SerializeStruct
    // fn serialize_list(self) -> SerializeList
    // fn finish(self) -> SerializeStruct
}

impl SerializeList {
    // TODO, implement:
    //
    // fn serialize_string(mut self, value: &str) -> Self
    // fn serialize_struct(mut self, value: &str) -> SerializeStruct
    // fn serialize_list(mut self) -> SerializeList

    // TODO:
    // Like `SerializeStruct::finish`, the return type depends on nesting.
    //
    // fn finish(mut self) -> ???
}
```

Diagram of valid transitions:

```bob
    +-----------+   +---------+------------+-----+
    |           |   |         |            |     |
    V           |   V         |            V     |
                +                                |
serializer --> structure --> property --> list +-+

    |           |   ^           |          ^
    V           |   |           |          |
                |   +-----------+          |
  String        |                          |
                +--------------------------+
```

<details>

- Building on our previous serializer, we now want to support **nested
  structures** and **lists**.

- However, this introduces both **duplication** and **structural complexity**.

- Even more critically, we now hit a **type system limitation**: we cannot
  cleanly express what `finish()` should return without duplicating variants for
  every nesting context (e.g. root, struct, list).

- From the diagram of valid transitions, we can observe:
  - The transitions are recursive
  - The return types depend on _where_ a substructure or list appears
  - Each context requires a return path to its parent

- With only concrete types, this becomes unmanageable. Our current approach
  leads to an explosion of types and manual wiring.

- In the next chapter, we’ll see how **generics** let us model recursive flows
  with less boilerplate, while still enforcing valid operations at compile time.

</details>



================================================
FILE: src/idiomatic/leveraging-the-type-system/typestate-pattern/typestate-example.md
================================================
## Typestate Pattern: Example

The typestate pattern encodes part of a value’s runtime state into its type.
This allows us to prevent invalid or inapplicable operations at compile time.

```rust,editable
use std::fmt::Write as _;

#[derive(Default)]
struct Serializer {
    output: String,
}

struct SerializeStruct {
    serializer: Serializer,
}

impl Serializer {
    fn serialize_struct(mut self, name: &str) -> SerializeStruct {
        writeln!(&mut self.output, "{name} {{").unwrap();
        SerializeStruct { serializer: self }
    }

    fn finish(self) -> String {
        self.output
    }
}

impl SerializeStruct {
    fn serialize_field(mut self, key: &str, value: &str) -> Self {
        writeln!(&mut self.serializer.output, "  {key}={value};").unwrap();
        self
    }

    fn finish_struct(mut self) -> Serializer {
        self.serializer.output.push_str("}\n");
        self.serializer
    }
}

fn main() {
    let serializer = Serializer::default()
        .serialize_struct("User")
        .serialize_field("id", "42")
        .serialize_field("name", "Alice")
        .finish_struct();

    println!("{}", serializer.finish());
}
```

`Serializer` usage flowchart:

```bob
+------------+  serialize struct   +-----------------+
| Serializer | ------------------> | SerializeStruct | <------+
+------------+                     +-----------------+        |
                                                              |
   |   ^                             |     |                  |
   |   |     finish struct           |     | serialize field  |
   |   +-----------------------------+     +------------------+
   |
   +---> finish
```

<details>

- This example is inspired by Serde’s
  [`Serializer` trait](https://docs.rs/serde/latest/serde/ser/trait.Serializer.html).
  Serde uses typestates internally to ensure serialization follows a valid
  structure. For more, see: <https://serde.rs/impl-serializer.html>

- The key idea behind typestate is that state transitions happen by consuming a
  value and producing a new one. At each step, only operations valid for that
  state are available.

- In this example:

  - We begin with a `Serializer`, which only allows us to start serializing a
    struct.

  - Once we call `.serialize_struct(...)`, ownership moves into a
    `SerializeStruct` value. From that point on, we can only call methods
    related to serializing struct fields.

  - The original `Serializer` is no longer accessible — preventing us from
    mixing modes (such as starting another _struct_ mid-struct) or calling
    `finish()` too early.

  - Only after calling `.finish_struct()` do we receive the `Serializer` back.
    At that point, the output can be finalized or reused.

- If we forget to call `finish_struct()` and drop the `SerializeStruct` early,
  the `Serializer` is also dropped. This ensures incomplete output cannot leak
  into the system.

- By contrast, if we had implemented everything on `Serializer` directly — as
  seen on the previous slide, nothing would stop someone from skipping important
  steps or mixing serialization flows.

</details>



================================================
FILE: src/idiomatic/leveraging-the-type-system/typestate-pattern/typestate-generics.md
================================================
## Typestate Pattern with Generics

By combining typestate modeling with generics, we can express a wider range of
valid states and transitions without duplicating logic. This approach is
especially useful when the number of states grows or when multiple states share
behavior but differ in structure.

```rust
{{#include typestate-generics.rs:Serializer-def}}

{{#include typestate-generics.rs:Root-def}}
{{#include typestate-generics.rs:Struct-def}}
{{#include typestate-generics.rs:Property-def}}
{{#include typestate-generics.rs:List-def}}
```

We now have all the tools needed to implement the methods for the `Serializer`
and its state type definitions. This ensures that our API only permits valid
transitions, as illustrated in the following diagram:

Diagram of valid transitions:

```bob
    +-----------+   +---------+------------+-----+
    |           |   |         |            |     |
    V           |   V         |            V     |
                +                                |
serializer --> structure --> property --> list +-+

    |           |   ^           |          ^
    V           |   |           |          |
                |   +-----------+          |
  String        |                          |
                +--------------------------+
```

<details>

- By leveraging generics to track the parent context, we can construct
  arbitrarily nested serializers that enforce valid transitions between struct,
  list, and property states.

- This enables us to build a recursive structure while maintaining strict
  control over which methods are accessible in each state.

- Methods common to all states can be defined for any `S` in `Serializer<S>`.

- Marker types (e.g., `List<S>`) introduce no memory or runtime overhead, as
  they contain no data other than a possible Zero-Sized Type. Their only role is
  to enforce correct API usage through the type system.

</details>



================================================
FILE: src/idiomatic/leveraging-the-type-system/typestate-pattern/typestate-generics.rs
================================================
// ANCHOR: Complete
use std::fmt::Write as _;

// ANCHOR: Serializer-def
struct Serializer<S> {
    // [...]
    indent: usize,
    buffer: String,
    state: S,
}
// ANCHOR_END: Serializer-def

// ANCHOR: Root-def
struct Root;
// ANCHOR_END: Root-def

// ANCHOR: Struct-def
struct Struct<S>(S);
// ANCHOR_END: Struct-def

// ANCHOR: List-def
struct List<S>(S);
// ANCHOR_END: List-def

// ANCHOR: Property-def
struct Property<S>(S);
// ANCHOR_END: Property-def

// ANCHOR: Root-impl
impl Serializer<Root> {
    fn new() -> Self {
        // [...]
        Self { indent: 0, buffer: String::new(), state: Root }
    }

    fn serialize_struct(mut self, name: &str) -> Serializer<Struct<Root>> {
        // [...]
        writeln!(self.buffer, "{name} {{").unwrap();
        Serializer {
            indent: self.indent + 1,
            buffer: self.buffer,
            state: Struct(self.state),
        }
    }

    fn finish(self) -> String {
        // [...]
        self.buffer
    }
}
// ANCHOR_END: Root-impl

// ANCHOR: Struct-impl
impl<S> Serializer<Struct<S>> {
    fn serialize_property(mut self, name: &str) -> Serializer<Property<Struct<S>>> {
        // [...]
        write!(self.buffer, "{}{name}: ", " ".repeat(self.indent * 2)).unwrap();
        Serializer {
            indent: self.indent,
            buffer: self.buffer,
            state: Property(self.state),
        }
    }

    fn finish_struct(mut self) -> Serializer<S> {
        // [...]
        self.indent -= 1;
        writeln!(self.buffer, "{}}}", " ".repeat(self.indent * 2)).unwrap();
        Serializer { indent: self.indent, buffer: self.buffer, state: self.state.0 }
    }
}
// ANCHOR_END: Struct-impl

// ANCHOR: Property-impl
impl<S> Serializer<Property<Struct<S>>> {
    fn serialize_struct(mut self, name: &str) -> Serializer<Struct<Struct<S>>> {
        // [...]
        writeln!(self.buffer, "{name} {{").unwrap();
        Serializer {
            indent: self.indent + 1,
            buffer: self.buffer,
            state: Struct(self.state.0),
        }
    }

    fn serialize_list(mut self) -> Serializer<List<Struct<S>>> {
        // [...]
        writeln!(self.buffer, "[").unwrap();
        Serializer {
            indent: self.indent + 1,
            buffer: self.buffer,
            state: List(self.state.0),
        }
    }

    fn serialize_string(mut self, value: &str) -> Serializer<Struct<S>> {
        // [...]
        writeln!(self.buffer, "{value},").unwrap();
        Serializer { indent: self.indent, buffer: self.buffer, state: self.state.0 }
    }
}
// ANCHOR_END: Property-impl

// ANCHOR: List-impl
impl<S> Serializer<List<S>> {
    fn serialize_struct(mut self, name: &str) -> Serializer<Struct<List<S>>> {
        // [...]
        writeln!(self.buffer, "{}{name} {{", " ".repeat(self.indent * 2)).unwrap();
        Serializer {
            indent: self.indent + 1,
            buffer: self.buffer,
            state: Struct(self.state),
        }
    }

    fn serialize_string(mut self, value: &str) -> Self {
        // [...]
        writeln!(self.buffer, "{}{value},", " ".repeat(self.indent * 2)).unwrap();
        self
    }

    fn finish_list(mut self) -> Serializer<S> {
        // [...]
        self.indent -= 1;
        writeln!(self.buffer, "{}]", " ".repeat(self.indent * 2)).unwrap();
        Serializer { indent: self.indent, buffer: self.buffer, state: self.state.0 }
    }
}
// ANCHOR_END: List-impl

// ANCHOR: main
fn main() {
    #[rustfmt::skip]
    let serializer = Serializer::new()
        .serialize_struct("Foo")
            .serialize_property("bar")
            .serialize_struct("Bar")
                .serialize_property("baz")
                .serialize_list()
                    .serialize_string("abc")
                    .serialize_struct("Baz")
                        .serialize_property("partial")
                        .serialize_string("def")
                        .serialize_property("empty")
                        .serialize_struct("Empty")
                        .finish_struct()
                    .finish_struct()
                .finish_list()
            .finish_struct()
        .finish_struct();

    let output = serializer.finish();

    println!("{output}");

    // These will all fail at compile time:

    // Serializer::new().serialize_list();
    // Serializer::new().serialize_string("foo");
    // Serializer::new().serialize_struct("Foo").serialize_string("bar");
    // Serializer::new().serialize_struct("Foo").serialize_list();
    // Serializer::new().serialize_property("foo");
}
// ANCHOR_END: main



================================================
FILE: src/idiomatic/leveraging-the-type-system/typestate-pattern/typestate-generics/complete.md
================================================
## Serializer: complete implementation

Looking back at our original desired flow:

```bob
    +-----------+   +---------+------------+-----+
    |           |   |         |            |     |
    V           |   V         |            V     |
                +                                |
serializer --> structure --> property --> list +-+

    |           |   ^           |          ^
    V           |   |           |          |
                |   +-----------+          |
  String        |                          |
                +--------------------------+
```

We can now see this reflected directly in the types of our serializer:

```bob
                                                         +------+
                                                 finish  |      |
                           serialize             struct  V      |
                           struct
+---------------------+ --------------> +-----------------------------+ <---------------+
| Serializer [ Root ] |                 | Serializer [ Struct [ S ] ] |                 |
+---------------------+ <-------------- +-----------------------------+ <-----------+   |
                          finish struct                                             |   |
         |                                  |     serialize   |                     |   |
         |                       +----------+     property    V          serialize  |   |
         |                       |                                       string or  |   |
finish   |                       |    +-------------------------------+  struct     |   |
         V                       |    | Serializer [ Property [ S ] ] | ------------+   |
                         finish  |    +-------------------------------+                 |
     +--------+          struct  |                                                      |
     | String |                  |                serialize   |                         |
     +--------+                  |                list        V                         |
                                 |                                         finish       |
                                 |        +---------------------------+    list         |
                                 +------> | Serializer [ List [ S ] ] | ----------------+
                                          +---------------------------+
                                                  serialize
                                                  list or string  ^
                                              |   or finish list  |
                                              +-------------------+
```

The code for the full implementation of the `Serializer` and all its states can
be found in
[this Rust playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2024&gist=c9cbb831cd05fe9db4ce42713c83ca16).

<details>

- This pattern isn't a silver bullet. It still allows issues like:
  - Empty or invalid property names (which can be fixed using
    [the newtype pattern](../../newtype-pattern.md))
  - Duplicate property names (which could be tracked in `Struct<S>` and handled
    via `Result`)

- If validation failures occur, we can also change method signatures to return a
  `Result`, allowing recovery:

  ```rust,compile_fail
  struct PropertySerializeError<S> {
      kind: PropertyError,
      serializer: Serializer<Struct<S>>,
  }

  impl<S> Serializer<Struct<S>> {
      fn serialize_property(
          self,
          name: &str,
      ) -> Result<Serializer<Property<Struct<S>>>, PropertySerializeError<S>> {
          /* ... */
      }
  }
  ```

- While this API is powerful, it’s not always ergonomic. Production serializers
  typically favor simpler APIs and reserve the typestate pattern for enforcing
  critical invariants.

- One excellent real-world example is
  [`rustls::ClientConfig`](https://docs.rs/rustls/latest/rustls/client/struct.ClientConfig.html#method.builder),
  which uses typestate with generics to guide the user through safe and correct
  configuration steps.

</details>



================================================
FILE: src/idiomatic/leveraging-the-type-system/typestate-pattern/typestate-generics/property.md
================================================
## Serializer: implement Property

```rust
# use std::fmt::Write as _;
{{#include ../typestate-generics.rs:Serializer-def}}

{{#include ../typestate-generics.rs:Struct-def}}
{{#include ../typestate-generics.rs:Property-def}}
{{#include ../typestate-generics.rs:List-def}}

{{#include ../typestate-generics.rs:Property-impl}}
```

With the addition of the Property state methods, our diagram is now nearly
complete:

```bob
                                                         +------+
                                                 finish  |      |
                           serialize             struct  V      |
                           struct
+---------------------+ --------------> +-----------------------------+
| Serializer [ Root ] |                 | Serializer [ Struct [ S ] ] |
+---------------------+ <-------------- +-----------------------------+ <-----------+
                          finish struct                                             |
         |                                        serialize   |                     |
         |                                        property    V          serialize  |
         |                                                               string or  |
finish   |                            +-------------------------------+  struct     |
         V                            | Serializer [ Property [ S ] ] | ------------+
                                      +-------------------------------+
     +--------+
     | String |                                   serialize   |
     +--------+                                   list        V

                                          +---------------------------+
                                          | Serializer [ List [ S ] ] |
                                          +---------------------------+
```

<details>

- A property can be defined as a `String`, `Struct<S>`, or `List<S>`, enabling
  the representation of nested structures.

- This concludes the step-by-step implementation. The full implementation,
  including support for `List<S>`, is shown in the next slide.

</details>



================================================
FILE: src/idiomatic/leveraging-the-type-system/typestate-pattern/typestate-generics/root.md
================================================
## Serializer: implement Root

```rust
# use std::fmt::Write as _;
{{#include ../typestate-generics.rs:Serializer-def}}

{{#include ../typestate-generics.rs:Root-def}}
{{#include ../typestate-generics.rs:Struct-def}}

{{#include ../typestate-generics.rs:Root-impl}}
```

Referring back to our original diagram of valid transitions, we can visualize
the beginning of our implementation as follows:

```bob
                           serialize
                           struct
+---------------------+ --------------> +--------------------------------+
| Serializer [ Root ] |                 | Serializer [ Struct [ Root ] ] |
+---------------------+ <-------------- +--------------------------------+
                          finish struct
         |
         |
         |
finish   |
         V

     +--------+
     | String |
     +--------+
```

<details>

- At the "root" of our `Serializer`, the only construct allowed is a `Struct`.

- The `Serializer` can only be finalized into a `String` from this root level.

</details>



================================================
FILE: src/idiomatic/leveraging-the-type-system/typestate-pattern/typestate-generics/struct.md
================================================
## Serializer: implement Struct

```rust
# use std::fmt::Write as _;
{{#include ../typestate-generics.rs:Serializer-def}}

{{#include ../typestate-generics.rs:Struct-def}}
{{#include ../typestate-generics.rs:Property-def}}

{{#include ../typestate-generics.rs:Struct-impl}}
```

The diagram can now be expanded as follows:

```bob
                                                         +------+
                                                 finish  |      |
                           serialize             struct  V      |
                           struct
+---------------------+ --------------> +-----------------------------+
| Serializer [ Root ] |                 | Serializer [ Struct [ S ] ] |
+---------------------+ <-------------- +-----------------------------+
                          finish struct
         |                                        serialize   |
         |                                        property    V
         |
finish   |                            +------------------------------------------+
         V                            | Serializer [ Property [ Struct [ S ] ] ] |
                                      +------------------------------------------+
     +--------+
     | String |
     +--------+
```

<details>

- A `Struct` can only contain a `Property`;

- Finishing a `Struct` returns control back to its parent, which in our previous
  slide was assumed the `Root`, but in reality however it can be also something
  else such as `Struct` in case of nested "structs".

</details>



================================================
FILE: src/iterators/Cargo.toml
================================================
[package]
name = "iterators"
version = "0.1.0"
edition = "2024"
publish = false

[lib]
name = "offset_differences"
path = "exercise.rs"



================================================
FILE: src/iterators/collect.md
================================================
---
minutes: 5
---

# `collect`

The [`collect`][3] method lets you build a collection from an [`Iterator`][2].

```rust,editable
fn main() {
    let primes = vec![2, 3, 5, 7];
    let prime_squares = primes.into_iter().map(|p| p * p).collect::<Vec<_>>();
    println!("prime_squares: {prime_squares:?}");
}
```

<details>

- Any iterator can be collected in to a `Vec`, `VecDeque`, or `HashSet`.
  Iterators that produce key-value pairs (i.e. a two-element tuple) can also be
  collected into `HashMap` and `BTreeMap`.

Show the students the definition for `collect` in the standard library docs.
There are two ways to specify the generic type `B` for this method:

- With the "turbofish": `some_iterator.collect::<COLLECTION_TYPE>()`, as shown.
  The `_` shorthand used here lets Rust infer the type of the `Vec` elements.
- With type inference: `let prime_squares: Vec<_> = some_iterator.collect()`.
  Rewrite the example to use this form.

## More to Explore

- If students are curious about how this works, you can bring up the
  [`FromIterator`][1] trait, which defines how each type of collection gets
  built from an iterator.
- In addition to the basic implementations of `FromIterator` for `Vec`,
  `HashMap`, etc., there are also more specialized implementations which let you
  do cool things like convert an `Iterator<Item = Result<V, E>>` into a
  `Result<Vec<V>, E>`.
- The reason type annotations are often needed with `collect` is because it's
  generic over its return type. This makes it harder for the compiler to infer
  the correct type in a lot of cases.

</details>

[1]: https://doc.rust-lang.org/std/iter/trait.FromIterator.html
[2]: https://doc.rust-lang.org/std/iter/trait.Iterator.html
[3]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect



================================================
FILE: src/iterators/exercise.md
================================================
---
minutes: 30
---

# Exercise: Iterator Method Chaining

In this exercise, you will need to find and use some of the provided methods in
the [`Iterator`][1] trait to implement a complex calculation.

Copy the following code to <https://play.rust-lang.org/> and make the tests
pass. Use an iterator expression and `collect` the result to construct the
return value.

```rust,editable
{{#include exercise.rs:offset_differences}}
    todo!()
}

{{#include exercise.rs:unit-tests}}
```

[1]: https://doc.rust-lang.org/std/iter/trait.Iterator.html



================================================
FILE: src/iterators/exercise.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![allow(dead_code)]

// ANCHOR: solution
// ANCHOR: offset_differences
/// Calculate the differences between elements of `values` offset by `offset`,
/// wrapping around from the end of `values` to the beginning.
///
/// Element `n` of the result is `values[(n+offset)%len] - values[n]`.
fn offset_differences(offset: usize, values: Vec<i32>) -> Vec<i32> {
    // ANCHOR_END: offset_differences
    let a = values.iter();
    let b = values.iter().cycle().skip(offset);
    a.zip(b).map(|(a, b)| *b - *a).collect()
}

// ANCHOR: unit-tests
#[test]
fn test_offset_one() {
    assert_eq!(offset_differences(1, vec![1, 3, 5, 7]), vec![2, 2, 2, -6]);
    assert_eq!(offset_differences(1, vec![1, 3, 5]), vec![2, 2, -4]);
    assert_eq!(offset_differences(1, vec![1, 3]), vec![2, -2]);
}

#[test]
fn test_larger_offsets() {
    assert_eq!(offset_differences(2, vec![1, 3, 5, 7]), vec![4, 4, -4, -4]);
    assert_eq!(offset_differences(3, vec![1, 3, 5, 7]), vec![6, -2, -2, -2]);
    assert_eq!(offset_differences(4, vec![1, 3, 5, 7]), vec![0, 0, 0, 0]);
    assert_eq!(offset_differences(5, vec![1, 3, 5, 7]), vec![2, 2, 2, -6]);
}

#[test]
fn test_degenerate_cases() {
    assert_eq!(offset_differences(1, vec![0]), vec![0]);
    assert_eq!(offset_differences(1, vec![1]), vec![0]);
    let empty: Vec<i32> = vec![];
    assert_eq!(offset_differences(1, empty), vec![]);
}
// ANCHOR_END: unit-tests



================================================
FILE: src/iterators/helpers.md
================================================
---
minutes: 5
---

# `Iterator` Helper Methods

In addition to the `next` method that defines how an iterator behaves, the
`Iterator` trait provides 70+ helper methods that can be used to build
customized iterators.

```rust,editable
fn main() {
    let result: i32 = (1..=10) // Create a range from 1 to 10
        .filter(|x| x % 2 == 0) // Keep only even numbers
        .map(|x| x * x) // Square each number
        .sum(); // Sum up all the squared numbers

    println!("The sum of squares of even numbers from 1 to 10 is: {}", result);
}
```

<details>

- The `Iterator` trait implements many common functional programming operations
  over collections (e.g. `map`, `filter`, `reduce`, etc). This is the trait
  where you can find all the documentation about them.

- Many of these helper methods take the original iterator and produce a new
  iterator with different behavior. These are know as "iterator adapter
  methods".

- Some methods, like `sum` and `count`, consume the iterator and pull all of the
  elements out of it.

- These methods are designed to be chained together so that it's easy to build a
  custom iterator that does exactly what you need.

## More to Explore

- Rust's iterators are extremely efficient and highly optimizable. Even complex
  iterators made by combining many adapter methods will still result in code as
  efficient as equivalent imperative implementations.

</details>



================================================
FILE: src/iterators/intoiterator.md
================================================
---
minutes: 5
---

# `IntoIterator`

The `Iterator` trait tells you how to _iterate_ once you have created an
iterator. The related trait
[`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html)
defines how to create an iterator for a type. It is used automatically by the
`for` loop.

```rust,editable
struct Grid {
    x_coords: Vec<u32>,
    y_coords: Vec<u32>,
}

impl IntoIterator for Grid {
    type Item = (u32, u32);
    type IntoIter = GridIter;
    fn into_iter(self) -> GridIter {
        GridIter { grid: self, i: 0, j: 0 }
    }
}

struct GridIter {
    grid: Grid,
    i: usize,
    j: usize,
}

impl Iterator for GridIter {
    type Item = (u32, u32);

    fn next(&mut self) -> Option<(u32, u32)> {
        if self.i >= self.grid.x_coords.len() {
            self.i = 0;
            self.j += 1;
            if self.j >= self.grid.y_coords.len() {
                return None;
            }
        }
        let res = Some((self.grid.x_coords[self.i], self.grid.y_coords[self.j]));
        self.i += 1;
        res
    }
}

fn main() {
    let grid = Grid { x_coords: vec![3, 5, 7, 9], y_coords: vec![10, 20, 30, 40] };
    for (x, y) in grid {
        println!("point = {x}, {y}");
    }
}
```

<details>

- `IntoIterator` is the trait that makes for loops work. It is implemented by
  collection types such as `Vec<T>` and references to them such as `&Vec<T>` and
  `&[T]`. Ranges also implement it. This is why you can iterate over a vector
  with `for i in some_vec { .. }` but `some_vec.next()` doesn't exist.

Click through to the docs for `IntoIterator`. Every implementation of
`IntoIterator` must declare two types:

- `Item`: the type to iterate over, such as `i8`,
- `IntoIter`: the `Iterator` type returned by the `into_iter` method.

Note that `IntoIter` and `Item` are linked: the iterator must have the same
`Item` type, which means that it returns `Option<Item>`

The example iterates over all combinations of x and y coordinates.

Try iterating over the grid twice in `main`. Why does this fail? Note that
`IntoIterator::into_iter` takes ownership of `self`.

Fix this issue by implementing `IntoIterator` for `&Grid` and creating a
`GridRefIter` that iterates by reference. A version with both `GridIter` and
`GridRefIter` is available [in this playground][1].

The same problem can occur for standard library types: `for e in some_vector`
will take ownership of `some_vector` and iterate over owned elements from that
vector. Use `for e in &some_vector` instead, to iterate over references to
elements of `some_vector`.

</details>

[1]: https://play.rust-lang.org/?version=stable&mode=debug&edition=2024&gist=947e371c7295af758504f01f149023a1



================================================
FILE: src/iterators/iterator.md
================================================
---
minutes: 5
---

# `Iterator` Trait

The [`Iterator`][1] trait defines how an object can be used to produce a
sequence of values. For example, if we wanted to create an iterator that can
produce the elements of a slice it might look something like this:

```rust,editable
struct SliceIter<'s> {
    slice: &'s [i32],
    i: usize,
}

impl<'s> Iterator for SliceIter<'s> {
    type Item = &'s i32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.i == self.slice.len() {
            None
        } else {
            let next = &self.slice[self.i];
            self.i += 1;
            Some(next)
        }
    }
}

fn main() {
    let slice = &[2, 4, 6, 8];
    let iter = SliceIter { slice, i: 0 };
    for elem in iter {
        dbg!(elem);
    }
}
```

<details>

- The `SliceIter` example implements the same logic as the C-style `for` loop
  demonstrated on the last slide.

- Point out to the students that iterators are lazy: Creating the iterator just
  initializes the struct but does not otherwise do any work. No work happens
  until the `next` method is called.

- Iterators don't need to be finite! It's entirely valid to have an iterator
  that will produce values forever. For example, a half open range like `0..`
  will keep going until integer overflow occurs.

## More to Explore

- The "real" version of `SliceIter` is the [`slice::Iter`][2] type in the
  standard library, however the real version uses pointers under the hood
  instead of an index in order to eliminate bounds checks.

- The `SliceIter` example is a good example of a struct that contains a
  reference and therefore uses lifetime annotations.

- You can also demonstrate adding a generic parameter to `SliceIter` to allow it
  to work with any kind of slice (not just `&[i32]`).

</details>

[1]: https://doc.rust-lang.org/std/iter/trait.Iterator.html
[2]: https://doc.rust-lang.org/stable/std/slice/struct.Iter.html



================================================
FILE: src/iterators/motivation.md
================================================
---
minutes: 3
---

# Motivating Iterators

If you want to iterate over the contents of an array, you'll need to define:

- Some state to keep track of where you are in the iteration process, e.g. an
  index.
- A condition to determine when iteration is done.
- Logic for updating the state of iteration each loop.
- Logic for fetching each element using that iteration state.

In a C-style for loop you declare these things directly:

```c,editable
for (int i = 0; i < array_len; i += 1) {
    int elem = array[i];
}
```

In Rust we bundle this state and logic together into an object known as an
"iterator".

<details>

- This slide provides context for what Rust iterators do under the hood. We use
  the (hopefully) familiar construct of a C-style `for` loop to show how
  iteration requires some state and some logic, that way on the next slide we
  can show how an iterator bundles these together.

- Rust doesn't have a C-style `for` loop, but we can express the same thing with
  `while`:
  ```rust,editable
  let array = [2, 4, 6, 8];
  let mut i = 0;
  while i < array.len() {
      let elem = array[i];
      i += 1;
  }
  ```

## More to Explore

There's another way to express array iteration using `for` in C and C++: You can
use a pointer to the front and a pointer to the end of the array and then
compare those pointers to determine when the loop should end.

```c,editable
for (int *ptr = array; ptr < array + len; ptr += 1) {
    int elem = *ptr;
}
```

If students ask, you can point out that this is how Rust's slice and array
iterators work under the hood (though implemented as a Rust iterator).

</details>



================================================
FILE: src/iterators/solution.md
================================================
# Solution

```rust,editable
{{#include exercise.rs:solution}}
```



================================================
FILE: src/lifetimes/Cargo.toml
================================================
[package]
name = "lifetimes"
version = "0.1.0"
edition = "2024"
publish = false

[dependencies]
thiserror = "2.0.16"

[lib]
name = "protobuf"
path = "exercise.rs"



================================================
FILE: src/lifetimes/exercise.md
================================================
---
minutes: 30
---

# Exercise: Protobuf Parsing

In this exercise, you will build a parser for the
[protobuf binary encoding](https://protobuf.dev/programming-guides/encoding/).
Don't worry, it's simpler than it seems! This illustrates a common parsing
pattern, passing slices of data. The underlying data itself is never copied.

Fully parsing a protobuf message requires knowing the types of the fields,
indexed by their field numbers. That is typically provided in a `proto` file. In
this exercise, we'll encode that information into `match` statements in
functions that get called for each field.

We'll use the following proto:

```proto
message PhoneNumber {
  optional string number = 1;
  optional string type = 2;
}

message Person {
  optional string name = 1;
  optional int32 id = 2;
  repeated PhoneNumber phones = 3;
}
```

## Messages

A proto message is encoded as a series of fields, one after the next. Each is
implemented as a "tag" followed by the value. The tag contains a field number
(e.g., `2` for the `id` field of a `Person` message) and a wire type defining
how the payload should be determined from the byte stream. These are combined
into a single integer, as decoded in `unpack_tag` below.

## Varint

Integers, including the tag, are represented with a variable-length encoding
called VARINT. Luckily, `parse_varint` is defined for you below.

## Wire Types

Proto defines several wire types, only two of which are used in this exercise.

The `Varint` wire type contains a single varint, and is used to encode proto
values of type `int32` such as `Person.id`.

The `Len` wire type contains a length expressed as a varint, followed by a
payload of that number of bytes. This is used to encode proto values of type
`string` such as `Person.name`. It is also used to encode proto values
containing sub-messages such as `Person.phones`, where the payload contains an
encoding of the sub-message.

## Exercise

The given code also defines callbacks to handle `Person` and `PhoneNumber`
fields, and to parse a message into a series of calls to those callbacks.

What remains for you is to implement the `parse_field` function and the
`ProtoMessage` trait for `Person` and `PhoneNumber`.

<!-- compile_fail because the stubbed out code has type inference errors. -->

```rust,editable,compile_fail
{{#include exercise.rs:preliminaries }}


{{#include exercise.rs:parse_field }}
        _ => todo!("Based on the wire type, build a Field, consuming as many bytes as necessary.")
    };
    todo!("Return the field, and any un-consumed bytes.")
}

{{#include exercise.rs:parse_message }}

{{#include exercise.rs:message_phone_number_type}}

{{#include exercise.rs:message_person_type}}

// TODO: Implement ProtoMessage for Person and PhoneNumber.

{{#include exercise.rs:tests }}
```

<details>

- In this exercise there are various cases where protobuf parsing might fail,
  e.g. if you try to parse an `i32` when there are fewer than 4 bytes left in
  the data buffer. In normal Rust code we'd handle this with the `Result` enum,
  but for simplicity in this exercise we panic if any errors are encountered. On
  day 4 we'll cover error handling in Rust in more detail.

</details>



================================================
FILE: src/lifetimes/exercise.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
#![allow(dead_code)]

// ANCHOR: solution
// ANCHOR: preliminaries
/// A wire type as seen on the wire.
enum WireType {
    /// The Varint WireType indicates the value is a single VARINT.
    Varint,
    // The I64 WireType indicates that the value is precisely 8 bytes in
    // little-endian order containing a 64-bit signed integer or double type.
    //I64,  -- not needed for this exercise
    /// The Len WireType indicates that the value is a length represented as a
    /// VARINT followed by exactly that number of bytes.
    Len,
    // The I32 WireType indicates that the value is precisely 4 bytes in
    // little-endian order containing a 32-bit signed integer or float type.
    //I32,  -- not needed for this exercise
}

#[derive(Debug)]
/// A field's value, typed based on the wire type.
enum FieldValue<'a> {
    Varint(u64),
    //I64(i64),  -- not needed for this exercise
    Len(&'a [u8]),
    //I32(i32),  -- not needed for this exercise
}

#[derive(Debug)]
/// A field, containing the field number and its value.
struct Field<'a> {
    field_num: u64,
    value: FieldValue<'a>,
}

trait ProtoMessage<'a>: Default {
    fn add_field(&mut self, field: Field<'a>);
}

impl From<u64> for WireType {
    fn from(value: u64) -> Self {
        match value {
            0 => WireType::Varint,
            //1 => WireType::I64,  -- not needed for this exercise
            2 => WireType::Len,
            //5 => WireType::I32,  -- not needed for this exercise
            _ => panic!("Invalid wire type: {value}"),
        }
    }
}

impl<'a> FieldValue<'a> {
    fn as_str(&self) -> &'a str {
        let FieldValue::Len(data) = self else {
            panic!("Expected string to be a `Len` field");
        };
        std::str::from_utf8(data).expect("Invalid string")
    }

    fn as_bytes(&self) -> &'a [u8] {
        let FieldValue::Len(data) = self else {
            panic!("Expected bytes to be a `Len` field");
        };
        data
    }

    fn as_u64(&self) -> u64 {
        let FieldValue::Varint(value) = self else {
            panic!("Expected `u64` to be a `Varint` field");
        };
        *value
    }
}

/// Parse a VARINT, returning the parsed value and the remaining bytes.
fn parse_varint(data: &[u8]) -> (u64, &[u8]) {
    for i in 0..7 {
        let Some(b) = data.get(i) else {
            panic!("Not enough bytes for varint");
        };
        if b & 0x80 == 0 {
            // This is the last byte of the VARINT, so convert it to
            // a u64 and return it.
            let mut value = 0u64;
            for b in data[..=i].iter().rev() {
                value = (value << 7) | (b & 0x7f) as u64;
            }
            return (value, &data[i + 1..]);
        }
    }

    // More than 7 bytes is invalid.
    panic!("Too many bytes for varint");
}

/// Convert a tag into a field number and a WireType.
fn unpack_tag(tag: u64) -> (u64, WireType) {
    let field_num = tag >> 3;
    let wire_type = WireType::from(tag & 0x7);
    (field_num, wire_type)
}
// ANCHOR_END: preliminaries

// ANCHOR: parse_field
/// Parse a field, returning the remaining bytes
fn parse_field(data: &[u8]) -> (Field<'_>, &[u8]) {
    let (tag, remainder) = parse_varint(data);
    let (field_num, wire_type) = unpack_tag(tag);
    let (fieldvalue, remainder) = match wire_type {
        // ANCHOR_END: parse_field
        WireType::Varint => {
            let (value, remainder) = parse_varint(remainder);
            (FieldValue::Varint(value), remainder)
        }
        WireType::Len => {
            let (len, remainder) = parse_varint(remainder);
            let len = len as usize; // cast for simplicity
            let (value, remainder) = remainder.split_at(len);
            (FieldValue::Len(value), remainder)
        }
    };
    (Field { field_num, value: fieldvalue }, remainder)
}

// ANCHOR: parse_message
/// Parse a message in the given data, calling `T::add_field` for each field in
/// the message.
///
/// The entire input is consumed.
fn parse_message<'a, T: ProtoMessage<'a>>(mut data: &'a [u8]) -> T {
    let mut result = T::default();
    while !data.is_empty() {
        let parsed = parse_field(data);
        result.add_field(parsed.0);
        data = parsed.1;
    }
    result
}
// ANCHOR_END: parse_message

#[derive(PartialEq)]
// ANCHOR: message_phone_number_type
#[derive(Debug, Default)]
struct PhoneNumber<'a> {
    number: &'a str,
    type_: &'a str,
}
// ANCHOR_END: message_phone_number_type

#[derive(PartialEq)]
// ANCHOR: message_person_type
#[derive(Debug, Default)]
struct Person<'a> {
    name: &'a str,
    id: u64,
    phone: Vec<PhoneNumber<'a>>,
}
// ANCHOR_END: message_person_type

impl<'a> ProtoMessage<'a> for Person<'a> {
    fn add_field(&mut self, field: Field<'a>) {
        match field.field_num {
            1 => self.name = field.value.as_str(),
            2 => self.id = field.value.as_u64(),
            3 => self.phone.push(parse_message(field.value.as_bytes())),
            _ => {} // skip everything else
        }
    }
}

impl<'a> ProtoMessage<'a> for PhoneNumber<'a> {
    fn add_field(&mut self, field: Field<'a>) {
        match field.field_num {
            1 => self.number = field.value.as_str(),
            2 => self.type_ = field.value.as_str(),
            _ => {} // skip everything else
        }
    }
}

// ANCHOR: tests
#[test]
fn test_id() {
    let person_id: Person = parse_message(&[0x10, 0x2a]);
    assert_eq!(person_id, Person { name: "", id: 42, phone: vec![] });
}

#[test]
fn test_name() {
    let person_name: Person = parse_message(&[
        0x0a, 0x0e, 0x62, 0x65, 0x61, 0x75, 0x74, 0x69, 0x66, 0x75, 0x6c, 0x20,
        0x6e, 0x61, 0x6d, 0x65,
    ]);
    assert_eq!(person_name, Person { name: "beautiful name", id: 0, phone: vec![] });
}

#[test]
fn test_just_person() {
    let person_name_id: Person =
        parse_message(&[0x0a, 0x04, 0x45, 0x76, 0x61, 0x6e, 0x10, 0x16]);
    assert_eq!(person_name_id, Person { name: "Evan", id: 22, phone: vec![] });
}

#[test]
fn test_phone() {
    let phone: Person = parse_message(&[
        0x0a, 0x00, 0x10, 0x00, 0x1a, 0x16, 0x0a, 0x0e, 0x2b, 0x31, 0x32, 0x33,
        0x34, 0x2d, 0x37, 0x37, 0x37, 0x2d, 0x39, 0x30, 0x39, 0x30, 0x12, 0x04,
        0x68, 0x6f, 0x6d, 0x65,
    ]);
    assert_eq!(
        phone,
        Person {
            name: "",
            id: 0,
            phone: vec![PhoneNumber { number: "+1234-777-9090", type_: "home" },],
        }
    );
}

// Put that all together into a single parse.
#[test]
fn test_full_person() {
    let person: Person = parse_message(&[
        0x0a, 0x07, 0x6d, 0x61, 0x78, 0x77, 0x65, 0x6c, 0x6c, 0x10, 0x2a, 0x1a,
        0x16, 0x0a, 0x0e, 0x2b, 0x31, 0x32, 0x30, 0x32, 0x2d, 0x35, 0x35, 0x35,
        0x2d, 0x31, 0x32, 0x31, 0x32, 0x12, 0x04, 0x68, 0x6f, 0x6d, 0x65, 0x1a,
        0x18, 0x0a, 0x0e, 0x2b, 0x31, 0x38, 0x30, 0x30, 0x2d, 0x38, 0x36, 0x37,
        0x2d, 0x35, 0x33, 0x30, 0x38, 0x12, 0x06, 0x6d, 0x6f, 0x62, 0x69, 0x6c,
        0x65,
    ]);
    assert_eq!(
        person,
        Person {
            name: "maxwell",
            id: 42,
            phone: vec![
                PhoneNumber { number: "+1202-555-1212", type_: "home" },
                PhoneNumber { number: "+1800-867-5308", type_: "mobile" },
            ]
        }
    );
}
// ANCHOR_END: tests



================================================
FILE: src/lifetimes/lifetime-annotations.md
================================================
---
minutes: 10
---

# Lifetime Annotations

A reference has a _lifetime_, which must not "outlive" the value it refers to.
This is verified by the borrow checker.

The lifetime can be implicit - this is what we have seen so far. Lifetimes can
also be explicit: `&'a Point`, `&'document str`. Lifetimes start with `'` and
`'a` is a typical default name. Read `&'a Point` as "a borrowed `Point` which is
valid for at least the lifetime `a`".

Only ownership, not lifetime annotations, control when values are destroyed and
determine the concrete lifetime of a given value. The borrow checker just
validates that borrows never extend beyond the concrete lifetime of the value.

Explicit lifetime annotations, like types, are required on function signatures
(but can be elided in common cases). These provide information for inference at
callsites and within the function body, helping the borrow checker to do its
job.

<!-- The multi-line formatting by rustfmt in left_most is apparently
     intentional: https://github.com/rust-lang/rustfmt/issues/1908 -->

```rust,editable,compile_fail
#[derive(Debug)]
struct Point(i32, i32);

fn left_most(p1: &Point, p2: &Point) -> &Point {
    if p1.0 < p2.0 { p1 } else { p2 }
}

fn main() {
    let p1 = Point(10, 10);
    let p2 = Point(20, 20);
    let p3 = left_most(&p1, &p2); // What is the lifetime of p3?
    dbg!(p3);
}
```

<details>

In this example, the compiler does not know what lifetime to infer for `p3`.
Looking inside the function body shows that it can only safely assume that
`p3`'s lifetime is the shorter of `p1` and `p2`. But just like types, Rust
requires explicit annotations of lifetimes on function arguments and return
values.

Add `'a` appropriately to `left_most`:

```rust,ignore
fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {
```

This says there is some lifetime `'a` which both `p1` and `p2` outlive, and
which outlives the return value. The borrow checker verifies this within the
function body, and uses this information in `main` to determine a lifetime for
`p3`.

Try dropping `p2` in `main` before printing `p3`.

</details>



================================================
FILE: src/lifetimes/lifetime-elision.md
================================================
---
minutes: 5
---

# Lifetimes in Function Calls

Lifetimes for function arguments and return values must be fully specified, but
Rust allows lifetimes to be elided in most cases with
[a few simple rules](https://doc.rust-lang.org/nomicon/lifetime-elision.html).
This is not inference -- it is just a syntactic shorthand.

- Each argument which does not have a lifetime annotation is given one.
- If there is only one argument lifetime, it is given to all un-annotated return
  values.
- If there are multiple argument lifetimes, but the first one is for `self`,
  that lifetime is given to all un-annotated return values.

```rust,editable
#[derive(Debug)]
struct Point(i32, i32);

fn cab_distance(p1: &Point, p2: &Point) -> i32 {
    (p1.0 - p2.0).abs() + (p1.1 - p2.1).abs()
}

fn find_nearest<'a>(points: &'a [Point], query: &Point) -> Option<&'a Point> {
    let mut nearest = None;
    for p in points {
        if let Some((_, nearest_dist)) = nearest {
            let dist = cab_distance(p, query);
            if dist < nearest_dist {
                nearest = Some((p, dist));
            }
        } else {
            nearest = Some((p, cab_distance(p, query)));
        };
    }
    nearest.map(|(p, _)| p)
}

fn main() {
    let points = &[Point(1, 0), Point(1, 0), Point(-1, 0), Point(0, -1)];
    let nearest = {
        let query = Point(0, 2);
        find_nearest(points, &query)
    };
    println!("{:?}", nearest);
}
```

<details>

In this example, `cab_distance` is trivially elided.

The `nearest` function provides another example of a function with multiple
references in its arguments that requires explicit annotation. In `main`, the
return value is allowed to outlive the query.

Try adjusting the signature to "lie" about the lifetimes returned:

```rust,ignore
fn find_nearest<'a, 'q>(points: &'a [Point], query: &'q Point) -> Option<&'q Point> {
```

This won't compile, demonstrating that the annotations are checked for validity
by the compiler. Note that this is not the case for raw pointers (unsafe), and
this is a common source of errors with unsafe Rust.

Students may ask when to use lifetimes. Rust borrows _always_ have lifetimes.
Most of the time, elision and type inference mean these don't need to be written
out. In more complicated cases, lifetime annotations can help resolve ambiguity.
Often, especially when prototyping, it's easier to just work with owned data by
cloning values where necessary.

</details>



================================================
FILE: src/lifetimes/solution.md
================================================
# Solution

```rust,editable
{{#include exercise.rs:solution}}
```



================================================
FILE: src/lifetimes/struct-lifetimes.md
================================================
---
minutes: 5
---

# Lifetimes in Data Structures

If a data type stores borrowed data, it must be annotated with a lifetime:

```rust,editable
#[derive(Debug)]
enum HighlightColor {
    Pink,
    Yellow,
}

#[derive(Debug)]
struct Highlight<'document> {
    slice: &'document str,
    color: HighlightColor,
}

fn main() {
    let doc = String::from("The quick brown fox jumps over the lazy dog.");
    let noun = Highlight { slice: &doc[16..19], color: HighlightColor::Yellow };
    let verb = Highlight { slice: &doc[20..25], color: HighlightColor::Pink };
    // drop(doc);
    dbg!(noun);
    dbg!(verb);
}
```

<details>

- In the above example, the annotation on `Highlight` enforces that the data
  underlying the contained `&str` lives at least as long as any instance of
  `Highlight` that uses that data. A struct cannot live longer than the data it
  references.
- If `doc` is dropped before the end of the lifetime of `noun` or `verb`, the
  borrow checker throws an error.
- Types with borrowed data force users to hold on to the original data. This can
  be useful for creating lightweight views, but it generally makes them somewhat
  harder to use.
- When possible, make data structures own their data directly.
- Some structs with multiple references inside can have more than one lifetime
  annotation. This can be necessary if there is a need to describe lifetime
  relationships between the references themselves, in addition to the lifetime
  of the struct itself. Those are very advanced use cases.

</details>



================================================
FILE: src/memory-management/approaches.md
================================================
---
minutes: 10
---

# Approaches to Memory Management

Traditionally, languages have fallen into two broad categories:

- Full control via manual memory management: C, C++, Pascal, ...
  - Programmer decides when to allocate or free heap memory.
  - Programmer must determine whether a pointer still points to valid memory.
  - Studies show, programmers make mistakes.
- Full safety via automatic memory management at runtime: Java, Python, Go,
  Haskell, ...
  - A runtime system ensures that memory is not freed until it can no longer be
    referenced.
  - Typically implemented with reference counting or garbage collection.

Rust offers a new mix:

> Full control _and_ safety via compile time enforcement of correct memory
> management.

It does this with an explicit ownership concept.

<details>

This slide is intended to help students coming from other languages to put Rust
in context.

- C must manage heap manually with `malloc` and `free`. Common errors include
  forgetting to call `free`, calling it multiple times for the same pointer, or
  dereferencing a pointer after the memory it points to has been freed.

- C++ has tools like smart pointers (`unique_ptr`, `shared_ptr`) that take
  advantage of language guarantees about calling destructors to ensure memory is
  freed when a function returns. It is still quite easy to misuse these tools
  and create similar bugs to C.

- Java, Go, and Python rely on the garbage collector to identify memory that is
  no longer reachable and discard it. This guarantees that any pointer can be
  dereferenced, eliminating use-after-free and other classes of bugs. But, GC
  has a runtime cost and is difficult to tune properly.

Rust's ownership and borrowing model can, in many cases, get the performance of
C, with alloc and free operations precisely where they are required --
zero-cost. It also provides tools similar to C++'s smart pointers. When
required, other options such as reference counting are available, and there are
even crates available to support runtime garbage collection (not covered in this
class).

</details>



================================================
FILE: src/memory-management/Cargo.toml
================================================
[package]
name = "memory-management"
version = "0.1.0"
edition = "2024"
publish = false

[[bin]]
name = "package-builder"
path = "exercise.rs"



================================================
FILE: src/memory-management/clone.md
================================================
---
minutes: 2
---

# Clone

Sometimes you _want_ to make a copy of a value. The `Clone` trait accomplishes
this.

```rust,editable
fn say_hello(name: String) {
    println!("Hello {name}")
}

fn main() {
    let name = String::from("Alice");
    say_hello(name.clone());
    say_hello(name);
}
```

<details>

- The idea of `Clone` is to make it easy to spot where heap allocations are
  occurring. Look for `.clone()` and a few others like `vec!` or `Box::new`.

- It's common to "clone your way out" of problems with the borrow checker, and
  return later to try to optimize those clones away.

- `clone` generally performs a deep copy of the value, meaning that if you e.g.
  clone an array, all of the elements of the array are cloned as well.

- The behavior for `clone` is user-defined, so it can perform custom cloning
  logic if needed.

</details>



================================================
FILE: src/memory-management/copy-types.md
================================================
---
minutes: 5
---

# Copy Types

While move semantics are the default, certain types are copied by default:

<!-- mdbook-xgettext: skip -->

```rust,editable
fn main() {
    let x = 42;
    let y = x;
    dbg!(x); // would not be accessible if not Copy
    dbg!(y);
}
```

These types implement the `Copy` trait.

You can opt-in your own types to use copy semantics:

<!-- mdbook-xgettext: skip -->

```rust,editable
#[derive(Copy, Clone, Debug)]
struct Point(i32, i32);

fn main() {
    let p1 = Point(3, 4);
    let p2 = p1;
    println!("p1: {p1:?}");
    println!("p2: {p2:?}");
}
```

- After the assignment, both `p1` and `p2` own their own data.
- We can also use `p1.clone()` to explicitly copy the data.

<details>

Copying and cloning are not the same thing:

- Copying refers to bitwise copies of memory regions and does not work on
  arbitrary objects.
- Copying does not allow for custom logic (unlike copy constructors in C++).
- Cloning is a more general operation and also allows for custom behavior by
  implementing the `Clone` trait.
- Copying does not work on types that implement the `Drop` trait.

In the above example, try the following:

- Add a `String` field to `struct Point`. It will not compile because `String`
  is not a `Copy` type.
- Remove `Copy` from the `derive` attribute. The compiler error is now in the
  `println!` for `p1`.
- Show that it works if you clone `p1` instead.

# More to Explore

- Shared references are `Copy`/`Clone`, mutable references are not. This is
  because Rust requires that mutable references be exclusive, so while it's
  valid to make a copy of a shared reference, creating a copy of a mutable
  reference would violate Rust's borrowing rules.

</details>



================================================
FILE: src/memory-management/drop.md
================================================
---
minutes: 8
---

# The `Drop` Trait

Values which implement [`Drop`][1] can specify code to run when they go out of
scope:

```rust,editable
struct Droppable {
    name: &'static str,
}

impl Drop for Droppable {
    fn drop(&mut self) {
        println!("Dropping {}", self.name);
    }
}

fn main() {
    let a = Droppable { name: "a" };
    {
        let b = Droppable { name: "b" };
        {
            let c = Droppable { name: "c" };
            let d = Droppable { name: "d" };
            println!("Exiting innermost block");
        }
        println!("Exiting next block");
    }
    drop(a);
    println!("Exiting main");
}
```

<details>

- Note that `std::mem::drop` is not the same as `std::ops::Drop::drop`.
- Values are automatically dropped when they go out of scope.
- When a value is dropped, if it implements `std::ops::Drop` then its
  `Drop::drop` implementation will be called.
- All its fields will then be dropped too, whether or not it implements `Drop`.
- `std::mem::drop` is just an empty function that takes any value. The
  significance is that it takes ownership of the value, so at the end of its
  scope it gets dropped. This makes it a convenient way to explicitly drop
  values earlier than they would otherwise go out of scope.
  - This can be useful for objects that do some work on `drop`: releasing locks,
    closing files, etc.

Discussion points:

- Why doesn't `Drop::drop` take `self`?
  - Short-answer: If it did, `std::mem::drop` would be called at the end of the
    block, resulting in another call to `Drop::drop`, and a stack overflow!
- Try replacing `drop(a)` with `a.drop()`.

</details>

[1]: https://doc.rust-lang.org/std/ops/trait.Drop.html



================================================
FILE: src/memory-management/exercise.md
================================================
---
minutes: 20
---

# Exercise: Builder Type

In this example, we will implement a complex data type that owns all of its
data. We will use the "builder pattern" to support building a new value
piece-by-piece, using convenience functions.

Fill in the missing pieces.

```rust,should_panic,editable
{{#include exercise.rs:Package}}
{{#include exercise.rs:as_dependency}}
        todo!("1")
    }
}

{{#include exercise.rs:PackageBuilder}}
{{#include exercise.rs:new}}
        todo!("2")
    }

{{#include exercise.rs:version}}

{{#include exercise.rs:authors}}
        todo!("3")
    }

{{#include exercise.rs:dependency}}
        todo!("4")
    }

{{#include exercise.rs:language}}
        todo!("5")
    }

{{#include exercise.rs:build}}

{{#include exercise.rs:main}}
```



================================================
FILE: src/memory-management/exercise.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![allow(dead_code)]

// ANCHOR: solution
// ANCHOR: Package
#[derive(Debug)]
enum Language {
    Rust,
    Java,
    Perl,
}

#[derive(Clone, Debug)]
struct Dependency {
    name: String,
    version_expression: String,
}

/// A representation of a software package.
#[derive(Debug)]
struct Package {
    name: String,
    version: String,
    authors: Vec<String>,
    dependencies: Vec<Dependency>,
    language: Option<Language>,
}

impl Package {
    // ANCHOR_END: Package
    // ANCHOR: as_dependency
    /// Return a representation of this package as a dependency, for use in
    /// building other packages.
    fn as_dependency(&self) -> Dependency {
        // ANCHOR_END: as_dependency
        Dependency {
            name: self.name.clone(),
            version_expression: self.version.clone(),
        }
    }
}

// ANCHOR: PackageBuilder
/// A builder for a Package. Use `build()` to create the `Package` itself.
struct PackageBuilder(Package);

impl PackageBuilder {
    // ANCHOR_END: PackageBuilder
    // ANCHOR: new
    fn new(name: impl Into<String>) -> Self {
        // ANCHOR_END: new
        Self(Package {
            name: name.into(),
            version: "0.1".into(),
            authors: Vec::new(),
            dependencies: Vec::new(),
            language: None,
        })
    }

    // ANCHOR: version
    /// Set the package version.
    fn version(mut self, version: impl Into<String>) -> Self {
        self.0.version = version.into();
        self
    }
    // ANCHOR_END: version

    // ANCHOR: authors
    /// Set the package authors.
    fn authors(mut self, authors: Vec<String>) -> Self {
        // ANCHOR_END: authors
        self.0.authors = authors;
        self
    }

    // ANCHOR: dependency
    /// Add an additional dependency.
    fn dependency(mut self, dependency: Dependency) -> Self {
        // ANCHOR_END: dependency
        self.0.dependencies.push(dependency);
        self
    }

    // ANCHOR: language
    /// Set the language. If not set, language defaults to None.
    fn language(mut self, language: Language) -> Self {
        // ANCHOR_END: language
        self.0.language = Some(language);
        self
    }

    // ANCHOR: build
    fn build(self) -> Package {
        self.0
    }
}
// ANCHOR_END: build

// ANCHOR: main
fn main() {
    let base64 = PackageBuilder::new("base64").version("0.13").build();
    dbg!(&base64);
    let log =
        PackageBuilder::new("log").version("0.4").language(Language::Rust).build();
    dbg!(&log);
    let serde = PackageBuilder::new("serde")
        .authors(vec!["djmitche".into()])
        .version(String::from("4.0"))
        .dependency(base64.as_dependency())
        .dependency(log.as_dependency())
        .build();
    dbg!(serde);
}
// ANCHOR_END: main



================================================
FILE: src/memory-management/move.md
================================================
---
minutes: 5
---

# Move Semantics

An assignment will transfer _ownership_ between variables:

```rust,editable
fn main() {
    let s1 = String::from("Hello!");
    let s2 = s1;
    dbg!(s2);
    // dbg!(s1);
}
```

- The assignment of `s1` to `s2` transfers ownership.
- When `s1` goes out of scope, nothing happens: it does not own anything.
- When `s2` goes out of scope, the string data is freed.

Before move to `s2`:

```bob
 Stack                             Heap
.- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - -.
:                           :     :                                     :
:    s1                     :     :                                     :
:   +-----------+-------+   :     :   +----+----+----+----+----+----+   :
:   | ptr       |   o---+---+-----+-->| H  | e  | l  | l  | o  | !  |   :
:   | len       |     6 |   :     :   +----+----+----+----+----+----+   :
:   | capacity  |     6 |   :     :                                     :
:   +-----------+-------+   :     :                                     :
:                           :     `- - - - - - - - - - - - - - - - - - -'
:                           :
`- - - - - - - - - - - - - -'
```

After move to `s2`:

```bob
 Stack                             Heap
.- - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - -.
:                           :     :                                     :
:    s1 "(inaccessible)"    :     :                                     :
:   +-----------+-------+   :     :   +----+----+----+----+----+----+   :
:   | ptr       |   o---+---+--+--+-->| H  | e  | l  | l  | o  | !  |   :
:   | len       |     6 |   :  |  :   +----+----+----+----+----+----+   :
:   | capacity  |     6 |   :  |  :                                     :
:   +-----------+-------+   :  |  :                                     :
:                           :  |  `- - - - - - - - - - - - - - - - - - -'
:    s2                     :  |
:   +-----------+-------+   :  |
:   | ptr       |   o---+---+--'
:   | len       |     6 |   :
:   | capacity  |     6 |   :
:   +-----------+-------+   :
:                           :
`- - - - - - - - - - - - - -'
```

When you pass a value to a function, the value is assigned to the function
parameter. This transfers ownership:

```rust,editable
fn say_hello(name: String) {
    println!("Hello {name}")
}

fn main() {
    let name = String::from("Alice");
    say_hello(name);
    // say_hello(name);
}
```

<details>

- Mention that this is the opposite of the defaults in C++, which copies by
  value unless you use `std::move` (and the move constructor is defined!).

- It is only the ownership that moves. Whether any machine code is generated to
  manipulate the data itself is a matter of optimization, and such copies are
  aggressively optimized away.

- Simple values (such as integers) can be marked `Copy` (see later slides).

- In Rust, clones are explicit (by using `clone`).

In the `say_hello` example:

- With the first call to `say_hello`, `main` gives up ownership of `name`.
  Afterwards, `name` cannot be used anymore within `main`.
- The heap memory allocated for `name` will be freed at the end of the
  `say_hello` function.
- `main` can retain ownership if it passes `name` as a reference (`&name`) and
  if `say_hello` accepts a reference as a parameter.
- Alternatively, `main` can pass a clone of `name` in the first call
  (`name.clone()`).
- Rust makes it harder than C++ to inadvertently create copies by making move
  semantics the default, and by forcing programmers to make clones explicit.

# More to Explore

## Defensive Copies in Modern C++

Modern C++ solves this differently:

```c++
std::string s1 = "Cpp";
std::string s2 = s1;  // Duplicate the data in s1.
```

- The heap data from `s1` is duplicated and `s2` gets its own independent copy.
- When `s1` and `s2` go out of scope, they each free their own memory.

Before copy-assignment:

```bob
 Stack                             Heap
.- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.
:                           :     :                       :
:    s1                     :     :                       :
:   +-----------+-------+   :     :   +----+----+----+    :
:   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :
:   | len       |     3 |   :     :   +----+----+----+    :
:   | capacity  |     3 |   :     :                       :
:   +-----------+-------+   :     :                       :
:                           :     `- - - - - - - - - - - -'
`- - - - - - - - - - - - - -'
```

After copy-assignment:

```bob
 Stack                             Heap
.- - - - - - - - - - - - - -.     .- - - - - - - - - - - -.
:                           :     :                       :
:    s1                     :     :                       :
:   +-----------+-------+   :     :   +----+----+----+    :
:   | ptr       |   o---+---+--+--+-->| C  | p  | p  |    :
:   | len       |     3 |   :     :   +----+----+----+    :
:   | capacity  |     3 |   :     :                       :
:   +-----------+-------+   :     :                       :
:                           :     :                       :
:    s2                     :     :                       :
:   +-----------+-------+   :     :   +----+----+----+    :
:   | ptr       |   o---+---+-----+-->| C  | p  | p  |    :
:   | len       |     3 |   :     :   +----+----+----+    :
:   | capacity  |     3 |   :     :                       :
:   +-----------+-------+   :     :                       :
:                           :     `- - - - - - - - - - - -'
`- - - - - - - - - - - - - -'
```

Key points:

- C++ has made a slightly different choice than Rust. Because `=` copies data,
  the string data has to be cloned. Otherwise we would get a double-free when
  either string goes out of scope.

- C++ also has [`std::move`], which is used to indicate when a value may be
  moved from. If the example had been `s2 = std::move(s1)`, no heap allocation
  would take place. After the move, `s1` would be in a valid but unspecified
  state. Unlike Rust, the programmer is allowed to keep using `s1`.

- Unlike Rust, `=` in C++ can run arbitrary code as determined by the type that
  is being copied or moved.

[`std::move`]: https://en.cppreference.com/w/cpp/utility/move

</details>



================================================
FILE: src/memory-management/ownership.md
================================================
---
minutes: 5
---

# Ownership

All variable bindings have a _scope_ where they are valid and it is an error to
use a variable outside its scope:

<!-- mdbook-xgettext: skip -->

```rust,editable,compile_fail
struct Point(i32, i32);

fn main() {
    {
        let p = Point(3, 4);
        dbg!(p.0);
    }
    dbg!(p.1);
}
```

We say that the variable _owns_ the value. Every Rust value has precisely one
owner at all times.

At the end of the scope, the variable is _dropped_ and the data is freed. A
destructor can run here to free up resources.

<details>

Students familiar with garbage collection implementations will know that a
garbage collector starts with a set of "roots" to find all reachable memory.
Rust's "single owner" principle is a similar idea.

</details>



================================================
FILE: src/memory-management/review.md
================================================
---
minutes: 5
---

# Review of Program Memory

Programs allocate memory in two ways:

- Stack: Continuous area of memory for local variables.
  - Values have fixed sizes known at compile time.
  - Extremely fast: just move a stack pointer.
  - Easy to manage: follows function calls.
  - Great memory locality.

- Heap: Storage of values outside of function calls.
  - Values have dynamic sizes determined at runtime.
  - Slightly slower than the stack: some bookkeeping needed.
  - No guarantee of memory locality.

## Example

Creating a `String` puts fixed-sized metadata on the stack and dynamically sized
data, the actual string, on the heap:

```rust,editable
fn main() {
    let s1 = String::from("Hello");
}
```

```bob
 Stack
.- - - - - - - - - - - - - -.      Heap
:                           :     .- - - - - - - - - - - - - - - -.
:    s1                     :     :                               :
:   +-----------+-------+   :     :                               :
:   | capacity  |     5 |   :     :   +----+----+----+----+----+  :
:   | ptr       |     o-+---+-----+-->| H  | e  | l  | l  | o  |  :
:   | len       |     5 |   :     :   +----+----+----+----+----+  :
:   +-----------+-------+   :     :                               :
:                           :     :                               :
`- - - - - - - - - - - - - -'     `- - - - - - - - - - - - - - - -'
```

<details>

- Mention that a `String` is backed by a `Vec`, so it has a capacity and length
  and can grow if mutable via reallocation on the heap.

- If students ask about it, you can mention that the underlying memory is heap
  allocated using the [System Allocator] and custom allocators can be
  implemented using the [Allocator API]

## More to Explore

We can inspect the memory layout with `unsafe` Rust. However, you should point
out that this is rightfully unsafe!

```rust,editable
fn main() {
    let mut s1 = String::from("Hello");
    s1.push(' ');
    s1.push_str("world");
    // DON'T DO THIS AT HOME! For educational purposes only.
    // String provides no guarantees about its layout, so this could lead to
    // undefined behavior.
    unsafe {
        let (capacity, ptr, len): (usize, usize, usize) = std::mem::transmute(s1);
        println!("capacity = {capacity}, ptr = {ptr:#x}, len = {len}");
    }
}
```

</details>

[System Allocator]: https://doc.rust-lang.org/std/alloc/struct.System.html
[Allocator API]: https://doc.rust-lang.org/std/alloc/index.html



================================================
FILE: src/memory-management/solution.md
================================================
# Solution

```rust,editable
{{#include exercise.rs:solution}}
```



================================================
FILE: src/methods-and-traits/Cargo.toml
================================================
[package]
name = "methods-and-traits"
version = "0.1.0"
edition = "2024"
publish = false

[[bin]]
name = "methods-and-traits"
path = "exercise.rs"



================================================
FILE: src/methods-and-traits/deriving.md
================================================
---
minutes: 3
---

# Deriving

Supported traits can be automatically implemented for your custom types, as
follows:

```rust,editable
#[derive(Debug, Clone, Default)]
struct Player {
    name: String,
    strength: u8,
    hit_points: u8,
}

fn main() {
    let p1 = Player::default(); // Default trait adds `default` constructor.
    let mut p2 = p1.clone(); // Clone trait adds `clone` method.
    p2.name = String::from("EldurScrollz");
    // Debug trait adds support for printing with `{:?}`.
    println!("{p1:?} vs. {p2:?}");
}
```

<details>

- Derivation is implemented with macros, and many crates provide useful derive
  macros to add useful functionality. For example, `serde` can derive
  serialization support for a struct using `#[derive(Serialize)]`.

- Derivation is usually provided for traits that have a common boilerplate
  implementation that is correct for most cases. For example, demonstrate how a
  manual `Clone` impl can be repetitive compared to deriving the trait:

  ```rust,ignore
  impl Clone for Player {
      fn clone(&self) -> Self {
          Player {
              name: self.name.clone(),
              strength: self.strength.clone(),
              hit_points: self.hit_points.clone(),
          }
      }
  }
  ```

  Not all of the `.clone()`s in the above are necessary in this case, but this
  demonstrates the generally boilerplate-y pattern that manual impls would
  follow, which should help make the use of `derive` clear to students.

</details>



================================================
FILE: src/methods-and-traits/exercise.md
================================================
---
minutes: 15
---

# Exercise: Logger Trait

Let's design a simple logging utility, using a trait `Logger` with a `log`
method. Code that might log its progress can then take an `&impl Logger`. In
testing, this might put messages in the test logfile, while in a production
build it would send messages to a log server.

However, the `StderrLogger` given below logs all messages, regardless of
verbosity. Your task is to write a `VerbosityFilter` type that will ignore
messages above a maximum verbosity.

This is a common pattern: a struct wrapping a trait implementation and
implementing that same trait, adding behavior in the process. In the "Generics"
segment, we will see how to make the wrapper generic over the wrapped type.

```rust,compile_fail,editable
{{#include exercise.rs:setup}}

// TODO: Implement the `Logger` trait for `VerbosityFilter`.

{{#include exercise.rs:main}}
```



================================================
FILE: src/methods-and-traits/exercise.rs
================================================
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: solution
// ANCHOR: setup
trait Logger {
    /// Log a message at the given verbosity level.
    fn log(&self, verbosity: u8, message: &str);
}

struct StderrLogger;

impl Logger for StderrLogger {
    fn log(&self, verbosity: u8, message: &str) {
        eprintln!("verbosity={verbosity}: {message}");
    }
}

/// Only log messages up to the given verbosity level.
struct VerbosityFilter {
    max_verbosity: u8,
    inner: StderrLogger,
}
// ANCHOR_END: setup

impl Logger for VerbosityFilter {
    fn log(&self, verbosity: u8, message: &str) {
        if verbosity <= self.max_verbosity {
            self.inner.log(verbosity, message);
        }
    }
}

// ANCHOR: main
fn main() {
    let logger = VerbosityFilter { max_verbosity: 3, inner: StderrLogger };
    logger.log(5, "FYI");
    logger.log(2, "Uhoh");
}
// ANCHOR_END: main



================================================
FILE: src/methods-and-traits/methods.md
================================================
---
minutes: 8
---

# Methods

Rust allows you to associate functions with your new types. You do this with an
`impl` block:

```rust,editable
#[derive(Debug)]
struct CarRace {
    name: String,
    laps: Vec<i32>,
}

impl CarRace {
    // No receiver, a static method
    fn new(name: &str) -> Self {
        Self { name: String::from(name), laps: Vec::new() }
    }

    // Exclusive borrowed read-write access to self
    fn add_lap(&mut self, lap: i32) {
        self.laps.push(lap);
    }

    // Shared and read-only borrowed access to self
    fn print_laps(&self) {
        println!("Recorded {} laps for {}:", self.laps.len(), self.name);
        for (idx, lap) in self.laps.iter().enumerate() {
            println!("Lap {idx}: {lap} sec");
        }
    }

    // Exclusive ownership of self (covered later)
    fn finish(self) {
        let total: i32 = self.laps.iter().sum();
        println!("Race {} is finished, total lap time: {}", self.name, total);
    }
}

fn main() {
    let mut race = CarRace::new("Monaco Grand Prix");
    race.add_lap(70);
    race.add_lap(68);
    race.print_laps();
    race.add_lap(71);
    race.print_laps();
    race.finish();
    // race.add_lap(42);
}
```

The `self` arguments specify the "receiver" - the object the method acts on.
There are several common receivers for a method:

- `&self`: borrows the object from the caller using a shared and immutable
  reference. The object can be used again afterwards.
- `&mut self`: borrows the object from the caller using a unique and mutable
  reference. The object can be used again afterwards.
- `self`: takes ownership of the object and moves it away from the caller. The
  method becomes the owner of the object. The object will be dropped
  (deallocated) when the method returns, unless its ownership is explicitly
  transmitted. Complete ownership does not automatically mean mutability.
- `mut self`: same as above, but the method can mutate the object.
- No receiver: this becomes a static method on the struct. Typically used to
  create constructors that are called `new` by convention.

<details>

Key Points:

- It can be helpful to introduce methods by comparing them to functions.
  - Methods are called on an instance of a type (such as a struct or enum), the
    first parameter represents the instance as `self`.
  - Developers may choose to use methods to take advantage of method receiver
    syntax and to help keep them more organized. By using methods we can keep
    all the implementation code in one predictable place.
  - Note that methods can also be called like associated functions by explicitly
    passing the receiver in, e.g. `CarRace::add_lap(&mut race, 20)`.
- Point out the use of the keyword `self`, a method receiver.
  - Show that it is an abbreviated term for `self: Self` and perhaps show how
    the struct name could also be used.
  - Explain that `Self` is a type alias for the type the `impl` block is in and
    can be used elsewhere in the block.
  - Note how `self` is used like other structs and dot notation can be used to
    refer to individual fields.
  - This might be a good time to demonstrate how the `&self` differs from `self`
    by trying to run `finish` twice.
  - Beyond variants on `self`, there are also
    [special wrapper types](https://doc.rust-lang.org/reference/special-types-and-traits.html)
    allowed to be receiver types, such as `Box<Self>`.

</details>



================================================
FILE: src/methods-and-traits/solution.md
================================================
# Solution

```rust,editable
{{#include exercise.rs:solution}}
```



================================================
FILE: src/methods-and-traits/traits.md
================================================
---
minutes: 15
---

# Traits

Rust lets you abstract over types with traits. They're similar to interfaces:

```rust,editable
trait Pet {
    /// Return a sentence from this pet.
    fn talk(&self) -> String;

    /// Print a string to the terminal greeting this pet.
    fn greet(&self);
}
```

<details>

- A trait defines a number of methods that types must have in order to implement
  the trait.

- In the "Generics" segment, next, we will see how to build functionality that
  is generic over all types implementing a trait.

</details>



================================================
FILE: src/methods-and-traits/traits/associated-types.md
================================================
# Associated Types

Associated types are placeholder types that are supplied by the trait
implementation.

```rust,editable
#[derive(Debug)]
struct Meters(i32);
#[derive(Debug)]
struct MetersSquared(i32);

trait Multiply {
    type Output;
    fn multiply(&self, other: &Self) -> Self::Output;
}

impl Multiply for Meters {
    type Output = MetersSquared;
    fn multiply(&self, other: &Self) -> Self::Output {
        MetersSquared(self.0 * other.0)
    }
}

fn main() {
    println!("{:?}", Meters(10).multiply(&Meters(20)));
}
```

<details>

- Associated types are sometimes also called "output types". The key observation
  is that the implementer, not the caller, chooses this type.

- Many standard library traits have associated types, including arithmetic
  operators and `Iterator`.

</details>



================================================
FILE: src/methods-and-traits/traits/implementing.md
================================================
# Implementing Traits

```rust,editable
trait Pet {
    fn talk(&self) -> String;

    fn greet(&self) {
        println!("Oh you're a cutie! What's your name? {}", self.talk());
    }
}

struct Dog {
    name: String,
    age: i8,
}

impl Pet for Dog {
    fn talk(&self) -> String {
        format!("Woof, my name is {}!", self.name)
    }
}

fn main() {
    let fido = Dog { name: String::from("Fido"), age: 5 };
    dbg!(fido.talk());
    fido.greet();
}
```

<details>

- To implement `Trait` for `Type`, you use an `impl Trait for Type { .. }`
  block.

- Unlike Go interfaces, just having matching methods is not enough: a `Cat` type
  with a `talk()` method would not automatically satisfy `Pet` unless it is in
  an `impl Pet` block.

- Traits may provide default implementations of some methods. Default
  implementations can rely on all the methods of the trait. In this case,
  `greet` is provided, and relies on `talk`.

- Multiple `impl` blocks are allowed for a given type. This includes both
  inherent `impl` blocks and trait `impl` blocks. Likewise multiple traits can
  be implemented for a given type (and often types implement many traits!).
  `impl` blocks can even be spread across multiple modules/files.

</details>



================================================
FILE: src/methods-and-traits/traits/supertraits.md
================================================
# Supertraits

A trait can require that types implementing it also implement other traits,
called _supertraits_. Here, any type implementing `Pet` must implement `Animal`.

```rust,editable
trait Animal {
    fn leg_count(&self) -> u32;
}

trait Pet: Animal {
    fn name(&self) -> String;
}

struct Dog(String);

impl Animal for Dog {
    fn leg_count(&self) -> u32 {
        4
    }
}

impl Pet for Dog {
    fn name(&self) -> String {
        self.0.clone()
    }
}

fn main() {
    let puppy = Dog(String::from("Rex"));
    println!("{} has {} legs", puppy.name(), puppy.leg_count());
}
```

<details>

This is sometimes called "trait inheritance" but students should not expect this
to behave like OO inheritance. It just specifies an additional requirement on
implementations of a trait.

</details>



================================================
FILE: src/modules/Cargo.toml
================================================
[package]
name = "modules"
version = "0.1.0"
edition = "2024"
publish = false

[[bin]]
name = "modules"
path = "exercise.rs"



================================================
FILE: src/modules/encapsulation.md
================================================
---
minutes: 5
---

# Visibility and Encapsulation

Like with items in a module, struct fields are also private by default. Private
fields are likewise visible within the rest of the module (including child
modules). This allows us to encapsulate implementation details of struct,
controlling what data and functionality is visible externally.

```rust,editable
use outer::Foo;

mod outer {
    pub struct Foo {
        pub val: i32,
        is_big: bool,
    }

    impl Foo {
        pub fn new(val: i32) -> Self {
            Self { val, is_big: val > 100 }
        }
    }

    pub mod inner {
        use super::Foo;

        pub fn print_foo(foo: &Foo) {
            println!("Is {} big? {}", foo.val, foo.is_big);
        }
    }
}

fn main() {
    let foo = Foo::new(42);
    println!("foo.val = {}", foo.val);
    // let foo = Foo { val: 42, is_big: true };

    outer::inner::print_foo(&foo);
    // println!("Is {} big? {}", foo.val, foo.is_big);
}
```

<details>

- This slide demonstrates how privacy in structs is module-based. Students
  coming from object-oriented languages may be used to types being the
  encapsulation boundary, so this demonstrates how Rust behaves differently
  while showing how we can still achieve encapsulation.

- Note how the `is_big` field is fully controlled by `Foo`, allowing `Foo` to
  control how it's initialized and enforce any invariants it needs to (e.g. that
  `is_big` is only `true` if `val > 100`).

- Point out how helper functions can be defined in the same module (including
  child modules) in order to get access to the type's private fields/methods.

- The first commented out line demonstrates that you cannot initialize a struct
  with private fields. The second one demonstrates that you also can't directly
  access private fields.

- Enums do not support privacy: Variants and data within those variants is
  always public.

## More to Explore

- If students want more information about privacy (or lack thereof) in enums,
  you can bring up `#[doc_hidden]` and `#[non_exhaustive]` and show how they're
  used to limit what can be done with an enum.

- Module privacy still applies when there are `impl` blocks in other modules
  [(example in the playground)][1].

</details>

[1]: https://play.rust-lang.org/?version=stable&mode=debug&edition=2024&gist=3e61f43c88de12bcdf69c1d6df9ab3da



================================================
FILE: src/modules/exercise.md
================================================
---
minutes: 15
---

# Exercise: Modules for a GUI Library

In this exercise, you will reorganize a small GUI Library implementation. This
library defines a `Widget` trait and a few implementations of that trait, as
well as a `main` function.

It is typical to put each type or set of closely-related types into its own
module, so each widget type should get its own module.

## Cargo Setup

The Rust playground only supports one file, so you will need to make a Cargo
project on your local filesystem:

```shell
cargo init gui-modules
cd gui-modules
cargo run
```

Edit the resulting `src/main.rs` to add `mod` statements, and add additional
files in the `src` directory.

## Source

Here's the single-module implementation of the GUI library:

```rust,editable
{{#include exercise.rs:single-module}}
```

<details>

Encourage students to divide the code in a way that feels natural for them, and
get accustomed to the required `mod`, `use`, and `pub` declarations. Afterward,
discuss what organizations are most idiomatic.

</details>



================================================
FILE: src/modules/exercise.rs
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: single-module
pub trait Widget {
    /// Natural width of `self`.
    fn width(&self) -> usize;

    /// Draw the widget into a buffer.
    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);

    /// Draw the widget on standard output.
    fn draw(&self) {
        let mut buffer = String::new();
        self.draw_into(&mut buffer);
        println!("{buffer}");
    }
}

pub struct Label {
    label: String,
}

impl Label {
    fn new(label: &str) -> Label {
        Label { label: label.to_owned() }
    }
}

pub struct Button {
    label: Label,
}

impl Button {
    fn new(label: &str) -> Button {
        Button { label: Label::new(label) }
    }
}

pub struct Window {
    title: String,
    widgets: Vec<Box<dyn Widget>>,
}

impl Window {
    fn new(title: &str) -> Window {
        Window { title: title.to_owned(), widgets: Vec::new() }
    }

    fn add_widget(&mut self, widget: Box<dyn Widget>) {
        self.widgets.push(widget);
    }

    fn inner_width(&self) -> usize {
        std::cmp::max(
            self.title.chars().count(),
            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),
        )
    }
}

impl Widget for Window {
    fn width(&self) -> usize {
        // Add 4 paddings for borders
        self.inner_width() + 4
    }

    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {
        let mut inner = String::new();
        for widget in &self.widgets {
            widget.draw_into(&mut inner);
        }

        let inner_width = self.inner_width();

        // TODO: Change draw_into to return Result<(), std::fmt::Error>. Then use the
        // ?-operator here instead of .unwrap().
        writeln!(buffer, "+-{:-<inner_width$}-+", "").unwrap();
        writeln!(buffer, "| {:^inner_width$} |", &self.title).unwrap();
        writeln!(buffer, "+={:=<inner_width$}=+", "").unwrap();
        for line in inner.lines() {
            writeln!(buffer, "| {:inner_width$} |", line).unwrap();
        }
        writeln!(buffer, "+-{:-<inner_width$}-+", "").unwrap();
    }
}

impl Widget for Button {
    fn width(&self) -> usize {
        self.label.width() + 8 // add a bit of padding
    }

    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {
        let width = self.width();
        let mut label = String::new();
        self.label.draw_into(&mut label);

        writeln!(buffer, "+{:-<width$}+", "").unwrap();
        for line in label.lines() {
            writeln!(buffer, "|{:^width$}|", &line).unwrap();
        }
        writeln!(buffer, "+{:-<width$}+", "").unwrap();
    }
}

impl Widget for Label {
    fn width(&self) -> usize {
        self.label.lines().map(|line| line.chars().count()).max().unwrap_or(0)
    }

    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {
        writeln!(buffer, "{}", &self.label).unwrap();
    }
}

fn main() {
    let mut window = Window::new("Rust GUI Demo 1.23");
    window.add_widget(Box::new(Label::new("This is a small text GUI demo.")));
    window.add_widget(Box::new(Button::new("Click me!")));
    window.draw();
}



================================================
FILE: src/modules/filesystem.md
================================================
---
minutes: 5
---

# Filesystem Hierarchy

Omitting the module content will tell Rust to look for it in another file:

```rust,editable,compile_fail
mod garden;
```

This tells Rust that the `garden` module content is found at `src/garden.rs`.
Similarly, a `garden::vegetables` module can be found at
`src/garden/vegetables.rs`.

The `crate` root is in:

- `src/lib.rs` (for a library crate)
- `src/main.rs` (for a binary crate)

Modules defined in files can be documented, too, using "inner doc comments".
These document the item that contains them -- in this case, a module.

```rust,editable,compile_fail
//! This module implements the garden, including a highly performant germination
//! implementation.

// Re-export types from this module.
pub use garden::Garden;
pub use seeds::SeedPacket;

/// Sow the given seed packets.
pub fn sow(seeds: Vec<SeedPacket>) {
    todo!()
}

/// Harvest the produce in the garden that is ready.
pub fn harvest(garden: &mut Garden) {
    todo!()
}
```

<details>

- Before Rust 2018, modules needed to be located at `module/mod.rs` instead of
  `module.rs`, and this is still a working alternative for editions after 2018.

- The main reason to introduce `filename.rs` as alternative to `filename/mod.rs`
  was because many files named `mod.rs` can be hard to distinguish in IDEs.

- Deeper nesting can use folders, even if the main module is a file:

  ```ignore
  src/
  ├── main.rs
  ├── top_module.rs
  └── top_module/
      └── sub_module.rs
  ```

- The place rust will look for modules can be changed with a compiler directive:

  ```rust,ignore
  #[path = "some/path.rs"]
  mod some_module;
  ```

  This is useful, for example, if you would like to place tests for a module in
  a file named `some_module_test.rs`, similar to the convention in Go.

</details>



================================================
FILE: src/modules/modules.md
================================================
---
minutes: 3
---

# Modules

We have seen how `impl` blocks let us namespace functions to a type.

Similarly, `mod` lets us namespace types and functions:

```rust,editable
mod foo {
    pub fn do_something() {
        println!("In the foo module");
    }
}

mod bar {
    pub fn do_something() {
        println!("In the bar module");
    }
}

fn main() {
    foo::do_something();
    bar::do_something();
}
```

<details>

- Packages provide functionality and include a `Cargo.toml` file that describes
  how to build a bundle of 1+ crates.
- Crates are a tree of modules, where a binary crate creates an executable and a
  library crate compiles to a library.
- Modules define organization, scope, and are the focus of this section.

</details>



================================================
FILE: src/modules/paths.md
================================================
---
minutes: 8
---

# use, super, self

A module can bring symbols from another module into scope with `use`. You will
typically see something like this at the top of each module:

```rust,editable
use std::collections::HashSet;
use std::process::abort;
```

## Paths

Paths are resolved as follows:

1. As a relative path:
   - `foo` or `self::foo` refers to `foo` in the current module,
   - `super::foo` refers to `foo` in the parent module.

2. As an absolute path:
   - `crate::foo` refers to `foo` in the root of the current crate,
   - `bar::foo` refers to `foo` in the `bar` crate.

<details>

- It is common to "re-export" symbols at a shorter path. For example, the
  top-level `lib.rs` in a crate might have

  ```rust,ignore
  mod storage;

  pub use storage::disk::DiskStorage;
  pub use storage::network::NetworkStorage;
  ```

  making `DiskStorage` and `NetworkStorage` available to other crates with a
  convenient, short path.

- For the most part, only items that appear in a module need to be `use`'d.
  However, a trait must be in scope to call any methods on that trait, even if a
  type implementing that trait is already in scope. For example, to use the
  `read_to_string` method on a type implementing the `Read` trait, you need to
  `use std::io::Read`.

- The `use` statement can have a wildcard: `use std::io::*`. This is discouraged
  because it is not clear which items are imported, and those might change over
  time.

</details>



================================================
FILE: src/modules/solution.md
================================================
# Solution

<!--
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
-->

```ignore
src
├── main.rs
├── widgets
│   ├── button.rs
│   ├── label.rs
│   └── window.rs
└── widgets.rs
```

```rust,ignore
// ---- src/widgets.rs ----
pub use button::Button;
pub use label::Label;
pub use window::Window;

mod button;
mod label;
mod window;

pub trait Widget {
    /// Natural width of `self`.
    fn width(&self) -> usize;

    /// Draw the widget into a buffer.
    fn draw_into(&self, buffer: &mut dyn std::fmt::Write);

    /// Draw the widget on standard output.
    fn draw(&self) {
        let mut buffer = String::new();
        self.draw_into(&mut buffer);
        println!("{buffer}");
    }
}
```

```rust,ignore
// ---- src/widgets/label.rs ----
use super::Widget;

pub struct Label {
    label: String,
}

impl Label {
    pub fn new(label: &str) -> Label {
        Label { label: label.to_owned() }
    }
}

impl Widget for Label {
    fn width(&self) -> usize {
        // ANCHOR_END: Label-width
        self.label.lines().map(|line| line.chars().count()).max().unwrap_or(0)
    }

    // ANCHOR: Label-draw_into
    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {
        // ANCHOR_END: Label-draw_into
        writeln!(buffer, "{}", &self.label).unwrap();
    }
}
```

```rust,ignore
// ---- src/widgets/button.rs ----
use super::{Label, Widget};

pub struct Button {
    label: Label,
}

impl Button {
    pub fn new(label: &str) -> Button {
        Button { label: Label::new(label) }
    }
}

impl Widget for Button {
    fn width(&self) -> usize {
        // ANCHOR_END: Button-width
        self.label.width() + 8 // add a bit of padding
    }

    // ANCHOR: Button-draw_into
    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {
        // ANCHOR_END: Button-draw_into
        let width = self.width();
        let mut label = String::new();
        self.label.draw_into(&mut label);

        writeln!(buffer, "+{:-<width$}+", "").unwrap();
        for line in label.lines() {
            writeln!(buffer, "|{:^width$}|", &line).unwrap();
        }
        writeln!(buffer, "+{:-<width$}+", "").unwrap();
    }
}
```

```rust,ignore
// ---- src/widgets/window.rs ----
use super::Widget;

pub struct Window {
    title: String,
    widgets: Vec<Box<dyn Widget>>,
}

impl Window {
    pub fn new(title: &str) -> Window {
        Window { title: title.to_owned(), widgets: Vec::new() }
    }

    pub fn add_widget(&mut self, widget: Box<dyn Widget>) {
        self.widgets.push(widget);
    }

    fn inner_width(&self) -> usize {
        std::cmp::max(
            self.title.chars().count(),
            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),
        )
    }
}

impl Widget for Window {
    fn width(&self) -> usize {
        // ANCHOR_END: Window-width
        // Add 4 paddings for borders
        self.inner_width() + 4
    }

    // ANCHOR: Window-draw_into
    fn draw_into(&self, buffer: &mut dyn std::fmt::Write) {
        // ANCHOR_END: Window-draw_into
        let mut inner = String::new();
        for widget in &self.widgets {
            widget.draw_into(&mut inner);
        }

        let inner_width = self.inner_width();

        // TODO: after learning about error handling, you can change
        // draw_into to return Result<(), std::fmt::Error>. Then use
        // the ?-operator here instead of .unwrap().
        writeln!(buffer, "+-{:-<inner_width$}-+", "").unwrap();
        writeln!(buffer, "| {:^inner_width$} |", &self.title).unwrap();
        writeln!(buffer, "+={:=<inner_width$}=+", "").unwrap();
        for line in inner.lines() {
            writeln!(buffer, "| {:inner_width$} |", line).unwrap();
        }
        writeln!(buffer, "+-{:-<inner_width$}-+", "").unwrap();
    }
}
```

```rust,ignore
// ---- src/main.rs ----
mod widgets;

use widgets::{Button, Label, Widget, Window};

fn main() {
    let mut window = Window::new("Rust GUI Demo 1.23");
    window.add_widget(Box::new(Label::new("This is a small text GUI demo.")));
    window.add_widget(Box::new(Button::new("Click me!")));
    window.draw();
}
```



================================================
FILE: src/modules/visibility.md
================================================
---
minutes: 5
---

# Visibility

Modules are a privacy boundary:

- Module items are private by default (hides implementation details).
- Parent and sibling items are always visible.
- In other words, if an item is visible in module `foo`, it's visible in all the
  descendants of `foo`.

```rust,editable
mod outer {
    fn private() {
        println!("outer::private");
    }

    pub fn public() {
        println!("outer::public");
    }

    mod inner {
        fn private() {
            println!("outer::inner::private");
        }

        pub fn public() {
            println!("outer::inner::public");
            super::private();
        }
    }
}

fn main() {
    outer::public();
}
```

<details>

- Use the `pub` keyword to make modules public.

Additionally, there are advanced `pub(...)` specifiers to restrict the scope of
public visibility.

- See the
  [Rust Reference](https://doc.rust-lang.org/reference/visibility-and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself).
- Configuring `pub(crate)` visibility is a common pattern.
- Less commonly, you can give visibility to a specific path.
- In any case, visibility must be granted to an ancestor module (and all of its
  descendants).

</details>



================================================
FILE: src/pattern-matching/Cargo.toml
================================================
[package]
name = "pattern-matching"
version = "0.1.0"
edition = "2024"
publish = false

[lib]
name = "eval"
path = "exercise.rs"



================================================
FILE: src/pattern-matching/destructuring-enums.md
================================================
---
minutes: 4
---

# Enums

Like tuples, enums can also be destructured by matching:

Patterns can also be used to bind variables to parts of your values. This is how
you inspect the structure of your types. Let us start with a simple `enum` type:

```rust,editable
enum Result {
    Ok(i32),
    Err(String),
}

fn divide_in_two(n: i32) -> Result {
    if n % 2 == 0 {
        Result::Ok(n / 2)
    } else {
        Result::Err(format!("cannot divide {n} into two equal parts"))
    }
}

fn main() {
    let n = 100;
    match divide_in_two(n) {
        Result::Ok(half) => println!("{n} divided in two is {half}"),
        Result::Err(msg) => println!("sorry, an error happened: {msg}"),
    }
}
```

Here we have used the arms to _destructure_ the `Result` value. In the first
arm, `half` is bound to the value inside the `Ok` variant. In the second arm,
`msg` is bound to the error message.

<details>

- The `if`/`else` expression is returning an enum that is later unpacked with a
  `match`.
- You can try adding a third variant to the enum definition and displaying the
  errors when running the code. Point out the places where your code is now
  inexhaustive and how the compiler tries to give you hints.
- The values in the enum variants can only be accessed after being pattern
  matched.
- Demonstrate what happens when the search is inexhaustive. Note the advantage
  the Rust compiler provides by confirming when all cases are handled.
- Demonstrate the syntax for a struct-style variant by adding one to the enum
  definition and the `match`. Point out how this is syntactically similar to
  matching on a struct.

</details>



================================================
FILE: src/pattern-matching/destructuring-structs.md
================================================
---
minutes: 4
---

# Structs

Like tuples, structs can also be destructured by matching:

```rust,editable
{{#include ../../third_party/rust-by-example/destructuring-structs.rs}}
```

<details>

- Change the literal values in `foo` to match with the other patterns.
- Add a new field to `Foo` and make changes to the pattern as needed.

## More to Explore

- Try `match &foo` and check the type of captures. The pattern syntax remains
  the same, but the captures become shared references. This is
  [match ergonomics](https://rust-lang.github.io/rfcs/2005-match-ergonomics.html)
  and is often useful with `match self` when implementing methods on an enum.
  - The same effect occurs with `match &mut foo`: the captures become exclusive
    references.
- The distinction between a capture and a constant expression can be hard to
  spot. Try changing the `2` in the first arm to a variable, and see that it
  subtly doesn't work. Change it to a `const` and see it working again.

</details>



================================================
FILE: src/pattern-matching/exercise.md
================================================
---
minutes: 15
---

# Exercise: Expression Evaluation

Let's write a simple recursive evaluator for arithmetic expressions.

An example of a small arithmetic expression could be `10 + 20`, which evaluates
to `30`. We can represent the expression as a tree:

<!-- mdbook-xgettext: skip -->

```bob
            .-------.
    .------ |   +   | ------.
    |       '-------'       |
    v                       v
.--------.              .--------.
|   10   |              |   20   |
'--------'              '--------'
```

A bigger and more complex expression would be `(10 * 9) + ((3 - 4) * 5)`, which
evaluates to `85`. We represent this as a much bigger tree:

<!-- mdbook-xgettext: skip -->

```bob
                              .-----.
            .---------------- |  +  | ----------------.
            |                 '-----'                 |
            v                                         v
         .-----.                                   .-----.
   .---- |  *  | ----.                       .---- |  *  | ----.
   |     '-----'     |                       |     '-----'     |
   v                 v                       v                 v
.------.          .-----.                 .-----.           .-----.
|  10  |          |  9  |           .---- |  "-"| ----.     |  5  |
'------'          '-----'           |     '-----'     |     '-----'
                                    v                 v
                                 .-----.           .-----.
                                 |  3  |           |  4  |
                                 '-----'           '-----'
```

In code, we will represent the tree with two types:

```rust,editable
{{#include exercise.rs:Operation}}

{{#include exercise.rs:Expression}}
```

The `Box` type here is a smart pointer, and will be covered in detail later in
the course. An expression can be "boxed" with `Box::new` as seen in the tests.
To evaluate a boxed expression, use the deref operator (`*`) to "unbox" it:
`eval(*boxed_expr)`.

Copy and paste the code into the Rust playground, and begin implementing `eval`.
The final product should pass the tests. It may be helpful to use `todo!()` and
get the tests to pass one-by-one. You can also skip a test temporarily with
`#[ignore]`:

```none
#[test]
#[ignore]
fn test_value() { .. }
```

```rust,editable
{{#include exercise.rs:Operation}}

{{#include exercise.rs:Expression}}

{{#include exercise.rs:eval}}
    todo!()
}

{{#include exercise.rs:tests}}
```



================================================
FILE: src/pattern-matching/exercise.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![allow(dead_code)]
// ANCHOR: solution
// ANCHOR: Operation
/// An operation to perform on two subexpressions.
#[derive(Debug)]
enum Operation {
    Add,
    Sub,
    Mul,
    Div,
}
// ANCHOR_END: Operation

// ANCHOR: Expression
/// An expression, in tree form.
#[derive(Debug)]
enum Expression {
    /// An operation on two subexpressions.
    Op { op: Operation, left: Box<Expression>, right: Box<Expression> },

    /// A literal value
    Value(i64),
}
// ANCHOR_END: Expression

// ANCHOR: eval
fn eval(e: Expression) -> i64 {
    // ANCHOR_END: eval
    match e {
        Expression::Op { op, left, right } => {
            let left = eval(*left);
            let right = eval(*right);
            match op {
                Operation::Add => left + right,
                Operation::Sub => left - right,
                Operation::Mul => left * right,
                Operation::Div => left / right,
            }
        }
        Expression::Value(v) => v,
    }
}

// ANCHOR: tests
#[test]
fn test_value() {
    assert_eq!(eval(Expression::Value(19)), 19);
}

#[test]
fn test_sum() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(Expression::Value(10)),
            right: Box::new(Expression::Value(20)),
        }),
        30
    );
}

#[test]
fn test_recursion() {
    let term1 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Value(10)),
        right: Box::new(Expression::Value(9)),
    };
    let term2 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Op {
            op: Operation::Sub,
            left: Box::new(Expression::Value(3)),
            right: Box::new(Expression::Value(4)),
        }),
        right: Box::new(Expression::Value(5)),
    };
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(term1),
            right: Box::new(term2),
        }),
        85
    );
}

#[test]
fn test_zeros() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(Expression::Value(0)),
            right: Box::new(Expression::Value(0))
        }),
        0
    );
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Mul,
            left: Box::new(Expression::Value(0)),
            right: Box::new(Expression::Value(0))
        }),
        0
    );
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Sub,
            left: Box::new(Expression::Value(0)),
            right: Box::new(Expression::Value(0))
        }),
        0
    );
}

#[test]
fn test_div() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Div,
            left: Box::new(Expression::Value(10)),
            right: Box::new(Expression::Value(2)),
        }),
        5
    )
}
// ANCHOR_END: tests



================================================
FILE: src/pattern-matching/infallible.md
================================================
---
minutes: 5
---

# Irrefutable Patterns

In day 1 we briefly saw how patterns can be used to _destructure_ compound
values. Let's review that and talk about a few other things patterns can
express:

```rust,editable
fn takes_tuple(tuple: (char, i32, bool)) {
    let a = tuple.0;
    let b = tuple.1;
    let c = tuple.2;

    // This does the same thing as above.
    let (a, b, c) = tuple;

    // Ignore the first element, only bind the second and third.
    let (_, b, c) = tuple;

    // Ignore everything but the last element.
    let (.., c) = tuple;
}

fn main() {
    takes_tuple(('a', 777, true));
}
```

<details>

- All of the demonstrated patterns are _irrefutable_, meaning that they will
  always match the value on the right hand side.

- Patterns are type-specific, including irrefutable patterns. Try adding or
  removing an element to the tuple and look at the resulting compiler errors.

- Variable names are patterns that always match and bind the matched value into
  a new variable with that name.

- `_` is a pattern that always matches any value, discarding the matched value.

- `..` allows you to ignore multiple values at once.

## More to Explore

- You can also demonstrate more advanced usages of `..`, such as ignoring the
  middle elements of a tuple.

  ```rust
  fn takes_tuple(tuple: (char, i32, bool, u8)) {
      let (first, .., last) = tuple;
  }
  ```

- All of these patterns work with arrays as well:

  ```rust
  fn takes_array(array: [u8; 5]) {
      let [first, .., last] = array;
  }
  ```

</details>



================================================
FILE: src/pattern-matching/let-control-flow.md
================================================
---
minutes: 10
---

# Let Control Flow

Rust has a few control flow constructs that differ from other languages. They
are used for pattern matching:

- `if let` expressions
- `while let` expressions
- `let else` expressions



================================================
FILE: src/pattern-matching/match.md
================================================
---
minutes: 10
---

# Matching Values

The `match` keyword lets you match a value against one or more _patterns_. The
patterns can be simple values, similarly to `switch` in C and C++, but they can
also be used to express more complex conditions:

```rust,editable
#[rustfmt::skip]
fn main() {
    let input = 'x';
    match input {
        'q'                       => println!("Quitting"),
        'a' | 's' | 'w' | 'd'     => println!("Moving around"),
        '0'..='9'                 => println!("Number input"),
        key if key.is_lowercase() => println!("Lowercase: {key}"),
        _                         => println!("Something else"),
    }
}
```

A variable in the pattern (`key` in this example) will create a binding that can
be used within the match arm. We will learn more about this on the next slide.

A match guard causes the arm to match only if the condition is true. If the
condition is false the match will continue checking later cases.

<details>

Key Points:

- You might point out how some specific characters are being used when in a
  pattern
  - `|` as an `or`
  - `..` matches any number of items
  - `1..=5` represents an inclusive range
  - `_` is a wild card

- Match guards as a separate syntax feature are important and necessary when we
  wish to concisely express more complex ideas than patterns alone would allow.
- Match guards are different from `if` expressions after the `=>`. An `if`
  expression is evaluated after the match arm is selected. Failing the `if`
  condition inside of that block won't result in other arms of the original
  `match` expression being considered. In the following example, the wildcard
  pattern `_ =>` is never even attempted.

```rust,editable
#[rustfmt::skip]
fn main() {
    let input = 'a';
    match input {
        key if key.is_uppercase() => println!("Uppercase"),
        key => if input == 'q' { println!("Quitting") },
        _   => println!("Bug: this is never printed"),
    }
}
```

- The condition defined in the guard applies to every expression in a pattern
  with an `|`.
- Note that you can't use an existing variable as the condition in a match arm,
  as it will instead be interpreted as a variable name pattern, which creates a
  new variable that will shadow the existing one. For example:
  ```rust
  let expected = 5;
  match 123 {
      expected => println!("Expected value is 5, actual is {expected}"),
      _ => println!("Value was something else"),
  }
  ```
  Here we're trying to match on the number 123, where we want the first case to
  check if the value is 5. The naive expectation is that the first case won't
  match because the value isn't 5, but instead this is interpreted as a variable
  pattern which always matches, meaning the first branch will always be taken.
  If a constant is used instead this will then work as expected.

# More To Explore

- Another piece of pattern syntax you can show students is the `@` syntax which
  binds a part of a pattern to a variable. For example:

  ```rust
  let opt = Some(123);
  match opt {
      outer @ Some(inner) => {
          println!("outer: {outer:?}, inner: {inner}");
      }
      None => {}
  }
  ```

  In this example `inner` has the value 123 which it pulled from the `Option`
  via destructuring, `outer` captures the entire `Some(inner)` expression, so it
  contains the full `Option::Some(123)`. This is rarely used but can be useful
  in more complex patterns.

</details>



================================================
FILE: src/pattern-matching/solution.md
================================================
# Solution

```rust,editable
{{#include exercise.rs:solution}}
```



================================================
FILE: src/pattern-matching/let-control-flow/if-let.md
================================================
# `if let` Expressions

The
[`if let` expression](https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions)
lets you execute different code depending on whether a value matches a pattern:

```rust,editable
use std::time::Duration;

fn sleep_for(secs: f32) {
    let result = Duration::try_from_secs_f32(secs);

    if let Ok(duration) = result {
        std::thread::sleep(duration);
        println!("slept for {duration:?}");
    }
}

fn main() {
    sleep_for(-10.0);
    sleep_for(0.8);
}
```

<details>

- Unlike `match`, `if let` does not have to cover all branches. This can make it
  more concise than `match`.
- A common usage is handling `Some` values when working with `Option`.
- Unlike `match`, `if let` does not support guard clauses for pattern matching.
- With an `else` clause, this can be used as an expression.

</details>



================================================
FILE: src/pattern-matching/let-control-flow/let-else.md
================================================
# `let else` Statements

For the common case of matching a pattern and returning from the function, use
[`let else`](https://doc.rust-lang.org/rust-by-example/flow_control/let_else.html).
The "else" case must diverge (`return`, `break`, or panic - anything but falling
off the end of the block).

```rust,editable
fn hex_or_die_trying(maybe_string: Option<String>) -> Result<u32, String> {
    let s = if let Some(s) = maybe_string {
        s
    } else {
        return Err(String::from("got None"));
    };

    let first_byte_char = if let Some(first) = s.chars().next() {
        first
    } else {
        return Err(String::from("got empty string"));
    };

    let digit = if let Some(digit) = first_byte_char.to_digit(16) {
        digit
    } else {
        return Err(String::from("not a hex digit"));
    };

    Ok(digit)
}

fn main() {
    println!("result: {:?}", hex_or_die_trying(Some(String::from("foo"))));
}
```

<details>
The rewritten version is:

```rust
fn hex_or_die_trying(maybe_string: Option<String>) -> Result<u32, String> {
    let Some(s) = maybe_string else {
        return Err(String::from("got None"));
    };

    let Some(first_byte_char) = s.chars().next() else {
        return Err(String::from("got empty string"));
    };

    let Some(digit) = first_byte_char.to_digit(16) else {
        return Err(String::from("not a hex digit"));
    };

    Ok(digit)
}
```

## More to Explore

- This early return-based control flow is common in Rust error handling code,
  where you try to get a value out of a `Result`, returning an error if the
  `Result` was `Err`.
- If students ask, you can also demonstrate how real error handling code would
  be written with `?`.

</details>



================================================
FILE: src/pattern-matching/let-control-flow/while-let.md
================================================
# `while let` Statements

Like with `if let`, there is a
[`while let`](https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops)
variant that repeatedly tests a value against a pattern:

```rust,editable
fn main() {
    let mut name = String::from("Comprehensive Rust 🦀");
    while let Some(c) = name.pop() {
        dbg!(c);
    }
    // (There are more efficient ways to reverse a string!)
}
```

Here
[`String::pop`](https://doc.rust-lang.org/stable/std/string/struct.String.html#method.pop)
returns `Some(c)` until the string is empty, after which it will return `None`.
The `while let` lets us keep iterating through all items.

<details>

- Point out that the `while let` loop will keep going as long as the value
  matches the pattern.
- You could rewrite the `while let` loop as an infinite loop with an if
  statement that breaks when there is no value to unwrap for `name.pop()`. The
  `while let` provides syntactic sugar for the above scenario.
- This form cannot be used as an expression, because it may have no value if the
  condition is false.

</details>



================================================
FILE: src/references/Cargo.toml
================================================
[package]
name = "references"
version = "0.1.0"
edition = "2024"
publish = false

[[bin]]
name = "references"
path = "exercise.rs"



================================================
FILE: src/references/dangling.md
================================================
---
minutes: 3
---

# Reference Validity

Rust enforces a number of rules for references that make them always safe to
use. One rule is that references can never be `null`, making them safe to use
without `null` checks. The other rule we'll look at for now is that references
can't _outlive_ the data they point to.

```rust,editable,compile_fail
fn main() {
    let x_ref = {
        let x = 10;
        &x
    };
    dbg!(x_ref);
}
```

<details>

- This slide gets students thinking about references as not simply being
  pointers, since Rust has different rules for references than other languages.

- We'll look at the rest of Rust's borrowing rules on day 3 when we talk about
  Rust's ownership system.

## More to Explore

- Rust's equivalent of nullability is the `Option` type, which can be used to
  make any type "nullable" (not just references/pointers). We haven't yet
  introduced enums or pattern matching, though, so try not to go into too much
  detail about this here.

</details>



================================================
FILE: src/references/exclusive.md
================================================
---
minutes: 5
---

# Exclusive References

Exclusive references, also known as mutable references, allow changing the value
they refer to. They have type `&mut T`.

<!-- mdbook-xgettext: skip -->

```rust,editable
fn main() {
    let mut point = (1, 2);
    let x_coord = &mut point.0;
    *x_coord = 20;
    println!("point: {point:?}");
}
```

<details>

Key points:

- "Exclusive" means that only this reference can be used to access the value. No
  other references (shared or exclusive) can exist at the same time, and the
  referenced value cannot be accessed while the exclusive reference exists. Try
  making an `&point.0` or changing `point.0` while `x_coord` is alive.

- Be sure to note the difference between `let mut x_coord: &i32` and
  `let x_coord: &mut i32`. The first one is a shared reference that can be bound
  to different values, while the second is an exclusive reference to a mutable
  value.

</details>



================================================
FILE: src/references/exercise.md
================================================
---
minutes: 20
---

# Exercise: Geometry

We will create a few utility functions for 3-dimensional geometry, representing
a point as `[f64;3]`. It is up to you to determine the function signatures.

```rust,compile_fail,editable
// Calculate the magnitude of a vector by summing the squares of its coordinates
// and taking the square root. Use the `sqrt()` method to calculate the square
// root, like `v.sqrt()`.

{{#include exercise.rs:magnitude}}
fn magnitude(...) -> f64 {
    todo!()
}

// Normalize a vector by calculating its magnitude and dividing all of its
// coordinates by that magnitude.

{{#include exercise.rs:normalize}}
fn normalize(...) {
    todo!()
}

// Use the following `main` to test your work.

{{#include exercise.rs:main}}
```



================================================
FILE: src/references/exercise.rs
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: solution
/// Calculate the magnitude of the given vector.
fn magnitude(vector: &[f64; 3]) -> f64 {
    let mut mag_squared = 0.0;
    for coord in vector {
        mag_squared += coord * coord;
    }
    mag_squared.sqrt()
}

/// Change the magnitude of the vector to 1.0 without changing its direction.
fn normalize(vector: &mut [f64; 3]) {
    let mag = magnitude(vector);
    for item in vector {
        *item /= mag;
    }
}

// ANCHOR: main
fn main() {
    println!("Magnitude of a unit vector: {}", magnitude(&[0.0, 1.0, 0.0]));

    let mut v = [1.0, 2.0, 9.0];
    println!("Magnitude of {v:?}: {}", magnitude(&v));
    normalize(&mut v);
    println!("Magnitude of {v:?} after normalization: {}", magnitude(&v));
}
// ANCHOR_END: main



================================================
FILE: src/references/shared.md
================================================
---
minutes: 7
---

# Shared References

A reference provides a way to access another value without taking ownership of
the value, and is also called "borrowing". Shared references are read-only, and
the referenced data cannot change.

```rust,editable
fn main() {
    let a = 'A';
    let b = 'B';

    let mut r: &char = &a;
    dbg!(r);

    r = &b;
    dbg!(r);
}
```

A shared reference to a type `T` has type `&T`. A reference value is made with
the `&` operator. The `*` operator "dereferences" a reference, yielding its
value.

<details>

- References can never be null in Rust, so null checking is not necessary.

- A reference is said to "borrow" the value it refers to, and this is a good
  model for students not familiar with pointers: code can use the reference to
  access the value, but is still "owned" by the original variable. The course
  will get into more detail on ownership in day 3.

- References are implemented as pointers, and a key advantage is that they can
  be much smaller than the thing they point to. Students familiar with C or C++
  will recognize references as pointers. Later parts of the course will cover
  how Rust prevents the memory-safety bugs that come from using raw pointers.

- Explicit referencing with `&` is usually required. However, Rust performs
  automatic referencing and dereferencing when invoking methods.

- Rust will auto-dereference in some cases, in particular when invoking methods
  (try `r.is_ascii()`). There is no need for an `->` operator like in C++.

- In this example, `r` is mutable so that it can be reassigned (`r = &b`). Note
  that this re-binds `r`, so that it refers to something else. This is different
  from C++, where assignment to a reference changes the referenced value.

- A shared reference does not allow modifying the value it refers to, even if
  that value was mutable. Try `*r = 'X'`.

- Rust is tracking the lifetimes of all references to ensure they live long
  enough. Dangling references cannot occur in safe Rust.

- We will talk more about borrowing and preventing dangling references when we
  get to ownership.

</details>



================================================
FILE: src/references/slices.md
================================================
---
minutes: 7
---

# Slices

A slice gives you a view into a larger collection:

<!-- mdbook-xgettext: skip -->

```rust,editable
fn main() {
    let a: [i32; 6] = [10, 20, 30, 40, 50, 60];
    println!("a: {a:?}");

    let s: &[i32] = &a[2..4];

    println!("s: {s:?}");
}
```

- Slices borrow data from the sliced type.

<details>

- We create a slice by borrowing `a` and specifying the starting and ending
  indexes in brackets.

- If the slice starts at index 0, Rust’s range syntax allows us to drop the
  starting index, meaning that `&a[0..a.len()]` and `&a[..a.len()]` are
  identical.

- The same is true for the last index, so `&a[2..a.len()]` and `&a[2..]` are
  identical.

- To easily create a slice of the full array, we can therefore use `&a[..]`.

- `s` is a reference to a slice of `i32`s. Notice that the type of `s`
  (`&[i32]`) no longer mentions the array length. This allows us to perform
  computation on slices of different sizes.

- Slices always borrow from another object. In this example, `a` has to remain
  'alive' (in scope) for at least as long as our slice.

- You can't "grow" a slice once it's created:
  - You can't append elements of the slice, since it doesn't own the backing
    buffer.
  - You can't grow a slice to point to a larger section of the backing buffer. A
    slice does not have information about the length of the underlying buffer
    and so you can't know how large the slice can be grown.
  - To get a larger slice you have to back to the original buffer and create a
    larger slice from there.

</details>



================================================
FILE: src/references/solution.md
================================================
# Solution

```rust,editable
{{#include exercise.rs:solution}}
```

<details>

- Note that in `normalize` we were able to do `*item /= mag` to modify each
  element. This is because we're iterating using a mutable reference to an
  array, which causes the `for` loop to give mutable references to each element.

- It is also possible to take slice references here, e.g.,
  `fn
  magnitude(vector: &[f64]) -> f64`. This makes the function more general,
  at the cost of a runtime length check.

</details>



================================================
FILE: src/references/strings.md
================================================
---
minutes: 10
---

<!-- NOTES:
Including `&str` as a way of representing a slice of valid utf-8
-->

# Strings

We can now understand the two string types in Rust:

- `&str` is a slice of UTF-8 encoded bytes, similar to `&[u8]`.
- `String` is an owned buffer of UTF-8 encoded bytes, similar to `Vec<T>`.

<!-- Avoid using fixed integers when slicing since this breaks
translations. Using the length of s1 and s2 is safe. -->

```rust,editable
fn main() {
    let s1: &str = "World";
    println!("s1: {s1}");

    let mut s2: String = String::from("Hello ");
    println!("s2: {s2}");

    s2.push_str(s1);
    println!("s2: {s2}");

    let s3: &str = &s2[2..9];
    println!("s3: {s3}");
}
```

<details>

- `&str` introduces a string slice, which is an immutable reference to UTF-8
  encoded string data stored in a block of memory. String literals (`"Hello"`),
  are stored in the program’s binary.

- Rust's `String` type is a wrapper around a vector of bytes. As with a
  `Vec<T>`, it is owned.

- As with many other types `String::from()` creates a string from a string
  literal; `String::new()` creates a new empty string, to which string data can
  be added using the `push()` and `push_str()` methods.

- The `format!()` macro is a convenient way to generate an owned string from
  dynamic values. It accepts the same format specification as `println!()`.

- You can borrow `&str` slices from `String` via `&` and optionally range
  selection. If you select a byte range that is not aligned to character
  boundaries, the expression will panic. The `chars` iterator iterates over
  characters and is preferred over trying to get character boundaries right.

- For C++ programmers: think of `&str` as `std::string_view` from C++, but the
  one that always points to a valid string in memory. Rust `String` is a rough
  equivalent of `std::string` from C++ (main difference: it can only contain
  UTF-8 encoded bytes and will never use a small-string optimization).

- Byte strings literals allow you to create a `&[u8]` value directly:

  <!-- mdbook-xgettext: skip -->
  ```rust,editable
  fn main() {
      println!("{:?}", b"abc");
      println!("{:?}", &[97, 98, 99]);
  }
  ```

- Raw strings allow you to create a `&str` value with escapes disabled:
  `r"\n" == "\\n"`. You can embed double-quotes by using an equal amount of `#`
  on either side of the quotes:

  <!-- mdbook-xgettext: skip -->
  ```rust,editable
  fn main() {
      println!(r#"<a href="link.html">link</a>"#);
      println!("<a href=\"link.html\">link</a>");
  }
  ```

</details>



================================================
FILE: src/running-the-course/course-structure.md
================================================
# Course Structure

> This page is for the course instructor.

## Rust Fundamentals

The first four days make up [Rust Fundamentals](../welcome-day-1.md). The days
are fast-paced and we cover a lot of ground!

{{%course outline Fundamentals}}

## Deep Dives

In addition to the 4-day class on Rust Fundamentals, we cover some more
specialized topics:

### Rust in Android

The [Rust in Android](../android.md) deep dive is a half-day course on using
Rust for Android platform development. This includes interoperability with C,
C++, and Java.

You will need an [AOSP checkout][1]. Make a checkout of the
[course repository][2] on the same machine and move the `src/android/` directory
into the root of your AOSP checkout. This will ensure that the Android build
system sees the `Android.bp` files in `src/android/`.

Ensure that `adb sync` works with your emulator or real device and pre-build all
Android examples using `src/android/build_all.sh`. Read the script to see the
commands it runs and make sure they work when you run them by hand.

[1]: https://source.android.com/docs/setup/download/downloading
[2]: https://github.com/google/comprehensive-rust

### Rust in Chromium

The [Rust in Chromium](../chromium.md) deep dive is a half-day course on using
Rust as part of the Chromium browser. It includes using Rust in Chromium's `gn`
build system, bringing in third-party libraries ("crates") and C++
interoperability.

You will need to be able to build Chromium --- a debug, component build is
[recommended](../chromium/setup.md) for speed but any build will work. Ensure
that you can run the Chromium browser that you've built.

### Bare-Metal Rust

The [Bare-Metal Rust](../bare-metal.md) deep dive is a full day class on using
Rust for bare-metal (embedded) development. Both microcontrollers and
application processors are covered.

For the microcontroller part, you will need to buy the
[BBC micro:bit](https://microbit.org/) v2 development board ahead of time.
Everybody will need to install a number of packages as described on the
[welcome page](../bare-metal.md).

### Concurrency in Rust

The [Concurrency in Rust](../concurrency/welcome.md) deep dive is a full day
class on classical as well as `async`/`await` concurrency.

You will need a fresh crate set up and the dependencies downloaded and ready to
go. You can then copy/paste the examples into `src/main.rs` to experiment with
them:

```shell
cargo init concurrency
cd concurrency
cargo add tokio --features full
cargo run
```

{{%course outline Concurrency}}

### Idiomatic Rust

The [Idiomatic Rust](../idiomatic/welcome.md) deep dive is a 2-day class on Rust
idioms and patterns.

You should be familiar with the material in
[Rust Fundamentals](../welcome-day-1.md) before starting this course.

{{%course outline Idiomatic Rust}}

### Unsafe (Work in Progress)

The [Unsafe](../unsafe-deep-dive/welcome.md) deep dive is a two-day class on the
_unsafe_ Rust language. It covers the fundamentals of Rust's safety guarantees,
the motivation for `unsafe`, review process for `unsafe` code, FFI basics, and
building data structures that the borrow checker would normally reject.

{{%course outline Unsafe}}

## Format

The course is meant to be very interactive and we recommend letting the
questions drive the exploration of Rust!



================================================
FILE: src/running-the-course/keyboard-shortcuts.md
================================================
# Keyboard Shortcuts

There are several useful keyboard shortcuts in mdBook:

- <kbd>Arrow-Left</kbd>: Navigate to the previous page.
- <kbd>Arrow-Right</kbd>: Navigate to the next page.
- <kbd>Ctrl</kbd> + <kbd>Enter</kbd>: Execute the code sample that has focus.
- <kbd>s</kbd>: Activate the search bar.

<details>

- Mention that these shortcuts are standard for `mdbook` and can be useful when
  navigating any `mdbook`-generated site.
- You can demonstrate each shortcut live to the students.
- The <kbd>s</kbd> key for search is particularly useful for quickly finding
  topics that have been discussed earlier.
- <kbd>Ctrl</kbd> + <kbd>Enter</kbd> will be super important for you since
  you'll do a lot of live coding.

</details>



================================================
FILE: src/running-the-course/translations.md
================================================
# Translations

The course has been translated into other languages by a set of wonderful
volunteers:

- [Brazilian Portuguese][pt-BR] by [@rastringer], [@hugojacob],
  [@joaovicmendes], and [@henrif75].
- [Chinese (Simplified)][zh-CN] by [@suetfei], [@wnghl], [@anlunx], [@kongy],
  [@noahdragon], [@superwhd], @SketchK, and [@nodmp].
- [Chinese (Traditional)][zh-TW] by [@hueich], [@victorhsieh], [@mingyc],
  [@kuanhungchen], and [@johnathan79717].
- [Farsi][fa] by [@DannyRavi], [@javad-jafari], [@Alix1383], [@moaminsharifi] ,
  [@hamidrezakp] and [@mehrad77].
- [Japanese][ja] by [@CoinEZ-JPN], [@momotaro1105], [@HidenoriKobayashi] and
  [@kantasv].
- [Korean][ko] by [@keispace], [@jiyongp], [@jooyunghan], and [@namhyung].
- [Spanish][es] by [@deavid].
- [Ukrainian][uk] by [@git-user-cpp], [@yaremam] and [@reta].

Use the language picker in the top-right corner to switch between languages.

## Incomplete Translations

There is a large number of in-progress translations. We link to the most
recently updated translations:

- [Arabic][ar] by [@younies]
- [Bengali][bn] by [@raselmandol].
- [French][fr] by [@KookaS], [@vcaen] and [@AdrienBaudemont].
- [German][de] by [@Throvn] and [@ronaldfw].
- [Italian][it] by [@henrythebuilder] and [@detro].

The full list of translations with their current status is also available either
[as of their last update][translation-report] or
[synced to the latest version of the course][synced-translation-report].

If you want to help with this effort, please see [our instructions] for how to
get going. Translations are coordinated on the [issue tracker].

[ar]: https://google.github.io/comprehensive-rust/ar/
[bn]: https://google.github.io/comprehensive-rust/bn/
[de]: https://google.github.io/comprehensive-rust/de/
[es]: https://google.github.io/comprehensive-rust/es/
[fa]: https://google.github.io/comprehensive-rust/fa/
[fr]: https://google.github.io/comprehensive-rust/fr/
[it]: https://google.github.io/comprehensive-rust/it/
[ja]: https://google.github.io/comprehensive-rust/ja/
[ko]: https://google.github.io/comprehensive-rust/ko/
[pt-BR]: https://google.github.io/comprehensive-rust/pt-BR/
[uk]: https://google.github.io/comprehensive-rust/uk/
[zh-CN]: https://google.github.io/comprehensive-rust/zh-CN/
[zh-TW]: https://google.github.io/comprehensive-rust/zh-TW/
[@AdrienBaudemont]: https://github.com/AdrienBaudemont
[@Alix1383]: https://github.com/alix1383
[@anlunx]: https://github.com/anlunx
[@CoinEZ-JPN]: https://github.com/CoinEZ
[@DannyRavi]: https://github.com/DannyRavi
[@deavid]: https://github.com/deavid
[@detro]: https://github.com/detro
[@git-user-cpp]: https://github.com/git-user-cpp
[@hamidrezakp]: https://github.com/hamidrezakp
[@henrif75]: https://github.com/henrif75
[@henrythebuilder]: https://github.com/henrythebuilder
[@HidenoriKobayashi]: https://github.com/HidenoriKobayashi
[@hueich]: https://github.com/hueich
[@hugojacob]: https://github.com/hugojacob
[@javad-jafari]: https://github.com/javad-jafari
[@jiyongp]: https://github.com/jiyongp
[@joaovicmendes]: https://github.com/joaovicmendes
[@johnathan79717]: https://github.com/johnathan79717
[@jooyunghan]: https://github.com/jooyunghan
[@kantasv]: https://github.com/kantasv
[@keispace]: https://github.com/keispace
[@kongy]: https://github.com/kongy
[@KookaS]: https://github.com/KookaS
[@kuanhungchen]: https://github.com/kuanhungchen
[@mehrad77]: https://github.com/mehrad77
[@mingyc]: https://github.com/mingyc
[@moaminsharifi]: https://github.com/moaminsharifi
[@momotaro1105]: https://github.com/momotaro1105
[@namhyung]: https://github.com/namhyung
[@noahdragon]: https://github.com/noahdragon
[@nodmp]: https://github.com/nodmp
[@raselmandol]: https://github.com/raselmandol
[@rastringer]: https://github.com/rastringer
[@reta]: https://github.com/reta
[@ronaldfw]: https://github.com/ronaldfw
[@suetfei]: https://github.com/suetfei
[@superwhd]: https://github.com/superwhd
[@Throvn]: https://github.com/Throvn
[@vcaen]: https://github.com/vcaen
[@victorhsieh]: https://github.com/victorhsieh
[@wnghl]: https://github.com/wnghl
[@yaremam]: https://github.com/yaremam
[@younies]: https://github.com/younies
[translation-report]: https://google.github.io/comprehensive-rust/translation-report.html
[synced-translation-report]: https://google.github.io/comprehensive-rust/synced-translation-report.html
[our instructions]: https://github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md
[issue tracker]: https://github.com/google/comprehensive-rust/issues/282

<details>

- This is a good opportunity to thank the volunteers who have contributed to the
  translations.
- If there are students in the class who speak any of the listed languages, you
  can encourage them to check out the translated versions and even contribute if
  they find any issues.
- Highlight that the project is open source and contributions are welcome, not
  just for translations but for the course content itself.

</details>



================================================
FILE: src/smart-pointers/box.md
================================================
---
minutes: 8
---

# `Box<T>`

[`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) is an owned pointer
to data on the heap:

```rust,editable
fn main() {
    let five = Box::new(5);
    println!("five: {}", *five);
}
```

```bob
 Stack                     Heap
.- - - - - - -.     .- - - - - - -.
:             :     :             :
:    five     :     :             :
:   +-----+   :     :   +-----+   :
:   | o---|---+-----+-->|  5  |   :
:   +-----+   :     :   +-----+   :
:             :     :             :
:             :     :             :
`- - - - - - -'     `- - - - - - -'
```

`Box<T>` implements `Deref<Target = T>`, which means that you can
[call methods
from `T` directly on a `Box<T>`](https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion).

Recursive data types or data types with dynamic sizes cannot be stored inline
without a pointer indirection. `Box` accomplishes that indirection:

```rust,editable
#[derive(Debug)]
enum List<T> {
    /// A non-empty list: first element and the rest of the list.
    Element(T, Box<List<T>>),
    /// An empty list.
    Nil,
}

fn main() {
    let list: List<i32> =
        List::Element(1, Box::new(List::Element(2, Box::new(List::Nil))));
    println!("{list:?}");
}
```

```bob
 Stack                           Heap
.- - - - - - - - - - - - - - .     .- - - - - - - - - - - - - - - - - - - - - - - - -.
:                            :     :                                                 :
:    list                    :     :                                                 :
:   +---------+----+----+    :     :    +---------+----+----+    +------+----+----+  :
:   | Element | 1  | o--+----+-----+--->| Element | 2  | o--+--->| Nil  | // | // |  :
:   +---------+----+----+    :     :    +---------+----+----+    +------+----+----+  :
:                            :     :                                                 :
:                            :     :                                                 :
'- - - - - - - - - - - - - - '     '- - - - - - - - - - - - - - - - - - - - - - - - -'
```

<details>

- `Box` is like `std::unique_ptr` in C++, except that it's guaranteed to be not
  null.
- A `Box` can be useful when you:
  - have a type whose size can't be known at compile time, but the Rust compiler
    wants to know an exact size.
  - want to transfer ownership of a large amount of data. To avoid copying large
    amounts of data on the stack, instead store the data on the heap in a `Box`
    so only the pointer is moved.

- If `Box` was not used and we attempted to embed a `List` directly into the
  `List`, the compiler would not be able to compute a fixed size for the struct
  in memory (the `List` would be of infinite size).

- `Box` solves this problem as it has the same size as a regular pointer and
  just points at the next element of the `List` in the heap.

- Remove the `Box` in the List definition and show the compiler error. We get
  the message "recursive without indirection", because for data recursion, we
  have to use indirection, a `Box` or reference of some kind, instead of storing
  the value directly.

- Though `Box` looks like `std::unique_ptr` in C++, it cannot be empty/null.
  This makes `Box` one of the types that allow the compiler to optimize storage
  of some enums (the "niche optimization").

</details>



================================================
FILE: src/smart-pointers/Cargo.toml
================================================
[package]
name = "smart-pointers"
version = "0.1.0"
edition = "2024"
publish = false

[lib]
name = "binary_tree"
path = "exercise.rs"



================================================
FILE: src/smart-pointers/exercise.md
================================================
---
minutes: 30
---

# Exercise: Binary Tree

A binary tree is a tree-type data structure where every node has two children
(left and right). We will create a tree where each node stores a value. For a
given node N, all nodes in a N's left subtree contain smaller values, and all
nodes in N's right subtree will contain larger values. A given value should only
be stored in the tree once, i.e. no duplicate nodes.

Implement the following types, so that the given tests pass.

```rust,compile_fail,editable
{{#include exercise.rs:types}}

// Implement `new`, `insert`, `len`, and `has` for `Subtree`.

{{#include exercise.rs:tests}}
```



================================================
FILE: src/smart-pointers/exercise.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
#![allow(dead_code)]

// ANCHOR: solution
use std::cmp::Ordering;

// ANCHOR: types
/// A node in the binary tree.
#[derive(Debug)]
struct Node<T: Ord> {
    value: T,
    left: Subtree<T>,
    right: Subtree<T>,
}

/// A possibly-empty subtree.
#[derive(Debug)]
struct Subtree<T: Ord>(Option<Box<Node<T>>>);

/// A container storing a set of values, using a binary tree.
///
/// If the same value is added multiple times, it is only stored once.
#[derive(Debug)]
pub struct BinaryTree<T: Ord> {
    root: Subtree<T>,
}

impl<T: Ord> BinaryTree<T> {
    fn new() -> Self {
        Self { root: Subtree::new() }
    }

    fn insert(&mut self, value: T) {
        self.root.insert(value);
    }

    fn has(&self, value: &T) -> bool {
        self.root.has(value)
    }

    fn len(&self) -> usize {
        self.root.len()
    }
}
// ANCHOR_END: types

impl<T: Ord> Subtree<T> {
    fn new() -> Self {
        Self(None)
    }

    fn insert(&mut self, value: T) {
        match &mut self.0 {
            None => self.0 = Some(Box::new(Node::new(value))),
            Some(n) => match value.cmp(&n.value) {
                Ordering::Less => n.left.insert(value),
                Ordering::Equal => {}
                Ordering::Greater => n.right.insert(value),
            },
        }
    }

    fn has(&self, value: &T) -> bool {
        match &self.0 {
            None => false,
            Some(n) => match value.cmp(&n.value) {
                Ordering::Less => n.left.has(value),
                Ordering::Equal => true,
                Ordering::Greater => n.right.has(value),
            },
        }
    }

    fn len(&self) -> usize {
        match &self.0 {
            None => 0,
            Some(n) => 1 + n.left.len() + n.right.len(),
        }
    }
}

impl<T: Ord> Node<T> {
    fn new(value: T) -> Self {
        Self { value, left: Subtree::new(), right: Subtree::new() }
    }
}

// ANCHOR: tests
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn len() {
        let mut tree = BinaryTree::new();
        assert_eq!(tree.len(), 0);
        tree.insert(2);
        assert_eq!(tree.len(), 1);
        tree.insert(1);
        assert_eq!(tree.len(), 2);
        tree.insert(2); // not a unique item
        assert_eq!(tree.len(), 2);
        tree.insert(3);
        assert_eq!(tree.len(), 3);
    }

    #[test]
    fn has() {
        let mut tree = BinaryTree::new();
        fn check_has(tree: &BinaryTree<i32>, exp: &[bool]) {
            let got: Vec<bool> =
                (0..exp.len()).map(|i| tree.has(&(i as i32))).collect();
            assert_eq!(&got, exp);
        }

        check_has(&tree, &[false, false, false, false, false]);
        tree.insert(0);
        check_has(&tree, &[true, false, false, false, false]);
        tree.insert(4);
        check_has(&tree, &[true, false, false, false, true]);
        tree.insert(4);
        check_has(&tree, &[true, false, false, false, true]);
        tree.insert(3);
        check_has(&tree, &[true, false, false, true, true]);
    }

    #[test]
    fn unbalanced() {
        let mut tree = BinaryTree::new();
        for i in 0..100 {
            tree.insert(i);
        }
        assert_eq!(tree.len(), 100);
        assert!(tree.has(&50));
    }
}
// ANCHOR_END: tests



================================================
FILE: src/smart-pointers/rc.md
================================================
---
minutes: 5
---

# `Rc`

[`Rc`][1] is a reference-counted shared pointer. Use this when you need to refer
to the same data from multiple places:

```rust,editable
use std::rc::Rc;

fn main() {
    let a = Rc::new(10);
    let b = Rc::clone(&a);

    dbg!(a);
    dbg!(b);
}
```

Each `Rc` points to the same shared data structure, containing strong and weak
pointers and the value:

```bob
 Stack                     Heap
.- - - - - - - -.     .- - - - - - - - - - - - - - - - -.
:               :     :                                 :
:     +-----+   :     :   +-----------+-------------+   :
:  a: | o---|---:--+--:-->|  count: 2 |  value: 10  |   :
:     +-----+   :  |  :   +-----------+-------------+   :
:  b: | o---|---:--+  :                                 :
:     +-----+   :     `- - - - - - - - - - - - - - - - -'
:               :     
`- - - - - - - -'
```

- See [`Arc`][2] and [`Mutex`][3] if you are in a multi-threaded context.
- You can _downgrade_ a shared pointer into a [`Weak`][4] pointer to create
  cycles that will get dropped.

[1]: https://doc.rust-lang.org/std/rc/struct.Rc.html
[2]: ../concurrency/shared-state/arc.md
[3]: https://doc.rust-lang.org/std/sync/struct.Mutex.html
[4]: https://doc.rust-lang.org/std/rc/struct.Weak.html

<details>

- `Rc`'s count ensures that its contained value is valid for as long as there
  are references.
- `Rc` in Rust is like `std::shared_ptr` in C++.
- `Rc::clone` is cheap: it creates a pointer to the same allocation and
  increases the reference count. Does not make a deep clone and can generally be
  ignored when looking for performance issues in code.
- `make_mut` actually clones the inner value if necessary ("clone-on-write") and
  returns a mutable reference.
- Use `Rc::strong_count` to check the reference count.
- `Rc::downgrade` gives you a _weakly reference-counted_ object to create cycles
  that will be dropped properly (likely in combination with `RefCell`).

</details>



================================================
FILE: src/smart-pointers/solution.md
================================================
# Solution

```rust,editable
{{#include exercise.rs:solution}}
```



================================================
FILE: src/smart-pointers/trait-objects.md
================================================
---
minutes: 10
---

# Owned Trait Objects

We previously saw how trait objects can be used with references, e.g `&dyn Pet`.
However, we can also use trait objects with smart pointers like `Box` to create
an owned trait object: `Box<dyn Pet>`.

```rust,editable
struct Dog {
    name: String,
    age: i8,
}
struct Cat {
    lives: i8,
}

trait Pet {
    fn talk(&self) -> String;
}

impl Pet for Dog {
    fn talk(&self) -> String {
        format!("Woof, my name is {}!", self.name)
    }
}

impl Pet for Cat {
    fn talk(&self) -> String {
        String::from("Miau!")
    }
}

fn main() {
    let pets: Vec<Box<dyn Pet>> = vec![
        Box::new(Cat { lives: 9 }),
        Box::new(Dog { name: String::from("Fido"), age: 5 }),
    ];
    for pet in pets {
        println!("Hello, who are you? {}", pet.talk());
    }
}
```

Memory layout after allocating `pets`:

```bob
 Stack                             Heap
.- - - - - - - - - - - - - - - -.     .- - - - - - - - - - - - - - - - - - - - - - -.
:                               :     :                                             :
:    "pets: Vec<Box<dyn Pet>>"  :     :   "data: Cat"         +----+----+----+----+ :
:   +-----------+-------+       :     :  +-------+-------+    | F  | i  | d  | o  | :
:   | ptr       |   o---+-------+--.  :  | lives |     9 |    +----+----+----+----+ :
:   | len       |     2 |       :  |  :  +-------+-------+      ^                   :
:   | capacity  |     2 |       :  |  :       ^                 |                   :
:   +-----------+-------+       :  |  :       |                 '-------.           :
:                               :  |  :       |               data:"Dog"|           :
:                               :  |  :       |              +-------+--|-------+   :
`- - - - - - - - - - - - - - - -'  |  :   +---|-+-----+      | name  |  o, 4, 4 |   :
                                   `--+-->| o o | o o-|----->| age   |        5 |   :
                                      :   +-|---+-|---+      +-------+----------+   :
                                      :     |     |                                 :
                                      `- - -| - - |- - - - - - - - - - - - - - - - -'
                                            |     |
                                            |     |                      "Program text"
                                      .- - -| - - |- - - - - - - - - - - - - - - - -.
                                      :     |     |       vtable                    :
                                      :     |     |      +----------------------+   :
                                      :     |     `----->| "<Dog as Pet>::talk" |   :
                                      :     |            +----------------------+   :
                                      :     |             vtable                    :
                                      :     |            +----------------------+   :
                                      :     '----------->| "<Cat as Pet>::talk" |   :
                                      :                  +----------------------+   :
                                      :                                             :
                                      '- - - - - - - - - - - - - - - - - - - - - - -'
```

<details>

- Types that implement a given trait may be of different sizes. This makes it
  impossible to have things like `Vec<dyn Pet>` in the example above.
- `dyn Pet` is a way to tell the compiler about a dynamically sized type that
  implements `Pet`.
- In the example, `pets` is allocated on the stack and the vector data is on the
  heap. The two vector elements are _fat pointers_:
  - A fat pointer is a double-width pointer. It has two components: a pointer to
    the actual object and a pointer to the [virtual method table] (vtable) for
    the `Pet` implementation of that particular object.
  - The data for the `Dog` named Fido is the `name` and `age` fields. The `Cat`
    has a `lives` field.
- Compare these outputs in the above example:
  ```rust,ignore
  println!("{} {}", std::mem::size_of::<Dog>(), std::mem::size_of::<Cat>());
  println!("{} {}", std::mem::size_of::<&Dog>(), std::mem::size_of::<&Cat>());
  println!("{}", std::mem::size_of::<&dyn Pet>());
  println!("{}", std::mem::size_of::<Box<dyn Pet>>());
  ```

[virtual method table]: https://en.wikipedia.org/wiki/Virtual_method_table

</details>



================================================
FILE: src/std-traits/Cargo.toml
================================================
[package]
name = "std-traits"
version = "0.1.0"
edition = "2024"
publish = false

[lib]
name = "std_traits"
path = "exercise.rs"



================================================
FILE: src/std-traits/casting.md
================================================
---
minutes: 5
---

# Casting

Rust has no _implicit_ type conversions, but does support explicit casts with
`as`. These generally follow C semantics where those are defined.

```rust,editable
fn main() {
    let value: i64 = 1000;
    println!("as u16: {}", value as u16);
    println!("as i16: {}", value as i16);
    println!("as u8: {}", value as u8);
}
```

The results of `as` are _always_ defined in Rust and consistent across
platforms. This might not match your intuition for changing sign or casting to a
smaller type -- check the docs, and comment for clarity.

Casting with `as` is a relatively sharp tool that is easy to use incorrectly,
and can be a source of subtle bugs as future maintenance work changes the types
that are used or the ranges of values in types. Casts are best used only when
the intent is to indicate unconditional truncation (e.g. selecting the bottom 32
bits of a `u64` with `as u32`, regardless of what was in the high bits).

For infallible casts (e.g. `u32` to `u64`), prefer using `From` or `Into` over
`as` to confirm that the cast is in fact infallible. For fallible casts,
`TryFrom` and `TryInto` are available when you want to handle casts that fit
differently from those that don't.

<details>

Consider taking a break after this slide.

`as` is similar to a C++ static cast. Use of `as` in cases where data might be
lost is generally discouraged, or at least deserves an explanatory comment.

This is common in casting integers to `usize` for use as an index.

</details>



================================================
FILE: src/std-traits/comparisons.md
================================================
---
minutes: 5
---

# Comparisons

These traits support comparisons between values. All traits can be derived for
types containing fields that implement these traits.

## `PartialEq` and `Eq`

`PartialEq` is a partial equivalence relation, with required method `eq` and
provided method `ne`. The `==` and `!=` operators will call these methods.

```rust,editable
struct Key {
    id: u32,
    metadata: Option<String>,
}
impl PartialEq for Key {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
```

`Eq` is a full equivalence relation (reflexive, symmetric, and transitive) and
implies `PartialEq`. Functions that require full equivalence will use `Eq` as a
trait bound.

## `PartialOrd` and `Ord`

`PartialOrd` defines a partial ordering, with a `partial_cmp` method. It is used
to implement the `<`, `<=`, `>=`, and `>` operators.

```rust,editable
use std::cmp::Ordering;
#[derive(Eq, PartialEq)]
struct Citation {
    author: String,
    year: u32,
}
impl PartialOrd for Citation {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        match self.author.partial_cmp(&other.author) {
            Some(Ordering::Equal) => self.year.partial_cmp(&other.year),
            author_ord => author_ord,
        }
    }
}
```

`Ord` is a total ordering, with `cmp` returning `Ordering`.

<details>

- `PartialEq` can be implemented between different types, but `Eq` cannot,
  because it is reflexive:

  ```rust,editable
  struct Key {
      id: u32,
      metadata: Option<String>,
  }
  impl PartialEq<u32> for Key {
      fn eq(&self, other: &u32) -> bool {
          self.id == *other
      }
  }
  ```

- In practice, it's common to derive these traits, but uncommon to implement
  them.

- When comparing references in Rust, it will compare the value of the things
  pointed to, it will NOT compare the references themselves. That means that
  references to two different things can compare as equal if the values pointed
  to are the same:

  ```rust,editable
  fn main() {
      let a = "Hello";
      let b = String::from("Hello");
      assert_eq!(a, b);
  }
  ```

</details>



================================================
FILE: src/std-traits/default.md
================================================
---
minutes: 5
---

# The `Default` Trait

The [`Default`][1] trait produces a default value for a type.

```rust,editable
#[derive(Debug, Default)]
struct Derived {
    x: u32,
    y: String,
    z: Implemented,
}

#[derive(Debug)]
struct Implemented(String);

impl Default for Implemented {
    fn default() -> Self {
        Self("John Smith".into())
    }
}

fn main() {
    let default_struct = Derived::default();
    dbg!(default_struct);

    let almost_default_struct =
        Derived { y: "Y is set!".into(), ..Derived::default() };
    dbg!(almost_default_struct);

    let nothing: Option<Derived> = None;
    dbg!(nothing.unwrap_or_default());
}
```

<details>

- It can be implemented directly or it can be derived via `#[derive(Default)]`.
- A derived implementation will produce a value where all fields are set to
  their default values.
  - This means all types in the struct must implement `Default` too.
- Standard Rust types often implement `Default` with reasonable values (e.g.
  `0`, `""`, etc).
- The partial struct initialization works nicely with default.
- The Rust standard library is aware that types can implement `Default` and
  provides convenience methods that use it.
- The `..` syntax is called [struct update syntax][2].

</details>

[1]: https://doc.rust-lang.org/std/default/trait.Default.html
[2]: https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax



================================================
FILE: src/std-traits/exercise.md
================================================
---
minutes: 30
---

# Exercise: ROT13

In this example, you will implement the classic
["ROT13" cipher](https://en.wikipedia.org/wiki/ROT13). Copy this code to the
playground, and implement the missing bits. Only rotate ASCII alphabetic
characters, to ensure the result is still valid UTF-8.

```rust,editable
{{#include exercise.rs:head }}

// Implement the `Read` trait for `RotDecoder`.

{{#include exercise.rs:tests }}
```

What happens if you chain two `RotDecoder` instances together, each rotating by
13 characters?



================================================
FILE: src/std-traits/exercise.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![allow(unused_variables, dead_code)]
// ANCHOR: solution
// ANCHOR: head
use std::io::Read;

struct RotDecoder<R: Read> {
    input: R,
    rot: u8,
}
// ANCHOR_END: head

impl<R: Read> Read for RotDecoder<R> {
    fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
        let size = self.input.read(buf)?;
        for b in &mut buf[..size] {
            if b.is_ascii_alphabetic() {
                let base = if b.is_ascii_uppercase() { 'A' } else { 'a' } as u8;
                *b = (*b - base + self.rot) % 26 + base;
            }
        }
        Ok(size)
    }
}

// ANCHOR: tests
#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn joke() {
        let mut rot =
            RotDecoder { input: "Gb trg gb gur bgure fvqr!".as_bytes(), rot: 13 };
        let mut result = String::new();
        rot.read_to_string(&mut result).unwrap();
        assert_eq!(&result, "To get to the other side!");
    }

    #[test]
    fn binary() {
        let input: Vec<u8> = (0..=255u8).collect();
        let mut rot = RotDecoder::<&[u8]> { input: input.as_slice(), rot: 13 };
        let mut buf = [0u8; 256];
        assert_eq!(rot.read(&mut buf).unwrap(), 256);
        for i in 0..=255 {
            if input[i] != buf[i] {
                assert!(input[i].is_ascii_alphabetic());
                assert!(buf[i].is_ascii_alphabetic());
            }
        }
    }
}
// ANCHOR_END: tests



================================================
FILE: src/std-traits/from-and-into.md
================================================
---
minutes: 5
---

# `From` and `Into`

Types implement [`From`][1] and [`Into`][2] to facilitate type conversions.
Unlike `as`, these traits correspond to lossless, infallible conversions.

```rust,editable
fn main() {
    let s = String::from("hello");
    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);
    let one = i16::from(true);
    let bigger = i32::from(123_i16);
    println!("{s}, {addr}, {one}, {bigger}");
}
```

[`Into`][2] is automatically implemented when [`From`][1] is implemented:

```rust,editable
fn main() {
    let s: String = "hello".into();
    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();
    let one: i16 = true.into();
    let bigger: i32 = 123_i16.into();
    println!("{s}, {addr}, {one}, {bigger}");
}
```

<details>

- That's why it is common to only implement `From`, as your type will get `Into`
  implementation too.
- When declaring a function argument input type like "anything that can be
  converted into a `String`", the rule is opposite, you should use `Into`. Your
  function will accept types that implement `From` and those that _only_
  implement `Into`.

</details>

[1]: https://doc.rust-lang.org/std/convert/trait.From.html
[2]: https://doc.rust-lang.org/std/convert/trait.Into.html



================================================
FILE: src/std-traits/operators.md
================================================
---
minutes: 5
---

# Operators

Operator overloading is implemented via traits in [`std::ops`][1]:

```rust,editable
#[derive(Debug, Copy, Clone)]
struct Point {
    x: i32,
    y: i32,
}

impl std::ops::Add for Point {
    type Output = Self;

    fn add(self, other: Self) -> Self {
        Self { x: self.x + other.x, y: self.y + other.y }
    }
}

fn main() {
    let p1 = Point { x: 10, y: 20 };
    let p2 = Point { x: 100, y: 200 };
    println!("{p1:?} + {p2:?} = {:?}", p1 + p2);
}
```

<details>

Discussion points:

- You could implement `Add` for `&Point`. In which situations is that useful?
  - Answer: `Add:add` consumes `self`. If type `T` for which you are overloading
    the operator is not `Copy`, you should consider overloading the operator for
    `&T` as well. This avoids unnecessary cloning on the call site.
- Why is `Output` an associated type? Could it be made a type parameter of the
  method?
  - Short answer: Function type parameters are controlled by the caller, but
    associated types (like `Output`) are controlled by the implementer of a
    trait.
- You could implement `Add` for two different types, e.g.
  `impl Add<(i32, i32)> for Point` would add a tuple to a `Point`.

The `Not` trait (`!` operator) is notable because it does not convert the
argument to `bool` like the same operator in C-family languages; instead, for
integer types it flips each bit of the number, which, arithmetically, is
equivalent to subtracting the argument from `-1`: `!5 == -6`.

</details>

[1]: https://doc.rust-lang.org/std/ops/index.html



================================================
FILE: src/std-traits/read-and-write.md
================================================
---
minutes: 5
---

# `Read` and `Write`

Using [`Read`][1] and [`BufRead`][2], you can abstract over `u8` sources:

```rust,editable
use std::io::{BufRead, BufReader, Read, Result};

fn count_lines<R: Read>(reader: R) -> usize {
    let buf_reader = BufReader::new(reader);
    buf_reader.lines().count()
}

fn main() -> Result<()> {
    let slice: &[u8] = b"foo\nbar\nbaz\n";
    println!("lines in slice: {}", count_lines(slice));

    let file = std::fs::File::open(std::env::current_exe()?)?;
    println!("lines in file: {}", count_lines(file));
    Ok(())
}
```

Similarly, [`Write`][3] lets you abstract over `u8` sinks:

```rust,editable
use std::io::{Result, Write};

fn log<W: Write>(writer: &mut W, msg: &str) -> Result<()> {
    writer.write_all(msg.as_bytes())?;
    writer.write_all("\n".as_bytes())
}

fn main() -> Result<()> {
    let mut buffer = Vec::new();
    log(&mut buffer, "Hello")?;
    log(&mut buffer, "World")?;
    println!("Logged: {buffer:?}");
    Ok(())
}
```

[1]: https://doc.rust-lang.org/std/io/trait.Read.html
[2]: https://doc.rust-lang.org/std/io/trait.BufRead.html
[3]: https://doc.rust-lang.org/std/io/trait.Write.html



================================================
FILE: src/std-traits/solution.md
================================================
# Solution

```rust,editable
{{#include exercise.rs:solution}}
```



================================================
FILE: src/std-types/Cargo.toml
================================================
[package]
name = "std-types"
version = "0.1.0"
edition = "2024"
publish = false

[[bin]]
name = "hashset"
path = "exercise.rs"



================================================
FILE: src/std-types/docs.md
================================================
---
minutes: 5
---

# Documentation

Rust comes with extensive documentation. For example:

- All of the details about
  [loops](https://doc.rust-lang.org/stable/reference/expressions/loop-expr.html).
- Primitive types like
  [`u8`](https://doc.rust-lang.org/stable/std/primitive.u8.html).
- Standard library types like
  [`Option`](https://doc.rust-lang.org/stable/std/option/enum.Option.html) or
  [`BinaryHeap`](https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html).

Use `rustup doc --std` or <https://std.rs> to view the documentation.

In fact, you can document your own code:

```rust,editable
/// Determine whether the first argument is divisible by the second argument.
///
/// If the second argument is zero, the result is false.
fn is_divisible_by(lhs: u32, rhs: u32) -> bool {
    if rhs == 0 {
        return false;
    }
    lhs % rhs == 0
}
```

The contents are treated as Markdown. All published Rust library crates are
automatically documented at [`docs.rs`](https://docs.rs) using the
[rustdoc](https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html) tool. It is
idiomatic to document all public items in an API using this pattern.

To document an item from inside the item (such as inside a module), use `//!` or
`/*! .. */`, called "inner doc comments":

```rust,editable
//! This module contains functionality relating to divisibility of integers.
```

<details>

- Show students the generated docs for the `rand` crate at
  <https://docs.rs/rand>.

</details>



================================================
FILE: src/std-types/exercise.md
================================================
---
minutes: 20
---

# Exercise: Counter

In this exercise you will take a very simple data structure and make it generic.
It uses a
[`std::collections::HashMap`](https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html)
to keep track of what values have been seen and how many times each one has
appeared.

The initial version of `Counter` is hardcoded to only work for `u32` values.
Make the struct and its methods generic over the type of value being tracked,
that way `Counter` can track any type of value.

If you finish early, try using the
[`entry`](https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html#method.entry)
method to halve the number of hash lookups required to implement the `count`
method.

```rust,compile_fail,editable
use std::collections::HashMap;

/// Counter counts the number of times each value of type T has been seen.
struct Counter {
    values: HashMap<u32, u64>,
}

impl Counter {
    /// Create a new Counter.
    fn new() -> Self {
        Counter {
            values: HashMap::new(),
        }
    }

    /// Count an occurrence of the given value.
    fn count(&mut self, value: u32) {
        if self.values.contains_key(&value) {
            *self.values.get_mut(&value).unwrap() += 1;
        } else {
            self.values.insert(value, 1);
        }
    }

    /// Return the number of times the given value has been seen.
    fn times_seen(&self, value: u32) -> u64 {
        self.values.get(&value).copied().unwrap_or_default()
    }
}

{{#include exercise.rs:main}}
```



================================================
FILE: src/std-types/exercise.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![allow(unused_variables, dead_code)]
// ANCHOR: solution
use std::collections::HashMap;
use std::hash::Hash;

/// Counter counts the number of times each value of type T has been seen.
struct Counter<T> {
    values: HashMap<T, u64>,
}

impl<T: Eq + Hash> Counter<T> {
    /// Create a new Counter.
    fn new() -> Self {
        Counter { values: HashMap::new() }
    }

    /// Count an occurrence of the given value.
    fn count(&mut self, value: T) {
        *self.values.entry(value).or_default() += 1;
    }

    /// Return the number of times the given value has been seen.
    fn times_seen(&self, value: T) -> u64 {
        self.values.get(&value).copied().unwrap_or_default()
    }
}

// ANCHOR: main
fn main() {
    let mut ctr = Counter::new();
    ctr.count(13);
    ctr.count(14);
    ctr.count(16);
    ctr.count(14);
    ctr.count(14);
    ctr.count(11);

    for i in 10..20 {
        println!("saw {} values equal to {}", ctr.times_seen(i), i);
    }

    let mut strctr = Counter::new();
    strctr.count("apple");
    strctr.count("orange");
    strctr.count("apple");
    println!("got {} apples", strctr.times_seen("apple"));
}
// ANCHOR_END: main



================================================
FILE: src/std-types/hashmap.md
================================================
---
minutes: 5
---

# `HashMap`

Standard hash map with protection against HashDoS attacks:

```rust,editable
use std::collections::HashMap;

fn main() {
    let mut page_counts = HashMap::new();
    page_counts.insert("Adventures of Huckleberry Finn", 207);
    page_counts.insert("Grimms' Fairy Tales", 751);
    page_counts.insert("Pride and Prejudice", 303);

    if !page_counts.contains_key("Les Misérables") {
        println!(
            "We know about {} books, but not Les Misérables.",
            page_counts.len()
        );
    }

    for book in ["Pride and Prejudice", "Alice's Adventure in Wonderland"] {
        match page_counts.get(book) {
            Some(count) => println!("{book}: {count} pages"),
            None => println!("{book} is unknown."),
        }
    }

    // Use the .entry() method to insert a value if nothing is found.
    for book in ["Pride and Prejudice", "Alice's Adventure in Wonderland"] {
        let page_count: &mut i32 = page_counts.entry(book).or_insert(0);
        *page_count += 1;
    }

    dbg!(page_counts);
}
```

<details>

- `HashMap` is not defined in the prelude and needs to be brought into scope.
- Try the following lines of code. The first line will see if a book is in the
  hashmap and if not return an alternative value. The second line will insert
  the alternative value in the hashmap if the book is not found.

  ```rust,ignore
  let pc1 = page_counts
      .get("Harry Potter and the Sorcerer's Stone")
      .unwrap_or(&336);
  let pc2 = page_counts
      .entry("The Hunger Games")
      .or_insert(374);
  ```
- Unlike `vec!`, there is unfortunately no standard `hashmap!` macro.
  - Although, since Rust 1.56, HashMap implements [`From<[(K, V); N]>`][1],
    which allows us to easily initialize a hash map from a literal array:

    ```rust,ignore
    let page_counts = HashMap::from([
      ("Harry Potter and the Sorcerer's Stone".to_string(), 336),
      ("The Hunger Games".to_string(), 374),
    ]);
    ```

- Alternatively HashMap can be built from any `Iterator` that yields key-value
  tuples.

- This type has several "method-specific" return types, such as
  `std::collections::hash_map::Keys`. These types often appear in searches of
  the Rust docs. Show students the docs for this type, and the helpful link back
  to the `keys` method.

[1]: https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E

</details>



================================================
FILE: src/std-types/option.md
================================================
---
minutes: 10
---

# Option

We have already seen some use of `Option<T>`. It stores either a value of type
`T` or nothing. For example,
[`String::find`](https://doc.rust-lang.org/stable/std/string/struct.String.html#method.find)
returns an `Option<usize>`.

```rust,editable,should_panic
fn main() {
    let name = "Löwe 老虎 Léopard Gepardi";
    let mut position: Option<usize> = name.find('é');
    dbg!(position);
    assert_eq!(position.unwrap(), 14);
    position = name.find('Z');
    dbg!(position);
    assert_eq!(position.expect("Character not found"), 0);
}
```

<details>

- `Option` is widely used, not just in the standard library.
- `unwrap` will return the value in an `Option`, or panic. `expect` is similar
  but takes an error message.
  - You can panic on None, but you can't "accidentally" forget to check for
    None.
  - It's common to `unwrap`/`expect` all over the place when hacking something
    together, but production code typically handles `None` in a nicer fashion.

- The "niche optimization" means that `Option<T>` often has the same size in
  memory as `T`, if there is some representation that is not a valid value of T.
  For example, a reference cannot be NULL, so `Option<&T>` automatically uses
  NULL to represent the `None` variant, and thus can be stored in the same
  memory as `&T`.

</details>



================================================
FILE: src/std-types/result.md
================================================
---
minutes: 5
---

# Result

`Result` is similar to `Option`, but indicates the success or failure of an
operation, each with a different enum variant. It is generic: `Result<T, E>`
where `T` is used in the `Ok` variant and `E` appears in the `Err` variant.

```rust,editable
use std::fs::File;
use std::io::Read;

fn main() {
    let file: Result<File, std::io::Error> = File::open("diary.txt");
    match file {
        Ok(mut file) => {
            let mut contents = String::new();
            if let Ok(bytes) = file.read_to_string(&mut contents) {
                println!("Dear diary: {contents} ({bytes} bytes)");
            } else {
                println!("Could not read file content");
            }
        }
        Err(err) => {
            println!("The diary could not be opened: {err}");
        }
    }
}
```

<details>

- As with `Option`, the successful value sits inside of `Result`, forcing the
  developer to explicitly extract it. This encourages error checking. In the
  case where an error should never happen, `unwrap()` or `expect()` can be
  called, and this is a signal of the developer intent too.
- `Result` documentation is a recommended read. Not during the course, but it is
  worth mentioning. It contains a lot of convenience methods and functions that
  help functional-style programming.
- `Result` is the standard type to implement error handling as we will see on
  Day 4.

</details>



================================================
FILE: src/std-types/solution.md
================================================
# Solution

```rust,editable
{{#include exercise.rs:solution}}
```



================================================
FILE: src/std-types/std.md
================================================
---
minutes: 3
---

# Standard Library

Rust comes with a standard library that helps establish a set of common types
used by Rust libraries and programs. This way, two libraries can work together
smoothly because they both use the same `String` type.

In fact, Rust contains several layers of the Standard Library: `core`, `alloc`
and `std`.

- `core` includes the most basic types and functions that don't depend on
  `libc`, allocator or even the presence of an operating system.
- `alloc` includes types that require a global heap allocator, such as `Vec`,
  `Box` and `Arc`.
- Embedded Rust applications often only use `core`, and sometimes `alloc`.



================================================
FILE: src/std-types/string.md
================================================
---
minutes: 5
---

# String

[`String`][1] is a growable UTF-8 encoded string:

```rust,editable
fn main() {
    let mut s1 = String::new();
    s1.push_str("Hello");
    println!("s1: len = {}, capacity = {}", s1.len(), s1.capacity());

    let mut s2 = String::with_capacity(s1.len() + 1);
    s2.push_str(&s1);
    s2.push('!');
    println!("s2: len = {}, capacity = {}", s2.len(), s2.capacity());

    let s3 = String::from("🇨🇭");
    println!("s3: len = {}, number of chars = {}", s3.len(), s3.chars().count());
}
```

`String` implements [`Deref<Target = str>`][2], which means that you can call
all `str` methods on a `String`.

[1]: https://doc.rust-lang.org/std/string/struct.String.html
[2]: https://doc.rust-lang.org/std/string/struct.String.html#deref-methods-str

<details>

- `String::new` returns a new empty string, use `String::with_capacity` when you
  know how much data you want to push to the string.
- `String::len` returns the size of the `String` in bytes (which can be
  different from its length in characters).
- `String::chars` returns an iterator over the actual characters. Note that a
  `char` can be different from what a human will consider a "character" due to
  [grapheme clusters](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.Graphemes.html).
- When people refer to strings they could either be talking about `&str` or
  `String`.
- When a type implements `Deref<Target = T>`, the compiler will let you
  transparently call methods from `T`.
  - We haven't discussed the `Deref` trait yet, so at this point this mostly
    explains the structure of the sidebar in the documentation.
  - `String` implements `Deref<Target = str>` which transparently gives it
    access to `str`'s methods.
  - Write and compare `let s3 = s1.deref();` and `let s3 = &*s1;`.
- `String` is implemented as a wrapper around a vector of bytes, many of the
  operations you see supported on vectors are also supported on `String`, but
  with some extra guarantees.
- Compare the different ways to index a `String`:
  - To a character by using `s3.chars().nth(i).unwrap()` where `i` is in-bound,
    out-of-bounds.
  - To a substring by using `s3[0..4]`, where that slice is on character
    boundaries or not.
- Many types can be converted to a string with the
  [`to_string`](https://doc.rust-lang.org/std/string/trait.ToString.html#tymethod.to_string)
  method. This trait is automatically implemented for all types that implement
  `Display`, so anything that can be formatted can also be converted to a
  string.

</details>



================================================
FILE: src/std-types/vec.md
================================================
---
minutes: 5
---

# `Vec`

[`Vec`][1] is the standard resizable heap-allocated buffer:

```rust,editable
fn main() {
    let mut v1 = Vec::new();
    v1.push(42);
    println!("v1: len = {}, capacity = {}", v1.len(), v1.capacity());

    let mut v2 = Vec::with_capacity(v1.len() + 1);
    v2.extend(v1.iter());
    v2.push(9999);
    println!("v2: len = {}, capacity = {}", v2.len(), v2.capacity());

    // Canonical macro to initialize a vector with elements.
    let mut v3 = vec![0, 0, 1, 2, 3, 4];

    // Retain only the even elements.
    v3.retain(|x| x % 2 == 0);
    println!("{v3:?}");

    // Remove consecutive duplicates.
    v3.dedup();
    println!("{v3:?}");
}
```

`Vec` implements [`Deref<Target = [T]>`][2], which means that you can call slice
methods on a `Vec`.

[1]: https://doc.rust-lang.org/std/vec/struct.Vec.html
[2]: https://doc.rust-lang.org/std/vec/struct.Vec.html#deref-methods-%5BT%5D

<details>

- `Vec` is a type of collection, along with `String` and `HashMap`. The data it
  contains is stored on the heap. This means the amount of data doesn't need to
  be known at compile time. It can grow or shrink at runtime.
- Notice how `Vec<T>` is a generic type too, but you don't have to specify `T`
  explicitly. As always with Rust type inference, the `T` was established during
  the first `push` call.
- `vec![...]` is a canonical macro to use instead of `Vec::new()` and it
  supports adding initial elements to the vector.
- To index the vector you use `[` `]`, but they will panic if out of bounds.
  Alternatively, using `get` will return an `Option`. The `pop` function will
  remove the last element.

</details>



================================================
FILE: src/testing/Cargo.toml
================================================
[package]
name = "testing"
version = "0.1.0"
edition = "2024"
publish = false

[lints.rust]
unexpected_cfgs = { level = "warn", check-cfg = ['cfg(never)'] }

[lib]
name = "luhn"
path = "exercise.rs"



================================================
FILE: src/testing/exercise.md
================================================
---
minutes: 30
---

# Exercise: Luhn Algorithm

The [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) is used to
validate credit card numbers. The algorithm takes a string as input and does the
following to validate the credit card number:

- Ignore all spaces. Reject numbers with fewer than two digits. Reject letters
  and other non-digit characters.

- Moving from **right to left**, double every second digit: for the number
  `1234`, we double `3` and `1`. For the number `98765`, we double `6` and `8`.

- After doubling a digit, sum the digits if the result is greater than 9. So
  doubling `7` becomes `14` which becomes `1 + 4 = 5`.

- Sum all the undoubled and doubled digits.

- The credit card number is valid if the sum ends with `0`.

The provided code provides a buggy implementation of the luhn algorithm, along
with two basic unit tests that confirm that most of the algorithm is implemented
correctly.

Copy the code below to <https://play.rust-lang.org/> and write additional tests
to uncover bugs in the provided implementation, fixing any bugs you find.

```rust,editable
{{#include exercise.rs:luhn}}

{{#include exercise.rs:unit-tests}}
}
```



================================================
FILE: src/testing/exercise.rs
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
#![allow(dead_code)]

// This is the buggy version that appears in the problem.
#[cfg(never)]
// ANCHOR: luhn
pub fn luhn(cc_number: &str) -> bool {
    let mut sum = 0;
    let mut double = false;

    for c in cc_number.chars().rev() {
        if let Some(digit) = c.to_digit(10) {
            if double {
                let double_digit = digit * 2;
                sum +=
                    if double_digit > 9 { double_digit - 9 } else { double_digit };
            } else {
                sum += digit;
            }
            double = !double;
        } else {
            continue;
        }
    }

    sum % 10 == 0
}
// ANCHOR_END: luhn

// This is the solution and passes all of the tests below.
// ANCHOR: solution
pub fn luhn(cc_number: &str) -> bool {
    let mut sum = 0;
    let mut double = false;
    let mut digits = 0;

    for c in cc_number.chars().rev() {
        if let Some(digit) = c.to_digit(10) {
            digits += 1;
            if double {
                let double_digit = digit * 2;
                sum +=
                    if double_digit > 9 { double_digit - 9 } else { double_digit };
            } else {
                sum += digit;
            }
            double = !double;
        } else if c.is_whitespace() {
            // New: accept whitespace.
            continue;
        } else {
            // New: reject all other characters.
            return false;
        }
    }

    // New: check that we have at least two digits
    digits >= 2 && sum % 10 == 0
}

// ANCHOR: unit-tests
#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_valid_cc_number() {
        assert!(luhn("4263 9826 4026 9299"));
        assert!(luhn("4539 3195 0343 6467"));
        assert!(luhn("7992 7398 713"));
    }

    #[test]
    fn test_invalid_cc_number() {
        assert!(!luhn("4223 9826 4026 9299"));
        assert!(!luhn("4539 3195 0343 6476"));
        assert!(!luhn("8273 1232 7352 0569"));
    }
    // ANCHOR_END: unit-tests

    #[test]
    fn test_non_digit_cc_number() {
        assert!(!luhn("foo"));
        assert!(!luhn("foo 0 0"));
    }

    #[test]
    fn test_empty_cc_number() {
        assert!(!luhn(""));
        assert!(!luhn(" "));
        assert!(!luhn("  "));
        assert!(!luhn("    "));
    }

    #[test]
    fn test_single_digit_cc_number() {
        assert!(!luhn("0"));
    }

    #[test]
    fn test_two_digit_cc_number() {
        assert!(luhn(" 0 0 "));
    }
}



================================================
FILE: src/testing/lints.md
================================================
---
minutes: 3
---

# Compiler Lints and Clippy

The Rust compiler produces fantastic error messages, as well as helpful built-in
lints. [Clippy](https://doc.rust-lang.org/clippy/) provides even more lints,
organized into groups that can be enabled per-project.

```rust,editable,should_panic,warnunused
#[deny(clippy::cast_possible_truncation)]
fn main() {
    let mut x = 3;
    while (x < 70000) {
        x *= 2;
    }
    println!("X probably fits in a u16, right? {}", x as u16);
}
```

<details>

There are compiler lints visible here, but not clippy lints. Run `clippy` on the
playground site to show clippy warnings. Clippy has extensive documentation of
its lints, and adds new lints (including default-deny lints) all the time.

Note that errors or warnings with `help: ...` can be fixed with `cargo fix` or
via your editor.

</details>



================================================
FILE: src/testing/other.md
================================================
---
minutes: 5
---

# Other Types of Tests

## Integration Tests

If you want to test your library as a client, use an integration test.

Create a `.rs` file under `tests/`:

```rust,ignore
// tests/my_library.rs
use my_library::init;

#[test]
fn test_init() {
    assert!(init().is_ok());
}
```

These tests only have access to the public API of your crate.

## Documentation Tests

Rust has built-in support for documentation tests:

````rust
/// Shortens a string to the given length.
///
/// ```
/// # use playground::shorten_string;
/// assert_eq!(shorten_string("Hello World", 5), "Hello");
/// assert_eq!(shorten_string("Hello World", 20), "Hello World");
/// ```
pub fn shorten_string(s: &str, length: usize) -> &str {
    &s[..std::cmp::min(length, s.len())]
}
````

- Code blocks in `///` comments are automatically seen as Rust code.
- The code will be compiled and executed as part of `cargo test`.
- Adding `#` in the code will hide it from the docs, but will still compile/run
  it.
- Test the above code on the
  [Rust Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2024&gist=3ce2ad13ea1302f6572cb15cd96becf0).



================================================
FILE: src/testing/solution.md
================================================
# Solution

```rust,editable
{{#include exercise.rs:solution}}
```



================================================
FILE: src/testing/unit-tests.md
================================================
---
minutes: 5
---

# Unit Tests

Rust and Cargo come with a simple unit test framework. Tests are marked with
`#[test]`. Unit tests are often put in a nested `tests` module, using
`#[cfg(test)]` to conditionally compile them only when building tests.

```rust,editable
fn first_word(text: &str) -> &str {
    match text.find(' ') {
        Some(idx) => &text[..idx],
        None => &text,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_empty() {
        assert_eq!(first_word(""), "");
    }

    #[test]
    fn test_single_word() {
        assert_eq!(first_word("Hello"), "Hello");
    }

    #[test]
    fn test_multiple_words() {
        assert_eq!(first_word("Hello World"), "Hello");
    }
}
```

- This lets you unit test private helpers.
- The `#[cfg(test)]` attribute is only active when you run `cargo test`.



================================================
FILE: src/tuples-and-arrays/arrays.md
================================================
---
minutes: 5
---

# Arrays

<!-- mdbook-xgettext: skip -->

```rust,editable
fn main() {
    let mut a: [i8; 5] = [5, 4, 3, 2, 1];
    a[2] = 0;
    println!("a: {a:?}");
}
```

<details>

- Arrays can also be initialized using the shorthand syntax, e.g. `[0; 1024]`.
  This can be useful when you want to initialize all elements to the same value,
  or if you have a large array that would be hard to initialize manually.

- A value of the array type `[T; N]` holds `N` (a compile-time constant)
  elements of the same type `T`. Note that the length of the array is _part of
  its type_, which means that `[u8; 3]` and `[u8; 4]` are considered two
  different types. Slices, which have a size determined at runtime, are covered
  later.

- Try accessing an out-of-bounds array element. The compiler is able to
  determine that the index is unsafe, and will not compile the code:

```rust,editable,compile_fail
fn main() {
    let mut a: [i8; 5] = [5, 4, 3, 2, 1];
    a[6] = 0;
    println!("a: {a:?}");
}
```

- Array accesses are checked at runtime. Rust can usually optimize these checks
  away; meaning if the compiler can prove the access is safe, it removes the
  runtime check for better performance. They can be avoided using unsafe Rust.
  The optimization is so good that it's hard to give an example of runtime
  checks failing. The following code will compile but panic at runtime:

```rust,editable,should_panic
fn get_index() -> usize {
    6
}

fn main() {
    let mut a: [i8; 5] = [5, 4, 3, 2, 1];
    a[get_index()] = 0;
    println!("a: {a:?}");
}
```

- We can use literals to assign values to arrays.

- Arrays are not heap-allocated. They are regular values with a fixed size known
  at compile time, meaning they go on the stack. This can be different from what
  students expect if they come from a garbage-collected language, where arrays
  may be heap allocated by default.

- There is no way to remove elements from an array, nor add elements to an
  array. The length of an array is fixed at compile-time, and so its length
  cannot change at runtime.

## Debug Printing

- The `println!` macro asks for the debug implementation with the `?` format
  parameter: `{}` gives the default output, `{:?}` gives the debug output. Types
  such as integers and strings implement the default output, but arrays only
  implement the debug output. This means that we must use debug output here.

- Adding `#`, eg `{a:#?}`, invokes a "pretty printing" format, which can be
  easier to read.

</details>



================================================
FILE: src/tuples-and-arrays/Cargo.toml
================================================
[package]
name = "tuples-and-arrays"
version = "0.1.0"
edition = "2024"
publish = false

[[bin]]
name = "transpose"
path = "exercise.rs"



================================================
FILE: src/tuples-and-arrays/destructuring.md
================================================
---
minutes: 5
---

# Patterns and Destructuring

Rust supports using pattern matching to destructure a larger value like a tuple
into its constituent parts:

```rust,editable
fn check_order(tuple: (i32, i32, i32)) -> bool {
    let (left, middle, right) = tuple;
    left < middle && middle < right
}

fn main() {
    let tuple = (1, 5, 3);
    println!(
        "{tuple:?}: {}",
        if check_order(tuple) { "ordered" } else { "unordered" }
    );
}
```

<details>

- The patterns used here are "irrefutable", meaning that the compiler can
  statically verify that the value on the right of `=` has the same structure as
  the pattern.
- A variable name is an irrefutable pattern that always matches any value, hence
  why we can also use `let` to declare a single variable.
- Rust also supports using patterns in conditionals, allowing for equality
  comparison and destructuring to happen at the same time. This form of pattern
  matching will be discussed in more detail later.
- Edit the examples above to show the compiler error when the pattern doesn't
  match the value being matched on.

</details>



================================================
FILE: src/tuples-and-arrays/exercise.md
================================================
---
minutes: 15
---

# Exercise: Nested Arrays

Arrays can contain other arrays:

```rust,editable
let array = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
```

What is the type of this variable?

Use an array such as the above to write a function `transpose` that transposes a
matrix (turns rows into columns):

<!-- mdbook-xgettext: skip -->

```bob
           ⎛⎡1 2 3⎤⎞      ⎡1 4 7⎤
"transpose"⎜⎢4 5 6⎥⎟  "=="⎢2 5 8⎥
           ⎝⎣7 8 9⎦⎠      ⎣3 6 9⎦
```

Copy the code below to <https://play.rust-lang.org/> and implement the function.
This function only operates on 3x3 matrices.

```rust,should_panic,editable
{{#include exercise.rs:transpose}}
    todo!()
}

{{#include exercise.rs:main}}
```



================================================
FILE: src/tuples-and-arrays/exercise.rs
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Iterators are covered later.
#[allow(clippy::needless_range_loop)]
// ANCHOR: solution
// ANCHOR: transpose
fn transpose(matrix: [[i32; 3]; 3]) -> [[i32; 3]; 3] {
    // ANCHOR_END: transpose
    let mut result = [[0; 3]; 3];
    for i in 0..3 {
        for j in 0..3 {
            result[j][i] = matrix[i][j];
        }
    }
    result
}

// ANCHOR: main
fn main() {
    let matrix = [
        [101, 102, 103], // <-- the comment makes rustfmt add a newline
        [201, 202, 203],
        [301, 302, 303],
    ];

    println!("Original:");
    for row in &matrix {
        println!("{:?}", row);
    }

    let transposed = transpose(matrix);

    println!("\nTransposed:");
    for row in &transposed {
        println!("{:?}", row);
    }
}
// ANCHOR_END: main
// ANCHOR_END: solution

// This test does not appear in the exercise, as this is very early in the
// course, but it verifies that the solution is correct.
#[test]
fn test_transpose() {
    let matrix = [
        [101, 102, 103], //
        [201, 202, 203],
        [301, 302, 303],
    ];
    let transposed = transpose(matrix);
    assert_eq!(
        transposed,
        [
            [101, 201, 301], //
            [102, 202, 302],
            [103, 203, 303],
        ]
    );
}



================================================
FILE: src/tuples-and-arrays/iteration.md
================================================
---
minutes: 3
---

# Array Iteration

The `for` statement supports iterating over arrays (but not tuples).

```rust,editable
fn main() {
    let primes = [2, 3, 5, 7, 11, 13, 17, 19];
    for prime in primes {
        for i in 2..prime {
            assert_ne!(prime % i, 0);
        }
    }
}
```

<details>

This functionality uses the `IntoIterator` trait, but we haven't covered that
yet.

The `assert_ne!` macro is new here. There are also `assert_eq!` and `assert!`
macros. These are always checked, while debug-only variants like `debug_assert!`
compile to nothing in release builds.

</details>



================================================
FILE: src/tuples-and-arrays/solution.md
================================================
# Solution

```rust,editable
{{#include exercise.rs:solution}}
```



================================================
FILE: src/tuples-and-arrays/tuples.md
================================================
---
minutes: 5
---

# Tuples

<!-- mdbook-xgettext: skip -->

```rust,editable
fn main() {
    let t: (i8, bool) = (7, true);
    dbg!(t.0);
    dbg!(t.1);
}
```

<details>

- Like arrays, tuples have a fixed length.

- Tuples group together values of different types into a compound type.

- Fields of a tuple can be accessed by the period and the index of the value,
  e.g. `t.0`, `t.1`.

- The empty tuple `()` is referred to as the "unit type" and signifies absence
  of a return value, akin to `void` in other languages.

- Unlike arrays, tuples cannot be used in a `for` loop. This is because a `for`
  loop requires all the elements to have the same type, which may not be the
  case for a tuple.

- There is no way to add or remove elements from a tuple. The number of elements
  and their types are fixed at compile time and cannot be changed at runtime.

</details>



================================================
FILE: src/types-and-values/arithmetic.md
================================================
---
minutes: 3
---

# Arithmetic

```rust,editable
fn interproduct(a: i32, b: i32, c: i32) -> i32 {
    return a * b + b * c + c * a;
}

fn main() {
    println!("result: {}", interproduct(120, 100, 248));
}
```

<details>

This is the first time we've seen a function other than `main`, but the meaning
should be clear: it takes three integers, and returns an integer. Functions will
be covered in more detail later.

Arithmetic is very similar to other languages, with similar precedence.

What about integer overflow? In C and C++ overflow of _signed_ integers is
actually undefined, and might do unknown things at runtime. In Rust, it's
defined.

Change the `i32`'s to `i16` to see an integer overflow, which panics (checked)
in a debug build and wraps in a release build. There are other options, such as
overflowing, saturating, and carrying. These are accessed with method syntax,
e.g., `(a * b).saturating_add(b * c).saturating_add(c * a)`.

In fact, the compiler will detect overflow of constant expressions, which is why
the example requires a separate function.

</details>



================================================
FILE: src/types-and-values/Cargo.toml
================================================
[package]
name = "types-and-values"
version = "0.1.0"
edition = "2024"
publish = false

[[bin]]
name = "fizzbuzz"
path = "exercise.rs"



================================================
FILE: src/types-and-values/exercise.md
================================================
---
minutes: 15
---

# Exercise: Fibonacci

The Fibonacci sequence begins with `[0, 1]`. For `n > 1`, the next number is the
sum of the previous two.

Write a function `fib(n)` that calculates the nth Fibonacci number. When will
this function panic?

```rust,editable,should_panic
{{#include exercise.rs:fib}}
    if n < 2 {
        // The base case.
        return todo!("Implement this");
    } else {
        // The recursive case.
        return todo!("Implement this");
    }
}

{{#include exercise.rs:main}}
```

<details>

- This exercise is a classic introduction to recursion.
- Encourage students to think about the base cases and the recursive step.
- The question "When will this function panic?" is a hint to think about integer
  overflow. The Fibonacci sequence grows quickly!
- Students might come up with an iterative solution as well, which is a great
  opportunity to discuss the trade-offs between recursion and iteration (e.g.,
  performance, stack overflow for deep recursion).

</details>



================================================
FILE: src/types-and-values/exercise.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Omitting `return` is covered later.
#[allow(clippy::needless_return)]
// ANCHOR: solution
// ANCHOR: fib
fn fib(n: u32) -> u32 {
    // ANCHOR_END: fib
    if n < 2 {
        return n;
    } else {
        return fib(n - 1) + fib(n - 2);
    }
}

// ANCHOR: main
fn main() {
    let n = 20;
    println!("fib({n}) = {}", fib(n));
}
// ANCHOR_END: main



================================================
FILE: src/types-and-values/hello-world.md
================================================
---
minutes: 5
---

# Hello, World

Let us jump into the simplest possible Rust program, a classic Hello World
program:

```rust,editable
fn main() {
    println!("Hello 🌍!");
}
```

What you see:

- Functions are introduced with `fn`.
- The `main` function is the entry point of the program.
- Blocks are delimited by curly braces like in C and C++.
- Statements end with `;`.
- `println` is a macro, indicated by the `!` in the invocation.
- Rust strings are UTF-8 encoded and can contain any Unicode character.

<details>

This slide tries to make the students comfortable with Rust code. They will see
a ton of it over the next four days so we start small with something familiar.

Key points:

- Rust is very much like other languages in the C/C++/Java tradition. It is
  imperative and it doesn't try to reinvent things unless absolutely necessary.

- Rust is modern with full support for Unicode.

- Rust uses macros for situations where you want to have a variable number of
  arguments (no function [overloading](../control-flow-basics/functions.md)).

- `println!` is a macro because it needs to handle an arbitrary number of
  arguments based on the format string, which can't be done with a regular
  function. Otherwise it can be treated like a regular function.

- Rust is multi-paradigm. For example, it has powerful
  [object-oriented programming features](https://doc.rust-lang.org/book/ch17-00-oop.html),
  and, while it is not a functional language, it includes a range of
  [functional concepts](https://doc.rust-lang.org/book/ch13-00-functional-features.html).

</details>



================================================
FILE: src/types-and-values/inference.md
================================================
---
minutes: 3
---

# Type Inference

Rust will look at how the variable is _used_ to determine the type:

<!-- mdbook-xgettext: skip -->

```rust,editable
fn takes_u32(x: u32) {
    println!("u32: {x}");
}

fn takes_i8(y: i8) {
    println!("i8: {y}");
}

fn main() {
    let x = 10;
    let y = 20;

    takes_u32(x);
    takes_i8(y);
    // takes_u32(y);
}
```

<details>

This slide demonstrates how the Rust compiler infers types based on constraints
given by variable declarations and usages.

It is very important to emphasize that variables declared like this are not of
some sort of dynamic "any type" that can hold any data. The machine code
generated by such declaration is identical to the explicit declaration of a
type. The compiler does the job for us and helps us write more concise code.

When nothing constrains the type of an integer literal, Rust defaults to `i32`.
This sometimes appears as `{integer}` in error messages. Similarly,
floating-point literals default to `f64`.

```rust,compile_fail
fn main() {
    let x = 3.14;
    let y = 20;
    assert_eq!(x, y);
    // ERROR: no implementation for `{float} == {integer}`
}
```

</details>



================================================
FILE: src/types-and-values/solution.md
================================================
# Solution

```rust,editable
{{#include exercise.rs:solution}}
```

<details>

- Walk through the solution step-by-step.
- Explain the recursive calls and how they lead to the final result.
- Discuss the integer overflow issue. With `u32`, the function will panic for
  `n` around 47. You can demonstrate this by changing the input to `main`.
- Show an iterative solution as an alternative and compare its performance and
  memory usage with the recursive one. An iterative solution will be much more
  efficient.

## More to Explore

For a more advanced discussion, you can introduce memoization or dynamic
programming to optimize the recursive Fibonacci calculation, although this is
beyond the scope of the current topic.

</details>



================================================
FILE: src/types-and-values/values.md
================================================
---
minutes: 5
---

# Values

Here are some basic built-in types, and the syntax for literal values of each
type.

|                        | Types                                      | Literals                       |
| ---------------------- | ------------------------------------------ | ------------------------------ |
| Signed integers        | `i8`, `i16`, `i32`, `i64`, `i128`, `isize` | `-10`, `0`, `1_000`, `123_i64` |
| Unsigned integers      | `u8`, `u16`, `u32`, `u64`, `u128`, `usize` | `0`, `123`, `10_u16`           |
| Floating point numbers | `f32`, `f64`                               | `3.14`, `-10.0e20`, `2_f32`    |
| Unicode scalar values  | `char`                                     | `'a'`, `'α'`, `'∞'`            |
| Booleans               | `bool`                                     | `true`, `false`                |

The types have widths as follows:

- `iN`, `uN`, and `fN` are _N_ bits wide,
- `isize` and `usize` are the width of a pointer,
- `char` is 32 bits wide,
- `bool` is 8 bits wide.

<details>

There are a few syntaxes that are not shown above:

- All underscores in numbers can be left out, they are for legibility only. So
  `1_000` can be written as `1000` (or `10_00`), and `123_i64` can be written as
  `123i64`.

</details>



================================================
FILE: src/types-and-values/variables.md
================================================
---
minutes: 5
---

# Variables

Rust provides type safety via static typing. Variable bindings are made with
`let`:

```rust,editable,warnunused
fn main() {
    let x: i32 = 10;
    println!("x: {x}");
    // x = 20;
    // println!("x: {x}");
}
```

<details>

- Uncomment the `x = 20` to demonstrate that variables are immutable by default.
  Add the `mut` keyword to allow changes.

- Warnings are enabled for this slide, such as for unused variables or
  unnecessary `mut`. These are omitted in most slides to avoid distracting
  warnings. Try removing the mutation but leaving the `mut` keyword in place.

- The `i32` here is the type of the variable. This must be known at compile
  time, but type inference (covered later) allows the programmer to omit it in
  many cases.

</details>



================================================
FILE: src/unsafe-deep-dive/Cargo.toml
================================================
[Empty file]


================================================
FILE: src/unsafe-deep-dive/foundations.md
================================================
# Foundations

Some fundamental concepts and terms.

{{%segment outline}}



================================================
FILE: src/unsafe-deep-dive/motivations.md
================================================
---
minutes: 1
---

# Motivations

We know that writing code without the guarantees that Rust provides ...

> “Use-after-free (UAF), integer overflows, and out of bounds (OOB) reads/writes
> comprise 90% of vulnerabilities with OOB being the most common.”
>
> --— **Jeff Vander Stoep and Chong Zang**, Google.
> "[Queue the Hardening Enhancements](https://security.googleblog.com/2019/05/queue-hardening-enhancements.html)"

... so why is `unsafe` part of the language?

{{%segment outline}}

<details>

The `unsafe` keyword exists because there is no compiler technology available
today that makes it obsolete. Compilers cannot verify everything.

</details>



================================================
FILE: src/unsafe-deep-dive/setup.md
================================================
---
minutes: 2
---

# Setting Up

## Local Rust installation

You should have a Rust compiler installed that supports the 2024 edition of the
language, which is any version of rustc higher than 1.84.

```console
$ rustc --version 
rustc 1.87
```

<!--

  TODO (tim): Adding this for later while I'm here.
  TODO (tim): We should be able to avoid this by just relying on the `cc` crate

We recommend that you install the [Bazel build system](https://bazel.build/install).
This will allow you to easily compile project that combine multiple languages.

-->

## (Optional) Create a local instance of the course

```console
$ git clone --depth=1 https://github.com/google/comprehensive-rust.git
Cloning into 'comprehensive-rust'...
...
$ cd comprehensive-rust
$ cargo install-tools
...
$ cargo serve # then open http://127.0.0.1:3000/ in a browser
```

<details>

Ask everyone to confirm that everyone is able to execute `rustc` with a version
older that 1.87.

For those people who do not, tell them that we'll resolve that in the break.

</details>



================================================
FILE: src/unsafe-deep-dive/welcome.md
================================================
---
course: Unsafe
session: Day 1 Morning
target_minutes: 300
---

# Welcome to Unsafe Rust

> IMPORTANT: THIS MODULE IS IN AN EARLY STAGE OF DEVELOPMENT
>
> Please do not consider this module of Comprehensive Rust to be complete. With
> that in mind, your feedback, comments, and especially your concerns, are very
> welcome.
>
> To comment on this module's development, please use the
> [GitHub issue tracker].

[GitHub issue tracker]: https://github.com/google/comprehensive-rust/issues

The `unsafe` keyword is easy to type, but hard to master. When used
appropriately, it forms a useful and indeed essential part of the Rust
programming language.

By the end of this deep dive, you'll know how to work with `unsafe` code, review
others' changes that include the `unsafe` keyword, and produce your own.

What you'll learn:

- What the terms undefined behavior, soundness, and safety mean
- Why the `unsafe` keyword exists in the Rust language
- How to write your own code using `unsafe` safely
- How to review `unsafe` code

## Links to other sections of the course

The `unsafe` keyword has treatment in:

- _Rust Fundamentals_, the main module of Comprehensive Rust, includes a session
  on [Unsafe Rust] in its last day.
- _Rust in Chromium_ discusses how to [interoperate with C++]. Consult that
  material if you are looking into FFI.
- _Bare Metal Rust_ uses unsafe heavily to interact with the underlying host,
  among other things.

[interoperate with C++]: ../chromium/interoperability-with-cpp.md
[Unsafe Rust]: ../unsafe-rust.html



================================================
FILE: src/unsafe-deep-dive/foundations/actions-might-not-be.md
================================================
---
minutes: 2
---

# ... but actions on them might not be

```rust
fn main() {
    let n: i64 = 12345;
    let safe = &n as *const _;
    println!("{safe:p}");
}
```

<details>

Modify the example to de-reference `safe` without an `unsafe` block.

</details>



================================================
FILE: src/unsafe-deep-dive/foundations/data-structures-are-safe.md
================================================
---
minutes: 2
---

# Data structures are safe ...

Data structures are inert. They cannot do any harm by themselves.

Safe Rust code can create raw pointers:

```rust
fn main() {
    let n: i64 = 12345;
    let safe = &raw const n;
    println!("{safe:p}");
}
```

<details>

Consider a raw pointer to an integer, i.e., the value `safe` is the raw pointer
type `*const i64`. Raw pointers can be out-of-bounds, misaligned, or be null.
But the unsafe keyword is not required when creating them.

</details>



================================================
FILE: src/unsafe-deep-dive/foundations/less-powerful.md
================================================
---
minutes: 10
---

# Less powerful than it seems

The `unsafe` keyword does not allow you to break Rust.

```rust,ignore
use std::mem::transmute;

let orig = b"RUST";
let n: i32 = unsafe { transmute(orig) };

println!("{n}")
```

<details>

## Suggested outline

- Request that someone explains what `std::mem::transmute` does
- Discuss why it doesn't compile
- Fix the code

## Expected compiler output

```ignore
   Compiling playground v0.0.1 (/playground)
error[E0512]: cannot transmute between types of different sizes, or dependently-sized types
 --> src/main.rs:5:27
  |
5 |     let n: i32 = unsafe { transmute(orig) };
  |                           ^^^^^^^^^
  |
  = note: source type: `&[u8; 4]` (64 bits)
  = note: target type: `i32` (32 bits)
```

## Suggested change

```diff
- let n: i32 = unsafe { transmute(orig) };
+ let n: i64 = unsafe { transmute(orig) };
```

## Notes on less familiar Rust

- the `b` prefix on a string literal marks it as byte slice (`&[u8]`) rather
  than a string slice (`&str`)

</details>



================================================
FILE: src/unsafe-deep-dive/foundations/what-is-unsafe.md
================================================
---
minutes: 6
---

# What is &ldquo;unsafety&rdquo;?

Unsafe Rust is a superset of Safe Rust.

Let's create a list of things that are enabled by the `unsafe` keyword.

<details>

## Definitions from authoritative docs:

From the [unsafe keyword's documentation]():

> Code or interfaces whose memory safety cannot be verified by the type system.
>
> ...
>
> Here are the abilities Unsafe Rust has in addition to Safe Rust:
>
> - Dereference raw pointers
> - Implement unsafe traits
> - Call unsafe functions
> - Mutate statics (including external ones)
> - Access fields of unions

From the [reference](https://doc.rust-lang.org/reference/unsafety.html)

> The following language level features cannot be used in the safe subset of
> Rust:
>
> - Dereferencing a raw pointer.
> - Reading or writing a mutable or external static variable.
> - Accessing a field of a union, other than to assign to it.
> - Calling an unsafe function (including an intrinsic or foreign function).
> - Calling a safe function marked with a target_feature from a function that
>   does not have a target_feature attribute enabling the same features (see
>   attributes.codegen.target_feature.safety-restrictions).
> - Implementing an unsafe trait.
> - Declaring an extern block.
> - Applying an unsafe attribute to an item.

## Group exercise

> You may have a group of learners who are not familiar with each other yet.
> This is a way for you to gather some data about their confidence levels and
> the psychological safety that they're feeling.

### Part 1: Informal definition

> Use this to gauge the confidence level of the group. If they are uncertain,
> then tailor the next section to be more directed.

Ask the class: **By raising your hand, indicate if you would feel comfortable
defining unsafe?**

If anyone's feeling confident, allow them to try to explain.

### Part 2: Evidence gathering

Ask the class to spend 3-5 minutes.

- Find a use of the unsafe keyword. What contract/invariant/pre-condition is
  being established or satisfied?
- Write down terms that need to be defined (unsafe, memory safety, soundness,
  undefined behavior)

### Part 3: Write a working definition

### Part 4: Remarks

Mention that we'll be reviewing our definition at the end of the day.

## Note: Avoid detailed discussion about precise semantics of memory safety

It's possible that the group will slide into a discussion about the precise
semantics of what memory safety actually is and how define pointer validity.
This isn't a productive line of discussion. It can undermine confidence in less
experienced learners.

Perhaps refer people who wish to discuss this to the discussion within the
official [documentation for pointer types] (excerpt below) as a place for
further research.

> Many functions in [this module] take raw pointers as arguments and read from
> or write to them. For this to be safe, these pointers must be _valid_ for the
> given access.
>
> ...
>
> The precise rules for validity are not determined yet.

[this module]: https://doc.rust-lang.org/std/ptr/index.html
[documentation for pointer types]: https://doc.rust-lang.org/std/ptr/index.html#safety

</details>



================================================
FILE: src/unsafe-deep-dive/foundations/when-is-unsafe-used.md
================================================
---
minutes: 2
---

# When is unsafe used?

The unsafe keyword indicates that the programmer is responsible for upholding
Rust's safety guarantees.

The keyword has two roles:

- define pre-conditions that must be satisfied
- assert to the compiler (= promise) that those defined pre-conditions are
  satisfied

## Further references

- [The unsafe keyword chapter of the Rust Reference](https://doc.rust-lang.org/reference/unsafe-keyword.html)

<details>

Places where pre-conditions can be defined (Role 1)

- [unsafe functions] (`unsafe fn foo() { ... }`). Example: `get_unchecked`
  method on slices, which requires callers to verify that the index is
  in-bounds.
- unsafe traits (`unsafe trait`). Examples: [`Send`] and [`Sync`] marker traits
  in the standard library.

Places where pre-conditions must be satisfied (Role 2)

- unsafe blocks (`unafe { ... }`)
- implementing unsafe traits (`unsafe impl`)
- access external items (`unsafe extern`)
- adding
  [unsafe attributes](https://doc.rust-lang.org/reference/attributes.html) o an
  item. Examples: [`export_name`], [`link_section`] and [`no_mangle`]. Usage:
  `#[unsafe(no_mangle)]`

[unsafe functions]: https://doc.rust-lang.org/reference/unsafe-keyword.html#unsafe-functions-unsafe-fn
[unsafe traits]: https://doc.rust-lang.org/reference/unsafe-keyword.html#unsafe-traits-unsafe-trait
[`export_name`]: https://doc.rust-lang.org/reference/abi.html#the-export_name-attribute
[`link_section`]: https://doc.rust-lang.org/reference/abi.html#the-link_section-attribute
[`no_mangle`]: https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute
[`Send`]: https://doc.rust-lang.org/std/marker/trait.Send.html
[`Sync`]: https://doc.rust-lang.org/std/marker/trait.Sync.html

</details>



================================================
FILE: src/unsafe-deep-dive/motivations/data-structures.md
================================================
---
minutes: 5
---

# Data Structures

Some families of data structures are impossible to create in safe Rust.

- graphs
- bit twiddling
- self-referential types
- intrusive data structures

<details>

Graphs: General-purpose graphs cannot be created as they may need to represent
cycles. Cycles are impossible for the type system to reason about.

Bit twiddling: Overloading bits with multiple meanings. Examples include using
the NaN bits in `f64` for some other purpose or the higher-order bits of
pointers on `x86_64` platforms. This is somewhat common when writing language
interpreters to keep representations within the word size the target platform.

Self-referential types are too hard for the borrow checker to verify.

Intrusive data structures: store structural metadata (like pointers to other
elements) inside the elements themselves, which requires careful handling of
aliasing.

</details>



================================================
FILE: src/unsafe-deep-dive/motivations/interop.md
================================================
---
minutes: 5
---

> TODO: Refactor this content into multiple slides as this slide is intended as
> an introduction to the motivations only, rather than to be an elaborate
> discussion of the whole problem.

# Interoperability

Language interoperability allows you to:

- Call functions written in other languages from Rust
- Write functions in Rust that are callable from other languages

However, this requires unsafe.

```rust,editable,ignore
unsafe extern "C" {
    safe fn random() -> libc::c_long;
}

fn main() {
    let a = random() as i64;
    println!("{a:?}");
}
```

<details>

The Rust compiler can't enforce any safety guarantees for programs that it
hasn't compiled, so it delegates that responsibility to you through the unsafe
keyword.

The code example we're seeing shows how to call the random function provided by
libc within Rust. libc is available to scripts in the Rust Playground.

This uses Rust's _foreign function interface_.

This isn't the only style of interoperability, however it is the method that's
needed if you want to work between Rust and some other language in a zero cost
way. Another important strategy is message passing.

Message passing avoids unsafe, but serialization, allocation, data transfer and
parsing all take energy and time.

## Answers to questions

- _Where does "random" come from?_\
  libc is dynamically linked to Rust programs by default, allowing our code to
  rely on its symbols, including `random`, being available to our program.
- _What is the "safe" keyword?_\
  It allows callers to call the function without needing to wrap that call in
  `unsafe`. The [`safe` function qualifier][safe] was introduced in the 2024
  edition of Rust and can only be used within `extern` blocks. It was introduced
  because `unsafe` became a mandatory qualifier for `extern` blocks in that
  edition.
- _What is the [`std::ffi::c_long`] type?_\
  According to the C standard, an integer that's at least 32 bits wide. On
  today's systems, It's an `i32` on Windows and an `i64` on Linux.

[`std::ffi::c_long`]: https://doc.rust-lang.org/std/ffi/type.c_long.html
[safe]: https://doc.rust-lang.org/stable/edition-guide/rust-2024/unsafe-extern.html

## Consideration: type safety

Modify the code example to remove the need for type casting later. Discuss the
potential UB - long's width is defined by the target.

```rust
unsafe extern "C" {
    safe fn random() -> i64;
}

fn main() {
    let a = random();
    println!("{a:?}");
}
```

> Changes from the original:
>
> ```diff
> unsafe extern "C" {
> -    safe fn random() -> libc::c_long;
> +    safe fn random() -> i64;
> }
>
> fn main() {
> -    let a = random() as i64;
> +    let a = random();
>     println!("{a:?}");
> }
> ```

It's also possible to completely ignore the intended type and create undefined
behavior in multiple ways. The code below produces output most of the time, but
generally results in a stack overflow. It may also produce illegal `char`
values. Although `char` is represented in 4 bytes (32 bits),
[not all bit patterns are permitted as a `char`][char].

Stress that the Rust compiler will trust that the wrapper is telling the truth.

[char]: https://doc.rust-lang.org/std/primitive.char.html#validity-and-layout

<!-- TODO(timclicks): add libc to the mdbook build system so that the example can be tested -->

```rust,ignore
unsafe extern "C" {
    safe fn random() -> [char; 2];
}

fn main() {
    let a = random();
    println!("{a:?}");
}
```

> Changes from the original:
>
> ```diff
> unsafe extern "C" {
> -    safe fn random() -> libc::c_long;
> +    safe fn random() -> [char; 2];
> }
>
> fn main() {
> -    let a = random() as i64;
> -    println!("{a}");
> +    let a = random();
> +    println!("{a:?}");
> }
> ```

> Attempting to print a `[char; 2]` from randomly generated input will often
> produce strange output, including:
>
> ```ignore
> thread 'main' panicked at library/std/src/io/stdio.rs:1165:9:
> failed printing to stdout: Bad address (os error 14)
> ```
>
> ```ignore
> thread 'main' has overflowed its stack
> fatal runtime error: stack overflow, aborting
> ```

Mention that type safety is generally not a large concern in practice. Tools
that produce wrappers automatically, i.e. bindgen, are excellent at reading
header files and producing values of the correct type.

## Consideration: Ownership and lifetime management

While libc's `random` function doesn't use pointers, many do. This creates many
more possibilities for unsoundness.

- both sides might attempt to free the memory (double free)
- both sides can attempt to write to the data

For example, some C libraries expose functions that write to static buffers that
are re-used between calls.

<!--

TODO(timclicks): consider adding a safety comment in the docstring that discusses thread safety and the ownership of the returned pointer.

See <https://github.com/google/comprehensive-rust/pull/2806#discussion_r2207171041>.

-->

<!-- TODO(timclicks): add libc to the mdbook build system so that the example can be tested -->

```rust,ignore
use std::ffi::{CStr, c_char};
use std::time::{SystemTime, UNIX_EPOCH};

unsafe extern "C" {
    /// Create a formatted time based on time `t`, including trailing newline.
    /// Read `man 3 ctime` details.
    fn ctime(t: *const libc::time_t) -> *const c_char;
}

unsafe fn format_timestamp<'a>(t: u64) -> &'a str {
    let t = t as libc::time_t;

    unsafe {
        let fmt_ptr = ctime(&t);
        CStr::from_ptr(fmt_ptr).to_str().unwrap()
    }
}

fn main() {
    let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();

    let now = now.as_secs();
    let now_fmt = unsafe { format_timestamp(now) };
    print!("now (1): {}", now_fmt);

    let future = now + 60;
    let future_fmt = unsafe { format_timestamp(future) };
    print!("future:  {}", future_fmt);

    print!("now (2): {}", now_fmt);
}
```

> _Aside:_ Lifetimes in the `format_timestamp()` function
>
> Neither `'a`, nor `'static`, correctly describe the lifetime of the string
> that's returned. Rust treats it as an immutable reference, but subsequent
> calls to `ctime` will overwrite the static buffer that the string occupies.

## Consideration: Representation mismatch

Different programming languages have made different design decisions and this
can create impedance mismatches between different domains.

Consider string handling. C++ defines `std::string`, which has an incompatible
memory layout with Rust's `String` type. `String` also requires text to be
encoded as UTF-8, whereas `std::string` does not. In C, text is represented by a
null-terminated sequence of bytes (`char*`).

```rust
fn main() {
    let c_repr = b"Hello, C\0";
    let rust_repr = (b"Hello, Rust", 11);

    let c: &str = unsafe {
        let ptr = c_repr.as_ptr() as *const i8;
        std::ffi::CStr::from_ptr(ptr).to_str().unwrap()
    };
    println!("{c}");

    let rust: &str = unsafe {
        let ptr = rust_repr.0.as_ptr();
        let bytes = std::slice::from_raw_parts(ptr, rust_repr.1);
        std::str::from_utf8_unchecked(bytes)
    };
    println!("{rust}");
}
```

</details>



================================================
FILE: src/unsafe-deep-dive/motivations/performance.md
================================================
---
minutes: 5
---

# Performance

> TODO: Stub for now

It's easy to think of performance as the main reason for unsafe, but high
performance code makes up the minority of unsafe blocks.



================================================
FILE: src/unsafe-rust/Cargo.toml
================================================
[package]
name = "unsafe-rust"
version = "0.1.0"
edition = "2024"
publish = false

[dependencies]
tempfile = "3.21.0"

[[bin]]
name = "listdir"
path = "exercise.rs"



================================================
FILE: src/unsafe-rust/dereferencing.md
================================================
---
minutes: 10
---

# Dereferencing Raw Pointers

Creating pointers is safe, but dereferencing them requires `unsafe`:

```rust,editable
fn main() {
    let mut x = 10;

    let p1: *mut i32 = &raw mut x;
    let p2 = p1 as *const i32;

    // SAFETY: p1 and p2 were created by taking raw pointers to a local, so they
    // are guaranteed to be non-null, aligned, and point into a single (stack-)
    // allocated object.
    //
    // The object underlying the raw pointers lives for the entire function, so
    // it is not deallocated while the raw pointers still exist. It is not
    // accessed through references while the raw pointers exist, nor is it
    // accessed from other threads concurrently.
    unsafe {
        dbg!(*p1);
        *p1 = 6;
        // Mutation may soundly be observed through a raw pointer, like in C.
        dbg!(*p2);
    }

    // UNSOUND. DO NOT DO THIS.
    /*
    let r: &i32 = unsafe { &*p1 };
    dbg!(r);
    x = 50;
    dbg!(r); // Object underlying the reference has been mutated. This is UB.
    */
}
```

<details>

It is good practice (and required by the Android Rust style guide) to write a
comment for each `unsafe` block explaining how the code inside it satisfies the
safety requirements of the unsafe operations it is doing.

In the case of pointer dereferences, this means that the pointers must be
[_valid_](https://doc.rust-lang.org/std/ptr/index.html#safety), i.e.:

- The pointer must be non-null.
- The pointer must be _dereferenceable_ (within the bounds of a single allocated
  object).
- The object must not have been deallocated.
- There must not be concurrent accesses to the same location.
- If the pointer was obtained by casting a reference, the underlying object must
  be live and no reference may be used to access the memory.

In most cases the pointer must also be properly aligned.

The "UNSOUND" section gives an example of a common kind of UB bug: naïvely
taking a reference to the dereference of a raw pointer sidesteps the compiler's
knowledge of what object the reference is actually pointing to. As such, the
borrow checker does not freeze `x` and so we are able to modify it despite the
existence of a reference to it. Creating a reference from a pointer requires
_great care_.

</details>



================================================
FILE: src/unsafe-rust/exercise.md
================================================
---
minutes: 30
---

# Safe FFI Wrapper

Rust has great support for calling functions through a _foreign function
interface_ (FFI). We will use this to build a safe wrapper for the `libc`
functions you would use from C to read the names of files in a directory.

You will want to consult the manual pages:

- [`opendir(3)`](https://man7.org/linux/man-pages/man3/opendir.3.html)
- [`readdir(3)`](https://man7.org/linux/man-pages/man3/readdir.3.html)
- [`closedir(3)`](https://man7.org/linux/man-pages/man3/closedir.3.html)

You will also want to browse the [`std::ffi`] module. There you find a number of
string types which you need for the exercise:

| Types                      | Encoding       | Use                            |
| -------------------------- | -------------- | ------------------------------ |
| [`str`] and [`String`]     | UTF-8          | Text processing in Rust        |
| [`CStr`] and [`CString`]   | NUL-terminated | Communicating with C functions |
| [`OsStr`] and [`OsString`] | OS-specific    | Communicating with the OS      |

You will convert between all these types:

- `&str` to `CString`: you need to allocate space for a trailing `\0` character,
- `CString` to `*const i8`: you need a pointer to call C functions,
- `*const i8` to `&CStr`: you need something which can find the trailing `\0`
  character,
- `&CStr` to `&[u8]`: a slice of bytes is the universal interface for "some
  unknown data",
- `&[u8]` to `&OsStr`: `&OsStr` is a step towards `OsString`, use
  [`OsStrExt`](https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html) to
  create it,
- `&OsStr` to `OsString`: you need to clone the data in `&OsStr` to be able to
  return it and call `readdir` again.

The [Nomicon] also has a very useful chapter about FFI.

[`std::ffi`]: https://doc.rust-lang.org/std/ffi/
[`str`]: https://doc.rust-lang.org/std/primitive.str.html
[`String`]: https://doc.rust-lang.org/std/string/struct.String.html
[`CStr`]: https://doc.rust-lang.org/std/ffi/struct.CStr.html
[`CString`]: https://doc.rust-lang.org/std/ffi/struct.CString.html
[`OsStr`]: https://doc.rust-lang.org/std/ffi/struct.OsStr.html
[`OsString`]: https://doc.rust-lang.org/std/ffi/struct.OsString.html
[Nomicon]: https://doc.rust-lang.org/nomicon/ffi.html

Copy the code below to <https://play.rust-lang.org/> and fill in the missing
functions and methods:

```rust,should_panic,editable
// TODO: remove this when you're done with your implementation.
#![allow(unused_imports, unused_variables, dead_code)]

{{#include exercise.rs:ffi}}

{{#include exercise.rs:DirectoryIterator}}
        todo!()
    }
}

{{#include exercise.rs:Iterator}}
        todo!()
    }
}

{{#include exercise.rs:Drop}}
        todo!()
    }
}

{{#include exercise.rs:main}}
```

<details>

FFI binding code is typically generated by tools like [bindgen], rather than
being written manually as we are doing here. However, bindgen can't run in an
online playground.

</details>

[bindgen]: https://github.com/rust-lang/rust-bindgen



================================================
FILE: src/unsafe-rust/exercise.rs
================================================
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// `DIR` matches name of C struct.
#[allow(clippy::upper_case_acronyms)]
// ANCHOR: solution
// ANCHOR: ffi
mod ffi {
    use std::os::raw::{c_char, c_int};
    #[cfg(not(target_os = "macos"))]
    use std::os::raw::{c_long, c_uchar, c_ulong, c_ushort};

    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.
    #[repr(C)]
    pub struct DIR {
        _data: [u8; 0],
        _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
    }

    // Layout according to the Linux man page for readdir(3), where ino_t and
    // off_t are resolved according to the definitions in
    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.
    #[cfg(not(target_os = "macos"))]
    #[repr(C)]
    pub struct dirent {
        pub d_ino: c_ulong,
        pub d_off: c_long,
        pub d_reclen: c_ushort,
        pub d_type: c_uchar,
        pub d_name: [c_char; 256],
    }

    // Layout according to the macOS man page for dir(5).
    #[cfg(target_os = "macos")]
    #[repr(C)]
    pub struct dirent {
        pub d_fileno: u64,
        pub d_seekoff: u64,
        pub d_reclen: u16,
        pub d_namlen: u16,
        pub d_type: u8,
        pub d_name: [c_char; 1024],
    }

    unsafe extern "C" {
        pub unsafe fn opendir(s: *const c_char) -> *mut DIR;

        #[cfg(not(all(target_os = "macos", target_arch = "x86_64")))]
        pub unsafe fn readdir(s: *mut DIR) -> *const dirent;

        // See https://github.com/rust-lang/libc/issues/414 and the section on
        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).
        //
        // "Platforms that existed before these updates were available" refers
        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and PowerPC.
        #[cfg(all(target_os = "macos", target_arch = "x86_64"))]
        #[link_name = "readdir$INODE64"]
        pub unsafe fn readdir(s: *mut DIR) -> *const dirent;

        pub unsafe fn closedir(s: *mut DIR) -> c_int;
    }
}

use std::ffi::{CStr, CString, OsStr, OsString};
use std::os::unix::ffi::OsStrExt;

#[derive(Debug)]
struct DirectoryIterator {
    path: CString,
    dir: *mut ffi::DIR,
}
// ANCHOR_END: ffi

// ANCHOR: DirectoryIterator
impl DirectoryIterator {
    fn new(path: &str) -> Result<DirectoryIterator, String> {
        // Call opendir and return a Ok value if that worked,
        // otherwise return Err with a message.
        // ANCHOR_END: DirectoryIterator
        let path =
            CString::new(path).map_err(|err| format!("Invalid path: {err}"))?;
        // SAFETY: path.as_ptr() cannot be NULL.
        let dir = unsafe { ffi::opendir(path.as_ptr()) };
        if dir.is_null() {
            Err(format!("Could not open {path:?}"))
        } else {
            Ok(DirectoryIterator { path, dir })
        }
    }
}

// ANCHOR: Iterator
impl Iterator for DirectoryIterator {
    type Item = OsString;
    fn next(&mut self) -> Option<OsString> {
        // Keep calling readdir until we get a NULL pointer back.
        // ANCHOR_END: Iterator
        // SAFETY: self.dir is never NULL.
        let dirent = unsafe { ffi::readdir(self.dir) };
        if dirent.is_null() {
            // We have reached the end of the directory.
            return None;
        }
        // SAFETY: dirent is not NULL and dirent.d_name is NUL
        // terminated.
        let d_name = unsafe { CStr::from_ptr((*dirent).d_name.as_ptr()) };
        let os_str = OsStr::from_bytes(d_name.to_bytes());
        Some(os_str.to_owned())
    }
}

// ANCHOR: Drop
impl Drop for DirectoryIterator {
    fn drop(&mut self) {
        // Call closedir as needed.
        // ANCHOR_END: Drop
        // SAFETY: self.dir is never NULL.
        if unsafe { ffi::closedir(self.dir) } != 0 {
            panic!("Could not close {:?}", self.path);
        }
    }
}

// ANCHOR: main
fn main() -> Result<(), String> {
    let iter = DirectoryIterator::new(".")?;
    println!("files: {:#?}", iter.collect::<Vec<_>>());
    Ok(())
}
// ANCHOR_END: main

#[cfg(test)]
mod tests {
    use super::*;
    use std::error::Error;

    #[test]
    fn test_nonexisting_directory() {
        let iter = DirectoryIterator::new("no-such-directory");
        assert!(iter.is_err());
    }

    #[test]
    fn test_empty_directory() -> Result<(), Box<dyn Error>> {
        let tmp = tempfile::TempDir::new()?;
        let iter = DirectoryIterator::new(
            tmp.path().to_str().ok_or("Non UTF-8 character in path")?,
        )?;
        let mut entries = iter.collect::<Vec<_>>();
        entries.sort();
        assert_eq!(entries, &[".", ".."]);
        Ok(())
    }

    #[test]
    fn test_nonempty_directory() -> Result<(), Box<dyn Error>> {
        let tmp = tempfile::TempDir::new()?;
        std::fs::write(tmp.path().join("foo.txt"), "The Foo Diaries\n")?;
        std::fs::write(tmp.path().join("bar.png"), "<PNG>\n")?;
        std::fs::write(tmp.path().join("crab.rs"), "//! Crab\n")?;
        let iter = DirectoryIterator::new(
            tmp.path().to_str().ok_or("Non UTF-8 character in path")?,
        )?;
        let mut entries = iter.collect::<Vec<_>>();
        entries.sort();
        assert_eq!(entries, &[".", "..", "bar.png", "crab.rs", "foo.txt"]);
        Ok(())
    }
}



================================================
FILE: src/unsafe-rust/mutable-static.md
================================================
---
minutes: 5
---

# Mutable Static Variables

It is safe to read an immutable static variable:

```rust,editable
static HELLO_WORLD: &str = "Hello, world!";

fn main() {
    println!("HELLO_WORLD: {HELLO_WORLD}");
}
```

However, mutable static variables are unsafe to read and write because multiple
threads could do so concurrently without synchronization, constituting a data
race.

Using mutable statics soundly requires reasoning about concurrency without the
compiler's help:

```rust,editable
static mut COUNTER: u32 = 0;

fn add_to_counter(inc: u32) {
    // SAFETY: There are no other threads which could be accessing `COUNTER`.
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_counter(42);

    // SAFETY: There are no other threads which could be accessing `COUNTER`.
    unsafe {
        dbg!(COUNTER);
    }
}
```

<details>

- The program here is sound because it is single-threaded. However, the Rust
  compiler reasons about functions individually so can't assume that. Try
  removing the `unsafe` and see how the compiler explains that it is undefined
  behavior to access a mutable static from multiple threads.
- The 2024 Rust edition goes further and makes accessing a mutable static by
  reference an error by default.
- Using a mutable static is almost always a bad idea, you should use interior
  mutability instead.
- There are some cases where it might be necessary in low-level `no_std` code,
  such as implementing a heap allocator or working with some C APIs. In this
  case you should use pointers rather than references.

</details>



================================================
FILE: src/unsafe-rust/solution.md
================================================
# Solution

```rust,editable
{{#include exercise.rs:solution}}
```



================================================
FILE: src/unsafe-rust/unions.md
================================================
---
minutes: 5
---

# Unions

Unions are like enums, but you need to track the active field yourself:

```rust,editable
#[repr(C)]
union MyUnion {
    i: u8,
    b: bool,
}

fn main() {
    let u = MyUnion { i: 42 };
    println!("int: {}", unsafe { u.i });
    println!("bool: {}", unsafe { u.b }); // Undefined behavior!
}
```

<details>

Unions are very rarely needed in Rust as you can usually use an enum. They are
occasionally needed for interacting with C library APIs.

If you just want to reinterpret bytes as a different type, you probably want
[`std::mem::transmute`](https://doc.rust-lang.org/stable/std/mem/fn.transmute.html)
or a safe wrapper such as the [`zerocopy`](https://crates.io/crates/zerocopy)
crate.

</details>



================================================
FILE: src/unsafe-rust/unsafe-functions.md
================================================
---
minutes: 15
---

# Unsafe Functions

A function or method can be marked `unsafe` if it has extra preconditions you
must uphold to avoid undefined behaviour.

Unsafe functions may come from two places:

- Rust functions declared unsafe.
- Unsafe foreign functions in `extern "C"` blocks.

<details>

We will look at the two kinds of unsafe functions next.

</details>



================================================
FILE: src/unsafe-rust/unsafe-traits.md
================================================
---
minutes: 5
---

# Implementing Unsafe Traits

Like with functions, you can mark a trait as `unsafe` if the implementation must
guarantee particular conditions to avoid undefined behaviour.

For example, the `zerocopy` crate has an unsafe trait that looks
[something like this](https://docs.rs/zerocopy/latest/zerocopy/trait.IntoBytes.html):

```rust,editable
use std::{mem, slice};

/// ...
/// # Safety
/// The type must have a defined representation and no padding.
pub unsafe trait IntoBytes {
    fn as_bytes(&self) -> &[u8] {
        let len = mem::size_of_val(self);
        let slf: *const Self = self;
        unsafe { slice::from_raw_parts(slf.cast::<u8>(), len) }
    }
}

// SAFETY: `u32` has a defined representation and no padding.
unsafe impl IntoBytes for u32 {}
```

<details>

There should be a `# Safety` section on the Rustdoc for the trait explaining the
requirements for the trait to be safely implemented.

The actual safety section for `IntoBytes` is rather longer and more complicated.

The built-in `Send` and `Sync` traits are unsafe.

</details>



================================================
FILE: src/unsafe-rust/unsafe.md
================================================
---
minutes: 5
---

# Unsafe Rust

The Rust language has two parts:

- **Safe Rust:** memory safe, no undefined behavior possible.
- **Unsafe Rust:** can trigger undefined behavior if preconditions are violated.

We saw mostly safe Rust in this course, but it's important to know what Unsafe
Rust is.

Unsafe code is usually small and isolated, and its correctness should be
carefully documented. It is usually wrapped in a safe abstraction layer.

Unsafe Rust gives you access to five new capabilities:

- Dereference raw pointers.
- Access or modify mutable static variables.
- Access `union` fields.
- Call `unsafe` functions, including `extern` functions.
- Implement `unsafe` traits.

We will briefly cover unsafe capabilities next. For full details, please see
[Chapter 19.1 in the Rust Book](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)
and the [Rustonomicon](https://doc.rust-lang.org/nomicon/).

<details>

Unsafe Rust does not mean the code is incorrect. It means that developers have
turned off some compiler safety features and have to write correct code by
themselves. It means the compiler no longer enforces Rust's memory-safety rules.

</details>



================================================
FILE: src/unsafe-rust/unsafe-functions/calling.md
================================================
# Calling Unsafe Functions

Failing to uphold the safety requirements breaks memory safety!

```rust,editable
#[derive(Debug)]
#[repr(C)]
struct KeyPair {
    pk: [u16; 4], // 8 bytes
    sk: [u16; 4], // 8 bytes
}

const PK_BYTE_LEN: usize = 8;

fn log_public_key(pk_ptr: *const u16) {
    let pk: &[u16] = unsafe { std::slice::from_raw_parts(pk_ptr, PK_BYTE_LEN) };
    println!("{pk:?}");
}

fn main() {
    let key_pair = KeyPair { pk: [1, 2, 3, 4], sk: [0, 0, 42, 0] };
    log_public_key(key_pair.pk.as_ptr());
}
```

Always include a safety comment for each `unsafe` block. It must explain why the
code is actually safe. This example is missing a safety comment and is unsound.

<details>

Key points:

- The second argument to `slice::from_raw_parts` is the number of _elements_,
  not bytes! This example demonstrates unexpected behavior by reading past the
  end of one array and into another.
- This is undefined behavior because we're reading past the end of the array
  that the pointer was derived from.
- `log_public_key` should be unsafe, because `pk_ptr` must meet certain
  prerequisites to avoid undefined behaviour. A safe function which can cause
  undefined behaviour is said to be `unsound`. What should its safety
  documentation say?
- The standard library contains many low-level unsafe functions. Prefer the safe
  alternatives when possible!
- If you use an unsafe function as an optimization, make sure to add a benchmark
  to demonstrate the gain.

</details>



================================================
FILE: src/unsafe-rust/unsafe-functions/extern-c.md
================================================
# Unsafe External Functions

You can declare foreign functions for access from Rust with `unsafe extern`.
This is unsafe because the compiler has to way to reason about their behavior.
Functions declared in an `extern` block must be marked as `safe` or `unsafe`,
depending on whether they have preconditions for safe use:

```rust,editable
use std::ffi::c_char;

unsafe extern "C" {
    // `abs` doesn't deal with pointers and doesn't have any safety requirements.
    safe fn abs(input: i32) -> i32;

    /// # Safety
    ///
    /// `s` must be a pointer to a NUL-terminated C string which is valid and
    /// not modified for the duration of this function call.
    unsafe fn strlen(s: *const c_char) -> usize;
}

fn main() {
    println!("Absolute value of -3 according to C: {}", abs(-3));

    unsafe {
        // SAFETY: We pass a pointer to a C string literal which is valid for
        // the duration of the program.
        println!("String length: {}", strlen(c"String".as_ptr()));
    }
}
```

<details>

- Rust used to consider all extern functions unsafe, but this changed in Rust
  1.82 with `unsafe extern` blocks.
- `abs` must be explicitly marked as `safe` because it is an external function
  (FFI). Calling external functions is usually only a problem when those
  functions do things with pointers which might violate Rust's memory model, but
  in general any C function might have undefined behaviour under any arbitrary
  circumstances.
- The `"C"` in this example is the ABI;
  [other ABIs are available too](https://doc.rust-lang.org/reference/items/external-blocks.html).
- Note that there is no verification that the Rust function signature matches
  that of the function definition -- that's up to you!

</details>



================================================
FILE: src/unsafe-rust/unsafe-functions/rust.md
================================================
# Unsafe Rust Functions

You can mark your own functions as `unsafe` if they require particular
preconditions to avoid undefined behaviour.

```rust,editable
/// Swaps the values pointed to by the given pointers.
///
/// # Safety
///
/// The pointers must be valid, properly aligned, and not otherwise accessed for
/// the duration of the function call.
unsafe fn swap(a: *mut u8, b: *mut u8) {
    // SAFETY: Our caller promised that the pointers are valid, properly aligned
    // and have no other access.
    unsafe {
        let temp = *a;
        *a = *b;
        *b = temp;
    }
}

fn main() {
    let mut a = 42;
    let mut b = 66;

    // SAFETY: The pointers must be valid, aligned and unique because they came
    // from references.
    unsafe {
        swap(&mut a, &mut b);
    }

    println!("a = {}, b = {}", a, b);
}
```

<details>

We wouldn't actually use pointers for a `swap` function --- it can be done
safely with references.

Note that Rust 2021 and earlier allow unsafe code within an unsafe function
without an `unsafe` block. This changed in the 2024 edition. We can prohibit it
in older editions with `#[deny(unsafe_op_in_unsafe_fn)]`. Try adding it and see
what happens.

</details>



================================================
FILE: src/user-defined-types/aliases.md
================================================
---
minutes: 2
---

# Type Aliases

A type alias creates a name for another type. The two types can be used
interchangeably.

```rust,editable
enum CarryableConcreteItem {
    Left,
    Right,
}

type Item = CarryableConcreteItem;

// Aliases are more useful with long, complex types:
use std::cell::RefCell;
use std::sync::{Arc, RwLock};
type PlayerInventory = RwLock<Vec<Arc<RefCell<Item>>>>;
```

<details>

- A [newtype](tuple-structs.html) is often a better alternative since it creates
  a distinct type. Prefer `struct InventoryCount(usize)` to
  `type InventoryCount = usize`.

- C programmers will recognize this as similar to a `typedef`.

</details>



================================================
FILE: src/user-defined-types/Cargo.toml
================================================
[package]
name = "user-defined-types"
version = "0.1.0"
edition = "2024"
publish = false

[[bin]]
name = "elevator"
path = "exercise.rs"



================================================
FILE: src/user-defined-types/const.md
================================================
---
minutes: 10
---

# `const`

Constants are evaluated at compile time and their values are [inlined][1]
wherever they are used:

<!-- mdbook-xgettext: skip -->

```rust,editable
const DIGEST_SIZE: usize = 3;
const FILL_VALUE: u8 = calculate_fill_value();

const fn calculate_fill_value() -> u8 {
    if DIGEST_SIZE < 10 { 42 } else { 13 }
}

fn compute_digest(text: &str) -> [u8; DIGEST_SIZE] {
    let mut digest = [FILL_VALUE; DIGEST_SIZE];
    for (idx, &b) in text.as_bytes().iter().enumerate() {
        digest[idx % DIGEST_SIZE] = digest[idx % DIGEST_SIZE].wrapping_add(b);
    }
    digest
}

fn main() {
    let digest = compute_digest("Hello");
    println!("digest: {digest:?}");
}
```

Only functions marked `const` can be called at compile time to generate `const`
values. `const` functions can however be called at runtime.

<details>

- Mention that `const` behaves semantically similar to C++'s `constexpr`

</details>

[1]: https://rust-lang.github.io/rfcs/0246-const-vs-static.html



================================================
FILE: src/user-defined-types/enums.md
================================================
---
minutes: 5
---

# Enums

The `enum` keyword allows the creation of a type which has a few different
variants:

```rust,editable
#[derive(Debug)]
enum Direction {
    Left,
    Right,
}

#[derive(Debug)]
enum PlayerMove {
    Pass,                        // Simple variant
    Run(Direction),              // Tuple variant
    Teleport { x: u32, y: u32 }, // Struct variant
}

fn main() {
    let dir = Direction::Left;
    let player_move: PlayerMove = PlayerMove::Run(dir);
    println!("On this turn: {player_move:?}");
}
```

<details>

Key Points:

- Enumerations allow you to collect a set of values under one type.
- `Direction` is a type with variants. There are two values of `Direction`:
  `Direction::Left` and `Direction::Right`.
- `PlayerMove` is a type with three variants. In addition to the payloads, Rust
  will store a discriminant so that it knows at runtime which variant is in a
  `PlayerMove` value.
- This might be a good time to compare structs and enums:
  - In both, you can have a simple version without fields (unit struct) or one
    with different types of fields (variant payloads).
  - You could even implement the different variants of an enum with separate
    structs but then they wouldn’t be the same type as they would if they were
    all defined in an enum.
- Rust uses minimal space to store the discriminant.
  - If necessary, it stores an integer of the smallest required size
  - If the allowed variant values do not cover all bit patterns, it will use
    invalid bit patterns to encode the discriminant (the "niche optimization").
    For example, `Option<&u8>` stores either a pointer to an integer or `NULL`
    for the `None` variant.
  - You can control the discriminant if needed (e.g., for compatibility with C):

    <!-- mdbook-xgettext: skip -->
    ```rust,editable
    #[repr(u32)]
    enum Bar {
        A, // 0
        B = 10000,
        C, // 10001
    }

    fn main() {
        println!("A: {}", Bar::A as u32);
        println!("B: {}", Bar::B as u32);
        println!("C: {}", Bar::C as u32);
    }
    ```

    Without `repr`, the discriminant type takes 2 bytes, because 10001 fits 2
    bytes.

## More to Explore

Rust has several optimizations it can employ to make enums take up less space.

- Null pointer optimization: For
  [some types](https://doc.rust-lang.org/std/option/#representation), Rust
  guarantees that `size_of::<T>()` equals `size_of::<Option<T>>()`.

  Example code if you want to show how the bitwise representation _may_ look
  like in practice. It's important to note that the compiler provides no
  guarantees regarding this representation, therefore this is totally unsafe.

  <!-- mdbook-xgettext: skip -->
  ```rust,editable
  use std::mem::transmute;

  macro_rules! dbg_bits {
      ($e:expr, $bit_type:ty) => {
          println!("- {}: {:#x}", stringify!($e), transmute::<_, $bit_type>($e));
      };
  }

  fn main() {
      unsafe {
          println!("bool:");
          dbg_bits!(false, u8);
          dbg_bits!(true, u8);

          println!("Option<bool>:");
          dbg_bits!(None::<bool>, u8);
          dbg_bits!(Some(false), u8);
          dbg_bits!(Some(true), u8);

          println!("Option<Option<bool>>:");
          dbg_bits!(Some(Some(false)), u8);
          dbg_bits!(Some(Some(true)), u8);
          dbg_bits!(Some(None::<bool>), u8);
          dbg_bits!(None::<Option<bool>>, u8);

          println!("Option<&i32>:");
          dbg_bits!(None::<&i32>, usize);
          dbg_bits!(Some(&0i32), usize);
      }
  }
  ```

</details>



================================================
FILE: src/user-defined-types/exercise.md
================================================
---
minutes: 15
---

# Exercise: Elevator Events

We will create a data structure to represent an event in an elevator control
system. It is up to you to define the types and functions to construct various
events. Use `#[derive(Debug)]` to allow the types to be formatted with `{:?}`.

This exercise only requires creating and populating data structures so that
`main` runs without errors. The next part of the course will cover getting data
out of these structures.

```rust,editable,should_panic
{{#include exercise.rs:event}}
    // TODO: add required variants
}

{{#include exercise.rs:direction}}

{{#include exercise.rs:car_arrived}}
    todo!()
}

{{#include exercise.rs:car_door_opened}}
    todo!()
}

{{#include exercise.rs:car_door_closed}}
    todo!()
}

{{#include exercise.rs:lobby_call_button_pressed}}
    todo!()
}

{{#include exercise.rs:car_floor_button_pressed}}
    todo!()
}

{{#include exercise.rs:main}}
```

<details>

- If students ask about `#![allow(dead_code)]` at the top of the exercise, it's
  necessary because the only thing we do with the `Event` type is print it out.
  Due to a nuance of how the compiler checks for dead code this causes it to
  think the code is unused. They can ignore it for the purpose of this exercise.

</details>



================================================
FILE: src/user-defined-types/exercise.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: solution
// ANCHOR: event
#![allow(dead_code)]

#[derive(Debug)]
/// An event in the elevator system that the controller must react to.
enum Event {
    // ANCHOR_END: event
    /// A button was pressed.
    ButtonPressed(Button),

    /// The car has arrived at the given floor.
    CarArrived(Floor),

    /// The car's doors have opened.
    CarDoorOpened,

    /// The car's doors have closed.
    CarDoorClosed,
}

/// A floor is represented as an integer.
type Floor = i32;

// ANCHOR: direction
/// A direction of travel.
#[derive(Debug)]
enum Direction {
    Up,
    Down,
}
// ANCHOR_END: direction

/// A user-accessible button.
#[derive(Debug)]
enum Button {
    /// A button in the elevator lobby on the given floor.
    LobbyCall(Direction, Floor),

    /// A floor button within the car.
    CarFloor(Floor),
}

// ANCHOR: car_arrived
/// The car has arrived on the given floor.
fn car_arrived(floor: i32) -> Event {
    // ANCHOR_END: car_arrived
    Event::CarArrived(floor)
}

// ANCHOR: car_door_opened
/// The car doors have opened.
fn car_door_opened() -> Event {
    // ANCHOR_END: car_door_opened
    Event::CarDoorOpened
}

// ANCHOR: car_door_closed
/// The car doors have closed.
fn car_door_closed() -> Event {
    // ANCHOR_END: car_door_closed
    Event::CarDoorClosed
}

// ANCHOR: lobby_call_button_pressed
/// A directional button was pressed in an elevator lobby on the given floor.
fn lobby_call_button_pressed(floor: i32, dir: Direction) -> Event {
    // ANCHOR_END: lobby_call_button_pressed
    Event::ButtonPressed(Button::LobbyCall(dir, floor))
}

// ANCHOR: car_floor_button_pressed
/// A floor button was pressed in the elevator car.
fn car_floor_button_pressed(floor: i32) -> Event {
    // ANCHOR_END: car_floor_button_pressed
    Event::ButtonPressed(Button::CarFloor(floor))
}

// ANCHOR: main
fn main() {
    println!(
        "A ground floor passenger has pressed the up button: {:?}",
        lobby_call_button_pressed(0, Direction::Up)
    );
    println!("The car has arrived on the ground floor: {:?}", car_arrived(0));
    println!("The car door opened: {:?}", car_door_opened());
    println!(
        "A passenger has pressed the 3rd floor button: {:?}",
        car_floor_button_pressed(3)
    );
    println!("The car door closed: {:?}", car_door_closed());
    println!("The car has arrived on the 3rd floor: {:?}", car_arrived(3));
}
// ANCHOR_END: main



================================================
FILE: src/user-defined-types/named-structs.md
================================================
---
minutes: 10
---

# Named Structs

Like C and C++, Rust has support for custom structs:

<!-- dprint-ignore-start -->

```rust,editable
struct Person {
    name: String,
    age: u8,
}

fn describe(person: &Person) {
    println!("{} is {} years old", person.name, person.age);
}

fn main() {
    let mut peter = Person {
        name: String::from("Peter"),
        age: 27,
    };
    describe(&peter);

    peter.age = 28;
    describe(&peter);

    let name = String::from("Avery");
    let age = 39;
    let avery = Person { name, age };
    describe(&avery);
}
```

<!-- dprint-ignore-end -->

<details>

Key Points:

- Structs work like in C or C++.
  - Like in C++, and unlike in C, no typedef is needed to define a type.
  - Unlike in C++, there is no inheritance between structs.
- This may be a good time to let people know there are different types of
  structs.
  - Zero-sized structs (e.g. `struct Foo;`) might be used when implementing a
    trait on some type but don’t have any data that you want to store in the
    value itself.
  - The next slide will introduce Tuple structs, used when the field names are
    not important.
- If you already have variables with the right names, then you can create the
  struct using a shorthand.
- Struct fields do not support default values. Default values are specified by
  implementing the `Default` trait which we will cover later.

## More to Explore

- You can also demonstrate the struct update syntax here:

  ```rust,ignore
  let jackie = Person { name: String::from("Jackie"), ..avery };
  ```

- It allows us to copy the majority of the fields from the old struct without
  having to explicitly type it all out. It must always be the last element.

- It is mainly used in combination with the `Default` trait. We will talk about
  struct update syntax in more detail on the slide on the `Default` trait, so we
  don't need to talk about it here unless students ask about it.

</details>



================================================
FILE: src/user-defined-types/solution.md
================================================
# Solution

```rust,editable
{{#include exercise.rs:solution}}
```



================================================
FILE: src/user-defined-types/static.md
================================================
---
minutes: 5
---

# `static`

Static variables will live during the whole execution of the program, and
therefore will not move:

```rust,editable
static BANNER: &str = "Welcome to RustOS 3.14";

fn main() {
    println!("{BANNER}");
}
```

As noted in the [Rust RFC Book][1], these are not inlined upon use and have an
actual associated memory location. This is useful for unsafe and embedded code,
and the variable lives through the entirety of the program execution. When a
globally-scoped value does not have a reason to need object identity, `const` is
generally preferred.

<details>

- `static` is similar to mutable global variables in C++.
- `static` provides object identity: an address in memory and state as required
  by types with interior mutability such as `Mutex<T>`.

# More to Explore

Because `static` variables are accessible from any thread, they must be `Sync`.
Interior mutability is possible through a
[`Mutex`](https://doc.rust-lang.org/std/sync/struct.Mutex.html), atomic or
similar.

It is common to use `OnceLock` in a static as a way to support initialization on
first use. `OnceCell` is not `Sync` and thus cannot be used in this context.

Thread-local data can be created with the macro `std::thread_local`.

</details>

[1]: https://rust-lang.github.io/rfcs/0246-const-vs-static.html



================================================
FILE: src/user-defined-types/tuple-structs.md
================================================
---
minutes: 10
---

# Tuple Structs

If the field names are unimportant, you can use a tuple struct:

```rust,editable
struct Point(i32, i32);

fn main() {
    let p = Point(17, 23);
    println!("({}, {})", p.0, p.1);
}
```

This is often used for single-field wrappers (called newtypes):

```rust,editable,compile_fail
struct PoundsOfForce(f64);
struct Newtons(f64);

fn compute_thruster_force() -> PoundsOfForce {
    todo!("Ask a rocket scientist at NASA")
}

fn set_thruster_force(force: Newtons) {
    // ...
}

fn main() {
    let force = compute_thruster_force();
    set_thruster_force(force);
}
```

<details>

- Newtypes are a great way to encode additional information about the value in a
  primitive type, for example:
  - The number is measured in some units: `Newtons` in the example above.
  - The value passed some validation when it was created, so you no longer have
    to validate it again at every use: `PhoneNumber(String)` or
    `OddNumber(u32)`.
- The newtype pattern is covered extensively in the
  ["Idiomatic Rust" module](../idiomatic/leveraging-the-type-system/newtype-pattern.md).
- Demonstrate how to add a `f64` value to a `Newtons` type by accessing the
  single field in the newtype.
  - Rust generally avoids implicit conversions, like automatic unwrapping or
    using booleans as integers.
    - Operator overloading is discussed on Day 2
      ([Standard Library Traits](../std-traits.md)).
- When a tuple struct has zero fields, the `()` can be omitted. The result is a
  zero-sized type (ZST), of which there is only one value (the name of the
  type).
  - This is common for types that implement some behavior but have no data
    (imagine a `NullReader` that implements some reader behavior by always
    returning EOF).
- The example is a subtle reference to the
  [Mars Climate Orbiter](https://en.wikipedia.org/wiki/Mars_Climate_Orbiter)
  failure.

</details>



================================================
FILE: tests/README.md
================================================
# Testing Comprehensive Rust

The course material contains JS code that can break and needs to be checked for
functionality. Examples are `theme/speaker-notes.js` or `theme/book.js`.

Comprehensive Rust is using [webdriverIO](https://webdriver.io/) and the
[webdriverIO Expect API](https://webdriver.io/docs/api/expect-webdriverio/) in
combination with [Mocha](https://mochajs.org/). WebdriverIO is taking care of
accessing the webpage with a real browser and can access the state of the page
so behavior can be asserted.

The [Static Server Service](https://webdriver.io/docs/static-server-service/) is
used mainly in the [CI](../.github/workflows/build.yml) to serve the book on
port `localhost:8080` such that the test runner can access it. This mode is used
when `npm start` or `npm test` is executed.

> **Tip:** Use `cargo xtask web-tests` to run the tests in this directory from
> anywhere in the repository.

For local testing and quick iterations it is possible to use `mdbook serve`
which creates a small HTTP server on port 3000 by default. There is a special
config that is invoked with `npm run test-mdbook` that uses
`http://localhost:3000`



================================================
FILE: tests/package.json
================================================
{
  "name": "test",
  "type": "module",
  "devDependencies": {
    "@types/mocha": "^10.0.10",
    "@wdio/cli": "^9.19.2",
    "@wdio/local-runner": "^9.5.3",
    "@wdio/mocha-framework": "^9.5.0",
    "@wdio/static-server-service": "^9.5.0"
  },
  "scripts": {
    "start": "npm run test",
    "test": "wdio run ./wdio.conf.ts",
    "test-mdbook": "wdio run ./wdio.conf-mdbook.ts"
  }
}



================================================
FILE: tests/tsconfig.json
================================================
{
  "compilerOptions": {
    // This implicitly sets moduleResolution to "node16"
    // https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-resolution-is-host-defined
    "module": "Node18",
    "target": "ES2024",
    "lib": [
      // https://www.typescriptlang.org/tsconfig/#lib
      // include APIs that are enabled by ES2024
      "ES2024",
      // DOM definitions, window, document, etc.
      "DOM"
    ],
    "types": [
      "node",
      "@wdio/globals/types",
      "expect-webdriverio",
      "@wdio/mocha-framework"
    ],
    "skipLibCheck": true,
    "noEmit": true,
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": [
    "src/**/*.ts",
    "wdio.conf.ts"
  ]
}



================================================
FILE: tests/wdio.conf-mdbook.ts
================================================
import { deepmerge } from "deepmerge-ts";
import { config as default_config } from "./wdio.conf.js";

// have main config file as default but overwrite how the code is served
export const config = deepmerge(
  default_config,
  {
    // use the mdbook served content
    baseUrl: "http://localhost:3000",
    // clean services
    services: [],
  },
  { clone: false },
);



================================================
FILE: tests/wdio.conf.ts
================================================
import { env } from "node:process";
export const config: WebdriverIO.Config = {
  //
  // ====================
  // Runner Configuration
  // ====================
  // WebdriverIO supports running e2e tests as well as unit and component tests.
  runner: "local",
  tsConfigPath: "./tsconfig.json",

  //
  // ==================
  // Specify Test Files
  // ==================
  // Define which test specs should run. The pattern is relative to the directory
  // of the configuration file being run.
  //
  // The specs are defined as an array of spec files (optionally using wildcards
  // that will be expanded). The test for each spec file will be run in a separate
  // worker process. In order to have a group of spec files run in the same worker
  // process simply enclose them in an array within the specs array.
  //
  // The path of the spec files will be resolved relative from the directory of
  // of the config file unless it's absolute.
  //
  specs: ["./src/**/*.test.ts"],
  // Patterns to exclude.
  exclude: [
    // 'path/to/excluded/files'
  ],
  //
  // ============
  // Capabilities
  // ============
  // Define your capabilities here. WebdriverIO can run multiple capabilities at the same
  // time. Depending on the number of capabilities, WebdriverIO launches several test
  // sessions. Within your capabilities you can overwrite the spec and exclude options in
  // order to group specific specs to a specific capability.
  //
  // First, you can define how many instances should be started at the same time. Let's
  // say you have 3 different capabilities (Chrome, Firefox, and Safari) and you have
  // set maxInstances to 1; wdio will spawn 3 processes. Therefore, if you have 10 spec
  // files and you set maxInstances to 10, all spec files will get tested at the same time
  // and 30 processes will get spawned. The property handles how many capabilities
  // from the same test should run tests.
  //
  maxInstances: 10,
  //
  // If you have trouble getting all important capabilities together, check out the
  // Sauce Labs platform configurator - a great tool to configure your capabilities:
  // https://saucelabs.com/platform/platform-configurator
  //
  capabilities: [
    {
      // capabilities for local browser web tests
      browserName: "chrome",
      "goog:chromeOptions": {
        // In Github CI this variable is set to true
        args: env.CI
          ? // In CI, we use additional flags for stability.
            [
              "--headless",
              "--disable-gpu",
              "--no-sandbox",
              "--disable-dev-shm-usage",
            ]
          : // For local runs, you can comment out the line below to see the browser
            ["--headless"],
      },
    },
  ],

  //
  // ===================
  // Test Configurations
  // ===================
  // Define all options that are relevant for the WebdriverIO instance here
  //
  // Level of logging verbosity: trace | debug | info | warn | error | silent
  logLevel: "warn",
  //
  // Set specific log levels per logger
  // loggers:
  // - webdriver, webdriverio
  // - @wdio/browserstack-service, @wdio/lighthouse-service, @wdio/sauce-service
  // - @wdio/mocha-framework, @wdio/jasmine-framework
  // - @wdio/local-runner
  // - @wdio/sumologic-reporter
  // - @wdio/cli, @wdio/config, @wdio/utils
  // Level of logging verbosity: trace | debug | info | warn | error | silent
  // logLevels: {
  //     webdriver: 'info',
  //     '@wdio/appium-service': 'info'
  // },
  logLevels: {
    // Webdriverio outputs several lines per test, in the success case.
    webdriverio: "error",
  },
  // If you only want to run your tests until a specific amount of tests have failed use
  // bail (default is 0 - don't bail, run all tests).
  bail: 0,
  //
  // Set a base URL in order to shorten url command calls. If your `url` parameter starts
  // with `/`, the base url gets prepended, not including the path portion of your baseUrl.
  // If your `url` parameter starts without a scheme or `/` (like `some/path`), the base url
  // gets prepended directly.
  baseUrl: "http://localhost:8080",
  //
  // Default timeout for all waitFor* commands.
  waitforTimeout: 10000,
  //
  // Default timeout in milliseconds for request
  // if browser driver or grid doesn't send response
  connectionRetryTimeout: 120000,
  //
  // Default request retries count
  connectionRetryCount: 3,
  //
  // Test runner services
  // Services take over a specific job you don't want to take care of. They enhance
  // your test setup with almost no effort. Unlike plugins, they don't add new
  // commands. Instead, they hook themselves up into the test process.
  services: [
    [
      "static-server",
      {
        port: 8080,
        // use the environment variable "TEST_BOOK_DIR" if available or default to ""../book/html"
        folders: [{ mount: "/", path: env.TEST_BOOK_DIR || "../book/html" }],
      },
    ],
  ],
  //
  // Framework you want to run your specs with.
  // The following are supported: Mocha, Jasmine, and Cucumber
  // see also: https://webdriver.io/docs/frameworks
  //
  // Make sure you have the wdio adapter package for the specific framework installed
  // before running any tests.
  framework: "mocha",

  //
  // The number of times to retry the entire specfile when it fails as a whole
  // specFileRetries: 1,
  //
  // Delay in seconds between the spec file retry attempts
  // specFileRetriesDelay: 0,
  //
  // Whether or not retried spec files should be retried immediately or deferred to the end of the queue
  // specFileRetriesDeferred: false,
  //
  // Test reporter for stdout.
  // The only one supported by default is 'dot'
  // see also: https://webdriver.io/docs/dot-reporter
  // reporters: ['dot'],

  // Options to be passed to Mocha.
  // See the full list at http://mochajs.org/
  mochaOpts: {
    ui: "bdd",
    timeout: 60000,
  },

  //
  // =====
  // Hooks
  // =====
  // WebdriverIO provides several hooks you can use to interfere with the test process in order to enhance
  // it and to build services around it. You can either apply a single function or an array of
  // methods to it. If one of them returns with a promise, WebdriverIO will wait until that promise got
  // resolved to continue.
  /**
   * Gets executed once before all workers get launched.
   * @param {object} config wdio configuration object
   * @param {Array.<Object>} capabilities list of capabilities details
   */
  // onPrepare: function (config, capabilities) {
  // },
  /**
   * Gets executed before a worker process is spawned and can be used to initialize specific service
   * for that worker as well as modify runtime environments in an async fashion.
   * @param  {string} cid      capability id (e.g 0-0)
   * @param  {object} caps     object containing capabilities for session that will be spawn in the worker
   * @param  {object} specs    specs to be run in the worker process
   * @param  {object} args     object that will be merged with the main configuration once worker is initialized
   * @param  {object} execArgv list of string arguments passed to the worker process
   */
  // onWorkerStart: function (cid, caps, specs, args, execArgv) {
  // },
  /**
   * Gets executed just after a worker process has exited.
   * @param  {string} cid      capability id (e.g 0-0)
   * @param  {number} exitCode 0 - success, 1 - fail
   * @param  {object} specs    specs to be run in the worker process
   * @param  {number} retries  number of retries used
   */
  // onWorkerEnd: function (cid, exitCode, specs, retries) {
  // },
  /**
   * Gets executed just before initialising the webdriver session and test framework. It allows you
   * to manipulate configurations depending on the capability or spec.
   * @param {object} config wdio configuration object
   * @param {Array.<Object>} capabilities list of capabilities details
   * @param {Array.<String>} specs List of spec file paths that are to be run
   * @param {string} cid worker id (e.g. 0-0)
   */
  // beforeSession: function (config, capabilities, specs, cid) {
  // },
  /**
   * Gets executed before test execution begins. At this point you can access to all global
   * variables like `browser`. It is the perfect place to define custom commands.
   * @param {Array.<Object>} capabilities list of capabilities details
   * @param {Array.<String>} specs        List of spec file paths that are to be run
   * @param {object}         browser      instance of created browser/device session
   */
  before: function (capabilities, specs) {
    browser.setWindowSize(2560, 1440);
  },
  /**
   * Runs before a WebdriverIO command gets executed.
   * @param {string} commandName hook command name
   * @param {Array} args arguments that command would receive
   */
  // beforeCommand: function (commandName, args) {
  // },
  /**
   * Hook that gets executed before the suite starts
   * @param {object} suite suite details
   */
  // beforeSuite: function (suite) {
  // },
  /**
   * Function to be executed before a test (in Mocha/Jasmine) starts.
   */
  // beforeTest: function (test, context) {
  // },
  /**
   * Hook that gets executed _before_ a hook within the suite starts (e.g. runs before calling
   * beforeEach in Mocha)
   */
  // beforeHook: function (test, context, hookName) {
  // },
  /**
   * Hook that gets executed _after_ a hook within the suite starts (e.g. runs after calling
   * afterEach in Mocha)
   */
  // afterHook: function (test, context, { error, result, duration, passed, retries }, hookName) {
  // },
  /**
   * Function to be executed after a test (in Mocha/Jasmine only)
   * @param {object}  test             test object
   * @param {object}  context          scope object the test was executed with
   * @param {Error}   result.error     error object in case the test fails, otherwise `undefined`
   * @param {*}       result.result    return object of test function
   * @param {number}  result.duration  duration of test
   * @param {boolean} result.passed    true if test has passed, otherwise false
   * @param {object}  result.retries   information about spec related retries, e.g. `{ attempts: 0, limit: 0 }`
   */
  // afterTest: function(test, context, { error, result, duration, passed, retries }) {
  // },

  /**
   * Hook that gets executed after the suite has ended
   * @param {object} suite suite details
   */
  // afterSuite: function (suite) {
  // },
  /**
   * Runs after a WebdriverIO command gets executed
   * @param {string} commandName hook command name
   * @param {Array} args arguments that command would receive
   * @param {number} result 0 - command success, 1 - command error
   * @param {object} error error object if any
   */
  // afterCommand: function (commandName, args, result, error) {
  // },
  /**
   * Gets executed after all tests are done. You still have access to all global variables from
   * the test.
   * @param {number} result 0 - test pass, 1 - test fail
   * @param {Array.<Object>} capabilities list of capabilities details
   * @param {Array.<String>} specs List of spec file paths that ran
   */
  // after: function (result, capabilities, specs) {
  // },
  /**
   * Gets executed right after terminating the webdriver session.
   * @param {object} config wdio configuration object
   * @param {Array.<Object>} capabilities list of capabilities details
   * @param {Array.<String>} specs List of spec file paths that ran
   */
  // afterSession: function (config, capabilities, specs) {
  // },
  /**
   * Gets executed after all workers got shut down and the process is about to exit. An error
   * thrown in the onComplete hook will result in the test run failing.
   * @param {object} exitCode 0 - success, 1 - fail
   * @param {object} config wdio configuration object
   * @param {Array.<Object>} capabilities list of capabilities details
   * @param {<Object>} results object containing test results
   */
  // onComplete: function(exitCode, config, capabilities, results) {
  // },
  /**
   * Gets executed when a refresh happens.
   * @param {string} oldSessionId session ID of the old session
   * @param {string} newSessionId session ID of the new session
   */
  // onReload: function(oldSessionId, newSessionId) {
  // }
  /**
   * Hook that gets executed before a WebdriverIO assertion happens.
   * @param {object} params information about the assertion to be executed
   */
  // beforeAssertion: function(params) {
  // }
  /**
   * Hook that gets executed after a WebdriverIO assertion happened.
   * @param {object} params information about the assertion that was executed, including its results
   */
  // afterAssertion: function(params) {
  // }
};



================================================
FILE: tests/src/generic-page.test.ts
================================================
import { describe, it } from "mocha";
import { expect, browser, $ } from "@wdio/globals";

describe("Generic page", () => {
  beforeEach(async () => {
    await browser.url("/");
  });

  it("should have the default_theme light", async () => {
    expect(await browser.execute(() => window.default_theme)).toBe("light");
  });

  it("should have theme button and show theme list on click", async () => {
    await expect($("#theme-toggle")).toBeDisplayed();
    await $("#theme-toggle").click();
    await expect($("#theme-list")).toBeDisplayed();
  });

  it("should have search button and successfully provide search results on search", async () => {
    await expect($("#search-toggle")).toBeDisplayed();
    await $("#search-toggle").click();
    await browser.keys(["Welcome"]);
    // any of the <a> links in the searchresults is containing "Welcome"
    await expect($("#searchresults").$("*=Welcome")).toBeDisplayed();
  });

  it("should have language button and show language list on click", async () => {
    await expect($("#language-toggle")).toBeDisplayed();
    await $("#language-toggle").click();
    await expect($("#language-list")).toBeDisplayed();
  });
});



================================================
FILE: tests/src/playground.test.ts
================================================
import { describe, it } from "mocha";
import { expect, browser } from "@wdio/globals";
import { Key } from "webdriverio";
import Playground from "./objects/playground";

describe("Playground", () => {
  beforeEach(async () => {
    // this page contains a hello world playground
    await browser.url("/hello-world/hello-world.html");
  });

  it("exists and is shown but output fields do not yet exist", async () => {
    const playground = new Playground();
    // ensure a playground exists and pre-state is as expected
    await expect(playground.area).toExist();
    await expect(playground.start_button).toExist();
    await expect(playground.start_button).not.toBeDisplayed();
    await expect(playground.stderr).not.toExist();
    await expect(playground.stdout).not.toExist();
  });

  it("executes the hello world code and prints the hello message", async () => {
    const playground = new Playground();
    await playground.mock_success("Hello world!\n");
    await playground.activate();
    await playground.run();

    await expect(playground.stdout).toBeDisplayed();
    await expect(playground.stderr).not.toBeDisplayed();
    await expect(playground.stdout).toHaveText("Hello world!");
  });

  it("shows error messages in stderr if the code is broken", async () => {
    const playground = new Playground();
    await playground.mock_fail();
    await playground.activate();
    // append some failing code to the editor that is now in focus
    await browser.keys([Key.Enter, "fn expect_failure()"]);
    await playground.run();

    await expect(playground.stdout).toBeDisplayed();
    await expect(playground.stderr).toBeDisplayed();
    // check for error message in stderr
    await expect(playground.stderr).toHaveText(
      expect.stringContaining("error: could not compile"),
    );
    await expect(playground.stdout).toHaveText("No output");
  });
});



================================================
FILE: tests/src/slide-style-guide.test.ts
================================================
/**
 * This file contains tests that check the style of the slides.
 * It checks that the slides are not too high or wide and that
 * the code examples are not too wide or high based on the visibility of scrollbars.
 *
 * Slides that exist on the exemptions lists are tested for that violation
 * and if they are not violating the style, this alerts and the author should remove
 * the slide from the exemption list. This acts as a regression check.
 */
import { describe, it } from "mocha";
import { expect } from "@wdio/globals";
import { slides } from "./slides/slides.list.ts";
import {
  playground_size_exemptions,
  size_exemptions,
} from "./slides/slide-exemptions.list.ts";
import Slide from "./objects/slide.ts";

// these are empirically determined values in 16:9 ratio
const MAX_HEIGHT = 1333;
const MAX_WIDTH = 750;

const slide = new Slide();
slides.forEach((slide_path) => {
  describe("Slide " + slide_path, () => {
    before(async () => {
      slide.load(slide_path);
    });

    // slide size evaluation
    if (size_exemptions.includes(slide_path)) {
      // This slide is exempted and violated rules before.
      // It is expected to still do this and if not it should be removed from exemptions.
      // This acts as a regression check
      it("is on the exemption list but should be removed from size_exemptions in slide-exemptions.list.ts", async () => {
        const main_element = slide.main_content;
        console.info("slide " + slide_path + " is on the exemption list");
        expect(
          await slide.violates_max_size(main_element, MAX_HEIGHT, MAX_WIDTH),
        ).toBe(true);
      });
    } else {
      it(
        "should not be higher than " +
          MAX_HEIGHT +
          " pixels or wider than " +
          MAX_WIDTH +
          " pixels",
        async () => {
          const main_element = slide.main_content;
          expect(
            await slide.violates_max_size(main_element, MAX_HEIGHT, MAX_WIDTH),
          ).toBe(false);
        },
      );
    }

    // playground code examples are not too wide
    if (playground_size_exemptions.includes(slide_path)) {
      it("is on the exemption list but should be removed from playground_size_exemptions in slide-exemptions.list.ts", async () => {
        // This slide is exempted and violated rules before.
        // It is expected to still do this and if not it should be removed from exemptions.
        // This acts as a regression check
        await Promise.any([
          expect(slide.scrollbar_h).toBeDisplayed(),
          expect(slide.scrollbar_v).toBeDisplayed(),
        ]);
      });
    } else {
      it("should not show a scrollbar", async () => {
        if (await slide.has_code_example) {
          await Promise.all([
            expect(slide.scrollbar_h).not.toBeDisplayed(),
            expect(slide.scrollbar_v).not.toBeDisplayed(),
          ]);
        }
      });
    }
  });
});



================================================
FILE: tests/src/speaker-notes.test.ts
================================================
import { describe, it } from "mocha";
import { $, expect, browser } from "@wdio/globals";

describe("speaker-notes", () => {
  beforeEach(async () => {
    await browser.url("/");
  });

  it("contains summary with heading and button", async () => {
    const summary$ = await $("details summary");
    await expect(summary$).toExist();
    await expect(summary$.$("#speaker-notes")).toHaveText("Speaker Notes");
    await expect(summary$.$(".pop-out")).toExist();
  });

  it("opens a new window on button click and hide details on main page", async () => {
    const details$ = await $("details");
    const button$ = await $("details summary .pop-out");
    await expect(details$).toBeDisplayed();
    button$.scrollIntoView();
    await button$.click();
    await expect(details$).not.toBeDisplayed();

    // a new window should have opened, it should be the second one
    const handles = await browser.getWindowHandles();
    await browser.switchToWindow(handles[1]);
    await expect(browser).toHaveUrl(
      expect.stringContaining("#speaker-notes-open"),
    );
  });
});



================================================
FILE: tests/src/objects/playground.ts
================================================
import { $, browser } from "@wdio/globals";

export default class Playground {
  /**
   * stores a playground mock
   */
  mock: WebdriverIO.Mock;

  get area() {
    return $(".ace_content");
  }
  get start_button() {
    return $("button.play-button");
  }
  get stderr() {
    return $("code.result.stderr");
  }
  get stdout() {
    return $("code.result.stdout");
  }

  /**
   * activate the playground by clicking into it
   */
  async activate() {
    // clicking into the content is necessary for the button to be displayed
    await this.area.waitForClickable();
    await this.area.click();
  }

  /**
   *  run the code in the playground editor
   */
  async run() {
    // clicking the button triggers action
    await this.start_button.waitForClickable();
    // await browser.debug();
    await this.start_button.click();
  }

  /**
   * generate a new mock for the playground that overrides playground requests
   */
  async mock_new() {
    return browser.mock("https://play.rust-lang.org/execute", {
      method: "post",
    });
  }

  /**
   * reset the mock object
   */
  async mock_reset() {
    this.mock.clear();
  }

  /**
   * mock a successful playground run
   * @param stdout a string that is expected to be in stdout
   */
  async mock_success(stdout: string) {
    this.mock = await this.mock_new();

    // be aware that there is a still a preflight OPTIONS request
    this.mock.respond(
      {
        success: true,
        exitDetail: "Exited with status 0",
        stdout: stdout,
        stderr:
          "   Compiling playground v0.0.1 (/playground)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.62s\n     Running `target/debug/playground`\n",
      },
      {
        headers: {
          "Access-Control-Allow-Origin": "*",
        },
        fetchResponse: false,
      },
    );
  }

  /**
   * mock a failed run that would be caused if a `fn fail()` is added without any function body
   */
  async mock_fail() {
    // mock the response so this test does not rely on the playground backend to be working
    this.mock = await this.mock_new();

    // be aware that there is a still a preflight OPTIONS request
    this.mock.respond(
      {
        success: false,
        exitDetail: "Exited with status 101",
        stdout: "",
        stderr:
          '   Compiling playground v0.0.1 (/playground)\nerror: expected one of `->`, `where`, or `{`, found `}`\n --> src/main.rs:5:1\n  |\n4 |     fn fail()\n  |        ----  - expected one of `->`, `where`, or `{`\n  |        |\n  |        while parsing this `fn`\n5 | }\n  | ^ unexpected token\n\nerror: free function without a body\n --> src/main.rs:4:5\n  |\n4 |     fn fail()\n  |     ^^^^^^^^^- help: provide a definition for the function: `{ <body> }`\n\nerror: could not compile `playground` (bin "playground") due to 2 previous errors\n',
      },
      {
        headers: {
          "Access-Control-Allow-Origin": "*",
        },
        fetchResponse: false,
      },
    );
  }
}



================================================
FILE: tests/src/objects/slide.ts
================================================
import { $, browser } from "@wdio/globals";

export default class Slide {
  /**
   * convenience functions for interacting with a slide
   **/

  /**
   * @returns the scrollbar of the provided type if available
   */
  scrollbar_typed(scrollbar_type: string): ChainablePromiseElement {
    return $("#content main div.ace_scrollbar-" + scrollbar_type);
  }

  get scrollbar_v() {
    return this.scrollbar_typed("v");
  }

  get scrollbar_h() {
    return this.scrollbar_typed("h");
  }

  get main_content() {
    return $("#content > main");
  }

  /**
   *
   * @param element the element to be checked
   * @param height the maximum height
   * @param width the maximum width
   * @returns true if either height or width is higher than the provided numbers
   */
  async violates_max_size(
    element: ChainablePromiseElement,
    height: number,
    width: number,
  ): Promise<boolean> {
    const main_element_size = await element.getSize();
    return (
      main_element_size.height >= height || main_element_size.width > width
    );
  }

  async load(slide_path: string) {
    // ensure this is prefixed with /
    if (!slide_path.startsWith("/")) {
      slide_path = "/" + slide_path;
    }
    return await browser.url(slide_path);
  }
}



================================================
FILE: tests/src/slides/create-slide.list.sh
================================================
#!/bin/bash

# This script (re)creates the slides.list.ts file based on the given book html directory.
# It is used to regenerate the list of slides that are tested in the slide-size.test.ts file.
# Takes either TEST_BOOK_DIR environment variable or first parameter as override.

set -e
BASEDIR="$(dirname "$0")"

if [[ -n "$1" ]]; then
    # take directory from command line
    TEST_BOOK_DIR="$1"
fi

# check if TEST_BOOK_DIR is empty (not set by environment nor parameter)
if [[ -z "${TEST_BOOK_DIR}" ]]; then
  echo "Usage: $0 <book_html_dir>"
  exit 1
fi

# check if this is the correct root directory by checking if it contains the index.html
if [[ ! -f "${TEST_BOOK_DIR}/index.html" ]]; then
  echo "Could not find index.html in ${TEST_BOOK_DIR}. Please check if the correct directory is used (e.g. book/html). You might need to (re)create the directory with mdbook build."
  exit 1
fi

pushd "${TEST_BOOK_DIR}"
# exclude special pages that should never be tested
SLIDES=$(grep -L "Redirecting to..."  -R --include "*.html" \
    --exclude "exercise.html" \
    --exclude "solution.html" \
    --exclude "toc.html" \
    --exclude "print.html" \
    --exclude "404.html" \
    --exclude "glossary.html" \
    --exclude "index.html" \
    --exclude "course-structure.html"
    )
popd
OUTPUT="${BASEDIR}/slides.list.ts"

# create a ts module that can be imported in the tests
echo "export const slides = [" > ${OUTPUT};
for SLIDE in ${SLIDES}; do
echo "  \"${SLIDE}\"," >> ${OUTPUT};
done;
echo "];" >> ${OUTPUT};



================================================
FILE: tests/src/slides/slide-exemptions.list.ts
================================================
// These slides are known to violate the slide style guide.
// They are checked if they still violate and if not fail the test.
// Please remove slides that become good so they don't regress.
export const size_exemptions = [
  "android/interoperability/java.html",
  "android/testing.html",
  "bare-metal/aps/entry-point.html",
  "bare-metal/aps/aarch64-rt.html",
  "exercises/bare-metal/compass.html",
  "exercises/bare-metal/solutions-afternoon.html",
  "exercises/bare-metal/rtc.html",
  "exercises/bare-metal/solutions-morning.html",
  "exercises/chromium/interoperability-with-cpp.html",
  "exercises/chromium/bringing-it-together.html",
  "concurrency/async-exercises/chat-app.html",
  "concurrency/async-exercises/solutions.html",
  "concurrency/sync-exercises/solutions.html",
  "concurrency/sync-exercises/link-checker.html",
];

export const playground_size_exemptions = [
  "bare-metal/microcontrollers/type-state.html",
  "concurrency/async-pitfalls/cancellation.html",
  "iterators/intoiterator.html",
];



================================================
FILE: tests/src/slides/slides.list.ts
================================================
// to enable local testing for slide size checks please (re)generate this file by executing:
// $ ./tests/src/slides/create-slide.list.sh book/html
//
// This file is on purpose not pre-filled in the repository to avoid
// a) manual maintenance of slide list
// b) this takes some time to test
export const slides = [];



================================================
FILE: theme/book.js
================================================
"use strict";

// Fix back button cache problem
window.onunload = function () { };

function isPlaygroundModified(playground) {
    let code_block = playground.querySelector("code");
    if (window.ace && code_block.classList.contains("editable")) {
      let editor = window.ace.edit(code_block);
      return editor.getValue() != editor.originalCode;
    } else {
      return false;
    }
}

// Global variable, shared between modules
function playground_text(playground, hidden = true) {
    let code_block = playground.querySelector("code");

    if (window.ace && code_block.classList.contains("editable")) {
        let editor = window.ace.edit(code_block);
        return editor.getValue();
    } else if (hidden) {
        return code_block.textContent;
    } else {
        return code_block.innerText;
    }
}

(function codeSnippets() {
    function fetch_with_timeout(url, options, timeout = 15000) {
        return Promise.race([
            fetch(url, options),
            new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), timeout))
        ]);
    }

    var playgrounds = Array.from(document.querySelectorAll(".playground"));
    if (playgrounds.length > 0) {
        fetch_with_timeout("https://play.rust-lang.org/meta/crates", {
            headers: {
                'Content-Type': "application/json",
            },
            method: 'POST',
            mode: 'cors',
        })
        .then(response => response.json())
        .then(response => {
            // get list of crates available in the rust playground
            let playground_crates = response.crates.map(item => item["id"]);
            playgrounds.forEach(block => handle_crate_list_update(block, playground_crates));
        });
    }

    function handle_crate_list_update(playground_block, playground_crates) {
        // update the play buttons after receiving the response
        update_play_button(playground_block, playground_crates);

        // and install on change listener to dynamically update ACE editors
        if (window.ace) {
            let code_block = playground_block.querySelector("code");
            if (code_block.classList.contains("editable")) {
                let editor = window.ace.edit(code_block);
                editor.addEventListener("change", function (e) {
                    update_play_button(playground_block, playground_crates);
                });
                // add Ctrl-Enter command to execute rust code
                editor.commands.addCommand({
                    name: "run",
                    bindKey: {
                        win: "Ctrl-Enter",
                        mac: "Ctrl-Enter"
                    },
                    exec: _editor => run_rust_code(playground_block)
                });
            }
        }
    }

    // updates the visibility of play button based on `no_run` class and
    // used crates vs ones available on https://play.rust-lang.org
    function update_play_button(pre_block, playground_crates) {
        var play_button = pre_block.querySelector(".play-button");

        // skip if code is `no_run`
        if (pre_block.querySelector('code').classList.contains("no_run")) {
            play_button.classList.add("hidden");
            return;
        }

        // get list of `extern crate`'s from snippet
        var txt = playground_text(pre_block);
        var re = /extern\s+crate\s+([a-zA-Z_0-9]+)\s*;/g;
        var snippet_crates = [];
        var item;
        while (item = re.exec(txt)) {
            snippet_crates.push(item[1]);
        }

        // check if all used crates are available on play.rust-lang.org
        var all_available = snippet_crates.every(function (elem) {
            return playground_crates.indexOf(elem) > -1;
        });

        if (all_available) {
            play_button.classList.remove("hidden");
        } else {
            play_button.classList.add("hidden");
        }
    }

    function run_rust_code(code_block) {
        var result_stderr_block = code_block.querySelector(".result.stderr");
        if (!result_stderr_block) {
            result_stderr_block = document.createElement('code');
            result_stderr_block.className = 'result stderr hljs nohighlight hidden';

            code_block.append(result_stderr_block);
        }
        var result_block = code_block.querySelector(".result.stdout");
        if (!result_block) {
            result_block = document.createElement('code');
            result_block.className = 'result stdout hljs nohighlight';

            code_block.append(result_block);
        }

        let text = playground_text(code_block);
        let classes = code_block.querySelector('code').classList;
        // Unless the code block has `warnunused`, allow all "unused" lints to avoid cluttering
        // the output.
        if(!classes.contains("warnunused")) {
            text = '#![allow(unused)] ' + text;
        }
        let edition = "2015";
        if(classes.contains("edition2018")) {
            edition = "2018";
        } else if(classes.contains("edition2021")) {
            edition = "2021";
        } else if(classes.contains("edition2024")) {
            edition = "2024";
        }
        var params = {
            backtrace: true,
            channel: "stable",
            code: text,
            edition: edition,
            mode: "debug",
            tests: false,
            crateType: "bin",
        };

        // If the code block has no `main` but does have tests, run those.
        if (text.indexOf("fn main") === -1 && text.indexOf("#[test]") !== -1) {
            params.tests = true;
        }

        if (text.indexOf("#![feature") !== -1) {
            params.version = "nightly";
        }

        result_block.innerText = "Running...";
        // hide stderr block while running
        result_stderr_block.innerText = "";
        result_stderr_block.classList.add("hidden");

        const playgroundModified = isPlaygroundModified(code_block);
        const startTime = window.performance.now();
        fetch_with_timeout("https://play.rust-lang.org/execute", {
            headers: {
                'Content-Type': "application/json",
            },
            method: 'POST',
            mode: 'cors',
            body: JSON.stringify(params)
        })
        .then(response => response.json())
        .then(response => {
            const endTime = window.performance.now();
            gtag("event", "playground", {
                "modified": playgroundModified,
                "error": (response.error == null) ? null : 'compilation_error',
                "latency": (endTime - startTime) / 1000,
            });

            if (response.error != null && response.error != '') {
                // output the error if there's any. e.g. timeout
                result_block.innerText = response.error;
                result_block.classList.remove("result-no-output");
                return;
            }

            if (response.stdout.trim() === '') {
                result_block.innerText = "No output";
                result_block.classList.add("result-no-output");
            } else {
                result_block.innerText = response.stdout;
                result_block.classList.remove("result-no-output");
            }

            // trim compile message
            // ====================
            // Compiling playground v0.0.1 (/playground)
            // Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.60s
            // Running `target/debug/playground`
            // ====================
            const compileMsgRegex = /^\s+Compiling(.+)\s+Finished(.+)\s+Running(.+)\n/;
            response.stderr = response.stderr.replace(compileMsgRegex, "");
            if (response.stderr.trim() !== '') {
                result_stderr_block.classList.remove("hidden");
                result_stderr_block.innerText = response.stderr;
            }
        })
        .catch(error => {
            const endTime = window.performance.now();
            gtag("event", "playground", {
                "modified": playgroundModified,
                "error": error.message,
                "latency": (endTime - startTime) / 1000,
            });
            result_block.innerText = "Playground Communication: " + error.message
        });
    }

    // Syntax highlighting Configuration
    hljs.configure({
        tabReplace: '    ', // 4 spaces
        languages: [],      // Languages used for auto-detection
    });

    let code_nodes = Array
        .from(document.querySelectorAll('code'))
        // Don't highlight `inline code` blocks in headers.
        .filter(function (node) {return !node.parentElement.classList.contains("header"); });

    if (window.ace) {
        // language-rust class needs to be removed for editable
        // blocks or highlightjs will capture events
        code_nodes
            .filter(function (node) {return node.classList.contains("editable"); })
            .forEach(function (block) { block.classList.remove('language-rust'); });

        code_nodes
            .filter(function (node) {return !node.classList.contains("editable"); })
            .forEach(function (block) { hljs.highlightBlock(block); });
    } else {
        code_nodes.forEach(function (block) { hljs.highlightBlock(block); });
    }

    // Adding the hljs class gives code blocks the color css
    // even if highlighting doesn't apply
    code_nodes.forEach(function (block) { block.classList.add('hljs'); });

    Array.from(document.querySelectorAll("code.hljs")).forEach(function (block) {

        var lines = Array.from(block.querySelectorAll('.boring'));
        // If no lines were hidden, return
        if (!lines.length) { return; }
        block.classList.add("hide-boring");

        var buttons = document.createElement('div');
        buttons.className = 'buttons';
        buttons.innerHTML = "<button class=\"fa fa-eye\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button>";

        // add expand button
        var pre_block = block.parentNode;
        pre_block.insertBefore(buttons, pre_block.firstChild);

        pre_block.querySelector('.buttons').addEventListener('click', function (e) {
            if (e.target.classList.contains('fa-eye')) {
                e.target.classList.remove('fa-eye');
                e.target.classList.add('fa-eye-slash');
                e.target.title = 'Hide lines';
                e.target.setAttribute('aria-label', e.target.title);

                block.classList.remove('hide-boring');
            } else if (e.target.classList.contains('fa-eye-slash')) {
                e.target.classList.remove('fa-eye-slash');
                e.target.classList.add('fa-eye');
                e.target.title = 'Show hidden lines';
                e.target.setAttribute('aria-label', e.target.title);

                block.classList.add('hide-boring');
            }
        });
    });

    if (window.playground_copyable) {
        Array.from(document.querySelectorAll('pre code')).forEach(function (block) {
            var pre_block = block.parentNode;
            if (!pre_block.classList.contains('playground')) {
                var buttons = pre_block.querySelector(".buttons");
                if (!buttons) {
                    buttons = document.createElement('div');
                    buttons.className = 'buttons';
                    pre_block.insertBefore(buttons, pre_block.firstChild);
                }

                var clipButton = document.createElement('button');
                clipButton.className = 'clip-button';
                clipButton.title = 'Copy to clipboard';
                clipButton.setAttribute('aria-label', clipButton.title);
                clipButton.innerHTML = '<i class=\"tooltiptext\"></i>';

                buttons.insertBefore(clipButton, buttons.firstChild);
            }
        });
    }

    // Process playground code blocks
    Array.from(document.querySelectorAll(".playground")).forEach(function (pre_block) {
        // Add play button
        var buttons = pre_block.querySelector(".buttons");
        if (!buttons) {
            buttons = document.createElement('div');
            buttons.className = 'buttons';
            pre_block.insertBefore(buttons, pre_block.firstChild);
        }

        var runCodeButton = document.createElement('button');
        runCodeButton.className = 'fa fa-play play-button';
        runCodeButton.hidden = true;
        runCodeButton.title = 'Run this code';
        runCodeButton.setAttribute('aria-label', runCodeButton.title);

        buttons.insertBefore(runCodeButton, buttons.firstChild);
        runCodeButton.addEventListener('click', function (e) {
            run_rust_code(pre_block);
        });

        if (window.playground_copyable) {
            var copyCodeClipboardButton = document.createElement('button');
            copyCodeClipboardButton.className = 'clip-button';
            copyCodeClipboardButton.innerHTML = '<i class="tooltiptext"></i>';
            copyCodeClipboardButton.title = 'Copy to clipboard';
            copyCodeClipboardButton.setAttribute('aria-label', copyCodeClipboardButton.title);

            buttons.insertBefore(copyCodeClipboardButton, buttons.firstChild);
        }

        let code_block = pre_block.querySelector("code");
        if (window.ace && code_block.classList.contains("editable")) {
            var undoChangesButton = document.createElement('button');
            undoChangesButton.className = 'fa fa-history reset-button';
            undoChangesButton.title = 'Undo changes';
            undoChangesButton.setAttribute('aria-label', undoChangesButton.title);

            buttons.insertBefore(undoChangesButton, buttons.firstChild);

            undoChangesButton.addEventListener('click', function () {
                let editor = window.ace.edit(code_block);
                editor.setValue(editor.originalCode);
                editor.clearSelection();
            });
        }
    });
})();

(function themes() {
    var html = document.querySelector('html');
    var themeToggleButton = document.getElementById('theme-toggle');
    var themePopup = document.getElementById('theme-list');
    var themeColorMetaTag = document.querySelector('meta[name="theme-color"]');
    var themeIds = [];
    themePopup.querySelectorAll('button.theme').forEach(function (el) {
        themeIds.push(el.id);
    });
    var stylesheets = {
        ayuHighlight: document.querySelector("[href$='ayu-highlight.css']"),
        tomorrowNight: document.querySelector("[href$='tomorrow-night.css']"),
        highlight: document.querySelector("[href$='highlight.css']"),
    };

    function showThemes() {
        themePopup.style.display = 'block';
        themeToggleButton.setAttribute('aria-expanded', true);
        themePopup.querySelector("button#" + get_theme()).focus();
    }

    function updateThemeSelected() {
        themePopup.querySelectorAll('.theme-selected').forEach(function (el) {
            el.classList.remove('theme-selected');
        });
        themePopup.querySelector("button#" + get_theme()).classList.add('theme-selected');
    }

    function hideThemes() {
        themePopup.style.display = 'none';
        themeToggleButton.setAttribute('aria-expanded', false);
        themeToggleButton.focus();
    }

    function get_theme() {
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined || !themeIds.includes(theme)) {
            return default_theme;
        } else {
            return theme;
        }
    }

    function set_theme(theme, store = true) {
        let ace_theme;

        if (theme == 'coal' || theme == 'navy') {
            stylesheets.ayuHighlight.disabled = true;
            stylesheets.tomorrowNight.disabled = false;
            stylesheets.highlight.disabled = true;

            ace_theme = "ace/theme/tomorrow_night";
        } else if (theme == 'ayu') {
            stylesheets.ayuHighlight.disabled = false;
            stylesheets.tomorrowNight.disabled = true;
            stylesheets.highlight.disabled = true;
            ace_theme = "ace/theme/tomorrow_night";
        } else {
            stylesheets.ayuHighlight.disabled = true;
            stylesheets.tomorrowNight.disabled = true;
            stylesheets.highlight.disabled = false;
            ace_theme = "ace/theme/dawn";
        }

        setTimeout(function () {
            themeColorMetaTag.content = getComputedStyle(document.documentElement).backgroundColor;
        }, 1);

        if (window.ace && window.editors) {
            window.editors.forEach(function (editor) {
                editor.setTheme(ace_theme);
            });
        }

        var previousTheme = get_theme();

        if (store) {
            try { localStorage.setItem('mdbook-theme', theme); } catch (e) { }
        }

        html.classList.remove(previousTheme);
        html.classList.add(theme);
        updateThemeSelected();
    }

    // Set theme
    var theme = get_theme();

    set_theme(theme, false);

    themeToggleButton.addEventListener('click', function () {
        if (themePopup.style.display === 'block') {
            hideThemes();
        } else {
            showThemes();
        }
    });

    themePopup.addEventListener('click', function (e) {
        var theme;
        if (e.target.className === "theme") {
            theme = e.target.id;
        } else if (e.target.parentElement.className === "theme") {
            theme = e.target.parentElement.id;
        } else {
            return;
        }
        set_theme(theme);
    });

    themePopup.addEventListener('focusout', function(e) {
        // e.relatedTarget is null in Safari and Firefox on macOS (see workaround below)
        if (!!e.relatedTarget && !themeToggleButton.contains(e.relatedTarget) && !themePopup.contains(e.relatedTarget)) {
            hideThemes();
        }
    });

    // Should not be needed, but it works around an issue on macOS & iOS: https://github.com/rust-lang/mdBook/issues/628
    document.addEventListener('click', function(e) {
        if (themePopup.style.display === 'block' && !themeToggleButton.contains(e.target) && !themePopup.contains(e.target)) {
            hideThemes();
        }
    });

    document.addEventListener('keydown', function (e) {
        if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) { return; }
        if (!themePopup.contains(e.target)) { return; }

        switch (e.key) {
            case 'Escape':
                e.preventDefault();
                hideThemes();
                break;
            case 'ArrowUp':
                e.preventDefault();
                var li = document.activeElement.parentElement;
                if (li && li.previousElementSibling) {
                    li.previousElementSibling.querySelector('button').focus();
                }
                break;
            case 'ArrowDown':
                e.preventDefault();
                var li = document.activeElement.parentElement;
                if (li && li.nextElementSibling) {
                    li.nextElementSibling.querySelector('button').focus();
                }
                break;
            case 'Home':
                e.preventDefault();
                themePopup.querySelector('li:first-child button').focus();
                break;
            case 'End':
                e.preventDefault();
                themePopup.querySelector('li:last-child button').focus();
                break;
        }
    });
})();

(function sidebar() {
    var body = document.querySelector("body");
    var sidebar = document.getElementById("sidebar");
    var sidebarLinks = document.querySelectorAll('#sidebar a');
    var sidebarToggleButton = document.getElementById("sidebar-toggle");
    var sidebarToggleAnchor = document.getElementById("sidebar-toggle-anchor");
    var sidebarResizeHandle = document.getElementById("sidebar-resize-handle");
    var firstContact = null;

    function showSidebar() {
        body.classList.remove('sidebar-hidden')
        body.classList.add('sidebar-visible');
        Array.from(sidebarLinks).forEach(function (link) {
            link.setAttribute('tabIndex', 0);
        });
        sidebarToggleButton.setAttribute('aria-expanded', true);
        sidebar.setAttribute('aria-hidden', false);
        try { localStorage.setItem('mdbook-sidebar', 'visible'); } catch (e) { }
    }

    function hideSidebar() {
        body.classList.remove('sidebar-visible')
        body.classList.add('sidebar-hidden');
        Array.from(sidebarLinks).forEach(function (link) {
            link.setAttribute('tabIndex', -1);
        });
        sidebarToggleButton.setAttribute('aria-expanded', false);
        sidebar.setAttribute('aria-hidden', true);
        try { localStorage.setItem('mdbook-sidebar', 'hidden'); } catch (e) { }
    }

    // Toggle sidebar
    sidebarToggleAnchor.addEventListener('change', function sidebarToggle() {
        if (sidebarToggleAnchor.checked) {
            var current_width = parseInt(
                document.documentElement.style.getPropertyValue('--sidebar-width'), 10);
            if (current_width < 150) {
                document.documentElement.style.setProperty('--sidebar-width', '150px');
            }
            showSidebar();
        } else {
            hideSidebar();
        }
    });

    sidebarResizeHandle.addEventListener('mousedown', initResize, false);

    function initResize(e) {
        window.addEventListener('mousemove', resize, false);
        window.addEventListener('mouseup', stopResize, false);
        body.classList.add('sidebar-resizing');
    }
    function resize(e) {
        var pos = (e.clientX - sidebar.offsetLeft);
        if (pos < 20) {
            hideSidebar();
        } else {
            if (body.classList.contains("sidebar-hidden")) {
                showSidebar();
            }
            pos = Math.min(pos, window.innerWidth - 100);
            document.documentElement.style.setProperty('--sidebar-width', pos + 'px');
        }
    }
    //on mouseup remove windows functions mousemove & mouseup
    function stopResize(e) {
        body.classList.remove('sidebar-resizing');
        window.removeEventListener('mousemove', resize, false);
        window.removeEventListener('mouseup', stopResize, false);
    }

    document.addEventListener('touchstart', function (e) {
        firstContact = {
            x: e.touches[0].clientX,
            time: Date.now()
        };
    }, { passive: true });

    document.addEventListener('touchmove', function (e) {
        if (!firstContact)
            return;

        var curX = e.touches[0].clientX;
        var xDiff = curX - firstContact.x,
            tDiff = Date.now() - firstContact.time;

        if (tDiff < 250 && Math.abs(xDiff) >= 150) {
            if (xDiff >= 0 && firstContact.x < Math.min(document.body.clientWidth * 0.25, 300))
                showSidebar();
            else if (xDiff < 0 && curX < 300)
                hideSidebar();

            firstContact = null;
        }
    }, { passive: true });
})();

(function chapterNavigation() {
    document.addEventListener('keydown', function (e) {
        if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) { return; }
        if (window.search && window.search.hasFocus()) { return; }
        var html = document.querySelector('html');

        function next() {
            var nextButton = document.querySelector('.nav-chapters.next');
            if (nextButton) {
                window.location.href = nextButton.href;
            }
        }
        function prev() {
            var previousButton = document.querySelector('.nav-chapters.previous');
            if (previousButton) {
                window.location.href = previousButton.href;
            }
        }
        switch (e.key) {
            case 'ArrowRight':
                e.preventDefault();
                if (html.dir == 'rtl') {
                    prev();
                } else {
                    next();
                }
                break;
            case 'ArrowLeft':
                e.preventDefault();
                if (html.dir == 'rtl') {
                    next();
                } else {
                    prev();
                }
                break;
        }
    });
})();

(function clipboard() {
    var clipButtons = document.querySelectorAll('.clip-button');

    function hideTooltip(elem) {
        elem.firstChild.innerText = "";
        elem.className = 'clip-button';
    }

    function showTooltip(elem, msg) {
        elem.firstChild.innerText = msg;
        elem.className = 'clip-button tooltipped';
    }

    var clipboardSnippets = new ClipboardJS('.clip-button', {
        text: function (trigger) {
            hideTooltip(trigger);
            let playground = trigger.closest("pre");
            return playground_text(playground, false);
        }
    });

    Array.from(clipButtons).forEach(function (clipButton) {
        clipButton.addEventListener('mouseout', function (e) {
            hideTooltip(e.currentTarget);
        });
    });

    clipboardSnippets.on('success', function (e) {
        e.clearSelection();
        showTooltip(e.trigger, "Copied!");
    });

    clipboardSnippets.on('error', function (e) {
        showTooltip(e.trigger, "Clipboard error!");
    });
})();

(function scrollToTop () {
    var menuTitle = document.querySelector('.menu-title');

    menuTitle.addEventListener('click', function () {
        document.scrollingElement.scrollTo({ top: 0, behavior: 'smooth' });
    });
})();

(function controllMenu() {
    var menu = document.getElementById('menu-bar');

    (function controllPosition() {
        var scrollTop = document.scrollingElement.scrollTop;
        var prevScrollTop = scrollTop;
        var minMenuY = -menu.clientHeight - 50;
        // When the script loads, the page can be at any scroll (e.g. if you reforesh it).
        menu.style.top = scrollTop + 'px';
        // Same as parseInt(menu.style.top.slice(0, -2), but faster
        var topCache = menu.style.top.slice(0, -2);
        menu.classList.remove('sticky');
        var stickyCache = false; // Same as menu.classList.contains('sticky'), but faster
        document.addEventListener('scroll', function () {
            scrollTop = Math.max(document.scrollingElement.scrollTop, 0);
            // `null` means that it doesn't need to be updated
            var nextSticky = null;
            var nextTop = null;
            var scrollDown = scrollTop > prevScrollTop;
            var menuPosAbsoluteY = topCache - scrollTop;
            if (scrollDown) {
                nextSticky = false;
                if (menuPosAbsoluteY > 0) {
                    nextTop = prevScrollTop;
                }
            } else {
                if (menuPosAbsoluteY > 0) {
                    nextSticky = true;
                } else if (menuPosAbsoluteY < minMenuY) {
                    nextTop = prevScrollTop + minMenuY;
                }
            }
            if (nextSticky === true && stickyCache === false) {
                menu.classList.add('sticky');
                stickyCache = true;
            } else if (nextSticky === false && stickyCache === true) {
                menu.classList.remove('sticky');
                stickyCache = false;
            }
            if (nextTop !== null) {
                menu.style.top = nextTop + 'px';
                topCache = nextTop;
            }
            prevScrollTop = scrollTop;
        }, { passive: true });
    })();
    (function controllBorder() {
        function updateBorder() {
            if (menu.offsetTop === 0) {
                menu.classList.remove('bordered');
            } else {
                menu.classList.add('bordered');
            }
        }
        updateBorder();
        document.addEventListener('scroll', updateBorder, { passive: true });
    })();
})();



================================================
FILE: theme/head.hbs
================================================
<script async src="https://www.gstatic.com/brandstudio/kato/cookie_choice_component/cookie_consent_bar.v3.js"
        data-autoload-cookie-consent-bar="true"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZN78TEJMRW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ZN78TEJMRW');
</script>

{{! Move to template code after fixing this issue:
    https://github.com/google/mdbook-i18n-helpers/issues/70 }}
<script>
  (function () {
      // See these pages for details:
      // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
      // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
      let base = "https://google.github.io/comprehensive-rust";
      {{#if (eq language "en")}}
      let canonical_href = `${base}/{{ path }}`;
      {{else}}
      let canonical_href = `${base}/{{ language }}/{{ path }}`;
      {{/if}}

      // mdbook gives us a string ending in ".md", we replace it with ".html":
      canonical_href = canonical_href.slice(0, -"md".length) + "html";
      if (canonical_href.endsWith("/index.html")) {
          canonical_href = canonical_href.slice(0, -"index.html".length);
      }

      let link = document.createElement("link");
      link.rel = "canonical";
      link.href = canonical_href;
      document.head.appendChild(link);
  })()
</script>



================================================
FILE: theme/index.hbs
================================================
<!DOCTYPE HTML>
<html lang="{{ language }}" class="{{ default_theme }} sidebar-visible" dir="{{ text_direction }}">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>{{ title }}</title>
        {{#if is_print }}
        <meta name="robots" content="noindex">
        {{/if}}
        {{#if base_url}}
        <base href="{{ base_url }}">
        {{/if}}


        <!-- Custom HTML head -->
        {{> head}}

        <meta name="description" content="{{ description }}">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        {{#if favicon_svg}}
        <link rel="icon" href="{{ path_to_root }}favicon.svg">
        {{/if}}
        {{#if favicon_png}}
        <link rel="shortcut icon" href="{{ path_to_root }}favicon.png">
        {{/if}}
        <link rel="stylesheet" href="{{ path_to_root }}css/variables.css">
        <link rel="stylesheet" href="{{ path_to_root }}css/general.css">
        <link rel="stylesheet" href="{{ path_to_root }}css/chrome.css">
        {{#if print_enable}}
        <link rel="stylesheet" href="{{ path_to_root }}css/print.css" media="print">
        {{/if}}

        <!-- Fonts -->
        <link rel="stylesheet" href="{{ path_to_root }}FontAwesome/css/font-awesome.css">
        {{#if copy_fonts}}
        <link rel="stylesheet" href="{{ path_to_root }}fonts/fonts.css">
        {{/if}}

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="{{ path_to_root }}highlight.css">
        <link rel="stylesheet" href="{{ path_to_root }}tomorrow-night.css">
        <link rel="stylesheet" href="{{ path_to_root }}ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        {{#each additional_css}}
        <link rel="stylesheet" href="{{ ../path_to_root }}{{ this }}">
        {{/each}}

        {{#if mathjax_support}}
        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        {{/if}}

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "{{ path_to_root }}";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "{{ preferred_dark_theme }}" : "{{ default_theme }}";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="{{ path_to_root }}toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('{{ default_theme }}')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="{{ path_to_root }}toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                {{> header}}
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        {{#if search_enabled}}
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        {{/if}}
                    </div>

                    <h1 class="menu-title">{{ book_title }}</h1>

                    <div class="right-buttons">
                        <button id="language-toggle" class="icon-button" type="button"
                                title="Change language" aria-label="Change language"
                                aria-haspopup="true" aria-expanded="false"
                                aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="en">English</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="pt-BR">Brazilian Portuguese (Português do Brasil)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="zh-CN">Chinese Simplified (汉语)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="zh-TW">Chinese Traditional (漢語)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="ja">Japanese (日本語)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="ko">Korean (한국어)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="fa">Farsi (فارسی)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="es">Spanish (Español)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="uk">Ukrainian (українська)</a>
                          </button></li>
                        </ul>
                        <script>
                          let langToggle = document.getElementById("language-toggle");
                          let langList = document.getElementById("language-list");
                          langToggle.addEventListener("click", (event) => {
                              langList.style.display = langList.style.display == "block" ? "none" : "block";
                          });
                          let selectedLang = document.getElementById("{{ language }}");
                          if (selectedLang) {
                              selectedLang.parentNode.classList.add("theme-selected");
                          }

                          // The path to the root, taking the current
                          // language into account.
                          {{#if (eq language "en")}}
                          let full_path_to_root = "{{ path_to_root }}";
                          {{else}}
                          let full_path_to_root = "{{ path_to_root }}../";
                          {{/if}}
                          // The page path (mdbook only gives us
                          // access to the path to the Markdown file).
                          let path = "{{ path }}".replace(/\.md$/, ".html");
                          for (let lang of langList.querySelectorAll("a")) {
                              if (lang.id == "en") {
                                  lang.href = `${full_path_to_root}${path}`;
                              } else {
                                  lang.href = `${full_path_to_root}${lang.id}/${path}`;
                              }
                          }

                          // When the user clicks a list item, the page jump is performed, just like clicking the internal <a> tag.
                          langList.querySelectorAll("li").forEach(function(li) {
                            li.addEventListener("click", function(event) {
                              event.preventDefault();
        
                              let link = this.querySelector("a");
                              if (link && window.location.href !== link.href) {
                                window.location.href = link.href;
                              }
                            });
                          });
                        </script>

                        {{#if print_enable}}
                        <a href="{{ path_to_root }}print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        {{/if}}
                        {{#if git_repository_url}}
                        <a href="{{git_repository_url}}" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa {{git_repository_icon}}"></i>
                        </a>
                        {{/if}}
                        {{#if git_repository_edit_url}}
                        {{#if (eq language "en")}}
                        <a href="{{git_repository_edit_url}}" title="Suggest an edit" aria-label="Suggest an edit"
                           target="_blank">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                        {{else}}
                        <a href="https://github.com/google/comprehensive-rust/edit/main/po/{{language}}.po"
                           title="Suggest an edit to the translation" aria-label="Suggest an edit to the translation"
                           target="_blank">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                        {{/if}}
                        {{/if}}

                    </div>
                </div>

                {{#if search_enabled}}
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                {{/if}}

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        {{{ content }}}
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        {{#previous}}
                            <a rel="prev" href="{{ path_to_root }}{{link}}" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        {{/previous}}

                        {{#next}}
                            <a rel="next prefetch" href="{{ path_to_root }}{{link}}" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        {{/next}}

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                {{#previous}}
                    <a rel="prev" href="{{ path_to_root }}{{link}}" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                {{/previous}}

                {{#next}}
                    <a rel="next prefetch" href="{{ path_to_root }}{{link}}" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                {{/next}}
            </nav>

        </div>

        {{#if live_reload_endpoint}}
        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "{{{live_reload_endpoint}}}";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        {{/if}}

        {{#if google_analytics}}
        <!-- Google Analytics Tag -->
        <script>
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', '{{google_analytics}}', 'auto');
                ga('send', 'pageview');
            }
        </script>
        {{/if}}

        {{#if playground_line_numbers}}
        <script>
            window.playground_line_numbers = true;
        </script>
        {{/if}}

        {{#if playground_copyable}}
        <script>
            window.playground_copyable = true;
        </script>
        {{/if}}

        {{#if playground_js}}
        <script src="{{ path_to_root }}ace.js"></script>
        <script src="{{ path_to_root }}editor.js"></script>
        <script src="{{ path_to_root }}mode-rust.js"></script>
        <script src="{{ path_to_root }}theme-dawn.js"></script>
        <script src="{{ path_to_root }}theme-tomorrow_night.js"></script>
        {{/if}}

        {{#if search_js}}
        <script src="{{ path_to_root }}elasticlunr.min.js"></script>
        <script src="{{ path_to_root }}mark.min.js"></script>
        <script src="{{ path_to_root }}searcher.js"></script>
        {{/if}}

        <script src="{{ path_to_root }}clipboard.min.js"></script>
        <script src="{{ path_to_root }}highlight.js"></script>
        <script src="{{ path_to_root }}book.js"></script>

        <!-- Custom JS scripts -->
        {{#each additional_js}}
        <script src="{{ ../path_to_root }}{{this}}"></script>
        {{/each}}

        {{#if is_print}}
        {{#if mathjax_support}}
        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        {{else}}
        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        {{/if}}
        {{/if}}

    </div>
    </body>
</html>



================================================
FILE: theme/instructor-menu.js
================================================
(function handleInstructor() {
  function handleInstructorMenu() {
    let leftButtons = document.getElementsByClassName("left-buttons")[0];
    let instructorMenu = document.createElement("button");
    let instructorMenuList = document.createElement("ul");
    let redBoxItem = document.createElement("li");
    let redBoxButton = document.createElement("button");
    let playgroundStateItem = document.createElement("li");
    let playgroundStateButton = document.createElement("button");

    leftButtons.insertBefore(instructorMenu, leftButtons.lastChild);
    leftButtons.insertBefore(instructorMenuList, leftButtons.lastChild);
    instructorMenuList.insertBefore(redBoxItem, instructorMenuList.lastChild);
    instructorMenuList.insertBefore(
      playgroundStateItem,
      instructorMenuList.lastChild,
    );
    redBoxItem.insertBefore(redBoxButton, redBoxItem.lastChild);
    playgroundStateItem.insertBefore(
      playgroundStateButton,
      playgroundStateItem.lastChild,
    );

    instructorMenu.title = "Utilities for course instructors";
    instructorMenu.innerHTML =
      '<i class="fa fa-ellipsis-v" aria-hidden="true"></i>';
    redBoxButton.innerHTML = "aspect-ratio box";
    redBoxButton.title =
      "Outline the area that fits on one screen while teaching the course.";
    playgroundStateButton.innerHTML = "reset all playgrounds";
    playgroundStateButton.title =
      "Reset code in all playgrounds to its original value.";

    instructorMenu.className = "icon-button";
    instructorMenuList.className = "theme-popup";
    redBoxButton.className = "theme";
    playgroundStateButton.className = "theme";
    instructorMenuList.style.display = "none";

    instructorMenuList.role = "menu";
    redBoxItem.role = "none";
    playgroundStateItem.role = "none";
    redBoxButton.role = "menuitem";
    playgroundStateButton.role = "menuitem";

    redBoxButton.id = "redbox";
    instructorMenuList.id = "instructor-menu-list";
    playgroundStateButton.id = "playground-state";

    instructorMenu.addEventListener("click", () => {
      if (instructorMenuList.style.display === "none") {
        instructorMenuList.style.display = "block";
      } else {
        instructorMenuList.style.display = "none";
      }
    });

    document.addEventListener("click", (e) => {
      if (!instructorMenu.contains(e.target)) {
        instructorMenuList.style.display = "none";
      }
    });
  }
  handleInstructorMenu();
  var redBoxButton = document.getElementById("redbox");
  var playgroundStateButton = document.getElementById("playground-state");
  redBoxButton.addEventListener("click", () => window.redboxButtonClicked());
  playgroundStateButton.addEventListener("click", () =>
    window.resetPlaygroundsClicked(),
  );
})();



================================================
FILE: theme/redbox.js
================================================
(function redBoxButton() {
  // Create a new div element
  var newDiv = document.createElement("div");
  // Set the id attribute of the new div
  newDiv.id = "aspect-ratio-helper";
  // Create a nested div inside the new div
  var nestedDiv = document.createElement("div");
  // Append the nested div to the new div
  newDiv.appendChild(nestedDiv, newDiv.firstChild);
  // Get the parent element where you want to append the new div
  var parentElement = document.body; // Change this to your desired parent element
  // Append the new div to the parent element
  parentElement.insertBefore(newDiv, parentElement.firstChild);
  //Default hiding the redbox
  document.getElementById("aspect-ratio-helper").style.display = "none";
})();

//Create a function to button to perform on click action.
function redboxButtonClicked() {
  var hideShowButton = document.getElementById("redbox");
  if (document.getElementById("aspect-ratio-helper").style.display === "none") {
    document.getElementById("aspect-ratio-helper").style.display = "block";
    hideShowButton.innerHTML = "aspect-ratio box";
  } else {
    document.getElementById("aspect-ratio-helper").style.display = "none";
    hideShowButton.innerHTML = "aspect-ratio box";
  }
}
window.redboxButtonClicked = redboxButtonClicked;



================================================
FILE: theme/save-playgrounds.js
================================================
(function savePlaygrounds() {
  function setCodeToPlayground() {
    var codes = JSON.parse(
      localStorage.getItem(`${window.location.href}₹code`),
    );
    if (codes) {
      var i = 0;
      Array.from(document.querySelectorAll(".playground")).forEach(
        function (pre_block) {
          let code_block = pre_block.querySelector("code");
          let editor = window.ace.edit(code_block);
          editor.setValue(codes[i]);
          editor.clearSelection();
          i += 1;
        },
      );
    }
  }
  function getCodeFromPlayground() {
    var codes = [];
    Array.from(document.querySelectorAll(".playground")).forEach(
      function (pre_block) {
        let code_block = pre_block.querySelector("code");
        let editor = window.ace.edit(code_block);
        let code = editor.getValue();
        codes.push(code);
      },
    );
    localStorage.setItem(`${window.location.href}₹code`, JSON.stringify(codes));
  }
  setCodeToPlayground();
  addEventListener("pagehide", getCodeFromPlayground);
})();

function resetPlaygroundsClicked() {
  let keys = [];
  for (var i = 0, len = localStorage.length; i < len; i++) {
    if (localStorage.key(i).includes("₹code")) {
      keys.push(localStorage.key(i));
    }
  }
  for (let j = 0; j < keys.length; j++) {
    localStorage.removeItem(keys[j]);
  }
}
window.resetPlaygroundsClicked = resetPlaygroundsClicked;



================================================
FILE: theme/speaker-notes.js
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

(function () {
  // Valid speaker notes states
  const NotesState = {
    Popup: "popup",
    Inline: "inline-open",
    Closed: "inline-closed",
  };

  // The mode/function of this window
  const WindowMode = {
    Regular: "regular",
    RegularWithSpeakerNotes: "regular-speaker-notes",
    SpeakerNotes: "speaker-notes",
    PrintPage: "print-page",
  };

  // detect the current window mode based on window location properties
  function detectWindowMode() {
    if (window.location.hash == "#speaker-notes-open") {
      return WindowMode.SpeakerNotes;
    } else if (window.location.hash == "#speaker-notes") {
      return WindowMode.RegularWithSpeakerNotes;
    } else if (window.location.pathname.endsWith("/print.html")) {
      return WindowMode.PrintPage;
    } else {
      return WindowMode.Regular;
    }
  }

  // This channel is used to detect if a speaker notes window is open
  // The slides regularly pings the speaker notes window and the speaker notes send a pong
  // If that pong is missing, assume that the notes are closed
  const speakerNotesChannel = new BroadcastChannel("speaker-notes");
  // Track if a pong was received
  var speakerNotesPongReceived = false;

  // Messages sent across the broadcast channel
  const BroadcastMessage = {
    Ping: "ping",
    Pong: "pong",
    CloseNotes: "close-notes",
  };

  // Detect the speaker notes from the regular window
  function speakerNotesDetection() {
    // Reset the tracking variable
    speakerNotesPongReceived = false;
    // Send the ping
    speakerNotesChannel.postMessage(BroadcastMessage.Ping);
    setTimeout(() => {
      // Check if a pong message was received after the timeout of 500ms
      if (!speakerNotesPongReceived) {
        if (getSpeakerNotesState() == NotesState.Popup) {
          // Reset to Inline if we have been in Popup mode
          setSpeakerNotesState(NotesState.Inline);
        }
      } else {
        // Received a pong from a speaker notes window
        if (getSpeakerNotesState() != NotesState.Popup) {
          // but we are not in Popup mode, reset to Popup mode
          setSpeakerNotesState(NotesState.Popup);
        }
      }
    }, 500);
  }

  // Handle broadcast messages
  speakerNotesChannel.onmessage = (event) => {
    if (detectWindowMode() == WindowMode.SpeakerNotes) {
      // Messages for the speaker notes window
      if (event.data == BroadcastMessage.Ping) {
        // Regular window sent a ping request, send answer
        speakerNotesChannel.postMessage(BroadcastMessage.Pong);
      } else if (event.data == BroadcastMessage.CloseNotes) {
        // Regular window sent a close request, close the window
        window.close();
      }
    } else {
      // Messages for a regular window
      if (event.data == BroadcastMessage.Pong) {
        // Signal to the detection method that we received a pong
        speakerNotesPongReceived = true;
      }
    }
  };

  let notes = document.querySelector("details");
  // Create an unattached DOM node for the code below.
  if (!notes) {
    notes = document.createElement("details");
  }
  let popIn = document.createElement("button");

  // Apply the correct style for the inline speaker notes in the
  // regular window - do not use on speaker notes page
  function applyInlinePopupStyle() {
    switch (getSpeakerNotesState()) {
      case NotesState.Popup:
        popIn.classList.remove("hidden");
        notes.classList.add("hidden");
        break;
      case NotesState.Inline:
        popIn.classList.add("hidden");
        notes.open = true;
        notes.classList.remove("hidden");
        break;
      case NotesState.Closed:
        popIn.classList.add("hidden");
        notes.open = false;
        notes.classList.remove("hidden");
        break;
    }
  }

  // Get the state of the speaker note window.
  function getSpeakerNotesState() {
    return window.localStorage["speakerNotes"] || NotesState.Closed;
  }

  // Set the state of the speaker note window.
  function setSpeakerNotesState(state) {
    if (window.localStorage["speakerNotes"] == state) {
      // no change
      return;
    }
    window.localStorage["speakerNotes"] = state;
    applyInlinePopupStyle();
  }

  // Create controls for a regular page.
  function setupRegularPage() {
    // Set-up a detector for speaker notes windows that pings
    // potential speaker note windows every 1000ms
    setInterval(speakerNotesDetection, 1000);

    // Create pop-in button.
    popIn.setAttribute("id", "speaker-notes-toggle");
    popIn.setAttribute("type", "button");
    popIn.setAttribute("title", "Close speaker notes");
    popIn.setAttribute("aria-label", "Close speaker notes");
    popIn.classList.add("icon-button");
    let popInIcon = document.createElement("i");
    popInIcon.classList.add("fa", "fa-window-close-o");
    popIn.append(popInIcon);
    popIn.addEventListener("click", (event) => {
      // Send a message to the speaker notes to close itself
      speakerNotesChannel.postMessage(BroadcastMessage.CloseNotes);
      // Switch to Inline popup mode
      setSpeakerNotesState(NotesState.Inline);
    });
    document.querySelector(".left-buttons").append(popIn);

    // Create speaker notes.
    notes.addEventListener("toggle", (event) => {
      // This always fires on first load on a regular page when applyInlinePopupStyle()
      // is called notes are opened (if NotesState.Inline)
      setSpeakerNotesState(notes.open ? NotesState.Inline : NotesState.Closed);
    });

    let summary = document.createElement("summary");
    notes.insertBefore(summary, notes.firstChild);

    let h4 = document.createElement("h4");
    h4.setAttribute("id", "speaker-notes");
    h4.append("Speaker Notes");
    h4.addEventListener("click", (event) => {
      // Update fragment as if we had clicked a link. A regular a element would
      // result in double-fire of the event.
      window.location.hash = "#speaker-notes";
    });
    summary.append(h4);

    // Create pop-out button.
    let popOutLocation = new URL(window.location.href);
    popOutLocation.hash = "#speaker-notes-open";
    let popOut = document.createElement("button");
    popOut.classList.add("icon-button", "pop-out");
    popOut.addEventListener("click", (event) => {
      let popup = window.open(
        popOutLocation.href,
        "speakerNotes",
        NotesState.Popup,
      );
      if (popup) {
        setSpeakerNotesState(NotesState.Popup);
      } else {
        window.alert(
          "Could not open popup, please check your popup blocker settings.",
        );
      }
    });
    let popOutIcon = document.createElement("i");
    popOutIcon.classList.add("fa", "fa-external-link");
    popOut.append(popOutIcon);
    summary.append(popOut);
  }

  // Create headers on the print page.
  function setupPrintPage() {
    for (const notes of document.querySelectorAll("details")) {
      notes.open = true;
      let summary = document.createElement("summary");
      notes.insertBefore(summary, notes.firstChild);
      let h4 = document.createElement("h4");
      h4.append("Speaker Notes");
      summary.append(h4);
    }
  }

  // Create controls for a speaker note window.
  function setupSpeakerNotes() {
    // Hide sidebar and buttons.
    document.querySelector("html").classList.remove("sidebar-visible");
    document.querySelector("html").classList.add("sidebar-hidden");
    document.querySelector(".left-buttons").classList.add("hidden");
    document.querySelector(".right-buttons").classList.add("hidden");

    // Hide content except for the speaker notes and h1 elements.
    const main = document.querySelector("main");
    let children = main.childNodes;
    let i = 0;
    while (i < children.length) {
      const node = children[i];
      switch (node.tagName) {
        case "DETAILS":
          // We found the speaker notes: extract their content.
          let div = document.createElement("div");
          div.replaceChildren(...node.childNodes);
          node.replaceWith(div);
          i += 1;
          break;
        case "H1":
          // We found a header: turn it into a smaller header for the speaker
          // note window.
          let h4 = document.createElement("h4");
          let pageLocation = new URL(window.location.href);
          pageLocation.hash = "";
          let a = document.createElement("a");
          a.setAttribute("href", pageLocation.href);
          a.append(node.innerText);
          h4.append("Speaker Notes for ", a);
          node.replaceWith(h4);
          i += 1;
          break;
        default:
          // We found something else: remove it.
          main.removeChild(node);
      }
    }

    // Update prev/next buttons to keep speaker note state.
    document
      .querySelectorAll('a[rel~="prev"], a[rel~="next"]')
      .forEach((elem) => {
        elem.href += "#speaker-notes-open";
      });
  }

  // This will fire on _other_ open windows when we change window.localStorage.
  window.addEventListener("storage", (event) => {
    switch (event.key) {
      case "currentPage":
        if (getSpeakerNotesState() == NotesState.Popup) {
          // We link all windows when we are showing speaker notes.
          window.location.pathname = event.newValue;
        }
        break;
    }
  });
  window.localStorage["currentPage"] = window.location.pathname;

  // apply the correct state for the window
  switch (detectWindowMode()) {
    case WindowMode.SpeakerNotes:
      setupSpeakerNotes();
      break;
    case WindowMode.PrintPage:
      setupPrintPage();
      break;
    case WindowMode.RegularWithSpeakerNotes:
      // Regular page with inline speaker notes, set state then fall-through
      setSpeakerNotesState(NotesState.Inline);
    case WindowMode.Regular:
      // Manually apply the style once
      applyInlinePopupStyle();
      setupRegularPage();
      break;
  }
})();



================================================
FILE: theme/css/language-picker.css
================================================
#language-list {
  left: auto;
  right: 10px;
}

[dir="rtl"] #language-list {
  left: 10px;
  right: auto;
}

#language-list a {
  color: inherit;
}



================================================
FILE: theme/css/redbox.css
================================================
div#aspect-ratio-helper {
  position: fixed;
  top: 8px;
  left: 8px;
  right: 8px;
  z-index: 1000;
  pointer-events: none;
}

div#aspect-ratio-helper div {
  outline: 3px dashed red;
  margin: 0 auto;
  /* At this width, the theme fonts are readable in a 16
       person conference room. If the browser is wider, the
       text becomes too small to be legible. */
  max-width: 980px;
  /* On a standard 16/9 monitor, we expect to lose a bit
       of vertical space to borders. */
  aspect-ratio: 16/8.5;
}

#instructor-menu-list {
  margin-left: 55px;
}



================================================
FILE: theme/css/rtl.css
================================================
[dir="rtl"] .hljs,
[dir="rtl"] pre > code {
  text-align: left;
}
[dir="rtl"] #cookieBar {
  direction: ltr;
}
[dir="rtl"] svg {
  direction: ltr;
}



================================================
FILE: theme/css/speaker-notes.css
================================================
.content details {
  background: var(--sidebar-bg);
  color: var(--sidebar-fg) !important;
  border-radius: 0.25em;
  padding: 0.25em;
}

.content details summary h4 {
  display: inline-block;
  list-style: none;
  font-weight: normal;
  font-style: italic;
  margin: 0.5em 0.25em;
  cursor: pointer;
}

.content details summary h4:target::before {
  margin-left: -40px;
  width: 40px;
}

.content details summary .pop-out {
  color: var(--icons);
  padding: 0 8px;
  cursor: pointer;
  transition: color 0.5s;
}

.content details summary .pop-out i:hover {
  color: var(--icons-hover);
}



================================================
FILE: theme/css/svgbob.css
================================================
/* Ensure text is legible in all themes. */
svg text {
  fill: var(--fg);
}



================================================
FILE: third_party/README.md
================================================
# Third-party Course Content

The files in this directory are included in the course via the `{{#include ..}}`
syntax. All third-party content must be placed here to clearly indicate its
origin.

When we publish a translation of the course, we `git restore` the `src/` and
`third_party/` directories at the repository root back to the date listed in the
POT-Creation-Date header of the translation. **It is crucial, that all
translatable content lives in those two directories.** The other files (such as
`book.toml` and `theme/`) are not restored and we always use the latest version
of them.



================================================
FILE: third_party/cxx/README.md
================================================
# CXX

This directory contains files copied from CXX. Please see
<https://github.com/dtolnay/cxx> for the full project.

## License

CXX is licensed under either of

* Apache License, Version 2.0, ([LICENSE-APACHE](LICENSE-APACHE) or
  <http://www.apache.org/licenses/LICENSE-2.0>)
* MIT license ([LICENSE-MIT](LICENSE-MIT) or
  <http://opensource.org/licenses/MIT>)

at your option.



================================================
FILE: third_party/cxx/LICENSE-APACHE
================================================
                              Apache License
                        Version 2.0, January 2004
                     http://www.apache.org/licenses/

TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

1. Definitions.

   "License" shall mean the terms and conditions for use, reproduction,
   and distribution as defined by Sections 1 through 9 of this document.

   "Licensor" shall mean the copyright owner or entity authorized by
   the copyright owner that is granting the License.

   "Legal Entity" shall mean the union of the acting entity and all
   other entities that control, are controlled by, or are under common
   control with that entity. For the purposes of this definition,
   "control" means (i) the power, direct or indirect, to cause the
   direction or management of such entity, whether by contract or
   otherwise, or (ii) ownership of fifty percent (50%) or more of the
   outstanding shares, or (iii) beneficial ownership of such entity.

   "You" (or "Your") shall mean an individual or Legal Entity
   exercising permissions granted by this License.

   "Source" form shall mean the preferred form for making modifications,
   including but not limited to software source code, documentation
   source, and configuration files.

   "Object" form shall mean any form resulting from mechanical
   transformation or translation of a Source form, including but
   not limited to compiled object code, generated documentation,
   and conversions to other media types.

   "Work" shall mean the work of authorship, whether in Source or
   Object form, made available under the License, as indicated by a
   copyright notice that is included in or attached to the work
   (an example is provided in the Appendix below).

   "Derivative Works" shall mean any work, whether in Source or Object
   form, that is based on (or derived from) the Work and for which the
   editorial revisions, annotations, elaborations, or other modifications
   represent, as a whole, an original work of authorship. For the purposes
   of this License, Derivative Works shall not include works that remain
   separable from, or merely link (or bind by name) to the interfaces of,
   the Work and Derivative Works thereof.

   "Contribution" shall mean any work of authorship, including
   the original version of the Work and any modifications or additions
   to that Work or Derivative Works thereof, that is intentionally
   submitted to Licensor for inclusion in the Work by the copyright owner
   or by an individual or Legal Entity authorized to submit on behalf of
   the copyright owner. For the purposes of this definition, "submitted"
   means any form of electronic, verbal, or written communication sent
   to the Licensor or its representatives, including but not limited to
   communication on electronic mailing lists, source code control systems,
   and issue tracking systems that are managed by, or on behalf of, the
   Licensor for the purpose of discussing and improving the Work, but
   excluding communication that is conspicuously marked or otherwise
   designated in writing by the copyright owner as "Not a Contribution."

   "Contributor" shall mean Licensor and any individual or Legal Entity
   on behalf of whom a Contribution has been received by Licensor and
   subsequently incorporated within the Work.

2. Grant of Copyright License. Subject to the terms and conditions of
   this License, each Contributor hereby grants to You a perpetual,
   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
   copyright license to reproduce, prepare Derivative Works of,
   publicly display, publicly perform, sublicense, and distribute the
   Work and such Derivative Works in Source or Object form.

3. Grant of Patent License. Subject to the terms and conditions of
   this License, each Contributor hereby grants to You a perpetual,
   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
   (except as stated in this section) patent license to make, have made,
   use, offer to sell, sell, import, and otherwise transfer the Work,
   where such license applies only to those patent claims licensable
   by such Contributor that are necessarily infringed by their
   Contribution(s) alone or by combination of their Contribution(s)
   with the Work to which such Contribution(s) was submitted. If You
   institute patent litigation against any entity (including a
   cross-claim or counterclaim in a lawsuit) alleging that the Work
   or a Contribution incorporated within the Work constitutes direct
   or contributory patent infringement, then any patent licenses
   granted to You under this License for that Work shall terminate
   as of the date such litigation is filed.

4. Redistribution. You may reproduce and distribute copies of the
   Work or Derivative Works thereof in any medium, with or without
   modifications, and in Source or Object form, provided that You
   meet the following conditions:

   (a) You must give any other recipients of the Work or
       Derivative Works a copy of this License; and

   (b) You must cause any modified files to carry prominent notices
       stating that You changed the files; and

   (c) You must retain, in the Source form of any Derivative Works
       that You distribute, all copyright, patent, trademark, and
       attribution notices from the Source form of the Work,
       excluding those notices that do not pertain to any part of
       the Derivative Works; and

   (d) If the Work includes a "NOTICE" text file as part of its
       distribution, then any Derivative Works that You distribute must
       include a readable copy of the attribution notices contained
       within such NOTICE file, excluding those notices that do not
       pertain to any part of the Derivative Works, in at least one
       of the following places: within a NOTICE text file distributed
       as part of the Derivative Works; within the Source form or
       documentation, if provided along with the Derivative Works; or,
       within a display generated by the Derivative Works, if and
       wherever such third-party notices normally appear. The contents
       of the NOTICE file are for informational purposes only and
       do not modify the License. You may add Your own attribution
       notices within Derivative Works that You distribute, alongside
       or as an addendum to the NOTICE text from the Work, provided
       that such additional attribution notices cannot be construed
       as modifying the License.

   You may add Your own copyright statement to Your modifications and
   may provide additional or different license terms and conditions
   for use, reproduction, or distribution of Your modifications, or
   for any such Derivative Works as a whole, provided Your use,
   reproduction, and distribution of the Work otherwise complies with
   the conditions stated in this License.

5. Submission of Contributions. Unless You explicitly state otherwise,
   any Contribution intentionally submitted for inclusion in the Work
   by You to the Licensor shall be under the terms and conditions of
   this License, without any additional terms or conditions.
   Notwithstanding the above, nothing herein shall supersede or modify
   the terms of any separate license agreement you may have executed
   with Licensor regarding such Contributions.

6. Trademarks. This License does not grant permission to use the trade
   names, trademarks, service marks, or product names of the Licensor,
   except as required for reasonable and customary use in describing the
   origin of the Work and reproducing the content of the NOTICE file.

7. Disclaimer of Warranty. Unless required by applicable law or
   agreed to in writing, Licensor provides the Work (and each
   Contributor provides its Contributions) on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   implied, including, without limitation, any warranties or conditions
   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
   PARTICULAR PURPOSE. You are solely responsible for determining the
   appropriateness of using or redistributing the Work and assume any
   risks associated with Your exercise of permissions under this License.

8. Limitation of Liability. In no event and under no legal theory,
   whether in tort (including negligence), contract, or otherwise,
   unless required by applicable law (such as deliberate and grossly
   negligent acts) or agreed to in writing, shall any Contributor be
   liable to You for damages, including any direct, indirect, special,
   incidental, or consequential damages of any character arising as a
   result of this License or out of the use or inability to use the
   Work (including but not limited to damages for loss of goodwill,
   work stoppage, computer failure or malfunction, or any and all
   other commercial damages or losses), even if such Contributor
   has been advised of the possibility of such damages.

9. Accepting Warranty or Additional Liability. While redistributing
   the Work or Derivative Works thereof, You may choose to offer,
   and charge a fee for, acceptance of support, warranty, indemnity,
   or other liability obligations and/or rights consistent with this
   License. However, in accepting such obligations, You may act only
   on Your own behalf and on Your sole responsibility, not on behalf
   of any other Contributor, and only if You agree to indemnify,
   defend, and hold each Contributor harmless for any liability
   incurred by, or claims asserted against, such Contributor by reason
   of your accepting any such warranty or additional liability.

END OF TERMS AND CONDITIONS

APPENDIX: How to apply the Apache License to your work.

   To apply the Apache License to your work, attach the following
   boilerplate notice, with the fields enclosed by brackets "[]"
   replaced with your own identifying information. (Don't include
   the brackets!)  The text should be enclosed in the appropriate
   comment syntax for the file format. We also recommend that a
   file or class name and description of purpose be included on the
   same "printed page" as the copyright notice for easier
   identification within third-party archives.

Copyright [yyyy] [name of copyright owner]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.



================================================
FILE: third_party/cxx/LICENSE-MIT
================================================
Permission is hereby granted, free of charge, to any
person obtaining a copy of this software and associated
documentation files (the "Software"), to deal in the
Software without restriction, including without
limitation the rights to use, copy, modify, merge,
publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software
is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice
shall be included in all copies or substantial portions
of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.



================================================
FILE: third_party/cxx/blobstore/Android.bp
================================================
cc_library_static {
    name: "blobstore_cpp",
    srcs: ["src/blobstore.cc"],
    generated_headers: [
        "cxx-bridge-header",
        "blobstore_bridge_header"
    ],
    generated_sources: ["blobstore_bridge_code"],
}

genrule {
    name: "blobstore_bridge_header",
    tools: ["cxxbridge"],
    cmd: "$(location cxxbridge) $(in) --header > $(out)",
    srcs: ["src/main.rs"],
    out: ["main.rs.h"],
}

genrule {
    name: "blobstore_bridge_code",
    tools: ["cxxbridge"],
    cmd: "$(location cxxbridge) $(in) > $(out)",
    srcs: ["src/main.rs"],
    out: ["main.rs.cc"],
}

rust_binary {
    name: "blobstore",
    srcs: ["src/main.rs"],
    rustlibs: ["libcxx"],
    static_libs: ["blobstore_cpp"],
}



================================================
FILE: third_party/cxx/blobstore/BUILD
================================================
load("@rules_cc//cc:defs.bzl", "cc_library")
load("@rules_rust//rust:defs.bzl", "rust_binary")
load("//tools/bazel:rust_cxx_bridge.bzl", "rust_cxx_bridge")

rust_binary(
    name = "demo",
    srcs = glob(["src/**/*.rs"]),
    edition = "2021",
    deps = [
        ":blobstore-sys",
        ":bridge",
        "//:cxx",
    ],
)

rust_cxx_bridge(
    name = "bridge",
    src = "src/main.rs",
    deps = [":blobstore-include"],
)

cc_library(
    name = "blobstore-sys",
    srcs = ["src/blobstore.cc"],
    deps = [
        ":blobstore-include",
        ":bridge/include",
    ],
)

cc_library(
    name = "blobstore-include",
    hdrs = ["include/blobstore.h"],
    deps = ["//:core"],
)



================================================
FILE: third_party/cxx/blobstore/build.rs
================================================
fn main() {
    // Find target directory, either from CARGO_TARGET_DIR or in-tree if unset.
    let mut src_dir =
        std::env::var_os("CARGO_TARGET_DIR").unwrap_or("../../../target".into());
    src_dir.push("/cxxbridge/demo/src");

    cxx_build::bridge("src/main.rs")
        .file("src/blobstore.cc")
        .flag_if_supported("-std=c++14")
        .include(".")
        .include(src_dir)
        .compile("cxxbridge-demo");

    println!("cargo:rerun-if-changed=src/main.rs");
    println!("cargo:rerun-if-changed=src/blobstore.cc");
    println!("cargo:rerun-if-changed=include/blobstore.h");
}



================================================
FILE: third_party/cxx/blobstore/Cargo.toml
================================================
[package]
name = "demo"
version = "0.0.0"
authors = ["David Tolnay <dtolnay@gmail.com>"]
description = "Toy project from https://github.com/dtolnay/cxx"
edition = "2021"
license = "MIT OR Apache-2.0"
publish = false
repository = "https://github.com/dtolnay/cxx"

[dependencies]
cxx = "1.0"

[build-dependencies]
cxx-build = "1.0"



================================================
FILE: third_party/cxx/blobstore/include/blobstore.h
================================================
#pragma once
#include "rust/cxx.h"
#include <memory>
#include <set>
#include <unordered_map>
#include <string>

namespace org {
namespace blobstore {

struct MultiBuf;
struct BlobMetadata;

class BlobstoreClient {
public:
  BlobstoreClient();
  uint64_t put(MultiBuf &buf);
  void tag(uint64_t blobid, rust::Str tag);
  BlobMetadata metadata(uint64_t blobid) const;

private:
  using Blob = struct {
    std::string data;
    std::set<std::string> tags;
  };
  std::unordered_map<uint64_t, Blob> blobs;
};

std::unique_ptr<BlobstoreClient> new_blobstore_client();

} // namespace blobstore
} // namespace org



================================================
FILE: third_party/cxx/blobstore/src/blobstore.cc
================================================
#include "include/blobstore.h"
#include "main.rs.h"
#include <algorithm>
#include <functional>

namespace org {
namespace blobstore {

BlobstoreClient::BlobstoreClient() {}

// Upload a new blob and return a blobid that serves as a handle to the blob.
uint64_t BlobstoreClient::put(MultiBuf &buf) {
  std::string contents;

  // Traverse the caller's chunk iterator.
  //
  // In reality there might be sophisticated batching of chunks and/or parallel
  // upload implemented by the blobstore's C++ client.
  while (true) {
    auto chunk = next_chunk(buf);
    if (chunk.size() == 0) {
      break;
    }
    contents.append(reinterpret_cast<const char *>(chunk.data()), chunk.size());
  }

  // Insert into map and provide caller the handle.
  auto blobid = std::hash<std::string>{}(contents);
  blobs[blobid] = {std::move(contents), {}};
  return blobid;
}

// Add tag to an existing blob.
void BlobstoreClient::tag(uint64_t blobid, rust::Str tag) {
  blobs[blobid].tags.emplace(tag);
}

// Retrieve metadata about a blob.
BlobMetadata BlobstoreClient::metadata(uint64_t blobid) const {
  BlobMetadata metadata{};
  auto blob = blobs.find(blobid);
  if (blob != blobs.end()) {
    metadata.size = blob->second.data.size();
    std::for_each(blob->second.tags.cbegin(), blob->second.tags.cend(),
                  [&](auto &t) { metadata.tags.emplace_back(t); });
  }
  return metadata;
}

std::unique_ptr<BlobstoreClient> new_blobstore_client() {
  return std::make_unique<BlobstoreClient>();
}

} // namespace blobstore
} // namespace org



================================================
FILE: third_party/cxx/blobstore/src/main.rs
================================================
//! Example project demonstrating usage of CXX.
// ANCHOR: bridge
#[allow(unsafe_op_in_unsafe_fn)]
#[cxx::bridge(namespace = "org::blobstore")]
mod ffi {
    // Shared structs with fields visible to both languages.
    struct BlobMetadata {
        size: usize,
        tags: Vec<String>,
    }

    // ANCHOR: rust_bridge
    // Rust types and signatures exposed to C++.
    extern "Rust" {
        type MultiBuf;

        fn next_chunk(buf: &mut MultiBuf) -> &[u8];
    }
    // ANCHOR_END: rust_bridge

    // ANCHOR: cpp_bridge
    // C++ types and signatures exposed to Rust.
    unsafe extern "C++" {
        include!("include/blobstore.h");

        type BlobstoreClient;

        fn new_blobstore_client() -> UniquePtr<BlobstoreClient>;
        fn put(self: Pin<&mut BlobstoreClient>, parts: &mut MultiBuf) -> u64;
        fn tag(self: Pin<&mut BlobstoreClient>, blobid: u64, tag: &str);
        fn metadata(&self, blobid: u64) -> BlobMetadata;
    }
    // ANCHOR_END: cpp_bridge
}
// ANCHOR_END: bridge

/// An iterator over contiguous chunks of a discontiguous file object.
///
/// Toy implementation uses a Vec<Vec<u8>> but in reality this might be
/// iterating over some more complex Rust data structure like a rope, or maybe
/// loading chunks lazily from somewhere.
pub struct MultiBuf {
    chunks: Vec<Vec<u8>>,
    pos: usize,
}

/// Pulls the next chunk from the buffer.
pub fn next_chunk(buf: &mut MultiBuf) -> &[u8] {
    let next = buf.chunks.get(buf.pos);
    buf.pos += 1;
    next.map_or(&[], Vec::as_slice)
}

fn main() {
    let mut client = ffi::new_blobstore_client();

    // Upload a blob.
    let chunks = vec![b"fearless".to_vec(), b"concurrency".to_vec()];
    let mut buf = MultiBuf { chunks, pos: 0 };
    let blobid = client.pin_mut().put(&mut buf);
    println!("blobid = {}", blobid);

    // Add a tag.
    client.pin_mut().tag(blobid, "rust");

    // Read back the tags.
    let metadata = client.metadata(blobid);
    println!("tags = {:?}", metadata.tags);
}



================================================
FILE: third_party/cxx/book/snippets.cc
================================================
// This file contains various code snippets taken from the CXX book and
// tutorial. Some have been modified to fit the course better.

// ANCHOR: shared_enums_cpp
enum class Suit : uint8_t {
  Clubs = 0,
  Diamonds = 1,
  Hearts = 2,
  Spades = 3,
};
// ANCHOR_END: shared_enums_cpp



================================================
FILE: third_party/cxx/book/snippets.rs
================================================
//! This file contains various code snippets taken from the CXX book and
//! tutorial. Some have been modified to fit the course better.

// ANCHOR: rust_bridge
#[cxx::bridge]
mod ffi {
    extern "Rust" {
        type MyType; // Opaque type
        fn foo(&self); // Method on `MyType`
        fn bar() -> Box<MyType>; // Free function
    }
}

struct MyType(i32);

impl MyType {
    fn foo(&self) {
        println!("{}", self.0);
    }
}

fn bar() -> Box<MyType> {
    Box::new(MyType(123))
}
// ANCHOR_END: rust_bridge

// ANCHOR: cpp_bridge
#[cxx::bridge]
mod ffi {
    extern "C++" {
        include!("demo/include/blobstore.h");
        type BlobstoreClient;
        fn new_blobstore_client() -> UniquePtr<BlobstoreClient>;
        fn put(&self, parts: &mut MultiBuf) -> u64;
    }

    unsafe extern "C++" {
        fn f();  // safe to call
    }
}
// ANCHOR_END: cpp_bridge

// ANCHOR: shared_types
#[cxx::bridge]
mod ffi {
    #[derive(Clone, Debug, Hash)]
    struct PlayingCard {
        suit: Suit,
        value: u8,  // A=1, J=11, Q=12, K=13
    }

    enum Suit {
        Clubs,
        Diamonds,
        Hearts,
        Spades,
    }
}
// ANCHOR_END: shared_types

// ANCHOR: shared_enums_bridge
#[cxx::bridge]
mod ffi {
    enum Suit {
        Clubs,
        Diamonds,
        Hearts,
        Spades,
    }
}
// ANCHOR_END: shared_enums_bridge

// ANCHOR: shared_enums_rust
#[derive(Copy, Clone, PartialEq, Eq)]
#[repr(transparent)]
pub struct Suit {
    pub repr: u8,
}

#[allow(non_upper_case_globals)]
impl Suit {
    pub const Clubs: Self = Suit { repr: 0 };
    pub const Diamonds: Self = Suit { repr: 1 };
    pub const Hearts: Self = Suit { repr: 2 };
    pub const Spades: Self = Suit { repr: 3 };
}
// ANCHOR_END: shared_enums_rust

// ANCHOR: rust_result
#[cxx::bridge]
mod ffi {
    extern "Rust" {
        fn fallible(depth: usize) -> Result<String>;
    }
}

fn fallible(depth: usize) -> anyhow::Result<String> {
    if depth == 0 {
        return Err(anyhow::Error::msg("fallible1 requires depth > 0"));
    }

    Ok("Success!".into())
}
// ANCHOR_END: rust_result

// ANCHOR: cpp_exception
#[cxx::bridge]
mod ffi {
    unsafe extern "C++" {
        include!("example/include/example.h");
        fn fallible(depth: usize) -> Result<String>;
    }
}

fn main() {
    if let Err(err) = ffi::fallible(99) {
        eprintln!("Error: {}", err);
        process::exit(1);
    }
}
// ANCHOR_END: cpp_exception

// ANCHOR: cxx_overview
#[cxx::bridge]
mod ffi {
    extern "Rust" {
        type MultiBuf;

        fn next_chunk(buf: &mut MultiBuf) -> &[u8];
    }

    unsafe extern "C++" {
        include!("example/include/blobstore.h");

        type BlobstoreClient;

        fn new_blobstore_client() -> UniquePtr<BlobstoreClient>;
        fn put(self: &BlobstoreClient, buf: &mut MultiBuf) -> Result<u64>;
    }
}

// Definitions of Rust types and functions go here
// ANCHOR_END: cxx_overview


================================================
FILE: third_party/mdbook/README.md
================================================
# mdBook

This directory contains files copied from mdBook. Please see
<https://github.com/rust-lang/mdBook/> for the full project.

## License

mdBook is licensed under the Mozilla Public License v2.0 ([LICENSE](LICENSE)).



================================================
FILE: third_party/mdbook/LICENSE
================================================
Mozilla Public License, version 2.0

1. Definitions

1.1. "Contributor"

     means each individual or legal entity that creates, contributes to the
     creation of, or owns Covered Software.

1.2. "Contributor Version"

     means the combination of the Contributions of others (if any) used by a
     Contributor and that particular Contributor's Contribution.

1.3. "Contribution"

     means Covered Software of a particular Contributor.

1.4. "Covered Software"

     means Source Code Form to which the initial Contributor has attached the
     notice in Exhibit A, the Executable Form of such Source Code Form, and
     Modifications of such Source Code Form, in each case including portions
     thereof.

1.5. "Incompatible With Secondary Licenses"
     means

     a. that the initial Contributor has attached the notice described in
        Exhibit B to the Covered Software; or

     b. that the Covered Software was made available under the terms of
        version 1.1 or earlier of the License, but not also under the terms of
        a Secondary License.

1.6. "Executable Form"

     means any form of the work other than Source Code Form.

1.7. "Larger Work"

     means a work that combines Covered Software with other material, in a
     separate file or files, that is not Covered Software.

1.8. "License"

     means this document.

1.9. "Licensable"

     means having the right to grant, to the maximum extent possible, whether
     at the time of the initial grant or subsequently, any and all of the
     rights conveyed by this License.

1.10. "Modifications"

     means any of the following:

     a. any file in Source Code Form that results from an addition to,
        deletion from, or modification of the contents of Covered Software; or

     b. any new file in Source Code Form that contains any Covered Software.

1.11. "Patent Claims" of a Contributor

      means any patent claim(s), including without limitation, method,
      process, and apparatus claims, in any patent Licensable by such
      Contributor that would be infringed, but for the grant of the License,
      by the making, using, selling, offering for sale, having made, import,
      or transfer of either its Contributions or its Contributor Version.

1.12. "Secondary License"

      means either the GNU General Public License, Version 2.0, the GNU Lesser
      General Public License, Version 2.1, the GNU Affero General Public
      License, Version 3.0, or any later versions of those licenses.

1.13. "Source Code Form"

      means the form of the work preferred for making modifications.

1.14. "You" (or "Your")

      means an individual or a legal entity exercising rights under this
      License. For legal entities, "You" includes any entity that controls, is
      controlled by, or is under common control with You. For purposes of this
      definition, "control" means (a) the power, direct or indirect, to cause
      the direction or management of such entity, whether by contract or
      otherwise, or (b) ownership of more than fifty percent (50%) of the
      outstanding shares or beneficial ownership of such entity.


2. License Grants and Conditions

2.1. Grants

     Each Contributor hereby grants You a world-wide, royalty-free,
     non-exclusive license:

     a. under intellectual property rights (other than patent or trademark)
        Licensable by such Contributor to use, reproduce, make available,
        modify, display, perform, distribute, and otherwise exploit its
        Contributions, either on an unmodified basis, with Modifications, or
        as part of a Larger Work; and

     b. under Patent Claims of such Contributor to make, use, sell, offer for
        sale, have made, import, and otherwise transfer either its
        Contributions or its Contributor Version.

2.2. Effective Date

     The licenses granted in Section 2.1 with respect to any Contribution
     become effective for each Contribution on the date the Contributor first
     distributes such Contribution.

2.3. Limitations on Grant Scope

     The licenses granted in this Section 2 are the only rights granted under
     this License. No additional rights or licenses will be implied from the
     distribution or licensing of Covered Software under this License.
     Notwithstanding Section 2.1(b) above, no patent license is granted by a
     Contributor:

     a. for any code that a Contributor has removed from Covered Software; or

     b. for infringements caused by: (i) Your and any other third party's
        modifications of Covered Software, or (ii) the combination of its
        Contributions with other software (except as part of its Contributor
        Version); or

     c. under Patent Claims infringed by Covered Software in the absence of
        its Contributions.

     This License does not grant any rights in the trademarks, service marks,
     or logos of any Contributor (except as may be necessary to comply with
     the notice requirements in Section 3.4).

2.4. Subsequent Licenses

     No Contributor makes additional grants as a result of Your choice to
     distribute the Covered Software under a subsequent version of this
     License (see Section 10.2) or under the terms of a Secondary License (if
     permitted under the terms of Section 3.3).

2.5. Representation

     Each Contributor represents that the Contributor believes its
     Contributions are its original creation(s) or it has sufficient rights to
     grant the rights to its Contributions conveyed by this License.

2.6. Fair Use

     This License is not intended to limit any rights You have under
     applicable copyright doctrines of fair use, fair dealing, or other
     equivalents.

2.7. Conditions

     Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in
     Section 2.1.


3. Responsibilities

3.1. Distribution of Source Form

     All distribution of Covered Software in Source Code Form, including any
     Modifications that You create or to which You contribute, must be under
     the terms of this License. You must inform recipients that the Source
     Code Form of the Covered Software is governed by the terms of this
     License, and how they can obtain a copy of this License. You may not
     attempt to alter or restrict the recipients' rights in the Source Code
     Form.

3.2. Distribution of Executable Form

     If You distribute Covered Software in Executable Form then:

     a. such Covered Software must also be made available in Source Code Form,
        as described in Section 3.1, and You must inform recipients of the
        Executable Form how they can obtain a copy of such Source Code Form by
        reasonable means in a timely manner, at a charge no more than the cost
        of distribution to the recipient; and

     b. You may distribute such Executable Form under the terms of this
        License, or sublicense it under different terms, provided that the
        license for the Executable Form does not attempt to limit or alter the
        recipients' rights in the Source Code Form under this License.

3.3. Distribution of a Larger Work

     You may create and distribute a Larger Work under terms of Your choice,
     provided that You also comply with the requirements of this License for
     the Covered Software. If the Larger Work is a combination of Covered
     Software with a work governed by one or more Secondary Licenses, and the
     Covered Software is not Incompatible With Secondary Licenses, this
     License permits You to additionally distribute such Covered Software
     under the terms of such Secondary License(s), so that the recipient of
     the Larger Work may, at their option, further distribute the Covered
     Software under the terms of either this License or such Secondary
     License(s).

3.4. Notices

     You may not remove or alter the substance of any license notices
     (including copyright notices, patent notices, disclaimers of warranty, or
     limitations of liability) contained within the Source Code Form of the
     Covered Software, except that You may alter any license notices to the
     extent required to remedy known factual inaccuracies.

3.5. Application of Additional Terms

     You may choose to offer, and to charge a fee for, warranty, support,
     indemnity or liability obligations to one or more recipients of Covered
     Software. However, You may do so only on Your own behalf, and not on
     behalf of any Contributor. You must make it absolutely clear that any
     such warranty, support, indemnity, or liability obligation is offered by
     You alone, and You hereby agree to indemnify every Contributor for any
     liability incurred by such Contributor as a result of warranty, support,
     indemnity or liability terms You offer. You may include additional
     disclaimers of warranty and limitations of liability specific to any
     jurisdiction.

4. Inability to Comply Due to Statute or Regulation

   If it is impossible for You to comply with any of the terms of this License
   with respect to some or all of the Covered Software due to statute,
   judicial order, or regulation then You must: (a) comply with the terms of
   this License to the maximum extent possible; and (b) describe the
   limitations and the code they affect. Such description must be placed in a
   text file included with all distributions of the Covered Software under
   this License. Except to the extent prohibited by statute or regulation,
   such description must be sufficiently detailed for a recipient of ordinary
   skill to be able to understand it.

5. Termination

5.1. The rights granted under this License will terminate automatically if You
     fail to comply with any of its terms. However, if You become compliant,
     then the rights granted under this License from a particular Contributor
     are reinstated (a) provisionally, unless and until such Contributor
     explicitly and finally terminates Your grants, and (b) on an ongoing
     basis, if such Contributor fails to notify You of the non-compliance by
     some reasonable means prior to 60 days after You have come back into
     compliance. Moreover, Your grants from a particular Contributor are
     reinstated on an ongoing basis if such Contributor notifies You of the
     non-compliance by some reasonable means, this is the first time You have
     received notice of non-compliance with this License from such
     Contributor, and You become compliant prior to 30 days after Your receipt
     of the notice.

5.2. If You initiate litigation against any entity by asserting a patent
     infringement claim (excluding declaratory judgment actions,
     counter-claims, and cross-claims) alleging that a Contributor Version
     directly or indirectly infringes any patent, then the rights granted to
     You by any and all Contributors for the Covered Software under Section
     2.1 of this License shall terminate.

5.3. In the event of termination under Sections 5.1 or 5.2 above, all end user
     license agreements (excluding distributors and resellers) which have been
     validly granted by You or Your distributors under this License prior to
     termination shall survive termination.

6. Disclaimer of Warranty

   Covered Software is provided under this License on an "as is" basis,
   without warranty of any kind, either expressed, implied, or statutory,
   including, without limitation, warranties that the Covered Software is free
   of defects, merchantable, fit for a particular purpose or non-infringing.
   The entire risk as to the quality and performance of the Covered Software
   is with You. Should any Covered Software prove defective in any respect,
   You (not any Contributor) assume the cost of any necessary servicing,
   repair, or correction. This disclaimer of warranty constitutes an essential
   part of this License. No use of  any Covered Software is authorized under
   this License except under this disclaimer.

7. Limitation of Liability

   Under no circumstances and under no legal theory, whether tort (including
   negligence), contract, or otherwise, shall any Contributor, or anyone who
   distributes Covered Software as permitted above, be liable to You for any
   direct, indirect, special, incidental, or consequential damages of any
   character including, without limitation, damages for lost profits, loss of
   goodwill, work stoppage, computer failure or malfunction, or any and all
   other commercial damages or losses, even if such party shall have been
   informed of the possibility of such damages. This limitation of liability
   shall not apply to liability for death or personal injury resulting from
   such party's negligence to the extent applicable law prohibits such
   limitation. Some jurisdictions do not allow the exclusion or limitation of
   incidental or consequential damages, so this exclusion and limitation may
   not apply to You.

8. Litigation

   Any litigation relating to this License may be brought only in the courts
   of a jurisdiction where the defendant maintains its principal place of
   business and such litigation shall be governed by laws of that
   jurisdiction, without reference to its conflict-of-law provisions. Nothing
   in this Section shall prevent a party's ability to bring cross-claims or
   counter-claims.

9. Miscellaneous

   This License represents the complete agreement concerning the subject
   matter hereof. If any provision of this License is held to be
   unenforceable, such provision shall be reformed only to the extent
   necessary to make it enforceable. Any law or regulation which provides that
   the language of a contract shall be construed against the drafter shall not
   be used to construe this License against a Contributor.


10. Versions of the License

10.1. New Versions

      Mozilla Foundation is the license steward. Except as provided in Section
      10.3, no one other than the license steward has the right to modify or
      publish new versions of this License. Each version will be given a
      distinguishing version number.

10.2. Effect of New Versions

      You may distribute the Covered Software under the terms of the version
      of the License under which You originally received the Covered Software,
      or under the terms of any subsequent version published by the license
      steward.

10.3. Modified Versions

      If you create software not governed by this License, and you want to
      create a new license for such software, you may create and use a
      modified version of this License if you rename the license and remove
      any references to the name of the license steward (except to note that
      such modified license differs from this License).

10.4. Distributing Source Code Form that is Incompatible With Secondary
      Licenses If You choose to distribute Source Code Form that is
      Incompatible With Secondary Licenses under the terms of this version of
      the License, the notice described in Exhibit B of this License must be
      attached.

Exhibit A - Source Code Form License Notice

      This Source Code Form is subject to the
      terms of the Mozilla Public License, v.
      2.0. If a copy of the MPL was not
      distributed with this file, You can
      obtain one at
      http://mozilla.org/MPL/2.0/.

If it is not possible or desirable to put the notice in a particular file,
then You may include the notice in a location (such as a LICENSE file in a
relevant directory) where a recipient would be likely to look for such a
notice.

You may add additional accurate notices of copyright ownership.

Exhibit B - "Incompatible With Secondary Licenses" Notice

      This Source Code Form is "Incompatible
      With Secondary Licenses", as defined by
      the Mozilla Public License, v. 2.0.



================================================
SYMLINK: third_party/mdbook/book.js -> book.js
================================================



================================================
SYMLINK: third_party/mdbook/index.hbs -> index.hbs
================================================



================================================
FILE: third_party/rust-by-example/README.md
================================================
# Rust By Example

This directory contains examples copied from Rust by Example. Please see
<https://github.com/rust-lang/rust-by-example> for the full project.

## License

Rust by Example is licensed under either of

* Apache License, Version 2.0, ([LICENSE-APACHE](LICENSE-APACHE) or
  <http://www.apache.org/licenses/LICENSE-2.0>)
* MIT license ([LICENSE-MIT](LICENSE-MIT) or
  <http://opensource.org/licenses/MIT>)

at your option.



================================================
FILE: third_party/rust-by-example/destructuring-arrays.rs
================================================
#[rustfmt::skip]
fn main() {
    let triple = [0, -2, 3];
    println!("Tell me about {triple:?}");
    match triple {
        [0, y, z] => println!("First is 0, y = {y}, and z = {z}"),
        [1, ..]   => println!("First is 1 and the rest were ignored"),
        _         => println!("All elements were ignored"),
    }
}



================================================
FILE: third_party/rust-by-example/destructuring-structs.rs
================================================
struct Foo {
    x: (u32, u32),
    y: u32,
}

#[rustfmt::skip]
fn main() {
    let foo = Foo { x: (1, 2), y: 3 };
    match foo {
        Foo { y: 2, x: i }   => println!("y = 2, x = {i:?}"),
        Foo { x: (1, b), y } => println!("x.0 = 1, b = {b}, y = {y}"),
        Foo { y, .. }        => println!("y = {y}, other fields were ignored"),
    }
}



================================================
FILE: third_party/rust-by-example/LICENSE-APACHE
================================================
                              Apache License
                        Version 2.0, January 2004
                     http://www.apache.org/licenses/

TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

1. Definitions.

   "License" shall mean the terms and conditions for use, reproduction,
   and distribution as defined by Sections 1 through 9 of this document.

   "Licensor" shall mean the copyright owner or entity authorized by
   the copyright owner that is granting the License.

   "Legal Entity" shall mean the union of the acting entity and all
   other entities that control, are controlled by, or are under common
   control with that entity. For the purposes of this definition,
   "control" means (i) the power, direct or indirect, to cause the
   direction or management of such entity, whether by contract or
   otherwise, or (ii) ownership of fifty percent (50%) or more of the
   outstanding shares, or (iii) beneficial ownership of such entity.

   "You" (or "Your") shall mean an individual or Legal Entity
   exercising permissions granted by this License.

   "Source" form shall mean the preferred form for making modifications,
   including but not limited to software source code, documentation
   source, and configuration files.

   "Object" form shall mean any form resulting from mechanical
   transformation or translation of a Source form, including but
   not limited to compiled object code, generated documentation,
   and conversions to other media types.

   "Work" shall mean the work of authorship, whether in Source or
   Object form, made available under the License, as indicated by a
   copyright notice that is included in or attached to the work
   (an example is provided in the Appendix below).

   "Derivative Works" shall mean any work, whether in Source or Object
   form, that is based on (or derived from) the Work and for which the
   editorial revisions, annotations, elaborations, or other modifications
   represent, as a whole, an original work of authorship. For the purposes
   of this License, Derivative Works shall not include works that remain
   separable from, or merely link (or bind by name) to the interfaces of,
   the Work and Derivative Works thereof.

   "Contribution" shall mean any work of authorship, including
   the original version of the Work and any modifications or additions
   to that Work or Derivative Works thereof, that is intentionally
   submitted to Licensor for inclusion in the Work by the copyright owner
   or by an individual or Legal Entity authorized to submit on behalf of
   the copyright owner. For the purposes of this definition, "submitted"
   means any form of electronic, verbal, or written communication sent
   to the Licensor or its representatives, including but not limited to
   communication on electronic mailing lists, source code control systems,
   and issue tracking systems that are managed by, or on behalf of, the
   Licensor for the purpose of discussing and improving the Work, but
   excluding communication that is conspicuously marked or otherwise
   designated in writing by the copyright owner as "Not a Contribution."

   "Contributor" shall mean Licensor and any individual or Legal Entity
   on behalf of whom a Contribution has been received by Licensor and
   subsequently incorporated within the Work.

2. Grant of Copyright License. Subject to the terms and conditions of
   this License, each Contributor hereby grants to You a perpetual,
   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
   copyright license to reproduce, prepare Derivative Works of,
   publicly display, publicly perform, sublicense, and distribute the
   Work and such Derivative Works in Source or Object form.

3. Grant of Patent License. Subject to the terms and conditions of
   this License, each Contributor hereby grants to You a perpetual,
   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
   (except as stated in this section) patent license to make, have made,
   use, offer to sell, sell, import, and otherwise transfer the Work,
   where such license applies only to those patent claims licensable
   by such Contributor that are necessarily infringed by their
   Contribution(s) alone or by combination of their Contribution(s)
   with the Work to which such Contribution(s) was submitted. If You
   institute patent litigation against any entity (including a
   cross-claim or counterclaim in a lawsuit) alleging that the Work
   or a Contribution incorporated within the Work constitutes direct
   or contributory patent infringement, then any patent licenses
   granted to You under this License for that Work shall terminate
   as of the date such litigation is filed.

4. Redistribution. You may reproduce and distribute copies of the
   Work or Derivative Works thereof in any medium, with or without
   modifications, and in Source or Object form, provided that You
   meet the following conditions:

   (a) You must give any other recipients of the Work or
       Derivative Works a copy of this License; and

   (b) You must cause any modified files to carry prominent notices
       stating that You changed the files; and

   (c) You must retain, in the Source form of any Derivative Works
       that You distribute, all copyright, patent, trademark, and
       attribution notices from the Source form of the Work,
       excluding those notices that do not pertain to any part of
       the Derivative Works; and

   (d) If the Work includes a "NOTICE" text file as part of its
       distribution, then any Derivative Works that You distribute must
       include a readable copy of the attribution notices contained
       within such NOTICE file, excluding those notices that do not
       pertain to any part of the Derivative Works, in at least one
       of the following places: within a NOTICE text file distributed
       as part of the Derivative Works; within the Source form or
       documentation, if provided along with the Derivative Works; or,
       within a display generated by the Derivative Works, if and
       wherever such third-party notices normally appear. The contents
       of the NOTICE file are for informational purposes only and
       do not modify the License. You may add Your own attribution
       notices within Derivative Works that You distribute, alongside
       or as an addendum to the NOTICE text from the Work, provided
       that such additional attribution notices cannot be construed
       as modifying the License.

   You may add Your own copyright statement to Your modifications and
   may provide additional or different license terms and conditions
   for use, reproduction, or distribution of Your modifications, or
   for any such Derivative Works as a whole, provided Your use,
   reproduction, and distribution of the Work otherwise complies with
   the conditions stated in this License.

5. Submission of Contributions. Unless You explicitly state otherwise,
   any Contribution intentionally submitted for inclusion in the Work
   by You to the Licensor shall be under the terms and conditions of
   this License, without any additional terms or conditions.
   Notwithstanding the above, nothing herein shall supersede or modify
   the terms of any separate license agreement you may have executed
   with Licensor regarding such Contributions.

6. Trademarks. This License does not grant permission to use the trade
   names, trademarks, service marks, or product names of the Licensor,
   except as required for reasonable and customary use in describing the
   origin of the Work and reproducing the content of the NOTICE file.

7. Disclaimer of Warranty. Unless required by applicable law or
   agreed to in writing, Licensor provides the Work (and each
   Contributor provides its Contributions) on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   implied, including, without limitation, any warranties or conditions
   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
   PARTICULAR PURPOSE. You are solely responsible for determining the
   appropriateness of using or redistributing the Work and assume any
   risks associated with Your exercise of permissions under this License.

8. Limitation of Liability. In no event and under no legal theory,
   whether in tort (including negligence), contract, or otherwise,
   unless required by applicable law (such as deliberate and grossly
   negligent acts) or agreed to in writing, shall any Contributor be
   liable to You for damages, including any direct, indirect, special,
   incidental, or consequential damages of any character arising as a
   result of this License or out of the use or inability to use the
   Work (including but not limited to damages for loss of goodwill,
   work stoppage, computer failure or malfunction, or any and all
   other commercial damages or losses), even if such Contributor
   has been advised of the possibility of such damages.

9. Accepting Warranty or Additional Liability. While redistributing
   the Work or Derivative Works thereof, You may choose to offer,
   and charge a fee for, acceptance of support, warranty, indemnity,
   or other liability obligations and/or rights consistent with this
   License. However, in accepting such obligations, You may act only
   on Your own behalf and on Your sole responsibility, not on behalf
   of any other Contributor, and only if You agree to indemnify,
   defend, and hold each Contributor harmless for any liability
   incurred by, or claims asserted against, such Contributor by reason
   of your accepting any such warranty or additional liability.

END OF TERMS AND CONDITIONS

APPENDIX: How to apply the Apache License to your work.

   To apply the Apache License to your work, attach the following
   boilerplate notice, with the fields enclosed by brackets "[]"
   replaced with your own identifying information. (Don't include
   the brackets!)  The text should be enclosed in the appropriate
   comment syntax for the file format. We also recommend that a
   file or class name and description of purpose be included on the
   same "printed page" as the copyright notice for easier
   identification within third-party archives.

Copyright [yyyy] [name of copyright owner]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.



================================================
FILE: third_party/rust-by-example/LICENSE-MIT
================================================
Copyright (c) 2014 Jorge Aparicio

Permission is hereby granted, free of charge, to any
person obtaining a copy of this software and associated
documentation files (the "Software"), to deal in the
Software without restriction, including without
limitation the rights to use, copy, modify, merge,
publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software
is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice
shall be included in all copies or substantial portions
of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.



================================================
FILE: third_party/rust-by-example/match-guards.rs
================================================
#[rustfmt::skip]
fn main() {
    let pair = (2, -2);
    println!("Tell me about {pair:?}");
    match pair {
        (x, y) if x == y     => println!("These are twins"),
        (x, y) if x + y == 0 => println!("Antimatter, kaboom!"),
        (x, _) if x % 2 == 1 => println!("The first one is odd"),
        _                    => println!("No correlation..."),
    }
}



================================================
FILE: third_party/rust-by-example/webevent.rs
================================================
enum WebEvent {
    PageLoad,                 // Variant without payload
    KeyPress(char),           // Tuple struct variant
    Click { x: i64, y: i64 }, // Full struct variant
}

#[rustfmt::skip]
fn inspect(event: WebEvent) {
    match event {
        WebEvent::PageLoad       => println!("page loaded"),
        WebEvent::KeyPress(c)    => println!("pressed '{c}'"),
        WebEvent::Click { x, y } => println!("clicked at x={x}, y={y}"),
    }
}

fn main() {
    let load = WebEvent::PageLoad;
    let press = WebEvent::KeyPress('x');
    let click = WebEvent::Click { x: 20, y: 80 };

    inspect(load);
    inspect(press);
    inspect(click);
}



================================================
FILE: third_party/rust-on-exercism/README.md
================================================
# Exercism Rust Track

This directory contains exercises copied from the Exercism Rust Track. Please
see <https://github.com/exercism/rust> for the full project.

## License

The Exercism Rust Track is licensed under the MIT license ([LICENSE](LICENSE)).



================================================
FILE: third_party/rust-on-exercism/health-statistics.md
================================================
You're working on implementing a health-monitoring system. As part of that, you
need to keep track of users' health statistics.

You'll start with a stubbed function in an `impl` block as well as a `User`
struct definition. Your goal is to implement the stubbed out method on the
`User` `struct` defined in the `impl` block.



================================================
FILE: third_party/rust-on-exercism/health-statistics.rs
================================================
// ANCHOR: solution
// ANCHOR: setup

#![allow(dead_code)]
pub struct User {
    name: String,
    age: u32,
    height: f32,
    visit_count: u32,
    last_blood_pressure: Option<(u32, u32)>,
}

pub struct Measurements {
    height: f32,
    blood_pressure: (u32, u32),
}

pub struct HealthReport<'a> {
    patient_name: &'a str,
    visit_count: u32,
    height_change: f32,
    blood_pressure_change: Option<(i32, i32)>,
}

impl User {
    pub fn new(name: String, age: u32, height: f32) -> Self {
        Self { name, age, height, visit_count: 0, last_blood_pressure: None }
    }
    // ANCHOR_END: setup

    // ANCHOR: User_visit_doctor
    pub fn visit_doctor(&mut self, measurements: Measurements) -> HealthReport<'_> {
        // ANCHOR_END: User_visit_doctor
        self.visit_count += 1;
        let bp = measurements.blood_pressure;
        let report = HealthReport {
            patient_name: &self.name,
            visit_count: self.visit_count,
            height_change: measurements.height - self.height,
            blood_pressure_change: self
                .last_blood_pressure
                .map(|lbp| (bp.0 as i32 - lbp.0 as i32, bp.1 as i32 - lbp.1 as i32)),
        };
        self.height = measurements.height;
        self.last_blood_pressure = Some(bp);
        report
    }
}

// ANCHOR: tests
#[test]
fn test_visit() {
    let mut bob = User::new(String::from("Bob"), 32, 155.2);
    assert_eq!(bob.visit_count, 0);
    let report =
        bob.visit_doctor(Measurements { height: 156.1, blood_pressure: (120, 80) });
    assert_eq!(report.patient_name, "Bob");
    assert_eq!(report.visit_count, 1);
    assert_eq!(report.blood_pressure_change, None);
    assert!((report.height_change - 0.9).abs() < 0.00001);

    let report =
        bob.visit_doctor(Measurements { height: 156.1, blood_pressure: (115, 76) });

    assert_eq!(report.visit_count, 2);
    assert_eq!(report.blood_pressure_change, Some((-5, -4)));
    assert_eq!(report.height_change, 0.0);
}
// ANCHOR_END: tests



================================================
FILE: third_party/rust-on-exercism/LICENSE
================================================
MIT License

Copyright (c) 2021 Exercism

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: xtask/README.md
================================================
# xtask

The purpose of the xtask binary is to enable cross platform task automation
within the project (somewhat similar to how `npm run` is used in Node.js
projects to run scripts). Please see
[cargo xtask](https://github.com/matklad/cargo-xtask) for more information.

To add support for a new task, add a new arm to the `match` in the
`execute_task` function, and add a new handler function that contains the logic.



================================================
FILE: xtask/Cargo.toml
================================================
[package]
name = "xtask"
version = "0.1.0"
edition = "2024"
publish = false

[dependencies]
anyhow = "1.0.99"
clap = { version = "4.5.46", features = ["derive"] }



================================================
FILE: xtask/src/main.rs
================================================
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! This binary allows us to execute tasks within the project by running
//! `cargo xtask <task>`. It can thus be used as a task automation tool.
//! For example instead of repeatedly running `cargo install` from the CLI
//! to install all the necessary tools for the project we can just run
//! `cargo xtask install-tools` and the logic defined here will install
//! the tools.

use anyhow::{Context, Result, anyhow};
use clap::{Parser, Subcommand};
use std::env;
use std::path::{Path, PathBuf};
use std::process::Command;

fn main() -> Result<()> {
    execute_task()
}

#[derive(Parser)]
#[command(
    about = "Binary for executing tasks within the Comprehensive Rust project"
)]
struct Cli {
    /// The task to execute
    #[command(subcommand)]
    task: Task,
}

#[derive(Subcommand)]
enum Task {
    /// Installs the tools the project depends on.
    InstallTools {
        /// Use cargo-binstall for faster installation.
        #[arg(long)]
        binstall: bool,
    },
    /// Runs the web driver tests in the tests directory.
    WebTests {
        /// Optional 'book html' directory - if set, will also refresh the list
        /// of slides used by slide size test.
        #[arg(short, long)]
        dir: Option<PathBuf>,
    },
    /// Tests all included Rust snippets.
    RustTests,
    /// Starts a web server with the course.
    Serve {
        /// ISO 639 language code (e.g. da for the Danish translation).
        #[arg(short, long)]
        language: Option<String>,

        /// Directory to place the build. If not provided, defaults to the book/
        /// directory (or the book/xx directory if a language is provided).
        #[arg(short, long)]
        output: Option<PathBuf>,
    },
    /// Create a static version of the course.
    Build {
        /// ISO 639 language code (e.g. da for the Danish translation).
        #[arg(short, long)]
        language: Option<String>,

        /// Directory to place the build. If not provided, defaults to the book/
        /// directory (or the book/xx directory if a language is provided).
        #[arg(short, long)]
        output: Option<PathBuf>,
    },
}

fn execute_task() -> Result<()> {
    let cli = Cli::parse();
    match cli.task {
        Task::InstallTools { binstall } => install_tools(binstall),
        Task::WebTests { dir } => run_web_tests(dir),
        Task::RustTests => run_rust_tests(),
        Task::Serve { language, output } => start_web_server(language, output),
        Task::Build { language, output } => build(language, output),
    }
}

/// Executes a command and returns an error if it fails.
fn run_command(cmd: &mut Command) -> Result<()> {
    let command_display = format!("{cmd:?}");
    println!("> {command_display}");
    let status = cmd
        .status()
        .with_context(|| format!("Failed to execute command: {command_display}"))?;
    if !status.success() {
        let exit_description = if let Some(code) = status.code() {
            format!("exited with status code: {}", code)
        } else {
            "was terminated by a signal".to_string()
        };
        return Err(anyhow!("Command `{command_display}` {exit_description}"));
    }
    Ok(())
}

fn install_tools(binstall: bool) -> Result<()> {
    println!("Installing project tools...");

    let cargo = env!("CARGO");

    let install_command = if binstall { "binstall" } else { "install" };

    const PINNED_NIGHTLY: &str = "nightly-2025-09-01";

    // Install rustup components
    let rustup_steps = [
        ["toolchain", "install", "--profile", "minimal", PINNED_NIGHTLY],
        ["component", "add", "rustfmt", "--toolchain", PINNED_NIGHTLY],
    ];
    for args in rustup_steps {
        let mut cmd = Command::new("rustup");
        cmd.args(args);
        run_command(&mut cmd)?;
    }

    // The --locked flag is important for reproducible builds.
    let tools = [
        ("mdbook", "0.4.52"),
        ("mdbook-svgbob", "0.2.2"),
        ("mdbook-pandoc", "0.10.4"),
        ("mdbook-i18n-helpers", "0.3.6"),
        ("i18n-report", "0.2.0"),
        ("mdbook-linkcheck2", "0.9.1"),
    ];

    for (tool, version) in tools {
        let mut cmd = Command::new(cargo);
        cmd.args([install_command, tool, "--version", version, "--locked"]);
        run_command(&mut cmd)?;
    }

    // Install local tools from the workspace.
    let workspace_dir = Path::new(env!("CARGO_WORKSPACE_DIR"));
    // cargo-binstall does not support --path, so we always use cargo install here.
    let local_tools = ["mdbook-exerciser", "mdbook-course"];
    for tool in local_tools {
        let mut cmd = Command::new(cargo);
        cmd.args(["install", "--path"])
            .arg(workspace_dir.join(tool))
            .arg("--locked");
        run_command(&mut cmd)?;
    }

    // Uninstall original linkcheck if currently installed (see issue no 2773)
    uninstall_mdbook_linkcheck()?;

    Ok(())
}

fn uninstall_mdbook_linkcheck() -> Result<()> {
    println!("Uninstalling old mdbook-linkcheck if installed...");
    let output = Command::new(env!("CARGO"))
        .args(["uninstall", "mdbook-linkcheck"])
        .output()
        .context("Failed to execute `cargo uninstall mdbook-linkcheck`")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        // This specific error is OK, it just means the package wasn't installed.
        if !stderr.contains("did not match any packages") {
            return Err(anyhow!(
                "Failed to uninstall `mdbook-linkcheck`.\n--- stderr:\n{stderr}"
            ));
        }
        println!("mdbook-linkcheck not installed. Continuing...");
    }
    Ok(())
}

fn run_web_tests(dir: Option<PathBuf>) -> Result<()> {
    println!("Running web tests...");
    let workspace_dir = Path::new(env!("CARGO_WORKSPACE_DIR"));

    let absolute_dir = dir.map(|d| d.canonicalize()).transpose()?;

    if let Some(d) = &absolute_dir {
        println!("Refreshing slide lists...");
        let refresh_slides_script = Path::new("tests")
            .join("src")
            .join("slides")
            .join("create-slide.list.sh");
        let mut cmd = Command::new(&refresh_slides_script);
        cmd.current_dir(workspace_dir).arg(d);
        run_command(&mut cmd)?;
    }

    let tests_dir = workspace_dir.join("tests");
    let mut cmd = Command::new("npm");
    cmd.current_dir(tests_dir).arg("test");

    if let Some(d) = absolute_dir {
        cmd.env("TEST_BOOK_DIR", d);
    }
    run_command(&mut cmd)
}

fn run_rust_tests() -> Result<()> {
    println!("Running rust tests...");
    let workspace_root = Path::new(env!("CARGO_WORKSPACE_DIR"));

    let mut cmd = Command::new("mdbook");
    cmd.current_dir(workspace_root).arg("test");
    run_command(&mut cmd)
}

fn run_mdbook_command(
    subcommand: &str,
    language: Option<String>,
    output_arg: Option<PathBuf>,
) -> Result<()> {
    let workspace_root = Path::new(env!("CARGO_WORKSPACE_DIR"));

    let mut cmd = Command::new("mdbook");
    cmd.current_dir(workspace_root).arg(subcommand);

    if let Some(language) = &language {
        println!("Language: {language}");
        cmd.env("MDBOOK_BOOK__LANGUAGE", language);
    }

    cmd.arg("-d");
    cmd.arg(get_output_dir(language, output_arg));

    run_command(&mut cmd)
}

fn start_web_server(
    language: Option<String>,
    output_arg: Option<PathBuf>,
) -> Result<()> {
    println!("Starting web server ...");
    run_mdbook_command("serve", language, output_arg)
}

fn build(language: Option<String>, output_arg: Option<PathBuf>) -> Result<()> {
    println!("Building course...");
    run_mdbook_command("build", language, output_arg)
}

fn get_output_dir(language: Option<String>, output_arg: Option<PathBuf>) -> PathBuf {
    // If the 'output' arg is specified by the caller, use that, otherwise output to
    // the 'book/' directory (or the 'book/xx' directory if a language was
    // specified).
    if let Some(d) = output_arg {
        d
    } else {
        Path::new("book").join(language.unwrap_or("".to_string()))
    }
}



================================================
FILE: .cargo/config.toml
================================================
[alias]
xtask = "run --package xtask --"

[env]
# To provide an anchor to the root of the workspace when working with paths.
# See https://github.com/rust-lang/cargo/issues/3946#issuecomment-973132993
CARGO_WORKSPACE_DIR = { value = "", relative = true }



================================================
FILE: .github/CODEOWNERS
================================================
# Translations
po/ar.po @younies
po/bn.po @mirwasi @sudiptachatterjee
po/da.po @mgeisler @voss @thedataking
po/de.po @ronaldfw @fechu
po/el.po @Mandragorian
po/es.po @deavid @vzz1x2
po/fa.po @DannyRavi @hamidrezakp @moaminsharifi @mehrad77 @javad-jafari
po/fr.po @sakex
po/it.po @detro @nicomazz
po/ja.po @keiichiw @chikoski @kantasv @HidenoriKobayashi
po/ko.po @jiyongp @jooyunghan @namhyung
po/pl.po @jkotur @dyeroshenko
po/pt-BR.po @rastringer @hugojacob @henrif75 @joaovicmendes @azevedoalice
po/ro.po @AlexandraImbrisca @razvanm
po/ru.po @istolga @baltuky @zvonden @dyeroshenko
po/tr.po @alerque @Enes1313 @rexoplans1
po/uk.po @dyeroshenko
po/vi.po @daivinhtran @qu-ngx
po/zh-CN.po @wnghl @anlunx @kongy @noahdragon @superwhd @emmali01 @candysonya @AgainstEntropy
po/zh-TW.po @edong @hueich @kuanhungchen @victorhsieh @mingyc

# Dependency changes (mostly dependabot PRs)
Cargo.toml @djmitche @mgeisler @qwandor
Cargo.lock @djmitche @mgeisler @qwandor
src/bare-metal/alloc-example/Cargo.toml @djmitche @mgeisler @qwandor
src/bare-metal/alloc-example/Cargo.lock @djmitche @mgeisler @qwandor
src/bare-metal/aps/examples/Cargo.toml @djmitche @mgeisler @qwandor
src/bare-metal/aps/examples/Cargo.lock @djmitche @mgeisler @qwandor
src/bare-metal/microcontrollers/examples/Cargo.toml @djmitche @mgeisler @qwandor
src/bare-metal/microcontrollers/examples/Cargo.lock @djmitche @mgeisler @qwandor
src/exercises/bare-metal/compass/Cargo.toml @djmitche @mgeisler @qwandor
src/exercises/bare-metal/compass/Cargo.lock @djmitche @mgeisler @qwandor
src/exercises/bare-metal/rtc/Cargo.toml @djmitche @mgeisler @qwandor
src/exercises/bare-metal/rtc/Cargo.lock @djmitche @mgeisler @qwandor
.github/workflows @djmitche @mgeisler @qwandor



================================================
FILE: .github/dependabot.yml
================================================
# Please see the documentation for all configuration options:
# https://docs.github.com/github/administering-a-repository/configuration-options-for-dependency-updates

version: 2
updates:
  - package-ecosystem: cargo
    directory: /
    schedule:
      interval: monthly
    commit-message:
      prefix: cargo
    groups:
      minor:
        update-types:
          - minor
      patch:
        update-types:
          - patch
  - package-ecosystem: cargo
    directory: /src/bare-metal/alloc-example/
    schedule:
      interval: monthly
    commit-message:
      prefix: cargo
    groups:
      minor:
        update-types:
          - minor
      patch:
        update-types:
          - patch
  - package-ecosystem: cargo
    directory: /src/bare-metal/aps/examples/
    schedule:
      interval: monthly
    commit-message:
      prefix: cargo
    groups:
      minor:
        update-types:
          - minor
      patch:
        update-types:
          - patch
  - package-ecosystem: cargo
    directory: /src/bare-metal/microcontrollers/examples/
    schedule:
      interval: monthly
    commit-message:
      prefix: cargo
    groups:
      minor:
        update-types:
          - minor
      patch:
        update-types:
          - patch
  - package-ecosystem: cargo
    directory: /src/exercises/bare-metal/compass/
    schedule:
      interval: monthly
    commit-message:
      prefix: cargo
    groups:
      minor:
        update-types:
          - minor
      patch:
        update-types:
          - patch
  - package-ecosystem: cargo
    directory: /src/exercises/bare-metal/rtc/
    schedule:
      interval: monthly
    commit-message:
      prefix: cargo
    groups:
      minor:
        update-types:
          - minor
      patch:
        update-types:
          - patch
  - package-ecosystem: github-actions
    directory: /
    schedule:
      interval: monthly



================================================
FILE: .github/labeler.yml
================================================
translation:
  - changed-files:
      - any-glob-to-any-file: po/*.po

"translation/ar":
  - changed-files:
      - any-glob-to-any-file: po/ar.po

"translation/bn":
  - changed-files:
      - any-glob-to-any-file: po/bn.po

"translation/da":
  - changed-files:
      - any-glob-to-any-file: po/da.po

"translation/de":
  - changed-files:
      - any-glob-to-any-file: po/de.po

"translation/el":
  - changed-files:
      - any-glob-to-any-file: po/el.po

"translation/es":
  - changed-files:
      - any-glob-to-any-file: po/es.po

"translation/fa":
  - changed-files:
      - any-glob-to-any-file: po/fa.po

"translation/fr":
  - changed-files:
      - any-glob-to-any-file: po/fr.po

"translation/id":
  - changed-files:
      - any-glob-to-any-file: po/id.po

"translation/it":
  - changed-files:
      - any-glob-to-any-file: po/it.po

"translation/ja":
  - changed-files:
      - any-glob-to-any-file: po/ja.po

"translation/ko":
  - changed-files:
      - any-glob-to-any-file: po/ko.po

"translation/pl":
  - changed-files:
      - any-glob-to-any-file: po/pl.po

"translation/pt-BR":
  - changed-files:
      - any-glob-to-any-file: po/pt-BR.po

"translation/ro":
  - changed-files:
      - any-glob-to-any-file: po/ro.po

"translation/ru":
  - changed-files:
      - any-glob-to-any-file: po/ru.po

"translation/tr":
  - changed-files:
      - any-glob-to-any-file: po/tr.po

"translation/uk":
  - changed-files:
      - any-glob-to-any-file: po/uk.po

"translation/vi":
  - changed-files:
      - any-glob-to-any-file: po/vi.po

"translation/zh-CN":
  - changed-files:
      - any-glob-to-any-file: po/zh-CN.po

"translation/zh-TW":
  - changed-files:
      - any-glob-to-any-file: po/zh-TW.po



================================================
FILE: .github/typos.toml
================================================
[default.extend-identifiers]
# False positives.
mis = "mis"
MIS = "MIS"
inout = "inout"
BARs = "BARs"

[type.po]
# Localized content should not be checked for typos. English
# in these files should be validated manually.
extend-glob = ["*.po"]
check-file = false

[files]
# Typos in third party packages should be fixed upstream.
extend-exclude = ["third_party/*", "theme/book.js"]



================================================
FILE: .github/pandoc/README.md
================================================
# Config Overrides for `mdbook-pandoc`

The configuration file fragments here are used to override the configuration in
`book.toml`. See `.github/workflows/build.sh` for details.



================================================
FILE: .github/pandoc/ja.yaml
================================================
variables:
  CJKmainfont: "Noto Serif CJK JP"
  CJKsansfont: "Noto Sans CJK JP"
  CJKmonofont: "Noto Sans Mono CJK JP"



================================================
FILE: .github/pandoc/ko.yaml
================================================
variables:
  CJKmainfont: "Noto Serif CJK KR"
  CJKsansfont: "Noto Sans CJK KR"
  CJKmonofont: "Noto Sans Mono CJK KR"



================================================
FILE: .github/pandoc/zh-CN.yaml
================================================
variables:
  CJKmainfont: "Noto Serif CJK SC"
  CJKsansfont: "Noto Sans CJK SC"
  CJKmonofont: "Noto Sans Mono CJK SC"



================================================
FILE: .github/pandoc/zh-TW.yaml
================================================
variables:
  CJKmainfont: "Noto Serif CJK TC"
  CJKsansfont: "Noto Sans CJK TC"
  CJKmonofont: "Noto Sans Mono CJK TC"



================================================
FILE: .github/workflows/build.sh
================================================
#!/usr/bin/env bash
set -Eeuo pipefail

# Usage: build.sh <book-lang> <dest-dir>
#
# Build the course as of the date specified specified in the
# POT-Creation-Date header of po/$book_lang.po. The output can be
# found in $dest_dir.
#
# The src/ and third_party/ directories are left in a dirty state so
# you can run `mdbook test` and other commands afterwards.
#
# See also TRANSLATIONS.md.

book_lang=${1:?"Usage: $0 <book-lang> <dest-dir>"}
dest_dir=${2:?"Usage: $0 <book-lang> <dest-dir>"}

if [ "$book_lang" = "en" ]; then
    echo "::group::Building English course"
else
    pot_creation_date=$(grep --max-count 1 '^"POT-Creation-Date:' "po/$book_lang.po" | sed -E 's/".*: (.*)\\n"/\1/')
    pot_creation_date=${pot_creation_date:-now}
    echo "::group::Building $book_lang translation as of $pot_creation_date"

    # Back-date the sources to POT-Creation-Date. The content lives in two
    # directories:
    rm -r src/ third_party/
    git restore --source "$(git rev-list -n 1 --before "$pot_creation_date" @)" src/ third_party/ book.toml
    # Set language and adjust site URL. Clear the redirects since they are
    # in sync with the source files, not the translation.
    export MDBOOK_BOOK__LANGUAGE=$book_lang
    export MDBOOK_OUTPUT__HTML__SITE_URL=/comprehensive-rust/$book_lang/
    export MDBOOK_OUTPUT__HTML__REDIRECT='{}'

    # Include language-specific Pandoc configuration
    if [ -f ".github/pandoc/$book_lang.yaml" ]; then
        export MDBOOK_OUTPUT__PANDOC__PROFILE__PDF__DEFAULTS=".github/pandoc/$book_lang.yaml"
    fi
fi

# Enable mdbook-pandoc to build PDF version of the course
export MDBOOK_OUTPUT__PANDOC__DISABLED=false

mdbook build -d "$dest_dir"

# Disable the redbox button in built versions of the course
echo '// Disabled in published builds, see build.sh' > "${dest_dir}/html/theme/redbox.js"

mv "$dest_dir/pandoc/pdf/comprehensive-rust.pdf" "$dest_dir/html/"
(cd "$dest_dir/exerciser" && zip --recurse-paths ../html/comprehensive-rust-exercises.zip comprehensive-rust-exercises/)

echo "::endgroup::"



================================================
FILE: .github/workflows/build.yml
================================================
name: Test

on:
  pull_request:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  CARGO_TERM_COLOR: always

jobs:
  cargo:
    strategy:
      matrix:
        os:
          - ubuntu-latest
          - macos-latest
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Update Rust
        run: rustup update

      - name: Setup Rust cache
        uses: ./.github/workflows/setup-rust-cache

      - name: Build Rust code
        run: cargo build

      - name: Test Rust code
        run: cargo test

  bare-metal:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - directory: src/bare-metal/alloc-example
            target: aarch64-unknown-none
          - directory: src/bare-metal/aps/examples
            target: aarch64-unknown-none
          - directory: src/bare-metal/microcontrollers/examples
            target: thumbv7em-none-eabihf
          - directory: src/exercises/bare-metal/compass
            target: thumbv7em-none-eabihf
          - directory: src/exercises/bare-metal/rtc
            target: aarch64-unknown-none
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Install toolchain
        run: |
          rustup update
          rustup target add ${{ matrix.target }}

      - name: Setup Rust cache
        uses: ./.github/workflows/setup-rust-cache

      - name: Install dependencies
        uses: ./.github/workflows/apt-get-install
        with:
          packages: gcc-aarch64-linux-gnu

      - name: Build Rust code
        working-directory: ${{ matrix.directory }}
        run: cargo build

  find-languages:
    runs-on: ubuntu-latest
    outputs:
      languages: ${{ steps.find-languages.outputs.languages }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Find languages
        id: find-languages
        shell: python
        run: |
          import os, json, pathlib
          languages = ["en"] + [p.stem for p in pathlib.Path("po").iterdir() if p.suffix == ".po"]
          github_output = open(os.environ["GITHUB_OUTPUT"], "a")
          github_output.write("languages=")
          json.dump(sorted(languages), github_output)

  build:
    runs-on: ubuntu-latest
    needs:
      - find-languages
    strategy:
      matrix:
        language: ${{ fromJSON(needs.find-languages.outputs.languages) }}
      fail-fast: false
    env:
      # Opt-in for checking links in translations - add the language below.
      LINK_CHECKED_LANGUAGES: '["en", "fa"]'
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0 # We need the full history for build.sh below.

      - name: Update Rust
        run: rustup update

      - name: Setup Rust cache
        uses: ./.github/workflows/setup-rust-cache
        with:
          key: ${{ contains(fromJSON(env.LINK_CHECKED_LANGUAGES), matrix.language) }}

      - name: Install dependencies
        uses: ./.github/workflows/apt-get-install
        with:
          packages: gettext

      - name: Install mdbook
        uses: ./.github/workflows/install-mdbook

      - name: Test format of ${{ matrix.language }} translation
        if: matrix.language != 'en'
        run: msgfmt --statistics -o /dev/null po/${{ matrix.language }}.po

      - name: Test extracting English strings
        if: matrix.language == 'en'
        run: |
          MDBOOK_OUTPUT='{"xgettext": {"pot-file": "messages.pot"}}' mdbook build -d po
          msgfmt -o /dev/null --statistics po/messages.pot

      - name: Build ${{ matrix.language }} translation
        run: |
          .github/workflows/build.sh ${{ matrix.language }} book/comprehensive-rust-${{ matrix.language }}

      # Upload the book now to retain it in case mdbook test fails.
      - name: Upload book
        uses: actions/upload-artifact@v4
        with:
          name: comprehensive-rust-${{ matrix.language }}
          path: book/

      - name: Test code snippets
        env:
          MDBOOK_BOOK__LANGUAGE: ${{ matrix.language }}
        run: mdbook test

      - name: Setup Node
        if: matrix.language == 'en'
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: "npm"
          cache-dependency-path: "tests/package-lock.json"
      - name: Install test framework
        if: matrix.language == 'en'
        run: npm install
        working-directory: ./tests
      - name: Test Javascript
        if: matrix.language == 'en'
        run: |
          ./src/slides/create-slide.list.sh
          npm test
        env:
          TEST_BOOK_DIR: ../book/comprehensive-rust-${{ matrix.language }}/html
        working-directory: ./tests

  po-diff:
    name: Translation diff
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Update Rust
        run: rustup update

      - name: Setup Rust cache
        uses: ./.github/workflows/setup-rust-cache

      - name: Install mdbook
        uses: ./.github/workflows/install-mdbook

      - name: Copy latest version of translations
        run: cp -r po new-po

      - name: Checkout base version
        run: git checkout ${{ github.event.pull_request.base.sha }}

      - name: Translation diff
        run: i18n-report diff po/ new-po/ > $GITHUB_STEP_SUMMARY



================================================
FILE: .github/workflows/check-msgid-changes.py
================================================
# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Find changed msgid fields without a change in POT-Creation-Date.

When following the instructions in
https://github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md,
one of two things should happen:

- The `msgid` fields change because `msgmerge --update` was used. This
  will also update the POT-Creation-Date field since a new timestamp
  is merged in from the messages.pot file.

- Translations are added or updated. This should not change the
  `msgid` fields: only the `msgstr` fields should change. If the PO
  editor being used inadvertently changes the wrapping of both `msgid`
  and `msgstr` fields, then `dprint fmt` can be used to normalize them
  all.

The code here detects if both of these happen at the same time: if one
or more `msgid` fields changed without a corresponding change to the
POT-Creation-Date field. If this happens, the translator should fix it
by running:

  dprint fmt

Commit and push to the branch again.
"""

import os

# TODO: move the `git reset` from the action code to here. Infact, we
# should be able to determine this with read-only operations.

# TODO: use Git plumbing commands instead of porcelain, see
# https://mirrors.edge.kernel.org/pub/software/scm/git/docs/git.html.
for filename in os.popen("git diff --name-only").read().split():
    if not filename.endswith(".po"):
        continue

    # If POT-Creation-Date has changed, then we assume that the commit
    # is the result of `msgmerge --update`. It is expected that the
    # `msgid` fields change when `msgmerge` is run, so there is
    # nothing to check.
    if "POT-Creation-Date" in os.popen(
            f"git diff --unified=0 {filename}").read():
        print(
            f"Assuming {filename} was changed automatically, skipping msgid check"
        )
        continue

    changed_lines = {
        i + 1
        for i, line in enumerate(
            os.popen(f"git blame {filename}").readlines())
        if line.startswith("00000000")
    }

    # Look for a changed line between `msgid` and `msgstr`.
    saw_msgid = False
    with open(filename, "r") as f:
        line = f.readline()
        line_number = 1

        while line:
            if line.startswith("msgid"):
                saw_msgid = True
            elif line.startswith("msgstr"):
                saw_msgid = False

            if saw_msgid and line_number in changed_lines:
                print(f"Changed msgid in file {filename}:{line_number}!")
                print(
                    "Please read https://github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md#creating-and-updating-translations."
                )
                exit(1)

            line_number += 1
            line = f.readline()



================================================
FILE: .github/workflows/check-msgid-changes.yml
================================================
name: Prevent unintended msgid changes

on:
  pull_request:
    paths:
      - "po/*.po"

jobs:
  check-msgid-changes:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Reset git
        run: git reset origin/main

      - name: Check po file changes
        run: python3 .github/workflows/check-msgid-changes.py



================================================
FILE: .github/workflows/labeler.yml
================================================
name: "Pull Request Labeler"
on:
  - pull_request_target

jobs:
  triage:
    permissions:
      contents: read
      pull-requests: write
    runs-on: ubuntu-latest
    steps:
      - uses: actions/labeler@v5
        with:
          sync-labels: true



================================================
FILE: .github/workflows/lint.yml
================================================
name: Lint

on:
  pull_request:
  push:
    branches:
      - main

env:
  CARGO_TERM_COLOR: always

jobs:
  clippy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Setup Rust cache
        uses: ./.github/workflows/setup-rust-cache

      - name: Clippy
        run: cargo clippy -- -Dwarnings

  format:
    runs-on: ubuntu-latest
    env:
      NIGHTLY_VERSION: nightly-2025-09-01
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Install formatting dependencies
        uses: ./.github/workflows/apt-get-install
        with:
          packages: gettext yapf3

      - name: Install pinned nightly for rustfmt
        run: |
          rustup toolchain install --profile minimal "$NIGHTLY_VERSION"
          rustup component add rustfmt --toolchain "$NIGHTLY_VERSION"

      - name: Check formatting
        uses: dprint/check@v2.3

  typos:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Check for typos
        uses: crate-ci/typos@v1.35.7
        with:
          config: ./.github/typos.toml



================================================
FILE: .github/workflows/publish.yml
================================================
name: Publish

# See also TRANSLATIONS.md.

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

# Allow one concurrent deployment
concurrency:
  group: pages
  cancel-in-progress: true

env:
  CARGO_TERM_COLOR: always
  # Update the language picker in index.hbs to link new languages.
  LANGUAGES: ar bn da de el es fa fr id it ja ko pl pt-BR ro ru tr uk vi zh-CN zh-TW

jobs:
  publish:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0 # We need the full history for build.sh below.

      - name: Update Rust
        run: rustup update

      - name: Setup Rust cache
        uses: ./.github/workflows/setup-rust-cache

      - name: Install Gettext
        uses: ./.github/workflows/apt-get-install
        with:
          packages: gettext

      - name: Install mdbook
        uses: ./.github/workflows/install-mdbook

      - name: Build course in English
        run: .github/workflows/build.sh en book

      - name: Build all translations
        run: |
          for po_lang in ${{ env.LANGUAGES }}; do
              .github/workflows/build.sh $po_lang book/$po_lang
              mv book/$po_lang/html book/html/$po_lang
          done

      - name: Build translation report
        run: i18n-report report book/html/translation-report.html po/*.po

      - name: Build synced translation report
        run: |
          cp -r po synced-po
          MDBOOK_OUTPUT='{"xgettext": {"pot-file": "messages.pot", "granularity": 0}}' mdbook build -d synced-po
          for file in synced-po/*.po; do msgmerge --update $file synced-po/messages.pot ; done
          i18n-report report book/html/synced-translation-report.html synced-po/*.po

      - name: Setup Pages
        uses: actions/configure-pages@v5

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v4
        with:
          path: book/html

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4



================================================
FILE: .github/workflows/apt-get-install/action.yml
================================================
name: Setup Apt and Install Packages
description: Configures apt, runs update once per job, and installs packages.

inputs:
  packages:
    description: A space-separated list of packages to install.
    required: true

runs:
  using: composite
  steps:
    - name: Configure dpkg and apt for CI
      shell: bash
      run: |
        # Avoid time-consuming man-db updates.
        sudo tee /etc/dpkg/dpkg.cfg.d/99-no-doc > /dev/null <<EOF
        path-exclude /usr/share/doc/*
        path-exclude /usr/share/man/*
        path-exclude /usr/share/info/*
        EOF

        # Exclude translations.
        sudo tee /etc/apt/apt.conf.d/99-no-translations > /dev/null <<EOF
        Acquire::Languages "none";
        EOF

        # Exclude command-not-found utility.
        sudo rm -f /etc/apt/apt.conf.d/50command-not-found

        # Remove unnecessary repository lists (we don't install Azure
        # utilities)
        sudo rm -f /etc/apt/sources.list.d/microsoft-prod.* /etc/apt/sources.list.d/azure-cli.*

    - name: Run apt-get update
      if: env.APT_UPDATED != 'true'
      shell: bash
      run: |
        sudo apt-get update
        echo "APT_UPDATED=true" >> $GITHUB_ENV

    - name: Installing ${{ inputs.packages }}
      shell: bash
      run: |
        sudo apt-get install --quiet --yes ${{ inputs.packages }}



================================================
FILE: .github/workflows/install-mdbook/action.yml
================================================
name: Install mdbook and dependencies

description: Install mdbook with the dependencies we need.

runs:
  using: composite
  steps:
    - name: Ensure cargo-binstall is installed
      uses: cargo-bins/cargo-binstall@main

    - name: Install mdbook
      run: cargo xtask install-tools --binstall
      shell: bash

    - name: Install mdbook-pandoc dependencies
      uses: ./.github/workflows/apt-get-install
      with:
        packages: texlive texlive-luatex texlive-lang-cjk texlive-lang-arabic librsvg2-bin fonts-noto

    - name: Install mdbook-pandoc
      run: |
        curl -LsSf https://github.com/jgm/pandoc/releases/download/3.7.0.1/pandoc-3.7.0.1-linux-amd64.tar.gz | tar zxf -
        echo "$PWD/pandoc-3.7.0.1/bin" >> $GITHUB_PATH
      shell: bash



================================================
FILE: .github/workflows/setup-rust-cache/action.yml
================================================
name: Setup Rust cache

description: Configure the rust-cache workflow.

inputs:
  key:
    description: Additional caching key
    required: false
    default:

runs:
  using: composite
  steps:
    - name: Setup Rust cache
      uses: Swatinem/rust-cache@v2
      with:
        # Only save the cache on the main branch to avoid PRs filling
        # up the cache.
        save-if: ${{ github.ref == 'refs/heads/main' }}
        # Further, save the cache per key - e.g. language grouping.
        key: ${{ inputs.key }}


