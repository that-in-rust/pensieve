Directory structure:
└── that-in-rust-rustlings/
    ├── README.md
    ├── build.rs
    ├── Cargo.toml
    ├── clippy.toml
    ├── CONTRIBUTING.md
    ├── LICENSE
    ├── release-hook.sh
    ├── .typos.toml
    ├── dev/
    │   ├── Cargo.toml
    │   └── rustlings-repo.txt
    ├── dev-Cargo.toml -> Cargo.toml
    ├── exercises/
    │   ├── README.md
    │   ├── 00_intro/
    │   │   ├── README.md
    │   │   ├── intro1.rs
    │   │   └── intro2.rs
    │   ├── 01_variables/
    │   │   ├── README.md
    │   │   ├── variables1.rs
    │   │   ├── variables2.rs
    │   │   ├── variables3.rs
    │   │   ├── variables4.rs
    │   │   ├── variables5.rs
    │   │   └── variables6.rs
    │   ├── 02_functions/
    │   │   ├── README.md
    │   │   ├── functions1.rs
    │   │   ├── functions2.rs
    │   │   ├── functions3.rs
    │   │   ├── functions4.rs
    │   │   └── functions5.rs
    │   ├── 03_if/
    │   │   ├── README.md
    │   │   ├── if1.rs
    │   │   ├── if2.rs
    │   │   └── if3.rs
    │   ├── 04_primitive_types/
    │   │   ├── README.md
    │   │   ├── primitive_types1.rs
    │   │   ├── primitive_types2.rs
    │   │   ├── primitive_types3.rs
    │   │   ├── primitive_types4.rs
    │   │   ├── primitive_types5.rs
    │   │   └── primitive_types6.rs
    │   ├── 05_vecs/
    │   │   ├── README.md
    │   │   ├── vecs1.rs
    │   │   └── vecs2.rs
    │   ├── 06_move_semantics/
    │   │   ├── README.md
    │   │   ├── move_semantics1.rs
    │   │   ├── move_semantics2.rs
    │   │   ├── move_semantics3.rs
    │   │   ├── move_semantics4.rs
    │   │   └── move_semantics5.rs
    │   ├── 07_structs/
    │   │   ├── README.md
    │   │   ├── structs1.rs
    │   │   ├── structs2.rs
    │   │   └── structs3.rs
    │   ├── 08_enums/
    │   │   ├── README.md
    │   │   ├── enums1.rs
    │   │   ├── enums2.rs
    │   │   └── enums3.rs
    │   ├── 09_strings/
    │   │   ├── README.md
    │   │   ├── strings1.rs
    │   │   ├── strings2.rs
    │   │   ├── strings3.rs
    │   │   └── strings4.rs
    │   ├── 10_modules/
    │   │   ├── README.md
    │   │   ├── modules1.rs
    │   │   ├── modules2.rs
    │   │   └── modules3.rs
    │   ├── 11_hashmaps/
    │   │   ├── README.md
    │   │   ├── hashmaps1.rs
    │   │   ├── hashmaps2.rs
    │   │   └── hashmaps3.rs
    │   ├── 12_options/
    │   │   ├── README.md
    │   │   ├── options1.rs
    │   │   ├── options2.rs
    │   │   └── options3.rs
    │   ├── 13_error_handling/
    │   │   ├── README.md
    │   │   ├── errors1.rs
    │   │   ├── errors2.rs
    │   │   ├── errors3.rs
    │   │   ├── errors4.rs
    │   │   ├── errors5.rs
    │   │   └── errors6.rs
    │   ├── 14_generics/
    │   │   ├── README.md
    │   │   ├── generics1.rs
    │   │   └── generics2.rs
    │   ├── 15_traits/
    │   │   ├── README.md
    │   │   ├── traits1.rs
    │   │   ├── traits2.rs
    │   │   ├── traits3.rs
    │   │   ├── traits4.rs
    │   │   └── traits5.rs
    │   ├── 16_lifetimes/
    │   │   ├── README.md
    │   │   ├── lifetimes1.rs
    │   │   ├── lifetimes2.rs
    │   │   └── lifetimes3.rs
    │   ├── 17_tests/
    │   │   ├── README.md
    │   │   ├── tests1.rs
    │   │   ├── tests2.rs
    │   │   └── tests3.rs
    │   ├── 18_iterators/
    │   │   ├── README.md
    │   │   ├── iterators1.rs
    │   │   ├── iterators2.rs
    │   │   ├── iterators3.rs
    │   │   ├── iterators4.rs
    │   │   └── iterators5.rs
    │   ├── 19_smart_pointers/
    │   │   ├── README.md
    │   │   ├── arc1.rs
    │   │   ├── box1.rs
    │   │   ├── cow1.rs
    │   │   └── rc1.rs
    │   ├── 20_threads/
    │   │   ├── README.md
    │   │   ├── threads1.rs
    │   │   ├── threads2.rs
    │   │   └── threads3.rs
    │   ├── 21_macros/
    │   │   ├── README.md
    │   │   ├── macros1.rs
    │   │   ├── macros2.rs
    │   │   ├── macros3.rs
    │   │   └── macros4.rs
    │   ├── 22_clippy/
    │   │   ├── README.md
    │   │   ├── clippy1.rs
    │   │   ├── clippy2.rs
    │   │   └── clippy3.rs
    │   ├── 23_conversions/
    │   │   ├── README.md
    │   │   ├── as_ref_mut.rs
    │   │   ├── from_into.rs
    │   │   ├── from_str.rs
    │   │   ├── try_from_into.rs
    │   │   └── using_as.rs
    │   └── quizzes/
    │       ├── README.md
    │       ├── quiz1.rs
    │       ├── quiz2.rs
    │       └── quiz3.rs
    ├── rustlings-macros/
    │   ├── Cargo.toml
    │   ├── info.toml
    │   └── src/
    │       └── lib.rs
    ├── solutions/
    │   ├── README.md
    │   ├── 00_intro/
    │   │   ├── intro1.rs
    │   │   └── intro2.rs
    │   ├── 01_variables/
    │   │   ├── variables1.rs
    │   │   ├── variables2.rs
    │   │   ├── variables3.rs
    │   │   ├── variables4.rs
    │   │   ├── variables5.rs
    │   │   └── variables6.rs
    │   ├── 02_functions/
    │   │   ├── functions1.rs
    │   │   ├── functions2.rs
    │   │   ├── functions3.rs
    │   │   ├── functions4.rs
    │   │   └── functions5.rs
    │   ├── 03_if/
    │   │   ├── if1.rs
    │   │   ├── if2.rs
    │   │   └── if3.rs
    │   ├── 04_primitive_types/
    │   │   ├── primitive_types1.rs
    │   │   ├── primitive_types2.rs
    │   │   ├── primitive_types3.rs
    │   │   ├── primitive_types4.rs
    │   │   ├── primitive_types5.rs
    │   │   └── primitive_types6.rs
    │   ├── 05_vecs/
    │   │   ├── vecs1.rs
    │   │   └── vecs2.rs
    │   ├── 06_move_semantics/
    │   │   ├── move_semantics1.rs
    │   │   ├── move_semantics2.rs
    │   │   ├── move_semantics3.rs
    │   │   ├── move_semantics4.rs
    │   │   └── move_semantics5.rs
    │   ├── 07_structs/
    │   │   ├── structs1.rs
    │   │   ├── structs2.rs
    │   │   └── structs3.rs
    │   ├── 08_enums/
    │   │   ├── enums1.rs
    │   │   ├── enums2.rs
    │   │   └── enums3.rs
    │   ├── 09_strings/
    │   │   ├── strings1.rs
    │   │   ├── strings2.rs
    │   │   ├── strings3.rs
    │   │   └── strings4.rs
    │   ├── 10_modules/
    │   │   ├── modules1.rs
    │   │   ├── modules2.rs
    │   │   └── modules3.rs
    │   ├── 11_hashmaps/
    │   │   ├── hashmaps1.rs
    │   │   ├── hashmaps2.rs
    │   │   └── hashmaps3.rs
    │   ├── 12_options/
    │   │   ├── options1.rs
    │   │   ├── options2.rs
    │   │   └── options3.rs
    │   ├── 13_error_handling/
    │   │   ├── errors1.rs
    │   │   ├── errors2.rs
    │   │   ├── errors3.rs
    │   │   ├── errors4.rs
    │   │   ├── errors5.rs
    │   │   └── errors6.rs
    │   ├── 14_generics/
    │   │   ├── generics1.rs
    │   │   └── generics2.rs
    │   ├── 15_traits/
    │   │   ├── traits1.rs
    │   │   ├── traits2.rs
    │   │   ├── traits3.rs
    │   │   ├── traits4.rs
    │   │   └── traits5.rs
    │   ├── 16_lifetimes/
    │   │   ├── lifetimes1.rs
    │   │   ├── lifetimes2.rs
    │   │   └── lifetimes3.rs
    │   ├── 17_tests/
    │   │   ├── tests1.rs
    │   │   ├── tests2.rs
    │   │   └── tests3.rs
    │   ├── 18_iterators/
    │   │   ├── iterators1.rs
    │   │   ├── iterators2.rs
    │   │   ├── iterators3.rs
    │   │   ├── iterators4.rs
    │   │   └── iterators5.rs
    │   ├── 19_smart_pointers/
    │   │   ├── arc1.rs
    │   │   ├── box1.rs
    │   │   ├── cow1.rs
    │   │   └── rc1.rs
    │   ├── 20_threads/
    │   │   ├── threads1.rs
    │   │   ├── threads2.rs
    │   │   └── threads3.rs
    │   ├── 21_macros/
    │   │   ├── macros1.rs
    │   │   ├── macros2.rs
    │   │   ├── macros3.rs
    │   │   └── macros4.rs
    │   ├── 22_clippy/
    │   │   ├── clippy1.rs
    │   │   ├── clippy2.rs
    │   │   └── clippy3.rs
    │   ├── 23_conversions/
    │   │   ├── as_ref_mut.rs
    │   │   ├── from_into.rs
    │   │   ├── from_str.rs
    │   │   ├── try_from_into.rs
    │   │   └── using_as.rs
    │   └── quizzes/
    │       ├── quiz1.rs
    │       ├── quiz2.rs
    │       └── quiz3.rs
    ├── src/
    │   ├── app_state.rs
    │   ├── cargo_toml.rs
    │   ├── cmd.rs
    │   ├── dev.rs
    │   ├── embedded.rs
    │   ├── exercise.rs
    │   ├── info_file.rs
    │   ├── init.rs
    │   ├── list.rs
    │   ├── main.rs
    │   ├── run.rs
    │   ├── term.rs
    │   ├── watch.rs
    │   ├── dev/
    │   │   ├── check.rs
    │   │   ├── new.rs
    │   │   └── update.rs
    │   ├── list/
    │   │   ├── scroll_state.rs
    │   │   └── state.rs
    │   └── watch/
    │       ├── notify_event.rs
    │       ├── state.rs
    │       └── terminal_event.rs
    ├── tests/
    │   ├── integration_tests.rs
    │   └── test_exercises/
    │       ├── info.toml
    │       ├── dev/
    │       │   └── Cargo.toml
    │       └── exercises/
    │           ├── compilation_failure.rs
    │           ├── compilation_success.rs
    │           ├── not_in_info.rs
    │           ├── test_failure.rs
    │           └── test_success.rs
    ├── website/
    │   ├── config.toml
    │   ├── input.css
    │   ├── justfile
    │   ├── package.json
    │   ├── content/
    │   │   ├── _index.md
    │   │   ├── community-exercises/
    │   │   │   └── index.md
    │   │   ├── setup/
    │   │   │   └── index.md
    │   │   └── usage/
    │   │       └── index.md
    │   └── templates/
    │       ├── 404.html
    │       ├── anchor-link.html
    │       ├── base.html
    │       ├── index.html
    │       ├── page.html
    │       └── shortcodes/
    │           └── details.html
    ├── .cargo/
    │   └── config.toml
    └── .github/
        └── workflows/
            ├── rust.yml
            └── website.yml

================================================
FILE: README.md
================================================
# [Rustlings](https://rustlings.rust-lang.org) 🦀

Small exercises to get you used to reading and writing [Rust](https://www.rust-lang.org) code - _Recommended in parallel to reading [the official Rust book](https://doc.rust-lang.org/book) 📚️_

Visit the **website** for a demo, info about setup and more:

## ➡️ [rustlings.rust-lang.org](https://rustlings.rust-lang.org) ⬅️



================================================
FILE: build.rs
================================================
fn main() {
    // Fix building from source on Windows because it can't handle file links.
    #[cfg(windows)]
    let _ = std::fs::copy("dev/Cargo.toml", "dev-Cargo.toml");
}



================================================
FILE: Cargo.toml
================================================
[workspace]
exclude = [
  "tests/test_exercises",
  "dev",
]

[workspace.package]
version = "6.5.0"
authors = [
  "Mo Bitar <mo8it@proton.me>", # https://github.com/mo8it
  "Liv <mokou@fastmail.com>", # https://github.com/shadows-withal
  # Alumni
  "Carol (Nichols || Goulding) <carol.nichols@gmail.com>", # https://github.com/carols10cents
]
repository = "https://github.com/rust-lang/rustlings"
license = "MIT"
edition = "2024" # On Update: Update the edition of `rustfmt` in `dev check` and `CARGO_TOML` in `dev new`.
rust-version = "1.88"

[workspace.dependencies]
serde = { version = "1.0", features = ["derive"] }
toml = { version = "0.9", default-features = false, features = ["std", "parse", "serde"] }

[package]
name = "rustlings"
description = "Small exercises to get you used to reading and writing Rust code!"
version.workspace = true
authors.workspace = true
repository.workspace = true
license.workspace = true
edition.workspace = true
rust-version.workspace = true
keywords = [
  "exercise",
  "learning",
]
include = [
  "/src/",
  "/exercises/",
  "/solutions/",
  # A symlink to be able to include `dev/Cargo.toml` although `dev` is excluded.
  "/dev-Cargo.toml",
  "/README.md",
  "/LICENSE",
]

[dependencies]
anyhow = "1.0"
clap = { version = "4.5", features = ["derive"] }
crossterm = { version = "0.29", default-features = false, features = ["windows", "events"] }
notify = "8.0"
rustlings-macros = { path = "rustlings-macros", version = "=6.5.0" }
serde_json = "1.0"
serde.workspace = true
toml.workspace = true

[target.'cfg(not(windows))'.dependencies]
rustix = { version = "1.0", default-features = false, features = ["std", "stdio", "termios"] }

[dev-dependencies]
tempfile = "3.21"

[profile.release]
panic = "abort"

[profile.dev]
panic = "abort"

[package.metadata.release]
pre-release-hook = ["./release-hook.sh"]
pre-release-commit-message = "Release 🎉"

[workspace.lints.rust]
unsafe_code = "forbid"
unstable_features = "forbid"

[workspace.lints.clippy]
empty_loop = "forbid"
disallowed-types = "deny"
disallowed-methods = "deny"
infinite_loop = "deny"
mem_forget = "deny"
dbg_macro = "warn"
todo = "warn"

[lints]
workspace = true



================================================
FILE: clippy.toml
================================================
disallowed-types = [
  { path = "crossterm::style::Stylize", reason = "inefficient, use `.queue(…)` instead" },
  { path = "crossterm::style::styled_content::StyledContent", reason = "inefficient, use `.queue(…)` instead" },
]

disallowed-methods = [
  { path = "crossterm::style::style", reason = "inefficient, use `.queue(…)` instead" },
  { path = "std::thread::spawn", replacement = "std::thread::Builder::spawn", reason = "handle the error" },
  { path = "std::thread::Scope::spawn", replacement = "std::thread::Builder::spawn", reason = "handle the error" },
  { path = "std::process::exit", replacement = "std::process::ExitCode" },
]



================================================
FILE: CONTRIBUTING.md
================================================
# Contributing to Rustlings

First off, thanks for taking the time to contribute! ❤️

## Quick Reference

I want to …

- _report a bug!_ ➡️ [open an issue](#issues)
- _fix a bug!_ ➡️ [open a pull request](#pull-requests)
- _implement a new feature!_ ➡️ [open an issue to discuss it first, then a pull request](#issues)
- _add an exercise!_ ➡️ [read this](#adding-an-exercise)
- _update an outdated exercise!_ ➡️ [open a pull request](#pull-requests)

## Issues

You can open an issue [here](https://github.com/rust-lang/rustlings/issues/new).
If you're reporting a bug, please include the output of the following commands:

- `cargo --version`
- `rustlings --version`
- `ls -la`
- Your OS name and version

## Pull Requests

You are welcome to open a pull request, but unless it is small and trivial, **please open an issue to discuss your idea first** 🙏🏼

Opening a pull request is as easy as forking the repository and committing your changes.
If you need any help with it or face any Git related problems, don't hesitate to ask for help 🤗

It may take time to review your pull request.
Please be patient 😇

When updating an exercise, check if its solution needs to be updated.

## Adding An Exercise

- Name the file `exercises/yourTopic/yourTopicN.rs`.
- Make sure to put in some helpful links, and link to sections of The Book in `exercises/yourTopic/README.md`.
- In the exercise, add a `// TODO: …` comment where user changes are required.
- Add a solution at `solutions/yourTopic/yourTopicN.rs` with comments explaining it.
- Add the [metadata for your exercise](#exercise-metadata) in the `rustlings-macros/info.toml` file.
- Make sure your exercise runs with `rustlings run yourTopicN`.
- [Open a pull request](#pull-requests).

### Exercise Metadata

The exercise metadata should contain the following:

```toml
[[exercises]]
name = "yourTopicN"
dir = "yourTopic"
hint = """
A useful (multi-line) hint for your exercise.
Include links to a section in The Book or a documentation page."""
```

If your exercise doesn't contain any test, add `test = false` to the exercise metadata.
But adding tests is recommended.



================================================
FILE: LICENSE
================================================
The MIT License (MIT)

Copyright (c) 2016 Carol (Nichols || Goulding)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.




================================================
FILE: release-hook.sh
================================================
#!/bin/bash

# Error out if any command fails
set -e

typos
cargo upgrades

# Similar to CI
cargo clippy -- --deny warnings
cargo fmt --all --check
cargo test --workspace
cargo dev check --require-solutions

# MSRV
cargo +1.88 dev check --require-solutions



================================================
FILE: .typos.toml
================================================
[default.extend-words]
"earch" = "earch" # Because of <s>earch in the list footer

[files]
extend-exclude = [
  "CHANGELOG.md",
]



================================================
FILE: dev/Cargo.toml
================================================
# Don't edit the `bin` list manually! It is updated by `cargo dev update`. This comment line will be stripped in `rustlings init`.
bin = [
  { name = "intro1", path = "../exercises/00_intro/intro1.rs" },
  { name = "intro1_sol", path = "../solutions/00_intro/intro1.rs" },
  { name = "intro2", path = "../exercises/00_intro/intro2.rs" },
  { name = "intro2_sol", path = "../solutions/00_intro/intro2.rs" },
  { name = "variables1", path = "../exercises/01_variables/variables1.rs" },
  { name = "variables1_sol", path = "../solutions/01_variables/variables1.rs" },
  { name = "variables2", path = "../exercises/01_variables/variables2.rs" },
  { name = "variables2_sol", path = "../solutions/01_variables/variables2.rs" },
  { name = "variables3", path = "../exercises/01_variables/variables3.rs" },
  { name = "variables3_sol", path = "../solutions/01_variables/variables3.rs" },
  { name = "variables4", path = "../exercises/01_variables/variables4.rs" },
  { name = "variables4_sol", path = "../solutions/01_variables/variables4.rs" },
  { name = "variables5", path = "../exercises/01_variables/variables5.rs" },
  { name = "variables5_sol", path = "../solutions/01_variables/variables5.rs" },
  { name = "variables6", path = "../exercises/01_variables/variables6.rs" },
  { name = "variables6_sol", path = "../solutions/01_variables/variables6.rs" },
  { name = "functions1", path = "../exercises/02_functions/functions1.rs" },
  { name = "functions1_sol", path = "../solutions/02_functions/functions1.rs" },
  { name = "functions2", path = "../exercises/02_functions/functions2.rs" },
  { name = "functions2_sol", path = "../solutions/02_functions/functions2.rs" },
  { name = "functions3", path = "../exercises/02_functions/functions3.rs" },
  { name = "functions3_sol", path = "../solutions/02_functions/functions3.rs" },
  { name = "functions4", path = "../exercises/02_functions/functions4.rs" },
  { name = "functions4_sol", path = "../solutions/02_functions/functions4.rs" },
  { name = "functions5", path = "../exercises/02_functions/functions5.rs" },
  { name = "functions5_sol", path = "../solutions/02_functions/functions5.rs" },
  { name = "if1", path = "../exercises/03_if/if1.rs" },
  { name = "if1_sol", path = "../solutions/03_if/if1.rs" },
  { name = "if2", path = "../exercises/03_if/if2.rs" },
  { name = "if2_sol", path = "../solutions/03_if/if2.rs" },
  { name = "if3", path = "../exercises/03_if/if3.rs" },
  { name = "if3_sol", path = "../solutions/03_if/if3.rs" },
  { name = "quiz1", path = "../exercises/quizzes/quiz1.rs" },
  { name = "quiz1_sol", path = "../solutions/quizzes/quiz1.rs" },
  { name = "primitive_types1", path = "../exercises/04_primitive_types/primitive_types1.rs" },
  { name = "primitive_types1_sol", path = "../solutions/04_primitive_types/primitive_types1.rs" },
  { name = "primitive_types2", path = "../exercises/04_primitive_types/primitive_types2.rs" },
  { name = "primitive_types2_sol", path = "../solutions/04_primitive_types/primitive_types2.rs" },
  { name = "primitive_types3", path = "../exercises/04_primitive_types/primitive_types3.rs" },
  { name = "primitive_types3_sol", path = "../solutions/04_primitive_types/primitive_types3.rs" },
  { name = "primitive_types4", path = "../exercises/04_primitive_types/primitive_types4.rs" },
  { name = "primitive_types4_sol", path = "../solutions/04_primitive_types/primitive_types4.rs" },
  { name = "primitive_types5", path = "../exercises/04_primitive_types/primitive_types5.rs" },
  { name = "primitive_types5_sol", path = "../solutions/04_primitive_types/primitive_types5.rs" },
  { name = "primitive_types6", path = "../exercises/04_primitive_types/primitive_types6.rs" },
  { name = "primitive_types6_sol", path = "../solutions/04_primitive_types/primitive_types6.rs" },
  { name = "vecs1", path = "../exercises/05_vecs/vecs1.rs" },
  { name = "vecs1_sol", path = "../solutions/05_vecs/vecs1.rs" },
  { name = "vecs2", path = "../exercises/05_vecs/vecs2.rs" },
  { name = "vecs2_sol", path = "../solutions/05_vecs/vecs2.rs" },
  { name = "move_semantics1", path = "../exercises/06_move_semantics/move_semantics1.rs" },
  { name = "move_semantics1_sol", path = "../solutions/06_move_semantics/move_semantics1.rs" },
  { name = "move_semantics2", path = "../exercises/06_move_semantics/move_semantics2.rs" },
  { name = "move_semantics2_sol", path = "../solutions/06_move_semantics/move_semantics2.rs" },
  { name = "move_semantics3", path = "../exercises/06_move_semantics/move_semantics3.rs" },
  { name = "move_semantics3_sol", path = "../solutions/06_move_semantics/move_semantics3.rs" },
  { name = "move_semantics4", path = "../exercises/06_move_semantics/move_semantics4.rs" },
  { name = "move_semantics4_sol", path = "../solutions/06_move_semantics/move_semantics4.rs" },
  { name = "move_semantics5", path = "../exercises/06_move_semantics/move_semantics5.rs" },
  { name = "move_semantics5_sol", path = "../solutions/06_move_semantics/move_semantics5.rs" },
  { name = "structs1", path = "../exercises/07_structs/structs1.rs" },
  { name = "structs1_sol", path = "../solutions/07_structs/structs1.rs" },
  { name = "structs2", path = "../exercises/07_structs/structs2.rs" },
  { name = "structs2_sol", path = "../solutions/07_structs/structs2.rs" },
  { name = "structs3", path = "../exercises/07_structs/structs3.rs" },
  { name = "structs3_sol", path = "../solutions/07_structs/structs3.rs" },
  { name = "enums1", path = "../exercises/08_enums/enums1.rs" },
  { name = "enums1_sol", path = "../solutions/08_enums/enums1.rs" },
  { name = "enums2", path = "../exercises/08_enums/enums2.rs" },
  { name = "enums2_sol", path = "../solutions/08_enums/enums2.rs" },
  { name = "enums3", path = "../exercises/08_enums/enums3.rs" },
  { name = "enums3_sol", path = "../solutions/08_enums/enums3.rs" },
  { name = "strings1", path = "../exercises/09_strings/strings1.rs" },
  { name = "strings1_sol", path = "../solutions/09_strings/strings1.rs" },
  { name = "strings2", path = "../exercises/09_strings/strings2.rs" },
  { name = "strings2_sol", path = "../solutions/09_strings/strings2.rs" },
  { name = "strings3", path = "../exercises/09_strings/strings3.rs" },
  { name = "strings3_sol", path = "../solutions/09_strings/strings3.rs" },
  { name = "strings4", path = "../exercises/09_strings/strings4.rs" },
  { name = "strings4_sol", path = "../solutions/09_strings/strings4.rs" },
  { name = "modules1", path = "../exercises/10_modules/modules1.rs" },
  { name = "modules1_sol", path = "../solutions/10_modules/modules1.rs" },
  { name = "modules2", path = "../exercises/10_modules/modules2.rs" },
  { name = "modules2_sol", path = "../solutions/10_modules/modules2.rs" },
  { name = "modules3", path = "../exercises/10_modules/modules3.rs" },
  { name = "modules3_sol", path = "../solutions/10_modules/modules3.rs" },
  { name = "hashmaps1", path = "../exercises/11_hashmaps/hashmaps1.rs" },
  { name = "hashmaps1_sol", path = "../solutions/11_hashmaps/hashmaps1.rs" },
  { name = "hashmaps2", path = "../exercises/11_hashmaps/hashmaps2.rs" },
  { name = "hashmaps2_sol", path = "../solutions/11_hashmaps/hashmaps2.rs" },
  { name = "hashmaps3", path = "../exercises/11_hashmaps/hashmaps3.rs" },
  { name = "hashmaps3_sol", path = "../solutions/11_hashmaps/hashmaps3.rs" },
  { name = "quiz2", path = "../exercises/quizzes/quiz2.rs" },
  { name = "quiz2_sol", path = "../solutions/quizzes/quiz2.rs" },
  { name = "options1", path = "../exercises/12_options/options1.rs" },
  { name = "options1_sol", path = "../solutions/12_options/options1.rs" },
  { name = "options2", path = "../exercises/12_options/options2.rs" },
  { name = "options2_sol", path = "../solutions/12_options/options2.rs" },
  { name = "options3", path = "../exercises/12_options/options3.rs" },
  { name = "options3_sol", path = "../solutions/12_options/options3.rs" },
  { name = "errors1", path = "../exercises/13_error_handling/errors1.rs" },
  { name = "errors1_sol", path = "../solutions/13_error_handling/errors1.rs" },
  { name = "errors2", path = "../exercises/13_error_handling/errors2.rs" },
  { name = "errors2_sol", path = "../solutions/13_error_handling/errors2.rs" },
  { name = "errors3", path = "../exercises/13_error_handling/errors3.rs" },
  { name = "errors3_sol", path = "../solutions/13_error_handling/errors3.rs" },
  { name = "errors4", path = "../exercises/13_error_handling/errors4.rs" },
  { name = "errors4_sol", path = "../solutions/13_error_handling/errors4.rs" },
  { name = "errors5", path = "../exercises/13_error_handling/errors5.rs" },
  { name = "errors5_sol", path = "../solutions/13_error_handling/errors5.rs" },
  { name = "errors6", path = "../exercises/13_error_handling/errors6.rs" },
  { name = "errors6_sol", path = "../solutions/13_error_handling/errors6.rs" },
  { name = "generics1", path = "../exercises/14_generics/generics1.rs" },
  { name = "generics1_sol", path = "../solutions/14_generics/generics1.rs" },
  { name = "generics2", path = "../exercises/14_generics/generics2.rs" },
  { name = "generics2_sol", path = "../solutions/14_generics/generics2.rs" },
  { name = "traits1", path = "../exercises/15_traits/traits1.rs" },
  { name = "traits1_sol", path = "../solutions/15_traits/traits1.rs" },
  { name = "traits2", path = "../exercises/15_traits/traits2.rs" },
  { name = "traits2_sol", path = "../solutions/15_traits/traits2.rs" },
  { name = "traits3", path = "../exercises/15_traits/traits3.rs" },
  { name = "traits3_sol", path = "../solutions/15_traits/traits3.rs" },
  { name = "traits4", path = "../exercises/15_traits/traits4.rs" },
  { name = "traits4_sol", path = "../solutions/15_traits/traits4.rs" },
  { name = "traits5", path = "../exercises/15_traits/traits5.rs" },
  { name = "traits5_sol", path = "../solutions/15_traits/traits5.rs" },
  { name = "quiz3", path = "../exercises/quizzes/quiz3.rs" },
  { name = "quiz3_sol", path = "../solutions/quizzes/quiz3.rs" },
  { name = "lifetimes1", path = "../exercises/16_lifetimes/lifetimes1.rs" },
  { name = "lifetimes1_sol", path = "../solutions/16_lifetimes/lifetimes1.rs" },
  { name = "lifetimes2", path = "../exercises/16_lifetimes/lifetimes2.rs" },
  { name = "lifetimes2_sol", path = "../solutions/16_lifetimes/lifetimes2.rs" },
  { name = "lifetimes3", path = "../exercises/16_lifetimes/lifetimes3.rs" },
  { name = "lifetimes3_sol", path = "../solutions/16_lifetimes/lifetimes3.rs" },
  { name = "tests1", path = "../exercises/17_tests/tests1.rs" },
  { name = "tests1_sol", path = "../solutions/17_tests/tests1.rs" },
  { name = "tests2", path = "../exercises/17_tests/tests2.rs" },
  { name = "tests2_sol", path = "../solutions/17_tests/tests2.rs" },
  { name = "tests3", path = "../exercises/17_tests/tests3.rs" },
  { name = "tests3_sol", path = "../solutions/17_tests/tests3.rs" },
  { name = "iterators1", path = "../exercises/18_iterators/iterators1.rs" },
  { name = "iterators1_sol", path = "../solutions/18_iterators/iterators1.rs" },
  { name = "iterators2", path = "../exercises/18_iterators/iterators2.rs" },
  { name = "iterators2_sol", path = "../solutions/18_iterators/iterators2.rs" },
  { name = "iterators3", path = "../exercises/18_iterators/iterators3.rs" },
  { name = "iterators3_sol", path = "../solutions/18_iterators/iterators3.rs" },
  { name = "iterators4", path = "../exercises/18_iterators/iterators4.rs" },
  { name = "iterators4_sol", path = "../solutions/18_iterators/iterators4.rs" },
  { name = "iterators5", path = "../exercises/18_iterators/iterators5.rs" },
  { name = "iterators5_sol", path = "../solutions/18_iterators/iterators5.rs" },
  { name = "box1", path = "../exercises/19_smart_pointers/box1.rs" },
  { name = "box1_sol", path = "../solutions/19_smart_pointers/box1.rs" },
  { name = "rc1", path = "../exercises/19_smart_pointers/rc1.rs" },
  { name = "rc1_sol", path = "../solutions/19_smart_pointers/rc1.rs" },
  { name = "arc1", path = "../exercises/19_smart_pointers/arc1.rs" },
  { name = "arc1_sol", path = "../solutions/19_smart_pointers/arc1.rs" },
  { name = "cow1", path = "../exercises/19_smart_pointers/cow1.rs" },
  { name = "cow1_sol", path = "../solutions/19_smart_pointers/cow1.rs" },
  { name = "threads1", path = "../exercises/20_threads/threads1.rs" },
  { name = "threads1_sol", path = "../solutions/20_threads/threads1.rs" },
  { name = "threads2", path = "../exercises/20_threads/threads2.rs" },
  { name = "threads2_sol", path = "../solutions/20_threads/threads2.rs" },
  { name = "threads3", path = "../exercises/20_threads/threads3.rs" },
  { name = "threads3_sol", path = "../solutions/20_threads/threads3.rs" },
  { name = "macros1", path = "../exercises/21_macros/macros1.rs" },
  { name = "macros1_sol", path = "../solutions/21_macros/macros1.rs" },
  { name = "macros2", path = "../exercises/21_macros/macros2.rs" },
  { name = "macros2_sol", path = "../solutions/21_macros/macros2.rs" },
  { name = "macros3", path = "../exercises/21_macros/macros3.rs" },
  { name = "macros3_sol", path = "../solutions/21_macros/macros3.rs" },
  { name = "macros4", path = "../exercises/21_macros/macros4.rs" },
  { name = "macros4_sol", path = "../solutions/21_macros/macros4.rs" },
  { name = "clippy1", path = "../exercises/22_clippy/clippy1.rs" },
  { name = "clippy1_sol", path = "../solutions/22_clippy/clippy1.rs" },
  { name = "clippy2", path = "../exercises/22_clippy/clippy2.rs" },
  { name = "clippy2_sol", path = "../solutions/22_clippy/clippy2.rs" },
  { name = "clippy3", path = "../exercises/22_clippy/clippy3.rs" },
  { name = "clippy3_sol", path = "../solutions/22_clippy/clippy3.rs" },
  { name = "using_as", path = "../exercises/23_conversions/using_as.rs" },
  { name = "using_as_sol", path = "../solutions/23_conversions/using_as.rs" },
  { name = "from_into", path = "../exercises/23_conversions/from_into.rs" },
  { name = "from_into_sol", path = "../solutions/23_conversions/from_into.rs" },
  { name = "from_str", path = "../exercises/23_conversions/from_str.rs" },
  { name = "from_str_sol", path = "../solutions/23_conversions/from_str.rs" },
  { name = "try_from_into", path = "../exercises/23_conversions/try_from_into.rs" },
  { name = "try_from_into_sol", path = "../solutions/23_conversions/try_from_into.rs" },
  { name = "as_ref_mut", path = "../exercises/23_conversions/as_ref_mut.rs" },
  { name = "as_ref_mut_sol", path = "../solutions/23_conversions/as_ref_mut.rs" },
]

[package]
name = "exercises"
edition = "2024"
# Don't publish the exercises on crates.io!
publish = false

[profile.release]
panic = "abort"

[profile.dev]
panic = "abort"

[lints.rust]
# You shouldn't write unsafe code in Rustlings!
unsafe_code = "forbid"
# You don't need unstable features in Rustlings and shouldn't rely on them while learning Rust.
unstable_features = "forbid"
# Dead code warnings can't be avoided in some exercises and might distract while learning.
dead_code = "allow"

[lints.clippy]
# You forgot a `todo!()`!
todo = "forbid"
# This can only happen by mistake in Rustlings.
empty_loop = "forbid"
# No infinite loops are needed in Rustlings.
infinite_loop = "deny"
# You shouldn't leak memory while still learning Rust!
mem_forget = "deny"
# Currently, there are no disallowed methods. This line avoids problems when developing Rustlings.
disallowed_methods = "allow"



================================================
FILE: dev/rustlings-repo.txt
================================================
This file is used to check if the user tries to run Rustlings in the repository (the method before version 6)



================================================
SYMLINK: dev-Cargo.toml -> Cargo.toml
================================================



================================================
FILE: exercises/README.md
================================================
# Exercise to Book Chapter mapping

| Exercise               | Book Chapter        |
| ---------------------- | ------------------- |
| variables              | §3.1                |
| functions              | §3.3                |
| if                     | §3.5                |
| primitive_types        | §3.2, §4.3          |
| vecs                   | §8.1                |
| move_semantics         | §4.1-2              |
| structs                | §5.1, §5.3          |
| enums                  | §6, §18.3           |
| strings                | §8.2                |
| modules                | §7                  |
| hashmaps               | §8.3                |
| options                | §10.1               |
| error_handling         | §9                  |
| generics               | §10                 |
| traits                 | §10.2               |
| lifetimes              | §10.3               |
| tests                  | §11.1               |
| iterators              | §13.2-4             |
| smart_pointers         | §15, §16.3          |
| threads                | §16.1-3             |
| macros                 | §20.5               |
| clippy                 | Appendix D          |
| conversions            | n/a                 |



================================================
FILE: exercises/00_intro/README.md
================================================
# Intro

Rust uses the `print!` and `println!` macros to print text to the console.

## Further information

- [Hello World](https://doc.rust-lang.org/rust-by-example/hello.html)
- [Formatted print](https://doc.rust-lang.org/rust-by-example/hello/print.html)



================================================
FILE: exercises/00_intro/intro1.rs
================================================
// TODO: We sometimes encourage you to keep trying things on a given exercise
// even after you already figured it out. If you got everything working and feel
// ready for the next exercise, enter `n` in the terminal.
//
// The exercise file will be reloaded when you change one of the lines below!
// Try adding a new `println!` and check the updated output in the terminal.

fn main() {
    println!(r#"       Welcome to...                      "#);
    println!(r#"                 _   _ _                  "#);
    println!(r#"  _ __ _   _ ___| |_| (_)_ __   __ _ ___  "#);
    println!(r#" | '__| | | / __| __| | | '_ \ / _` / __| "#);
    println!(r#" | |  | |_| \__ \ |_| | | | | | (_| \__ \ "#);
    println!(r#" |_|   \__,_|___/\__|_|_|_| |_|\__, |___/ "#);
    println!(r#"                               |___/      "#);
    println!();
    println!("This exercise compiles successfully. The remaining exercises contain a compiler");
    println!("or logic error. The central concept behind Rustlings is to fix these errors and");
    println!("solve the exercises. Good luck!");
    println!();
    println!("The file of this exercise is `exercises/00_intro/intro1.rs`. Have a look!");
    println!("The current exercise path will be always shown under the progress bar.");
    println!("You can click on the path to open the exercise file in your editor.");
}



================================================
FILE: exercises/00_intro/intro2.rs
================================================
fn main() {
    // TODO: Fix the code to print "Hello world!".
    printline!("Hello world!");
}



================================================
FILE: exercises/01_variables/README.md
================================================
# Variables

In Rust, variables are immutable by default.
When a variable is immutable, once a value is bound to a name, you can't change that value.
You can make them mutable by adding `mut` in front of the variable name.

## Further information

- [Variables and Mutability](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html)



================================================
FILE: exercises/01_variables/variables1.rs
================================================
fn main() {
    // TODO: Add the missing keyword.
    x = 5;

    println!("x has the value {x}");
}



================================================
FILE: exercises/01_variables/variables2.rs
================================================
fn main() {
    // TODO: Change the line below to fix the compiler error.
    let x;

    if x == 10 {
        println!("x is ten!");
    } else {
        println!("x is not ten!");
    }
}



================================================
FILE: exercises/01_variables/variables3.rs
================================================
fn main() {
    // TODO: Change the line below to fix the compiler error.
    let x: i32;

    println!("Number {x}");
}



================================================
FILE: exercises/01_variables/variables4.rs
================================================
// TODO: Fix the compiler error.
fn main() {
    let x = 3;
    println!("Number {x}");

    x = 5; // Don't change this line
    println!("Number {x}");
}



================================================
FILE: exercises/01_variables/variables5.rs
================================================
fn main() {
    let number = "T-H-R-E-E"; // Don't change this line
    println!("Spell a number: {number}");

    // TODO: Fix the compiler error by changing the line below without renaming the variable.
    number = 3;
    println!("Number plus two is: {}", number + 2);
}



================================================
FILE: exercises/01_variables/variables6.rs
================================================
// TODO: Change the line below to fix the compiler error.
const NUMBER = 3;

fn main() {
    println!("Number: {NUMBER}");
}



================================================
FILE: exercises/02_functions/README.md
================================================
# Functions

Here, you'll learn how to write functions and how the Rust compiler can help you debug errors even
in more complex code.

## Further information

- [How Functions Work](https://doc.rust-lang.org/book/ch03-03-how-functions-work.html)



================================================
FILE: exercises/02_functions/functions1.rs
================================================
// TODO: Add some function with the name `call_me` without arguments or a return value.

fn main() {
    call_me(); // Don't change this line
}



================================================
FILE: exercises/02_functions/functions2.rs
================================================
// TODO: Add the missing type of the argument `num` after the colon `:`.
fn call_me(num:) {
    for i in 0..num {
        println!("Ring! Call number {}", i + 1);
    }
}

fn main() {
    call_me(3);
}



================================================
FILE: exercises/02_functions/functions3.rs
================================================
fn call_me(num: u8) {
    for i in 0..num {
        println!("Ring! Call number {}", i + 1);
    }
}

fn main() {
    // TODO: Fix the function call.
    call_me();
}



================================================
FILE: exercises/02_functions/functions4.rs
================================================
// This store is having a sale where if the price is an even number, you get 10
// Rustbucks off, but if it's an odd number, it's 3 Rustbucks off.
// Don't worry about the function bodies themselves, we are only interested in
// the signatures for now.

fn is_even(num: i64) -> bool {
    num % 2 == 0
}

// TODO: Fix the function signature.
fn sale_price(price: i64) -> {
    if is_even(price) {
        price - 10
    } else {
        price - 3
    }
}

fn main() {
    let original_price = 51;
    println!("Your sale price is {}", sale_price(original_price));
}



================================================
FILE: exercises/02_functions/functions5.rs
================================================
// TODO: Fix the function body without changing the signature.
fn square(num: i32) -> i32 {
    num * num;
}

fn main() {
    let answer = square(3);
    println!("The square of 3 is {answer}");
}



================================================
FILE: exercises/03_if/README.md
================================================
# If

`if`, the most basic (but still surprisingly versatile!) type of control flow, is what you'll learn here.

## Further information

- [Control Flow - if expressions](https://doc.rust-lang.org/book/ch03-05-control-flow.html#if-expressions)



================================================
FILE: exercises/03_if/if1.rs
================================================
fn bigger(a: i32, b: i32) -> i32 {
    // TODO: Complete this function to return the bigger number!
    // If both numbers are equal, any of them can be returned.
    // Do not use:
    // - another function call
    // - additional variables
}

fn main() {
    // You can optionally experiment here.
}

// Don't mind this for now :)
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ten_is_bigger_than_eight() {
        assert_eq!(10, bigger(10, 8));
    }

    #[test]
    fn fortytwo_is_bigger_than_thirtytwo() {
        assert_eq!(42, bigger(32, 42));
    }

    #[test]
    fn equal_numbers() {
        assert_eq!(42, bigger(42, 42));
    }
}



================================================
FILE: exercises/03_if/if2.rs
================================================
// TODO: Fix the compiler error on this function.
fn picky_eater(food: &str) -> &str {
    if food == "strawberry" {
        "Yummy!"
    } else {
        1
    }
}

fn main() {
    // You can optionally experiment here.
}

// TODO: Read the tests to understand the desired behavior.
// Make all tests pass without changing them.
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn yummy_food() {
        // This means that calling `picky_eater` with the argument "strawberry" should return "Yummy!".
        assert_eq!(picky_eater("strawberry"), "Yummy!");
    }

    #[test]
    fn neutral_food() {
        assert_eq!(picky_eater("potato"), "I guess I can eat that.");
    }

    #[test]
    fn default_disliked_food() {
        assert_eq!(picky_eater("broccoli"), "No thanks!");
        assert_eq!(picky_eater("gummy bears"), "No thanks!");
        assert_eq!(picky_eater("literally anything"), "No thanks!");
    }
}



================================================
FILE: exercises/03_if/if3.rs
================================================
fn animal_habitat(animal: &str) -> &str {
    // TODO: Fix the compiler error in the statement below.
    let identifier = if animal == "crab" {
        1
    } else if animal == "gopher" {
        2.0
    } else if animal == "snake" {
        3
    } else {
        "Unknown"
    };

    // Don't change the expression below!
    if identifier == 1 {
        "Beach"
    } else if identifier == 2 {
        "Burrow"
    } else if identifier == 3 {
        "Desert"
    } else {
        "Unknown"
    }
}

fn main() {
    // You can optionally experiment here.
}

// Don't change the tests!
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn gopher_lives_in_burrow() {
        assert_eq!(animal_habitat("gopher"), "Burrow")
    }

    #[test]
    fn snake_lives_in_desert() {
        assert_eq!(animal_habitat("snake"), "Desert")
    }

    #[test]
    fn crab_lives_on_beach() {
        assert_eq!(animal_habitat("crab"), "Beach")
    }

    #[test]
    fn unknown_animal() {
        assert_eq!(animal_habitat("dinosaur"), "Unknown")
    }
}



================================================
FILE: exercises/04_primitive_types/README.md
================================================
# Primitive Types

Rust has a couple of basic types that are directly implemented into the
compiler. In this section, we'll go through the most important ones.

## Further information

- [Data Types](https://doc.rust-lang.org/book/ch03-02-data-types.html)
- [The Slice Type](https://doc.rust-lang.org/book/ch04-03-slices.html)



================================================
FILE: exercises/04_primitive_types/primitive_types1.rs
================================================
// Booleans (`bool`)

fn main() {
    let is_morning = true;
    if is_morning {
        println!("Good morning!");
    }

    // TODO: Define a boolean variable with the name `is_evening` before the `if` statement below.
    // The value of the variable should be the negation (opposite) of `is_morning`.
    // let …
    if is_evening {
        println!("Good evening!");
    }
}



================================================
FILE: exercises/04_primitive_types/primitive_types2.rs
================================================
// Characters (`char`)

fn main() {
    // Note the _single_ quotes, these are different from the double quotes
    // you've been seeing around.
    let my_first_initial = 'C';
    if my_first_initial.is_alphabetic() {
        println!("Alphabetical!");
    } else if my_first_initial.is_numeric() {
        println!("Numerical!");
    } else {
        println!("Neither alphabetic nor numeric!");
    }

    // TODO: Analogous to the example before, declare a variable called `your_character`
    // below with your favorite character.
    // Try a letter, try a digit (in single quotes), try a special character, try a character
    // from a different language than your own, try an emoji 😉
    // let your_character = '';

    if your_character.is_alphabetic() {
        println!("Alphabetical!");
    } else if your_character.is_numeric() {
        println!("Numerical!");
    } else {
        println!("Neither alphabetic nor numeric!");
    }
}



================================================
FILE: exercises/04_primitive_types/primitive_types3.rs
================================================
fn main() {
    // TODO: Create an array called `a` with at least 100 elements in it.
    // let a = ???

    if a.len() >= 100 {
        println!("Wow, that's a big array!");
    } else {
        println!("Meh, I eat arrays like that for breakfast.");
        panic!("Array not big enough, more elements needed");
    }
}



================================================
FILE: exercises/04_primitive_types/primitive_types4.rs
================================================
fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    #[test]
    fn slice_out_of_array() {
        let a = [1, 2, 3, 4, 5];

        // TODO: Get a slice called `nice_slice` out of the array `a` so that the test passes.
        // let nice_slice = ???

        assert_eq!([2, 3, 4], nice_slice);
    }
}



================================================
FILE: exercises/04_primitive_types/primitive_types5.rs
================================================
fn main() {
    let cat = ("Furry McFurson", 3.5);

    // TODO: Destructure the `cat` tuple in one statement so that the println works.
    // let /* your pattern here */ = cat;

    println!("{name} is {age} years old");
}



================================================
FILE: exercises/04_primitive_types/primitive_types6.rs
================================================
fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    #[test]
    fn indexing_tuple() {
        let numbers = (1, 2, 3);

        // TODO: Use a tuple index to access the second element of `numbers`
        // and assign it to a variable called `second`.
        // let second = ???;

        assert_eq!(second, 2, "This is not the 2nd number in the tuple!");
    }
}



================================================
FILE: exercises/05_vecs/README.md
================================================
# Vectors

Vectors are one of the most-used Rust data structures. In other programming
languages, they'd simply be called Arrays, but since Rust operates on a
bit of a lower level, an array in Rust is stored on the stack (meaning it
can't grow or shrink, and the size needs to be known at compile time),
and a Vector is stored in the heap (where these restrictions do not apply).

Vectors are a bit of a later chapter in the book, but we think that they're
useful enough to talk about them a bit earlier. We shall be talking about
the other useful data structure, hash maps, later.

## Further information

- [Storing Lists of Values with Vectors](https://doc.rust-lang.org/book/ch08-01-vectors.html)
- [`iter_mut`](https://doc.rust-lang.org/std/primitive.slice.html#method.iter_mut)
- [`map`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map)



================================================
FILE: exercises/05_vecs/vecs1.rs
================================================
fn array_and_vec() -> ([i32; 4], Vec<i32>) {
    let a = [10, 20, 30, 40]; // Array

    // TODO: Create a vector called `v` which contains the exact same elements as in the array `a`.
    // Use the vector macro.
    // let v = ???;

    (a, v)
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_array_and_vec_similarity() {
        let (a, v) = array_and_vec();
        assert_eq!(a, *v);
    }
}



================================================
FILE: exercises/05_vecs/vecs2.rs
================================================
fn vec_loop(input: &[i32]) -> Vec<i32> {
    let mut output = Vec::new();

    for element in input {
        // TODO: Multiply each element in the `input` slice by 2 and push it to
        // the `output` vector.
    }

    output
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vec_loop() {
        let input = [2, 4, 6, 8, 10];
        let ans = vec_loop(&input);
        assert_eq!(ans, [4, 8, 12, 16, 20]);
    }
}



================================================
FILE: exercises/06_move_semantics/README.md
================================================
# Move Semantics

These exercises are adapted from [pnkfelix](https://github.com/pnkfelix)'s [Rust Tutorial](https://pnkfelix.github.io/rust-examples-icfp2014/) -- Thank you Felix!!!

## Further information

For this section, the book links are especially important.

- [Ownership](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html)
- [Reference and borrowing](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html)



================================================
FILE: exercises/06_move_semantics/move_semantics1.rs
================================================
// TODO: Fix the compiler error in this function.
fn fill_vec(vec: Vec<i32>) -> Vec<i32> {
    let vec = vec;

    vec.push(88);

    vec
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn move_semantics1() {
        let vec0 = vec![22, 44, 66];
        let vec1 = fill_vec(vec0);
        assert_eq!(vec1, vec![22, 44, 66, 88]);
    }
}



================================================
FILE: exercises/06_move_semantics/move_semantics2.rs
================================================
fn fill_vec(vec: Vec<i32>) -> Vec<i32> {
    let mut vec = vec;

    vec.push(88);

    vec
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    // TODO: Make both vectors `vec0` and `vec1` accessible at the same time to
    // fix the compiler error in the test.
    #[test]
    fn move_semantics2() {
        let vec0 = vec![22, 44, 66];

        let vec1 = fill_vec(vec0);

        assert_eq!(vec0, [22, 44, 66]);
        assert_eq!(vec1, [22, 44, 66, 88]);
    }
}



================================================
FILE: exercises/06_move_semantics/move_semantics3.rs
================================================
// TODO: Fix the compiler error in the function without adding any new line.
fn fill_vec(vec: Vec<i32>) -> Vec<i32> {
    vec.push(88);

    vec
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn move_semantics3() {
        let vec0 = vec![22, 44, 66];
        let vec1 = fill_vec(vec0);
        assert_eq!(vec1, [22, 44, 66, 88]);
    }
}



================================================
FILE: exercises/06_move_semantics/move_semantics4.rs
================================================
fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    // TODO: Fix the compiler errors only by reordering the lines in the test.
    // Don't add, change or remove any line.
    #[test]
    fn move_semantics4() {
        let mut x = Vec::new();
        let y = &mut x;
        let z = &mut x;
        y.push(42);
        z.push(13);
        assert_eq!(x, [42, 13]);
    }
}



================================================
FILE: exercises/06_move_semantics/move_semantics5.rs
================================================
#![allow(clippy::ptr_arg)]

// TODO: Fix the compiler errors without changing anything except adding or
// removing references (the character `&`).

// Shouldn't take ownership
fn get_char(data: String) -> char {
    data.chars().last().unwrap()
}

// Should take ownership
fn string_uppercase(mut data: &String) {
    data = data.to_uppercase();

    println!("{data}");
}

fn main() {
    let data = "Rust is great!".to_string();

    get_char(data);

    string_uppercase(&data);
}



================================================
FILE: exercises/07_structs/README.md
================================================
# Structs

Rust has three struct types: a classic C struct, a tuple struct, and a unit struct.

## Further information

- [Structures](https://doc.rust-lang.org/book/ch05-01-defining-structs.html)
- [Method Syntax](https://doc.rust-lang.org/book/ch05-03-method-syntax.html)



================================================
FILE: exercises/07_structs/structs1.rs
================================================
struct ColorRegularStruct {
    // TODO: Add the fields that the test `regular_structs` expects.
    // What types should the fields have? What are the minimum and maximum values for RGB colors?
}

struct ColorTupleStruct(/* TODO: Add the fields that the test `tuple_structs` expects */);

#[derive(Debug)]
struct UnitStruct;

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn regular_structs() {
        // TODO: Instantiate a regular struct.
        // let green =

        assert_eq!(green.red, 0);
        assert_eq!(green.green, 255);
        assert_eq!(green.blue, 0);
    }

    #[test]
    fn tuple_structs() {
        // TODO: Instantiate a tuple struct.
        // let green =

        assert_eq!(green.0, 0);
        assert_eq!(green.1, 255);
        assert_eq!(green.2, 0);
    }

    #[test]
    fn unit_structs() {
        // TODO: Instantiate a unit struct.
        // let unit_struct =
        let message = format!("{unit_struct:?}s are fun!");

        assert_eq!(message, "UnitStructs are fun!");
    }
}



================================================
FILE: exercises/07_structs/structs2.rs
================================================
#[derive(Debug)]
struct Order {
    name: String,
    year: u32,
    made_by_phone: bool,
    made_by_mobile: bool,
    made_by_email: bool,
    item_number: u32,
    count: u32,
}

fn create_order_template() -> Order {
    Order {
        name: String::from("Bob"),
        year: 2019,
        made_by_phone: false,
        made_by_mobile: false,
        made_by_email: true,
        item_number: 123,
        count: 0,
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn your_order() {
        let order_template = create_order_template();

        // TODO: Create your own order using the update syntax and template above!
        // let your_order =

        assert_eq!(your_order.name, "Hacker in Rust");
        assert_eq!(your_order.year, order_template.year);
        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);
        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);
        assert_eq!(your_order.made_by_email, order_template.made_by_email);
        assert_eq!(your_order.item_number, order_template.item_number);
        assert_eq!(your_order.count, 1);
    }
}



================================================
FILE: exercises/07_structs/structs3.rs
================================================
// Structs contain data, but can also have logic. In this exercise, we have
// defined the `Package` struct, and we want to test some logic attached to it.

#[derive(Debug)]
struct Package {
    sender_country: String,
    recipient_country: String,
    weight_in_grams: u32,
}

impl Package {
    fn new(sender_country: String, recipient_country: String, weight_in_grams: u32) -> Self {
        if weight_in_grams < 10 {
            // This isn't how you should handle errors in Rust, but we will
            // learn about error handling later.
            panic!("Can't ship a package with weight below 10 grams");
        }

        Self {
            sender_country,
            recipient_country,
            weight_in_grams,
        }
    }

    // TODO: Add the correct return type to the function signature.
    fn is_international(&self) {
        // TODO: Read the tests that use this method to find out when a package
        // is considered international.
    }

    // TODO: Add the correct return type to the function signature.
    fn get_fees(&self, cents_per_gram: u32) {
        // TODO: Calculate the package's fees.
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn fail_creating_weightless_package() {
        let sender_country = String::from("Spain");
        let recipient_country = String::from("Austria");

        Package::new(sender_country, recipient_country, 5);
    }

    #[test]
    fn create_international_package() {
        let sender_country = String::from("Spain");
        let recipient_country = String::from("Russia");

        let package = Package::new(sender_country, recipient_country, 1200);

        assert!(package.is_international());
    }

    #[test]
    fn create_local_package() {
        let sender_country = String::from("Canada");
        let recipient_country = sender_country.clone();

        let package = Package::new(sender_country, recipient_country, 1200);

        assert!(!package.is_international());
    }

    #[test]
    fn calculate_transport_fees() {
        let sender_country = String::from("Spain");
        let recipient_country = String::from("Spain");

        let cents_per_gram = 3;

        let package = Package::new(sender_country, recipient_country, 1500);

        assert_eq!(package.get_fees(cents_per_gram), 4500);
        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);
    }
}



================================================
FILE: exercises/08_enums/README.md
================================================
# Enums

Rust allows you to define types called "enums" which enumerate possible values.
Enums are a feature in many languages, but their capabilities differ in each language. Rust's enums are most similar to algebraic data types in functional languages, such as F#, OCaml, and Haskell.
Useful in combination with enums is Rust's "pattern matching" facility, which makes it easy to run different code for different values of an enumeration.

## Further information

- [Enums](https://doc.rust-lang.org/book/ch06-00-enums.html)
- [Pattern syntax](https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html)



================================================
FILE: exercises/08_enums/enums1.rs
================================================
#[derive(Debug)]
enum Message {
    // TODO: Define a few types of messages as used below.
}

fn main() {
    println!("{:?}", Message::Resize);
    println!("{:?}", Message::Move);
    println!("{:?}", Message::Echo);
    println!("{:?}", Message::ChangeColor);
    println!("{:?}", Message::Quit);
}



================================================
FILE: exercises/08_enums/enums2.rs
================================================
#[derive(Debug)]
struct Point {
    x: u64,
    y: u64,
}

#[derive(Debug)]
enum Message {
    // TODO: Define the different variants used below.
}

impl Message {
    fn call(&self) {
        println!("{self:?}");
    }
}

fn main() {
    let messages = [
        Message::Resize {
            width: 10,
            height: 30,
        },
        Message::Move(Point { x: 10, y: 15 }),
        Message::Echo(String::from("hello world")),
        Message::ChangeColor(200, 255, 255),
        Message::Quit,
    ];

    for message in &messages {
        message.call();
    }
}



================================================
FILE: exercises/08_enums/enums3.rs
================================================
struct Point {
    x: u64,
    y: u64,
}

enum Message {
    Resize { width: u64, height: u64 },
    Move(Point),
    Echo(String),
    ChangeColor(u8, u8, u8),
    Quit,
}

struct State {
    width: u64,
    height: u64,
    position: Point,
    message: String,
    // RGB color composed of red, green and blue.
    color: (u8, u8, u8),
    quit: bool,
}

impl State {
    fn resize(&mut self, width: u64, height: u64) {
        self.width = width;
        self.height = height;
    }

    fn move_position(&mut self, point: Point) {
        self.position = point;
    }

    fn echo(&mut self, s: String) {
        self.message = s;
    }

    fn change_color(&mut self, red: u8, green: u8, blue: u8) {
        self.color = (red, green, blue);
    }

    fn quit(&mut self) {
        self.quit = true;
    }

    fn process(&mut self, message: Message) {
        // TODO: Create a match expression to process the different message
        // variants using the methods defined above.
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_match_message_call() {
        let mut state = State {
            width: 0,
            height: 0,
            position: Point { x: 0, y: 0 },
            message: String::from("hello world"),
            color: (0, 0, 0),
            quit: false,
        };

        state.process(Message::Resize {
            width: 10,
            height: 30,
        });
        state.process(Message::Move(Point { x: 10, y: 15 }));
        state.process(Message::Echo(String::from("Hello world!")));
        state.process(Message::ChangeColor(255, 0, 255));
        state.process(Message::Quit);

        assert_eq!(state.width, 10);
        assert_eq!(state.height, 30);
        assert_eq!(state.position.x, 10);
        assert_eq!(state.position.y, 15);
        assert_eq!(state.message, "Hello world!");
        assert_eq!(state.color, (255, 0, 255));
        assert!(state.quit);
    }
}



================================================
FILE: exercises/09_strings/README.md
================================================
# Strings

Rust has two string types, a string slice (`&str`) and an owned string (`String`).
We're not going to dictate when you should use which one, but we'll show you how
to identify and create them, as well as use them.

## Further information

- [Strings](https://doc.rust-lang.org/book/ch08-02-strings.html)



================================================
FILE: exercises/09_strings/strings1.rs
================================================
// TODO: Fix the compiler error without changing the function signature.
fn current_favorite_color() -> String {
    "blue"
}

fn main() {
    let answer = current_favorite_color();
    println!("My current favorite color is {answer}");
}



================================================
FILE: exercises/09_strings/strings2.rs
================================================
// TODO: Fix the compiler error in the `main` function without changing this function.
fn is_a_color_word(attempt: &str) -> bool {
    attempt == "green" || attempt == "blue" || attempt == "red"
}

fn main() {
    let word = String::from("green"); // Don't change this line.

    if is_a_color_word(word) {
        println!("That is a color word I know!");
    } else {
        println!("That is not a color word I know.");
    }
}



================================================
FILE: exercises/09_strings/strings3.rs
================================================
fn trim_me(input: &str) -> &str {
    // TODO: Remove whitespace from both ends of a string.
}

fn compose_me(input: &str) -> String {
    // TODO: Add " world!" to the string! There are multiple ways to do this.
}

fn replace_me(input: &str) -> String {
    // TODO: Replace "cars" in the string with "balloons".
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn trim_a_string() {
        assert_eq!(trim_me("Hello!     "), "Hello!");
        assert_eq!(trim_me("  What's up!"), "What's up!");
        assert_eq!(trim_me("   Hola!  "), "Hola!");
        assert_eq!(trim_me("Hi!"), "Hi!");
    }

    #[test]
    fn compose_a_string() {
        assert_eq!(compose_me("Hello"), "Hello world!");
        assert_eq!(compose_me("Goodbye"), "Goodbye world!");
    }

    #[test]
    fn replace_a_string() {
        assert_eq!(
            replace_me("I think cars are cool"),
            "I think balloons are cool",
        );
        assert_eq!(
            replace_me("I love to look at cars"),
            "I love to look at balloons",
        );
    }
}



================================================
FILE: exercises/09_strings/strings4.rs
================================================
// Calls of this function should be replaced with calls of `string_slice` or `string`.
fn placeholder() {}

fn string_slice(arg: &str) {
    println!("{arg}");
}

fn string(arg: String) {
    println!("{arg}");
}

// TODO: Here are a bunch of values - some are `String`, some are `&str`.
// Your task is to replace `placeholder(…)` with either `string_slice(…)`
// or `string(…)` depending on what you think each value is.
fn main() {
    placeholder("blue");

    placeholder("red".to_string());

    placeholder(String::from("hi"));

    placeholder("rust is fun!".to_owned());

    placeholder("nice weather".into());

    placeholder(format!("Interpolation {}", "Station"));

    // WARNING: This is byte indexing, not character indexing.
    // Character indexing can be done using `s.chars().nth(INDEX)`.
    placeholder(&String::from("abc")[0..1]);

    placeholder("  hello there ".trim());

    placeholder("Happy Monday!".replace("Mon", "Tues"));

    placeholder("mY sHiFt KeY iS sTiCkY".to_lowercase());
}



================================================
FILE: exercises/10_modules/README.md
================================================
# Modules

In this section we'll give you an introduction to Rust's module system.

## Further information

- [The Module System](https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html)



================================================
FILE: exercises/10_modules/modules1.rs
================================================
// TODO: Fix the compiler error about calling a private function.
mod sausage_factory {
    // Don't let anybody outside of this module see this!
    fn get_secret_recipe() -> String {
        String::from("Ginger")
    }

    fn make_sausage() {
        get_secret_recipe();
        println!("sausage!");
    }
}

fn main() {
    sausage_factory::make_sausage();
}



================================================
FILE: exercises/10_modules/modules2.rs
================================================
// You can bring module paths into scopes and provide new names for them with
// the `use` and `as` keywords.

mod delicious_snacks {
    // TODO: Add the following two `use` statements after fixing them.
    // use self::fruits::PEAR as ???;
    // use self::veggies::CUCUMBER as ???;

    mod fruits {
        pub const PEAR: &str = "Pear";
        pub const APPLE: &str = "Apple";
    }

    mod veggies {
        pub const CUCUMBER: &str = "Cucumber";
        pub const CARROT: &str = "Carrot";
    }
}

fn main() {
    println!(
        "favorite snacks: {} and {}",
        delicious_snacks::fruit,
        delicious_snacks::veggie,
    );
}



================================================
FILE: exercises/10_modules/modules3.rs
================================================
// You can use the `use` keyword to bring module paths from modules from
// anywhere and especially from the standard library into your scope.

// TODO: Bring `SystemTime` and `UNIX_EPOCH` from the `std::time` module into
// your scope. Bonus style points if you can do it with one line!
// use ???;

fn main() {
    match SystemTime::now().duration_since(UNIX_EPOCH) {
        Ok(n) => println!("1970-01-01 00:00:00 UTC was {} seconds ago!", n.as_secs()),
        Err(_) => panic!("SystemTime before UNIX EPOCH!"),
    }
}



================================================
FILE: exercises/11_hashmaps/README.md
================================================
# Hashmaps

A *hash map* allows you to associate a value with a particular key.
You may also know this by the names [*unordered map* in C++](https://en.cppreference.com/w/cpp/container/unordered_map),
[*dictionary* in Python](https://docs.python.org/3/tutorial/datastructures.html#dictionaries) or an *associative array* in other languages.

This is the other data structure that we've been talking about before, when
talking about Vecs.

## Further information

- [Storing Keys with Associated Values in Hash Maps](https://doc.rust-lang.org/book/ch08-03-hash-maps.html)



================================================
FILE: exercises/11_hashmaps/hashmaps1.rs
================================================
// A basket of fruits in the form of a hash map needs to be defined. The key
// represents the name of the fruit and the value represents how many of that
// particular fruit is in the basket. You have to put at least 3 different
// types of fruits (e.g. apple, banana, mango) in the basket and the total count
// of all the fruits should be at least 5.

use std::collections::HashMap;

fn fruit_basket() -> HashMap<String, u32> {
    // TODO: Declare the hash map.
    // let mut basket =

    // Two bananas are already given for you :)
    basket.insert(String::from("banana"), 2);

    // TODO: Put more fruits in your basket.

    basket
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn at_least_three_types_of_fruits() {
        let basket = fruit_basket();
        assert!(basket.len() >= 3);
    }

    #[test]
    fn at_least_five_fruits() {
        let basket = fruit_basket();
        assert!(basket.values().sum::<u32>() >= 5);
    }
}



================================================
FILE: exercises/11_hashmaps/hashmaps2.rs
================================================
// We're collecting different fruits to bake a delicious fruit cake. For this,
// we have a basket, which we'll represent in the form of a hash map. The key
// represents the name of each fruit we collect and the value represents how
// many of that particular fruit we have collected. Three types of fruits -
// Apple (4), Mango (2) and Lychee (5) are already in the basket hash map. You
// must add fruit to the basket so that there is at least one of each kind and
// more than 11 in total - we have a lot of mouths to feed. You are not allowed
// to insert any more of the fruits that are already in the basket (Apple,
// Mango, and Lychee).

use std::collections::HashMap;

#[derive(Hash, PartialEq, Eq, Debug)]
enum Fruit {
    Apple,
    Banana,
    Mango,
    Lychee,
    Pineapple,
}

fn fruit_basket(basket: &mut HashMap<Fruit, u32>) {
    let fruit_kinds = [
        Fruit::Apple,
        Fruit::Banana,
        Fruit::Mango,
        Fruit::Lychee,
        Fruit::Pineapple,
    ];

    for fruit in fruit_kinds {
        // TODO: Insert new fruits if they are not already present in the
        // basket. Note that you are not allowed to put any type of fruit that's
        // already present!
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    // Don't modify this function!
    fn get_fruit_basket() -> HashMap<Fruit, u32> {
        let content = [(Fruit::Apple, 4), (Fruit::Mango, 2), (Fruit::Lychee, 5)];
        HashMap::from_iter(content)
    }

    #[test]
    fn test_given_fruits_are_not_modified() {
        let mut basket = get_fruit_basket();
        fruit_basket(&mut basket);
        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);
        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);
        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);
    }

    #[test]
    fn at_least_five_types_of_fruits() {
        let mut basket = get_fruit_basket();
        fruit_basket(&mut basket);
        let count_fruit_kinds = basket.len();
        assert!(count_fruit_kinds >= 5);
    }

    #[test]
    fn greater_than_eleven_fruits() {
        let mut basket = get_fruit_basket();
        fruit_basket(&mut basket);
        let count = basket.values().sum::<u32>();
        assert!(count > 11);
    }

    #[test]
    fn all_fruit_types_in_basket() {
        let fruit_kinds = [
            Fruit::Apple,
            Fruit::Banana,
            Fruit::Mango,
            Fruit::Lychee,
            Fruit::Pineapple,
        ];

        let mut basket = get_fruit_basket();
        fruit_basket(&mut basket);

        for fruit_kind in fruit_kinds {
            let Some(amount) = basket.get(&fruit_kind) else {
                panic!("Fruit kind {fruit_kind:?} was not found in basket");
            };
            assert!(*amount > 0);
        }
    }
}



================================================
FILE: exercises/11_hashmaps/hashmaps3.rs
================================================
// A list of scores (one per line) of a soccer match is given. Each line is of
// the form "<team_1_name>,<team_2_name>,<team_1_goals>,<team_2_goals>"
// Example: "England,France,4,2" (England scored 4 goals, France 2).
//
// You have to build a scores table containing the name of the team, the total
// number of goals the team scored, and the total number of goals the team
// conceded.

use std::collections::HashMap;

// A structure to store the goal details of a team.
#[derive(Default)]
struct TeamScores {
    goals_scored: u8,
    goals_conceded: u8,
}

fn build_scores_table(results: &str) -> HashMap<&str, TeamScores> {
    // The name of the team is the key and its associated struct is the value.
    let mut scores = HashMap::<&str, TeamScores>::new();

    for line in results.lines() {
        let mut split_iterator = line.split(',');
        // NOTE: We use `unwrap` because we didn't deal with error handling yet.
        let team_1_name = split_iterator.next().unwrap();
        let team_2_name = split_iterator.next().unwrap();
        let team_1_score: u8 = split_iterator.next().unwrap().parse().unwrap();
        let team_2_score: u8 = split_iterator.next().unwrap().parse().unwrap();

        // TODO: Populate the scores table with the extracted details.
        // Keep in mind that goals scored by team 1 will be the number of goals
        // conceded by team 2. Similarly, goals scored by team 2 will be the
        // number of goals conceded by team 1.
    }

    scores
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    const RESULTS: &str = "England,France,4,2
France,Italy,3,1
Poland,Spain,2,0
Germany,England,2,1
England,Spain,1,0";

    #[test]
    fn build_scores() {
        let scores = build_scores_table(RESULTS);

        assert!(["England", "France", "Germany", "Italy", "Poland", "Spain"]
            .into_iter()
            .all(|team_name| scores.contains_key(team_name)));
    }

    #[test]
    fn validate_team_score_1() {
        let scores = build_scores_table(RESULTS);
        let team = scores.get("England").unwrap();
        assert_eq!(team.goals_scored, 6);
        assert_eq!(team.goals_conceded, 4);
    }

    #[test]
    fn validate_team_score_2() {
        let scores = build_scores_table(RESULTS);
        let team = scores.get("Spain").unwrap();
        assert_eq!(team.goals_scored, 0);
        assert_eq!(team.goals_conceded, 3);
    }
}



================================================
FILE: exercises/12_options/README.md
================================================
# Options

Type Option represents an optional value: every Option is either Some and contains a value, or None, and does not.
Option types are very common in Rust code, as they have a number of uses:

- Initial values
- Return values for functions that are not defined over their entire input range (partial functions)
- Return value for otherwise reporting simple errors, where None is returned on error
- Optional struct fields
- Struct fields that can be loaned or "taken"
- Optional function arguments
- Nullable pointers
- Swapping things out of difficult situations

## Further Information

- [Option Enum Format](https://doc.rust-lang.org/book/ch10-01-syntax.html#in-enum-definitions)
- [Option Module Documentation](https://doc.rust-lang.org/std/option/)
- [Option Enum Documentation](https://doc.rust-lang.org/std/option/enum.Option.html)
- [if let](https://doc.rust-lang.org/rust-by-example/flow_control/if_let.html)
- [while let](https://doc.rust-lang.org/rust-by-example/flow_control/while_let.html)



================================================
FILE: exercises/12_options/options1.rs
================================================
// This function returns how much ice cream there is left in the fridge.
// If it's before 22:00 (24-hour system), then 5 scoops are left. At 22:00,
// someone eats it all, so no ice cream is left (value 0). Return `None` if
// `hour_of_day` is higher than 23.
fn maybe_ice_cream(hour_of_day: u16) -> Option<u16> {
    // TODO: Complete the function body.
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn raw_value() {
        // TODO: Fix this test. How do you get the value contained in the
        // Option?
        let ice_creams = maybe_ice_cream(12);

        assert_eq!(ice_creams, 5); // Don't change this line.
    }

    #[test]
    fn check_ice_cream() {
        assert_eq!(maybe_ice_cream(0), Some(5));
        assert_eq!(maybe_ice_cream(9), Some(5));
        assert_eq!(maybe_ice_cream(18), Some(5));
        assert_eq!(maybe_ice_cream(22), Some(0));
        assert_eq!(maybe_ice_cream(23), Some(0));
        assert_eq!(maybe_ice_cream(24), None);
        assert_eq!(maybe_ice_cream(25), None);
    }
}



================================================
FILE: exercises/12_options/options2.rs
================================================
fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    #[test]
    fn simple_option() {
        let target = "rustlings";
        let optional_target = Some(target);

        // TODO: Make this an if-let statement whose value is `Some`.
        word = optional_target {
            assert_eq!(word, target);
        }
    }

    #[test]
    fn layered_option() {
        let range = 10;
        let mut optional_integers: Vec<Option<i8>> = vec![None];

        for i in 1..=range {
            optional_integers.push(Some(i));
        }

        let mut cursor = range;

        // TODO: Make this a while-let statement. Remember that `Vec::pop()`
        // adds another layer of `Option`. You can do nested pattern matching
        // in if-let and while-let statements.
        integer = optional_integers.pop() {
            assert_eq!(integer, cursor);
            cursor -= 1;
        }

        assert_eq!(cursor, 0);
    }
}



================================================
FILE: exercises/12_options/options3.rs
================================================
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let optional_point = Some(Point { x: 100, y: 200 });

    // TODO: Fix the compiler error by adding something to this match statement.
    match optional_point {
        Some(p) => println!("Coordinates are {},{}", p.x, p.y),
        _ => panic!("No match!"),
    }

    println!("{optional_point:?}"); // Don't change this line.
}



================================================
FILE: exercises/13_error_handling/README.md
================================================
# Error handling

Most errors aren't serious enough to require the program to stop entirely.
Sometimes, when a function fails, it's for a reason that you can easily interpret and respond to.
For example, if you try to open a file and that operation fails because the file doesn't exist, you might want to create the file instead of terminating the process.

## Further information

- [Error Handling](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html)
- [Generics](https://doc.rust-lang.org/book/ch10-01-syntax.html)
- [Result](https://doc.rust-lang.org/rust-by-example/error/result.html)
- [Boxing errors](https://doc.rust-lang.org/rust-by-example/error/multiple_error_types/boxing_errors.html)



================================================
FILE: exercises/13_error_handling/errors1.rs
================================================
// TODO: This function refuses to generate text to be printed on a nametag if
// you pass it an empty string. It'd be nicer if it explained what the problem
// was instead of just returning `None`. Thankfully, Rust has a similar
// construct to `Option` that can be used to express error conditions. Change
// the function signature and body to return `Result<String, String>` instead
// of `Option<String>`.
fn generate_nametag_text(name: String) -> Option<String> {
    if name.is_empty() {
        // Empty names aren't allowed
        None
    } else {
        Some(format!("Hi! My name is {name}"))
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generates_nametag_text_for_a_nonempty_name() {
        assert_eq!(
            generate_nametag_text("Beyoncé".to_string()).as_deref(),
            Ok("Hi! My name is Beyoncé"),
        );
    }

    #[test]
    fn explains_why_generating_nametag_text_fails() {
        assert_eq!(
            generate_nametag_text(String::new())
                .as_ref()
                .map_err(|e| e.as_str()),
            Err("Empty names aren't allowed"),
        );
    }
}



================================================
FILE: exercises/13_error_handling/errors2.rs
================================================
// Say we're writing a game where you can buy items with tokens. All items cost
// 5 tokens, and whenever you purchase items there is a processing fee of 1
// token. A player of the game will type in how many items they want to buy, and
// the `total_cost` function will calculate the total cost of the items. Since
// the player typed in the quantity, we get it as a string. They might have
// typed anything, not just numbers!
//
// Right now, this function isn't handling the error case at all. What we want
// to do is: If we call the `total_cost` function on a string that is not a
// number, that function will return a `ParseIntError`. In that case, we want to
// immediately return that error from our function and not try to multiply and
// add.
//
// There are at least two ways to implement this that are both correct. But one
// is a lot shorter!

use std::num::ParseIntError;

fn total_cost(item_quantity: &str) -> Result<i32, ParseIntError> {
    let processing_fee = 1;
    let cost_per_item = 5;

    // TODO: Handle the error case as described above.
    let qty = item_quantity.parse::<i32>();

    Ok(qty * cost_per_item + processing_fee)
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::num::IntErrorKind;

    #[test]
    fn item_quantity_is_a_valid_number() {
        assert_eq!(total_cost("34"), Ok(171));
    }

    #[test]
    fn item_quantity_is_an_invalid_number() {
        assert_eq!(
            total_cost("beep boop").unwrap_err().kind(),
            &IntErrorKind::InvalidDigit,
        );
    }
}



================================================
FILE: exercises/13_error_handling/errors3.rs
================================================
// This is a program that is trying to use a completed version of the
// `total_cost` function from the previous exercise. It's not working though!
// Why not? What should we do to fix it?

use std::num::ParseIntError;

// Don't change this function.
fn total_cost(item_quantity: &str) -> Result<i32, ParseIntError> {
    let processing_fee = 1;
    let cost_per_item = 5;
    let qty = item_quantity.parse::<i32>()?;

    Ok(qty * cost_per_item + processing_fee)
}

// TODO: Fix the compiler error by changing the signature and body of the
// `main` function.
fn main() {
    let mut tokens = 100;
    let pretend_user_input = "8";

    // Don't change this line.
    let cost = total_cost(pretend_user_input)?;

    if cost > tokens {
        println!("You can't afford that many!");
    } else {
        tokens -= cost;
        println!("You now have {tokens} tokens.");
    }
}



================================================
FILE: exercises/13_error_handling/errors4.rs
================================================
#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

impl PositiveNonzeroInteger {
    fn new(value: i64) -> Result<Self, CreationError> {
        // TODO: This function shouldn't always return an `Ok`.
        // Read the tests below to clarify what should be returned.
        Ok(Self(value as u64))
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_creation() {
        assert_eq!(
            PositiveNonzeroInteger::new(10),
            Ok(PositiveNonzeroInteger(10)),
        );
        assert_eq!(
            PositiveNonzeroInteger::new(-10),
            Err(CreationError::Negative),
        );
        assert_eq!(PositiveNonzeroInteger::new(0), Err(CreationError::Zero));
    }
}



================================================
FILE: exercises/13_error_handling/errors5.rs
================================================
// This exercise is an altered version of the `errors4` exercise. It uses some
// concepts that we won't get to until later in the course, like `Box` and the
// `From` trait. It's not important to understand them in detail right now, but
// you can read ahead if you like. For now, think of the `Box<dyn ???>` type as
// an "I want anything that does ???" type.
//
// In short, this particular use case for boxes is for when you want to own a
// value and you care only that it is a type which implements a particular
// trait. To do so, the `Box` is declared as of type `Box<dyn Trait>` where
// `Trait` is the trait the compiler looks for on any value used in that
// context. For this exercise, that context is the potential errors which
// can be returned in a `Result`.

use std::error::Error;
use std::fmt;

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

// This is required so that `CreationError` can implement `Error`.
impl fmt::Display for CreationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let description = match *self {
            CreationError::Negative => "number is negative",
            CreationError::Zero => "number is zero",
        };
        f.write_str(description)
    }
}

impl Error for CreationError {}

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

impl PositiveNonzeroInteger {
    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {
        match value {
            x if x < 0 => Err(CreationError::Negative),
            0 => Err(CreationError::Zero),
            x => Ok(PositiveNonzeroInteger(x as u64)),
        }
    }
}

// TODO: Add the correct return type `Result<(), Box<dyn ???>>`. What can we
// use to describe both errors? Is there a trait which both errors implement?
fn main() {
    let pretend_user_input = "42";
    let x: i64 = pretend_user_input.parse()?;
    println!("output={:?}", PositiveNonzeroInteger::new(x)?);
    Ok(())
}



================================================
FILE: exercises/13_error_handling/errors6.rs
================================================
// Using catch-all error types like `Box<dyn Error>` isn't recommended for
// library code where callers might want to make decisions based on the error
// content instead of printing it out or propagating it further. Here, we define
// a custom error type to make it possible for callers to decide what to do next
// when our function returns an error.

use std::num::ParseIntError;

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

// A custom error type that we will be using in `PositiveNonzeroInteger::parse`.
#[derive(PartialEq, Debug)]
enum ParsePosNonzeroError {
    Creation(CreationError),
    ParseInt(ParseIntError),
}

impl ParsePosNonzeroError {
    fn from_creation(err: CreationError) -> Self {
        Self::Creation(err)
    }

    // TODO: Add another error conversion function here.
    // fn from_parse_int(???) -> Self { ??? }
}

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

impl PositiveNonzeroInteger {
    fn new(value: i64) -> Result<Self, CreationError> {
        match value {
            x if x < 0 => Err(CreationError::Negative),
            0 => Err(CreationError::Zero),
            x => Ok(Self(x as u64)),
        }
    }

    fn parse(s: &str) -> Result<Self, ParsePosNonzeroError> {
        // TODO: change this to return an appropriate error instead of panicking
        // when `parse()` returns an error.
        let x: i64 = s.parse().unwrap();
        Self::new(x).map_err(ParsePosNonzeroError::from_creation)
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_parse_error() {
        assert!(matches!(
            PositiveNonzeroInteger::parse("not a number"),
            Err(ParsePosNonzeroError::ParseInt(_)),
        ));
    }

    #[test]
    fn test_negative() {
        assert_eq!(
            PositiveNonzeroInteger::parse("-555"),
            Err(ParsePosNonzeroError::Creation(CreationError::Negative)),
        );
    }

    #[test]
    fn test_zero() {
        assert_eq!(
            PositiveNonzeroInteger::parse("0"),
            Err(ParsePosNonzeroError::Creation(CreationError::Zero)),
        );
    }

    #[test]
    fn test_positive() {
        let x = PositiveNonzeroInteger::new(42).unwrap();
        assert_eq!(x.0, 42);
        assert_eq!(PositiveNonzeroInteger::parse("42"), Ok(x));
    }
}



================================================
FILE: exercises/14_generics/README.md
================================================
# Generics

Generics is the topic of generalizing types and functionalities to broader cases.
This is extremely useful for reducing code duplication in many ways, but can call for some rather involved syntax.
Namely, being generic requires taking great care to specify over which types a generic type is actually considered valid.
The simplest and most common use of generics is for type parameters.

## Further information

- [Generic Data Types](https://doc.rust-lang.org/book/ch10-01-syntax.html)
- [Bounds](https://doc.rust-lang.org/rust-by-example/generics/bounds.html)



================================================
FILE: exercises/14_generics/generics1.rs
================================================
// `Vec<T>` is generic over the type `T`. In most cases, the compiler is able to
// infer `T`, for example after pushing a value with a concrete type to the vector.
// But in this exercise, the compiler needs some help through a type annotation.

fn main() {
    // TODO: Fix the compiler error by annotating the type of the vector
    // `Vec<T>`. Choose `T` as some integer type that can be created from
    // `u8` and `i8`.
    let mut numbers = Vec::new();

    // Don't change the lines below.
    let n1: u8 = 42;
    numbers.push(n1.into());
    let n2: i8 = -1;
    numbers.push(n2.into());

    println!("{numbers:?}");
}



================================================
FILE: exercises/14_generics/generics2.rs
================================================
// This powerful wrapper provides the ability to store a positive integer value.
// TODO: Rewrite it using a generic so that it supports wrapping ANY type.
struct Wrapper {
    value: u32,
}

// TODO: Adapt the struct's implementation to be generic over the wrapped value.
impl Wrapper {
    fn new(value: u32) -> Self {
        Wrapper { value }
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn store_u32_in_wrapper() {
        assert_eq!(Wrapper::new(42).value, 42);
    }

    #[test]
    fn store_str_in_wrapper() {
        assert_eq!(Wrapper::new("Foo").value, "Foo");
    }
}



================================================
FILE: exercises/15_traits/README.md
================================================
# Traits

A trait is a collection of methods.

Data types can implement traits. To do so, the methods making up the trait are defined for the data type. For example, the `String` data type implements the `From<&str>` trait. This allows a user to write `String::from("hello")`.

In this way, traits are somewhat similar to Java interfaces and C++ abstract classes.

Some additional common Rust traits include:

- `Clone` (the `clone` method)
- `Display` (which allows formatted display via `{}`)
- `Debug` (which allows formatted display via `{:?}`)

Because traits indicate shared behavior between data types, they are useful when writing generics.

## Further information

- [Traits](https://doc.rust-lang.org/book/ch10-02-traits.html)



================================================
FILE: exercises/15_traits/traits1.rs
================================================
// The trait `AppendBar` has only one function which appends "Bar" to any object
// implementing this trait.
trait AppendBar {
    fn append_bar(self) -> Self;
}

impl AppendBar for String {
    // TODO: Implement `AppendBar` for the type `String`.
}

fn main() {
    let s = String::from("Foo");
    let s = s.append_bar();
    println!("s: {s}");
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_foo_bar() {
        assert_eq!(String::from("Foo").append_bar(), "FooBar");
    }

    #[test]
    fn is_bar_bar() {
        assert_eq!(String::from("").append_bar().append_bar(), "BarBar");
    }
}



================================================
FILE: exercises/15_traits/traits2.rs
================================================
trait AppendBar {
    fn append_bar(self) -> Self;
}

// TODO: Implement the trait `AppendBar` for a vector of strings.
// `append_bar` should push the string "Bar" into the vector.

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_vec_pop_eq_bar() {
        let mut foo = vec![String::from("Foo")].append_bar();
        assert_eq!(foo.pop().unwrap(), "Bar");
        assert_eq!(foo.pop().unwrap(), "Foo");
    }
}



================================================
FILE: exercises/15_traits/traits3.rs
================================================
trait Licensed {
    // TODO: Add a default implementation for `licensing_info` so that
    // implementors like the two structs below can share that default behavior
    // without repeating the function.
    // The default license information should be the string "Default license".
    fn licensing_info(&self) -> String;
}

struct SomeSoftware {
    version_number: i32,
}

struct OtherSoftware {
    version_number: String,
}

impl Licensed for SomeSoftware {} // Don't edit this line.
impl Licensed for OtherSoftware {} // Don't edit this line.

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_licensing_info_the_same() {
        let licensing_info = "Default license";
        let some_software = SomeSoftware { version_number: 1 };
        let other_software = OtherSoftware {
            version_number: "v2.0.0".to_string(),
        };
        assert_eq!(some_software.licensing_info(), licensing_info);
        assert_eq!(other_software.licensing_info(), licensing_info);
    }
}



================================================
FILE: exercises/15_traits/traits4.rs
================================================
trait Licensed {
    fn licensing_info(&self) -> String {
        "Default license".to_string()
    }
}

struct SomeSoftware;
struct OtherSoftware;

impl Licensed for SomeSoftware {}
impl Licensed for OtherSoftware {}

// TODO: Fix the compiler error by only changing the signature of this function.
fn compare_license_types(software1: ???, software2: ???) -> bool {
    software1.licensing_info() == software2.licensing_info()
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn compare_license_information() {
        assert!(compare_license_types(SomeSoftware, OtherSoftware));
    }

    #[test]
    fn compare_license_information_backwards() {
        assert!(compare_license_types(OtherSoftware, SomeSoftware));
    }
}



================================================
FILE: exercises/15_traits/traits5.rs
================================================
trait SomeTrait {
    fn some_function(&self) -> bool {
        true
    }
}

trait OtherTrait {
    fn other_function(&self) -> bool {
        true
    }
}

struct SomeStruct;
impl SomeTrait for SomeStruct {}
impl OtherTrait for SomeStruct {}

struct OtherStruct;
impl SomeTrait for OtherStruct {}
impl OtherTrait for OtherStruct {}

// TODO: Fix the compiler error by only changing the signature of this function.
fn some_func(item: ???) -> bool {
    item.some_function() && item.other_function()
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_some_func() {
        assert!(some_func(SomeStruct));
        assert!(some_func(OtherStruct));
    }
}



================================================
FILE: exercises/16_lifetimes/README.md
================================================
# Lifetimes

Lifetimes tell the compiler how to check whether references live long
enough to be valid in any given situation. For example lifetimes say
"make sure parameter 'a' lives as long as parameter 'b' so that the return
value is valid".

They are only necessary on borrows, i.e. references,
since copied parameters or moves are owned in their scope and cannot
be referenced outside. Lifetimes mean that calling code of e.g. functions
can be checked to make sure their arguments are valid. Lifetimes are
restrictive of their callers.

If you'd like to learn more about lifetime annotations, the
[lifetimekata](https://tfpk.github.io/lifetimekata/) project
has a similar style of exercises to Rustlings, but is all about
learning to write lifetime annotations.

## Further information

- [Lifetimes (in Rust By Example)](https://doc.rust-lang.org/stable/rust-by-example/scope/lifetime.html)
- [Validating References with Lifetimes](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html)



================================================
FILE: exercises/16_lifetimes/lifetimes1.rs
================================================
// The Rust compiler needs to know how to check whether supplied references are
// valid, so that it can let the programmer know if a reference is at risk of
// going out of scope before it is used. Remember, references are borrows and do
// not own their own data. What if their owner goes out of scope?

// TODO: Fix the compiler error by updating the function signature.
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_longest() {
        assert_eq!(longest("abcd", "123"), "abcd");
        assert_eq!(longest("abc", "1234"), "1234");
    }
}



================================================
FILE: exercises/16_lifetimes/lifetimes2.rs
================================================
// Don't change this function.
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    // TODO: Fix the compiler error by moving one line.

    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(&string1, &string2);
    }
    println!("The longest string is '{result}'");
}



================================================
FILE: exercises/16_lifetimes/lifetimes3.rs
================================================
// Lifetimes are also needed when structs hold references.

// TODO: Fix the compiler errors about the struct.
struct Book {
    author: &str,
    title: &str,
}

fn main() {
    let book = Book {
        author: "George Orwell",
        title: "1984",
    };

    println!("{} by {}", book.title, book.author);
}



================================================
FILE: exercises/17_tests/README.md
================================================
# Tests

Going out of order from the book to cover tests -- many of the following exercises will ask you to make tests pass!

## Further information

- [Writing Tests](https://doc.rust-lang.org/book/ch11-01-writing-tests.html)



================================================
FILE: exercises/17_tests/tests1.rs
================================================
// Tests are important to ensure that your code does what you think it should
// do.

fn is_even(n: i64) -> bool {
    n % 2 == 0
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    // TODO: Import `is_even`. You can use a wildcard to import everything in
    // the outer module.

    #[test]
    fn you_can_assert() {
        // TODO: Test the function `is_even` with some values.
        assert!();
        assert!();
    }
}



================================================
FILE: exercises/17_tests/tests2.rs
================================================
// Calculates the power of 2 using a bit shift.
// `1 << n` is equivalent to "2 to the power of n".
fn power_of_2(n: u8) -> u64 {
    1 << n
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn you_can_assert_eq() {
        // TODO: Test the function `power_of_2` with some values.
        assert_eq!();
        assert_eq!();
        assert_eq!();
        assert_eq!();
    }
}



================================================
FILE: exercises/17_tests/tests3.rs
================================================
struct Rectangle {
    width: i32,
    height: i32,
}

impl Rectangle {
    // Don't change this function.
    fn new(width: i32, height: i32) -> Self {
        if width <= 0 || height <= 0 {
            // Returning a `Result` would be better here. But we want to learn
            // how to test functions that can panic.
            panic!("Rectangle width and height must be positive");
        }

        Rectangle { width, height }
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn correct_width_and_height() {
        // TODO: This test should check if the rectangle has the size that we
        // pass to its constructor.
        let rect = Rectangle::new(10, 20);
        assert_eq!(todo!(), 10); // Check width
        assert_eq!(todo!(), 20); // Check height
    }

    // TODO: This test should check if the program panics when we try to create
    // a rectangle with negative width.
    #[test]
    fn negative_width() {
        let _rect = Rectangle::new(-10, 10);
    }

    // TODO: This test should check if the program panics when we try to create
    // a rectangle with negative height.
    #[test]
    fn negative_height() {
        let _rect = Rectangle::new(10, -10);
    }
}



================================================
FILE: exercises/18_iterators/README.md
================================================
# Iterators

This section will teach you about Iterators.

## Further information

- [Iterator](https://doc.rust-lang.org/book/ch13-02-iterators.html)
- [Iterator documentation](https://doc.rust-lang.org/stable/std/iter/)



================================================
FILE: exercises/18_iterators/iterators1.rs
================================================
// When performing operations on elements within a collection, iterators are
// essential. This module helps you get familiar with the structure of using an
// iterator and how to go through elements within an iterable collection.

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    #[test]
    fn iterators() {
        let my_fav_fruits = ["banana", "custard apple", "avocado", "peach", "raspberry"];

        // TODO: Create an iterator over the array.
        let mut fav_fruits_iterator = todo!();

        assert_eq!(fav_fruits_iterator.next(), Some(&"banana"));
        assert_eq!(fav_fruits_iterator.next(), todo!()); // TODO: Replace `todo!()`
        assert_eq!(fav_fruits_iterator.next(), Some(&"avocado"));
        assert_eq!(fav_fruits_iterator.next(), todo!()); // TODO: Replace `todo!()`
        assert_eq!(fav_fruits_iterator.next(), Some(&"raspberry"));
        assert_eq!(fav_fruits_iterator.next(), todo!()); // TODO: Replace `todo!()`
    }
}



================================================
FILE: exercises/18_iterators/iterators2.rs
================================================
// In this exercise, you'll learn some of the unique advantages that iterators
// can offer.

// TODO: Complete the `capitalize_first` function.
// "hello" -> "Hello"
fn capitalize_first(input: &str) -> String {
    let mut chars = input.chars();
    match chars.next() {
        None => String::new(),
        Some(first) => todo!(),
    }
}

// TODO: Apply the `capitalize_first` function to a slice of string slices.
// Return a vector of strings.
// ["hello", "world"] -> ["Hello", "World"]
fn capitalize_words_vector(words: &[&str]) -> Vec<String> {
    // ???
}

// TODO: Apply the `capitalize_first` function again to a slice of string
// slices. Return a single string.
// ["hello", " ", "world"] -> "Hello World"
fn capitalize_words_string(words: &[&str]) -> String {
    // ???
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_success() {
        assert_eq!(capitalize_first("hello"), "Hello");
    }

    #[test]
    fn test_empty() {
        assert_eq!(capitalize_first(""), "");
    }

    #[test]
    fn test_iterate_string_vec() {
        let words = vec!["hello", "world"];
        assert_eq!(capitalize_words_vector(&words), ["Hello", "World"]);
    }

    #[test]
    fn test_iterate_into_string() {
        let words = vec!["hello", " ", "world"];
        assert_eq!(capitalize_words_string(&words), "Hello World");
    }
}



================================================
FILE: exercises/18_iterators/iterators3.rs
================================================
#[derive(Debug, PartialEq, Eq)]
enum DivisionError {
    // Example: 42 / 0
    DivideByZero,
    // Only case for `i64`: `i64::MIN / -1` because the result is `i64::MAX + 1`
    IntegerOverflow,
    // Example: 5 / 2 = 2.5
    NotDivisible,
}

// TODO: Calculate `a` divided by `b` if `a` is evenly divisible by `b`.
// Otherwise, return a suitable error.
fn divide(a: i64, b: i64) -> Result<i64, DivisionError> {
    todo!();
}

// TODO: Add the correct return type and complete the function body.
// Desired output: `Ok([1, 11, 1426, 3])`
fn result_with_list() {
    let numbers = [27, 297, 38502, 81];
    let division_results = numbers.into_iter().map(|n| divide(n, 27));
}

// TODO: Add the correct return type and complete the function body.
// Desired output: `[Ok(1), Ok(11), Ok(1426), Ok(3)]`
fn list_of_results() {
    let numbers = [27, 297, 38502, 81];
    let division_results = numbers.into_iter().map(|n| divide(n, 27));
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_success() {
        assert_eq!(divide(81, 9), Ok(9));
        assert_eq!(divide(81, -1), Ok(-81));
        assert_eq!(divide(i64::MIN, i64::MIN), Ok(1));
    }

    #[test]
    fn test_divide_by_0() {
        assert_eq!(divide(81, 0), Err(DivisionError::DivideByZero));
    }

    #[test]
    fn test_integer_overflow() {
        assert_eq!(divide(i64::MIN, -1), Err(DivisionError::IntegerOverflow));
    }

    #[test]
    fn test_not_divisible() {
        assert_eq!(divide(81, 6), Err(DivisionError::NotDivisible));
    }

    #[test]
    fn test_divide_0_by_something() {
        assert_eq!(divide(0, 81), Ok(0));
    }

    #[test]
    fn test_result_with_list() {
        assert_eq!(result_with_list().unwrap(), [1, 11, 1426, 3]);
    }

    #[test]
    fn test_list_of_results() {
        assert_eq!(list_of_results(), [Ok(1), Ok(11), Ok(1426), Ok(3)]);
    }
}



================================================
FILE: exercises/18_iterators/iterators4.rs
================================================
fn factorial(num: u64) -> u64 {
    // TODO: Complete this function to return the factorial of `num` which is
    // defined as `1 * 2 * 3 * … * num`.
    // https://en.wikipedia.org/wiki/Factorial
    //
    // Do not use:
    // - early returns (using the `return` keyword explicitly)
    // Try not to use:
    // - imperative style loops (for/while)
    // - additional variables
    // For an extra challenge, don't use:
    // - recursion
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn factorial_of_0() {
        assert_eq!(factorial(0), 1);
    }

    #[test]
    fn factorial_of_1() {
        assert_eq!(factorial(1), 1);
    }
    #[test]
    fn factorial_of_2() {
        assert_eq!(factorial(2), 2);
    }

    #[test]
    fn factorial_of_4() {
        assert_eq!(factorial(4), 24);
    }
}



================================================
FILE: exercises/18_iterators/iterators5.rs
================================================
// Let's define a simple model to track Rustlings' exercise progress. Progress
// will be modelled using a hash map. The name of the exercise is the key and
// the progress is the value. Two counting functions were created to count the
// number of exercises with a given progress. Recreate this counting
// functionality using iterators. Try to not use imperative loops (for/while).

use std::collections::HashMap;

#[derive(Clone, Copy, PartialEq, Eq)]
enum Progress {
    None,
    Some,
    Complete,
}

fn count_for(map: &HashMap<String, Progress>, value: Progress) -> usize {
    let mut count = 0;
    for val in map.values() {
        if *val == value {
            count += 1;
        }
    }
    count
}

// TODO: Implement the functionality of `count_for` but with an iterator instead
// of a `for` loop.
fn count_iterator(map: &HashMap<String, Progress>, value: Progress) -> usize {
    // `map` is a hash map with `String` keys and `Progress` values.
    // map = { "variables1": Complete, "from_str": None, … }
}

fn count_collection_for(collection: &[HashMap<String, Progress>], value: Progress) -> usize {
    let mut count = 0;
    for map in collection {
        for val in map.values() {
            if *val == value {
                count += 1;
            }
        }
    }
    count
}

// TODO: Implement the functionality of `count_collection_for` but with an
// iterator instead of a `for` loop.
fn count_collection_iterator(collection: &[HashMap<String, Progress>], value: Progress) -> usize {
    // `collection` is a slice of hash maps.
    // collection = [{ "variables1": Complete, "from_str": None, … },
    //               { "variables2": Complete, … }, … ]
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_map() -> HashMap<String, Progress> {
        use Progress::*;

        let mut map = HashMap::new();
        map.insert(String::from("variables1"), Complete);
        map.insert(String::from("functions1"), Complete);
        map.insert(String::from("hashmap1"), Complete);
        map.insert(String::from("arc1"), Some);
        map.insert(String::from("as_ref_mut"), None);
        map.insert(String::from("from_str"), None);

        map
    }

    fn get_vec_map() -> Vec<HashMap<String, Progress>> {
        use Progress::*;

        let map = get_map();

        let mut other = HashMap::new();
        other.insert(String::from("variables2"), Complete);
        other.insert(String::from("functions2"), Complete);
        other.insert(String::from("if1"), Complete);
        other.insert(String::from("from_into"), None);
        other.insert(String::from("try_from_into"), None);

        vec![map, other]
    }

    #[test]
    fn count_complete() {
        let map = get_map();
        assert_eq!(count_iterator(&map, Progress::Complete), 3);
    }

    #[test]
    fn count_some() {
        let map = get_map();
        assert_eq!(count_iterator(&map, Progress::Some), 1);
    }

    #[test]
    fn count_none() {
        let map = get_map();
        assert_eq!(count_iterator(&map, Progress::None), 2);
    }

    #[test]
    fn count_complete_equals_for() {
        let map = get_map();
        let progress_states = [Progress::Complete, Progress::Some, Progress::None];
        for progress_state in progress_states {
            assert_eq!(
                count_for(&map, progress_state),
                count_iterator(&map, progress_state),
            );
        }
    }

    #[test]
    fn count_collection_complete() {
        let collection = get_vec_map();
        assert_eq!(
            count_collection_iterator(&collection, Progress::Complete),
            6,
        );
    }

    #[test]
    fn count_collection_some() {
        let collection = get_vec_map();
        assert_eq!(count_collection_iterator(&collection, Progress::Some), 1);
    }

    #[test]
    fn count_collection_none() {
        let collection = get_vec_map();
        assert_eq!(count_collection_iterator(&collection, Progress::None), 4);
    }

    #[test]
    fn count_collection_equals_for() {
        let collection = get_vec_map();
        let progress_states = [Progress::Complete, Progress::Some, Progress::None];

        for progress_state in progress_states {
            assert_eq!(
                count_collection_for(&collection, progress_state),
                count_collection_iterator(&collection, progress_state),
            );
        }
    }
}



================================================
FILE: exercises/19_smart_pointers/README.md
================================================
# Smart Pointers

In Rust, smart pointers are variables that contain an address in memory and reference some other data, but they also have additional metadata and capabilities.
Smart pointers in Rust often own the data they point to, while references only borrow data.

## Further Information

- [Smart Pointers](https://doc.rust-lang.org/book/ch15-00-smart-pointers.html)
- [Using Box to Point to Data on the Heap](https://doc.rust-lang.org/book/ch15-01-box.html)
- [Rc\<T\>, the Reference Counted Smart Pointer](https://doc.rust-lang.org/book/ch15-04-rc.html)
- [Shared-State Concurrency](https://doc.rust-lang.org/book/ch16-03-shared-state.html)
- [Cow Documentation](https://doc.rust-lang.org/std/borrow/enum.Cow.html)



================================================
FILE: exercises/19_smart_pointers/arc1.rs
================================================
// In this exercise, we are given a `Vec` of `u32` called `numbers` with values
// ranging from 0 to 99. We would like to use this set of numbers within 8
// different threads simultaneously. Each thread is going to get the sum of
// every eighth value with an offset.
//
// The first thread (offset 0), will sum 0, 8, 16, …
// The second thread (offset 1), will sum 1, 9, 17, …
// The third thread (offset 2), will sum 2, 10, 18, …
// …
// The eighth thread (offset 7), will sum 7, 15, 23, …
//
// Each thread should own a reference-counting pointer to the vector of
// numbers. But `Rc` isn't thread-safe. Therefore, we need to use `Arc`.
//
// Don't get distracted by how threads are spawned and joined. We will practice
// that later in the exercises about threads.

// Don't change the lines below.
#![forbid(unused_imports)]
use std::{sync::Arc, thread};

fn main() {
    let numbers: Vec<_> = (0..100u32).collect();

    // TODO: Define `shared_numbers` by using `Arc`.
    // let shared_numbers = ???;

    let mut join_handles = Vec::new();

    for offset in 0..8 {
        // TODO: Define `child_numbers` using `shared_numbers`.
        // let child_numbers = ???;

        let handle = thread::spawn(move || {
            let sum: u32 = child_numbers.iter().filter(|&&n| n % 8 == offset).sum();
            println!("Sum of offset {offset} is {sum}");
        });

        join_handles.push(handle);
    }

    for handle in join_handles.into_iter() {
        handle.join().unwrap();
    }
}



================================================
FILE: exercises/19_smart_pointers/box1.rs
================================================
// At compile time, Rust needs to know how much space a type takes up. This
// becomes problematic for recursive types, where a value can have as part of
// itself another value of the same type. To get around the issue, we can use a
// `Box` - a smart pointer used to store data on the heap, which also allows us
// to wrap a recursive type.
//
// The recursive type we're implementing in this exercise is the "cons list", a
// data structure frequently found in functional programming languages. Each
// item in a cons list contains two elements: The value of the current item and
// the next item. The last item is a value called `Nil`.

// TODO: Use a `Box` in the enum definition to make the code compile.
#[derive(PartialEq, Debug)]
enum List {
    Cons(i32, List),
    Nil,
}

// TODO: Create an empty cons list.
fn create_empty_list() -> List {
    todo!()
}

// TODO: Create a non-empty cons list.
fn create_non_empty_list() -> List {
    todo!()
}

fn main() {
    println!("This is an empty cons list: {:?}", create_empty_list());
    println!(
        "This is a non-empty cons list: {:?}",
        create_non_empty_list(),
    );
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_empty_list() {
        assert_eq!(create_empty_list(), List::Nil);
    }

    #[test]
    fn test_create_non_empty_list() {
        assert_ne!(create_empty_list(), create_non_empty_list());
    }
}



================================================
FILE: exercises/19_smart_pointers/cow1.rs
================================================
// This exercise explores the `Cow` (Clone-On-Write) smart pointer. It can
// enclose and provide immutable access to borrowed data and clone the data
// lazily when mutation or ownership is required. The type is designed to work
// with general borrowed data via the `Borrow` trait.

use std::borrow::Cow;

fn abs_all(input: &mut Cow<[i32]>) {
    for ind in 0..input.len() {
        let value = input[ind];
        if value < 0 {
            // Clones into a vector if not already owned.
            input.to_mut()[ind] = -value;
        }
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn reference_mutation() {
        // Clone occurs because `input` needs to be mutated.
        let vec = vec![-1, 0, 1];
        let mut input = Cow::from(&vec);
        abs_all(&mut input);
        assert!(matches!(input, Cow::Owned(_)));
    }

    #[test]
    fn reference_no_mutation() {
        // No clone occurs because `input` doesn't need to be mutated.
        let vec = vec![0, 1, 2];
        let mut input = Cow::from(&vec);
        abs_all(&mut input);
        // TODO: Replace `todo!()` with `Cow::Owned(_)` or `Cow::Borrowed(_)`.
        assert!(matches!(input, todo!()));
    }

    #[test]
    fn owned_no_mutation() {
        // We can also pass `vec` without `&` so `Cow` owns it directly. In this
        // case, no mutation occurs (all numbers are already absolute) and thus
        // also no clone. But the result is still owned because it was never
        // borrowed or mutated.
        let vec = vec![0, 1, 2];
        let mut input = Cow::from(vec);
        abs_all(&mut input);
        // TODO: Replace `todo!()` with `Cow::Owned(_)` or `Cow::Borrowed(_)`.
        assert!(matches!(input, todo!()));
    }

    #[test]
    fn owned_mutation() {
        // Of course this is also the case if a mutation does occur (not all
        // numbers are absolute). In this case, the call to `to_mut()` in the
        // `abs_all` function returns a reference to the same data as before.
        let vec = vec![-1, 0, 1];
        let mut input = Cow::from(vec);
        abs_all(&mut input);
        // TODO: Replace `todo!()` with `Cow::Owned(_)` or `Cow::Borrowed(_)`.
        assert!(matches!(input, todo!()));
    }
}



================================================
FILE: exercises/19_smart_pointers/rc1.rs
================================================
// In this exercise, we want to express the concept of multiple owners via the
// `Rc<T>` type. This is a model of our solar system - there is a `Sun` type and
// multiple `Planet`s. The planets take ownership of the sun, indicating that
// they revolve around the sun.

use std::rc::Rc;

#[derive(Debug)]
struct Sun;

#[derive(Debug)]
enum Planet {
    Mercury(Rc<Sun>),
    Venus(Rc<Sun>),
    Earth(Rc<Sun>),
    Mars(Rc<Sun>),
    Jupiter(Rc<Sun>),
    Saturn(Rc<Sun>),
    Uranus(Rc<Sun>),
    Neptune(Rc<Sun>),
}

impl Planet {
    fn details(&self) {
        println!("Hi from {self:?}!");
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn rc1() {
        let sun = Rc::new(Sun);
        println!("reference count = {}", Rc::strong_count(&sun)); // 1 reference

        let mercury = Planet::Mercury(Rc::clone(&sun));
        println!("reference count = {}", Rc::strong_count(&sun)); // 2 references
        mercury.details();

        let venus = Planet::Venus(Rc::clone(&sun));
        println!("reference count = {}", Rc::strong_count(&sun)); // 3 references
        venus.details();

        let earth = Planet::Earth(Rc::clone(&sun));
        println!("reference count = {}", Rc::strong_count(&sun)); // 4 references
        earth.details();

        let mars = Planet::Mars(Rc::clone(&sun));
        println!("reference count = {}", Rc::strong_count(&sun)); // 5 references
        mars.details();

        let jupiter = Planet::Jupiter(Rc::clone(&sun));
        println!("reference count = {}", Rc::strong_count(&sun)); // 6 references
        jupiter.details();

        // TODO
        let saturn = Planet::Saturn(Rc::new(Sun));
        println!("reference count = {}", Rc::strong_count(&sun)); // 7 references
        saturn.details();

        // TODO
        let uranus = Planet::Uranus(Rc::new(Sun));
        println!("reference count = {}", Rc::strong_count(&sun)); // 8 references
        uranus.details();

        // TODO
        let neptune = Planet::Neptune(Rc::new(Sun));
        println!("reference count = {}", Rc::strong_count(&sun)); // 9 references
        neptune.details();

        assert_eq!(Rc::strong_count(&sun), 9);

        drop(neptune);
        println!("reference count = {}", Rc::strong_count(&sun)); // 8 references

        drop(uranus);
        println!("reference count = {}", Rc::strong_count(&sun)); // 7 references

        drop(saturn);
        println!("reference count = {}", Rc::strong_count(&sun)); // 6 references

        drop(jupiter);
        println!("reference count = {}", Rc::strong_count(&sun)); // 5 references

        drop(mars);
        println!("reference count = {}", Rc::strong_count(&sun)); // 4 references

        // TODO
        println!("reference count = {}", Rc::strong_count(&sun)); // 3 references

        // TODO
        println!("reference count = {}", Rc::strong_count(&sun)); // 2 references

        // TODO
        println!("reference count = {}", Rc::strong_count(&sun)); // 1 reference

        assert_eq!(Rc::strong_count(&sun), 1);
    }
}



================================================
FILE: exercises/20_threads/README.md
================================================
# Threads

In most current operating systems, an executed program's code is run in a process, and the operating system manages multiple processes at once.
Within your program, you can also have independent parts that run simultaneously. The features that run these independent parts are called threads.

## Further information

- [Dining Philosophers example](https://doc.rust-lang.org/1.4.0/book/dining-philosophers.html)
- [Using Threads to Run Code Simultaneously](https://doc.rust-lang.org/book/ch16-01-threads.html)
- [Using Message Passing to Transfer Data Between Threads](https://doc.rust-lang.org/book/ch16-02-message-passing.html)



================================================
FILE: exercises/20_threads/threads1.rs
================================================
// This program spawns multiple threads that each runs for at least 250ms, and
// each thread returns how much time it took to complete. The program should
// wait until all the spawned threads have finished and should collect their
// return values into a vector.

use std::{
    thread,
    time::{Duration, Instant},
};

fn main() {
    let mut handles = Vec::new();
    for i in 0..10 {
        let handle = thread::spawn(move || {
            let start = Instant::now();
            thread::sleep(Duration::from_millis(250));
            println!("Thread {i} done");
            start.elapsed().as_millis()
        });
        handles.push(handle);
    }

    let mut results = Vec::new();
    for handle in handles {
        // TODO: Collect the results of all threads into the `results` vector.
        // Use the `JoinHandle` struct which is returned by `thread::spawn`.
    }

    if results.len() != 10 {
        panic!("Oh no! Some thread isn't done yet!");
    }

    println!();
    for (i, result) in results.into_iter().enumerate() {
        println!("Thread {i} took {result}ms");
    }
}



================================================
FILE: exercises/20_threads/threads2.rs
================================================
// Building on the last exercise, we want all of the threads to complete their
// work. But this time, the spawned threads need to be in charge of updating a
// shared value: `JobStatus.jobs_done`

use std::{sync::Arc, thread, time::Duration};

struct JobStatus {
    jobs_done: u32,
}

fn main() {
    // TODO: `Arc` isn't enough if you want a **mutable** shared state.
    let status = Arc::new(JobStatus { jobs_done: 0 });

    let mut handles = Vec::new();
    for _ in 0..10 {
        let status_shared = Arc::clone(&status);
        let handle = thread::spawn(move || {
            thread::sleep(Duration::from_millis(250));

            // TODO: You must take an action before you update a shared value.
            status_shared.jobs_done += 1;
        });
        handles.push(handle);
    }

    // Waiting for all jobs to complete.
    for handle in handles {
        handle.join().unwrap();
    }

    // TODO: Print the value of `JobStatus.jobs_done`.
    println!("Jobs done: {}", todo!());
}



================================================
FILE: exercises/20_threads/threads3.rs
================================================
use std::{sync::mpsc, thread, time::Duration};

struct Queue {
    first_half: Vec<u32>,
    second_half: Vec<u32>,
}

impl Queue {
    fn new() -> Self {
        Self {
            first_half: vec![1, 2, 3, 4, 5],
            second_half: vec![6, 7, 8, 9, 10],
        }
    }
}

fn send_tx(q: Queue, tx: mpsc::Sender<u32>) {
    // TODO: We want to send `tx` to both threads. But currently, it is moved
    // into the first thread. How could you solve this problem?
    thread::spawn(move || {
        for val in q.first_half {
            println!("Sending {val:?}");
            tx.send(val).unwrap();
            thread::sleep(Duration::from_millis(250));
        }
    });

    thread::spawn(move || {
        for val in q.second_half {
            println!("Sending {val:?}");
            tx.send(val).unwrap();
            thread::sleep(Duration::from_millis(250));
        }
    });
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn threads3() {
        let (tx, rx) = mpsc::channel();
        let queue = Queue::new();

        send_tx(queue, tx);

        let mut received = Vec::with_capacity(10);
        for value in rx {
            received.push(value);
        }

        received.sort();
        assert_eq!(received, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    }
}



================================================
FILE: exercises/21_macros/README.md
================================================
# Macros

Rust's macro system is very powerful, but also kind of difficult to wrap your
head around. We're not going to teach you how to write your own fully-featured
macros. Instead, we'll show you how to use and create them.

If you'd like to learn more about writing your own macros, the
[macrokata](https://github.com/tfpk/macrokata) project has a similar style
of exercises to Rustlings, but is all about learning to write Macros.

## Further information

- [The Rust Book - Macros](https://doc.rust-lang.org/book/ch20-05-macros.html)
- [The Little Book of Rust Macros](https://veykril.github.io/tlborm/)
- [Rust by Example - macro_rules!](https://doc.rust-lang.org/rust-by-example/macros.html)



================================================
FILE: exercises/21_macros/macros1.rs
================================================
macro_rules! my_macro {
    () => {
        println!("Check out my macro!");
    };
}

fn main() {
    // TODO: Fix the macro call.
    my_macro();
}



================================================
FILE: exercises/21_macros/macros2.rs
================================================
fn main() {
    my_macro!();
}

// TODO: Fix the compiler error by moving the whole definition of this macro.
macro_rules! my_macro {
    () => {
        println!("Check out my macro!");
    };
}



================================================
FILE: exercises/21_macros/macros3.rs
================================================
// TODO: Fix the compiler error without taking the macro definition out of this
// module.
mod macros {
    macro_rules! my_macro {
        () => {
            println!("Check out my macro!");
        };
    }
}

fn main() {
    my_macro!();
}



================================================
FILE: exercises/21_macros/macros4.rs
================================================
// TODO: Fix the compiler error by adding one or two characters.
#[rustfmt::skip]
macro_rules! my_macro {
    () => {
        println!("Check out my macro!");
    }
    ($val:expr) => {
        println!("Look at this other macro: {}", $val);
    }
}

fn main() {
    my_macro!();
    my_macro!(7777);
}



================================================
FILE: exercises/22_clippy/README.md
================================================
# Clippy

The Clippy tool is a collection of lints to analyze your code so you can catch common mistakes and improve your Rust code.

If you used the installation script for Rustlings, Clippy should be already installed.
If not you can install it manually via `rustup component add clippy`.

## Further information

- [GitHub Repository](https://github.com/rust-lang/rust-clippy).



================================================
FILE: exercises/22_clippy/clippy1.rs
================================================
// The Clippy tool is a collection of lints to analyze your code so you can
// catch common mistakes and improve your Rust code.
//
// For these exercises, the code will fail to compile when there are Clippy
// warnings. Check Clippy's suggestions from the output to solve the exercise.

fn main() {
    // TODO: Fix the Clippy lint in this line.
    let pi = 3.14;
    let radius: f32 = 5.0;

    let area = pi * radius.powi(2);

    println!("The area of a circle with radius {radius:.2} is {area:.5}");
}



================================================
FILE: exercises/22_clippy/clippy2.rs
================================================
fn main() {
    let mut res = 42;
    let option = Some(12);
    // TODO: Fix the Clippy lint.
    for x in option {
        res += x;
    }

    println!("{res}");
}



================================================
FILE: exercises/22_clippy/clippy3.rs
================================================
// Here are some more easy Clippy fixes so you can see its utility 📎
// TODO: Fix all the Clippy lints.

#[rustfmt::skip]
#[allow(unused_variables, unused_assignments)]
fn main() {
    let my_option: Option<&str> = None;
    // Assume that you don't know the value of `my_option`.
    // In the case of `Some`, we want to print its value.
    if my_option.is_none() {
        println!("{}", my_option.unwrap());
    }

    let my_arr = &[
        -1, -2, -3
        -4, -5, -6
    ];
    println!("My array! Here it is: {my_arr:?}");

    let my_empty_vec = vec![1, 2, 3, 4, 5].resize(0, 5);
    println!("This Vec is empty, see? {my_empty_vec:?}");

    let mut value_a = 45;
    let mut value_b = 66;
    // Let's swap these two!
    value_a = value_b;
    value_b = value_a;
    println!("value a: {value_a}; value b: {value_b}");
}



================================================
FILE: exercises/23_conversions/README.md
================================================
# Type conversions

Rust offers a multitude of ways to convert a value of a given type into another type.

The simplest form of type conversion is a type cast expression. It is denoted with the binary operator `as`. For instance, `println!("{}", 1 + 1.0);` would not compile, since `1` is an integer while `1.0` is a float. However, `println!("{}", 1 as f32 + 1.0)` should compile. The exercise [`using_as`](using_as.rs) tries to cover this.

Rust also offers traits that facilitate type conversions upon implementation. These traits can be found under the [`convert`](https://doc.rust-lang.org/std/convert/index.html) module.
The traits are the following:

- `From` and `Into` covered in [`from_into`](from_into.rs)
- `TryFrom` and `TryInto` covered in [`try_from_into`](try_from_into.rs)
- `AsRef` and `AsMut` covered in [`as_ref_mut`](as_ref_mut.rs)

Furthermore, the `std::str` module offers a trait called [`FromStr`](https://doc.rust-lang.org/std/str/trait.FromStr.html) which helps with converting strings into target types via the `parse` method on strings. If properly implemented for a given type `Person`, then `let p: Person = "Mark,20".parse().unwrap()` should both compile and run without panicking.

These should be the main ways ***within the standard library*** to convert data into your desired types.

## Further information

These are not directly covered in the book, but the standard library has a great documentation for it.

- [conversions](https://doc.rust-lang.org/std/convert/index.html)
- [`FromStr` trait](https://doc.rust-lang.org/std/str/trait.FromStr.html)



================================================
FILE: exercises/23_conversions/as_ref_mut.rs
================================================
// AsRef and AsMut allow for cheap reference-to-reference conversions. Read more
// about them at https://doc.rust-lang.org/std/convert/trait.AsRef.html and
// https://doc.rust-lang.org/std/convert/trait.AsMut.html, respectively.

// Obtain the number of bytes (not characters) in the given argument
// (`.len()` returns the number of bytes in a string).
// TODO: Add the `AsRef` trait appropriately as a trait bound.
fn byte_counter<T>(arg: T) -> usize {
    arg.as_ref().len()
}

// Obtain the number of characters (not bytes) in the given argument.
// TODO: Add the `AsRef` trait appropriately as a trait bound.
fn char_counter<T>(arg: T) -> usize {
    arg.as_ref().chars().count()
}

// Squares a number using `as_mut()`.
// TODO: Add the appropriate trait bound.
fn num_sq<T>(arg: &mut T) {
    // TODO: Implement the function body.
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn different_counts() {
        let s = "Café au lait";
        assert_ne!(char_counter(s), byte_counter(s));
    }

    #[test]
    fn same_counts() {
        let s = "Cafe au lait";
        assert_eq!(char_counter(s), byte_counter(s));
    }

    #[test]
    fn different_counts_using_string() {
        let s = String::from("Café au lait");
        assert_ne!(char_counter(s.clone()), byte_counter(s));
    }

    #[test]
    fn same_counts_using_string() {
        let s = String::from("Cafe au lait");
        assert_eq!(char_counter(s.clone()), byte_counter(s));
    }

    #[test]
    fn mut_box() {
        let mut num: Box<u32> = Box::new(3);
        num_sq(&mut num);
        assert_eq!(*num, 9);
    }
}



================================================
FILE: exercises/23_conversions/from_into.rs
================================================
// The `From` trait is used for value-to-value conversions. If `From` is
// implemented, an implementation of `Into` is automatically provided.
// You can read more about it in the documentation:
// https://doc.rust-lang.org/std/convert/trait.From.html

#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

// We implement the Default trait to use it as a fallback when the provided
// string is not convertible into a `Person` object.
impl Default for Person {
    fn default() -> Self {
        Self {
            name: String::from("John"),
            age: 30,
        }
    }
}

// TODO: Complete this `From` implementation to be able to parse a `Person`
// out of a string in the form of "Mark,20".
// Note that you'll need to parse the age component into a `u8` with something
// like `"4".parse::<u8>()`.
//
// Steps:
// 1. Split the given string on the commas present in it.
// 2. If the split operation returns less or more than 2 elements, return the
//    default of `Person`.
// 3. Use the first element from the split operation as the name.
// 4. If the name is empty, return the default of `Person`.
// 5. Parse the second element from the split operation into a `u8` as the age.
// 6. If parsing the age fails, return the default of `Person`.
impl From<&str> for Person {
    fn from(s: &str) -> Self {}
}

fn main() {
    // Use the `from` function.
    let p1 = Person::from("Mark,20");
    println!("{p1:?}");

    // Since `From` is implemented for Person, we are able to use `Into`.
    let p2: Person = "Gerald,70".into();
    println!("{p2:?}");
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default() {
        let dp = Person::default();
        assert_eq!(dp.name, "John");
        assert_eq!(dp.age, 30);
    }

    #[test]
    fn test_bad_convert() {
        let p = Person::from("");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_good_convert() {
        let p = Person::from("Mark,20");
        assert_eq!(p.name, "Mark");
        assert_eq!(p.age, 20);
    }

    #[test]
    fn test_bad_age() {
        let p = Person::from("Mark,twenty");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_comma_and_age() {
        let p: Person = Person::from("Mark");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_age() {
        let p: Person = Person::from("Mark,");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name() {
        let p: Person = Person::from(",1");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name_and_age() {
        let p: Person = Person::from(",");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name_and_invalid_age() {
        let p: Person = Person::from(",one");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_trailing_comma() {
        let p: Person = Person::from("Mike,32,");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_trailing_comma_and_some_string() {
        let p: Person = Person::from("Mike,32,dog");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }
}



================================================
FILE: exercises/23_conversions/from_str.rs
================================================
// This is similar to the previous `from_into` exercise. But this time, we'll
// implement `FromStr` and return errors instead of falling back to a default
// value. Additionally, upon implementing `FromStr`, you can use the `parse`
// method on strings to generate an object of the implementor type. You can read
// more about it in the documentation:
// https://doc.rust-lang.org/std/str/trait.FromStr.html

use std::num::ParseIntError;
use std::str::FromStr;

#[derive(Debug, PartialEq)]
struct Person {
    name: String,
    age: u8,
}

// We will use this error type for the `FromStr` implementation.
#[derive(Debug, PartialEq)]
enum ParsePersonError {
    // Incorrect number of fields
    BadLen,
    // Empty name field
    NoName,
    // Wrapped error from parse::<u8>()
    ParseInt(ParseIntError),
}

// TODO: Complete this `FromStr` implementation to be able to parse a `Person`
// out of a string in the form of "Mark,20".
// Note that you'll need to parse the age component into a `u8` with something
// like `"4".parse::<u8>()`.
//
// Steps:
// 1. Split the given string on the commas present in it.
// 2. If the split operation returns less or more than 2 elements, return the
//    error `ParsePersonError::BadLen`.
// 3. Use the first element from the split operation as the name.
// 4. If the name is empty, return the error `ParsePersonError::NoName`.
// 5. Parse the second element from the split operation into a `u8` as the age.
// 6. If parsing the age fails, return the error `ParsePersonError::ParseInt`.
impl FromStr for Person {
    type Err = ParsePersonError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {}
}

fn main() {
    let p = "Mark,20".parse::<Person>();
    println!("{p:?}");
}

#[cfg(test)]
mod tests {
    use super::*;
    use ParsePersonError::*;

    #[test]
    fn empty_input() {
        assert_eq!("".parse::<Person>(), Err(BadLen));
    }

    #[test]
    fn good_input() {
        let p = "John,32".parse::<Person>();
        assert!(p.is_ok());
        let p = p.unwrap();
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 32);
    }

    #[test]
    fn missing_age() {
        assert!(matches!("John,".parse::<Person>(), Err(ParseInt(_))));
    }

    #[test]
    fn invalid_age() {
        assert!(matches!("John,twenty".parse::<Person>(), Err(ParseInt(_))));
    }

    #[test]
    fn missing_comma_and_age() {
        assert_eq!("John".parse::<Person>(), Err(BadLen));
    }

    #[test]
    fn missing_name() {
        assert_eq!(",1".parse::<Person>(), Err(NoName));
    }

    #[test]
    fn missing_name_and_age() {
        assert!(matches!(",".parse::<Person>(), Err(NoName | ParseInt(_))));
    }

    #[test]
    fn missing_name_and_invalid_age() {
        assert!(matches!(
            ",one".parse::<Person>(),
            Err(NoName | ParseInt(_)),
        ));
    }

    #[test]
    fn trailing_comma() {
        assert_eq!("John,32,".parse::<Person>(), Err(BadLen));
    }

    #[test]
    fn trailing_comma_and_some_string() {
        assert_eq!("John,32,man".parse::<Person>(), Err(BadLen));
    }
}



================================================
FILE: exercises/23_conversions/try_from_into.rs
================================================
// `TryFrom` is a simple and safe type conversion that may fail in a controlled
// way under some circumstances. Basically, this is the same as `From`. The main
// difference is that this should return a `Result` type instead of the target
// type itself. You can read more about it in the documentation:
// https://doc.rust-lang.org/std/convert/trait.TryFrom.html

#![allow(clippy::useless_vec)]
use std::convert::{TryFrom, TryInto};

#[derive(Debug, PartialEq)]
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}

// We will use this error type for the `TryFrom` conversions.
#[derive(Debug, PartialEq)]
enum IntoColorError {
    // Incorrect length of slice
    BadLen,
    // Integer conversion error
    IntConversion,
}

// TODO: Tuple implementation.
// Correct RGB color values must be integers in the 0..=255 range.
impl TryFrom<(i16, i16, i16)> for Color {
    type Error = IntoColorError;

    fn try_from(tuple: (i16, i16, i16)) -> Result<Self, Self::Error> {}
}

// TODO: Array implementation.
impl TryFrom<[i16; 3]> for Color {
    type Error = IntoColorError;

    fn try_from(arr: [i16; 3]) -> Result<Self, Self::Error> {}
}

// TODO: Slice implementation.
// This implementation needs to check the slice length.
impl TryFrom<&[i16]> for Color {
    type Error = IntoColorError;

    fn try_from(slice: &[i16]) -> Result<Self, Self::Error> {}
}

fn main() {
    // Using the `try_from` function.
    let c1 = Color::try_from((183, 65, 14));
    println!("{c1:?}");

    // Since `TryFrom` is implemented for `Color`, we can use `TryInto`.
    let c2: Result<Color, _> = [183, 65, 14].try_into();
    println!("{c2:?}");

    let v = vec![183, 65, 14];
    // With slice we should use the `try_from` function
    let c3 = Color::try_from(&v[..]);
    println!("{c3:?}");
    // or put the slice within round brackets and use `try_into`.
    let c4: Result<Color, _> = (&v[..]).try_into();
    println!("{c4:?}");
}

#[cfg(test)]
mod tests {
    use super::*;
    use IntoColorError::*;

    #[test]
    fn test_tuple_out_of_range_positive() {
        assert_eq!(Color::try_from((256, 1000, 10000)), Err(IntConversion));
    }

    #[test]
    fn test_tuple_out_of_range_negative() {
        assert_eq!(Color::try_from((-1, -10, -256)), Err(IntConversion));
    }

    #[test]
    fn test_tuple_sum() {
        assert_eq!(Color::try_from((-1, 255, 255)), Err(IntConversion));
    }

    #[test]
    fn test_tuple_correct() {
        let c: Result<Color, _> = (183, 65, 14).try_into();
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14,
            }
        );
    }

    #[test]
    fn test_array_out_of_range_positive() {
        let c: Result<Color, _> = [1000, 10000, 256].try_into();
        assert_eq!(c, Err(IntConversion));
    }

    #[test]
    fn test_array_out_of_range_negative() {
        let c: Result<Color, _> = [-10, -256, -1].try_into();
        assert_eq!(c, Err(IntConversion));
    }

    #[test]
    fn test_array_sum() {
        let c: Result<Color, _> = [-1, 255, 255].try_into();
        assert_eq!(c, Err(IntConversion));
    }

    #[test]
    fn test_array_correct() {
        let c: Result<Color, _> = [183, 65, 14].try_into();
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }

    #[test]
    fn test_slice_out_of_range_positive() {
        let arr = [10000, 256, 1000];
        assert_eq!(Color::try_from(&arr[..]), Err(IntConversion));
    }

    #[test]
    fn test_slice_out_of_range_negative() {
        let arr = [-256, -1, -10];
        assert_eq!(Color::try_from(&arr[..]), Err(IntConversion));
    }

    #[test]
    fn test_slice_sum() {
        let arr = [-1, 255, 255];
        assert_eq!(Color::try_from(&arr[..]), Err(IntConversion));
    }

    #[test]
    fn test_slice_correct() {
        let v = vec![183, 65, 14];
        let c: Result<Color, _> = Color::try_from(&v[..]);
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14,
            }
        );
    }

    #[test]
    fn test_slice_excess_length() {
        let v = vec![0, 0, 0, 0];
        assert_eq!(Color::try_from(&v[..]), Err(BadLen));
    }

    #[test]
    fn test_slice_insufficient_length() {
        let v = vec![0, 0];
        assert_eq!(Color::try_from(&v[..]), Err(BadLen));
    }
}



================================================
FILE: exercises/23_conversions/using_as.rs
================================================
// Type casting in Rust is done via the usage of the `as` operator.
// Note that the `as` operator is not only used when type casting. It also helps
// with renaming imports.

fn average(values: &[f64]) -> f64 {
    let total = values.iter().sum::<f64>();
    // TODO: Make a conversion before dividing.
    total / values.len()
}

fn main() {
    let values = [3.5, 0.3, 13.0, 11.7];
    println!("{}", average(&values));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn returns_proper_type_and_value() {
        assert_eq!(average(&[3.5, 0.3, 13.0, 11.7]), 7.125);
    }
}



================================================
FILE: exercises/quizzes/README.md
================================================
# Quizzes

After every couple of sections, there will be a quiz in this directory that'll test your knowledge on a bunch of sections at once.



================================================
FILE: exercises/quizzes/quiz1.rs
================================================
// This is a quiz for the following sections:
// - Variables
// - Functions
// - If
//
// Mary is buying apples. The price of an apple is calculated as follows:
// - An apple costs 2 rustbucks.
// - However, if Mary buys more than 40 apples, the price of each apple in the
// entire order is reduced to only 1 rustbuck!

// TODO: Write a function that calculates the price of an order of apples given
// the quantity bought.
// fn calculate_price_of_apples(???) -> ??? { ??? }

fn main() {
    // You can optionally experiment here.
}

// Don't change the tests!
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn verify_test() {
        assert_eq!(calculate_price_of_apples(35), 70);
        assert_eq!(calculate_price_of_apples(40), 80);
        assert_eq!(calculate_price_of_apples(41), 41);
        assert_eq!(calculate_price_of_apples(65), 65);
    }
}



================================================
FILE: exercises/quizzes/quiz2.rs
================================================
// This is a quiz for the following sections:
// - Strings
// - Vecs
// - Move semantics
// - Modules
// - Enums
//
// Let's build a little machine in the form of a function. As input, we're going
// to give a list of strings and commands. These commands determine what action
// is going to be applied to the string. It can either be:
// - Uppercase the string
// - Trim the string
// - Append "bar" to the string a specified amount of times
//
// The exact form of this will be:
// - The input is going to be a Vector of 2-length tuples,
//   the first element is the string, the second one is the command.
// - The output element is going to be a vector of strings.

enum Command {
    Uppercase,
    Trim,
    Append(usize),
}

mod my_module {
    use super::Command;

    // TODO: Complete the function as described above.
    // pub fn transformer(input: ???) -> ??? { ??? }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    // TODO: What do we need to import to have `transformer` in scope?
    // use ???;
    use super::Command;

    #[test]
    fn it_works() {
        let input = vec![
            ("hello".to_string(), Command::Uppercase),
            (" all roads lead to rome! ".to_string(), Command::Trim),
            ("foo".to_string(), Command::Append(1)),
            ("bar".to_string(), Command::Append(5)),
        ];
        let output = transformer(input);

        assert_eq!(
            output,
            [
                "HELLO",
                "all roads lead to rome!",
                "foobar",
                "barbarbarbarbarbar",
            ]
        );
    }
}



================================================
FILE: exercises/quizzes/quiz3.rs
================================================
// This quiz tests:
// - Generics
// - Traits
//
// An imaginary magical school has a new report card generation system written
// in Rust! Currently, the system only supports creating report cards where the
// student's grade is represented numerically (e.g. 1.0 -> 5.5). However, the
// school also issues alphabetical grades (A+ -> F-) and needs to be able to
// print both types of report card!
//
// Make the necessary code changes in the struct `ReportCard` and the impl
// block to support alphabetical report cards in addition to numerical ones.

// TODO: Adjust the struct as described above.
struct ReportCard {
    grade: f32,
    student_name: String,
    student_age: u8,
}

// TODO: Adjust the impl block as described above.
impl ReportCard {
    fn print(&self) -> String {
        format!(
            "{} ({}) - achieved a grade of {}",
            &self.student_name, &self.student_age, &self.grade,
        )
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generate_numeric_report_card() {
        let report_card = ReportCard {
            grade: 2.1,
            student_name: "Tom Wriggle".to_string(),
            student_age: 12,
        };
        assert_eq!(
            report_card.print(),
            "Tom Wriggle (12) - achieved a grade of 2.1",
        );
    }

    #[test]
    fn generate_alphabetic_report_card() {
        let report_card = ReportCard {
            grade: "A+",
            student_name: "Gary Plotter".to_string(),
            student_age: 11,
        };
        assert_eq!(
            report_card.print(),
            "Gary Plotter (11) - achieved a grade of A+",
        );
    }
}



================================================
FILE: rustlings-macros/Cargo.toml
================================================
[package]
name = "rustlings-macros"
description = "A macros crate intended to be used only by Rustlings"
version.workspace = true
authors.workspace = true
repository.workspace = true
license.workspace = true
edition.workspace = true
rust-version.workspace = true
include = [
  "/src/",
  "/info.toml",
]

[lib]
proc-macro = true

[dependencies]
quote = "1.0"
serde.workspace = true
toml.workspace = true

[lints]
workspace = true



================================================
FILE: rustlings-macros/info.toml
================================================
format_version = 1

welcome_message = """
Is this your first time? Don't worry, Rustlings is made for beginners!
We are going to teach you a lot of things about Rust, but before we can
get started, here are some notes about how Rustlings operates:

1. The central concept behind Rustlings is that you solve exercises. These
   exercises usually contain some compiler or logic errors which cause the
   exercise to fail compilation or testing. It's your job to find all errors
   and fix them!
2. Make sure to have your editor open in the `rustlings/` directory. Rustlings
   will show you the path of the current exercise under the progress bar. Open
   the exercise file in your editor, fix errors and save the file. Rustlings
   will automatically detect the file change and rerun the exercise. If all
   errors are fixed, Rustlings will ask you to move on to the next exercise.
3. If you're stuck on an exercise, enter `h` to show a hint.
4. If an exercise doesn't make sense to you, feel free to open an issue on
   GitHub! (https://github.com/rust-lang/rustlings). We look at every issue, and
   sometimes, other learners do too so you can help each other out!"""

final_message = """
We hope you enjoyed learning about the various aspects of Rust!
If you noticed any issues, don't hesitate to report them on Github.
You can also contribute your own exercises to help the greater community!

Before reporting an issue or contributing, please read our guidelines:
https://github.com/rust-lang/rustlings/blob/main/CONTRIBUTING.md"""

# INTRO

[[exercises]]
name = "intro1"
dir = "00_intro"
test = false
skip_check_unsolved = true
hint = """
Enter `n` to move on to the next exercise.
You might need to press ENTER after typing `n`."""

[[exercises]]
name = "intro2"
dir = "00_intro"
test = false
hint = """
The compiler is informing us that we've got the name of the print macro wrong.
It also suggests an alternative."""

# VARIABLES

[[exercises]]
name = "variables1"
dir = "01_variables"
test = false
hint = """
The declaration in the `main` function is missing a keyword that is needed
in Rust to create a new variable binding."""

[[exercises]]
name = "variables2"
dir = "01_variables"
test = false
hint = """
The compiler message is saying that Rust can't infer the type that the
variable binding `x` has with what is given here.

What happens if you annotate the first line in the `main` function with a type
annotation?

What if you give `x` a value?

What if you do both?

What type should `x` be, anyway?

What if `x` is the same type as `10`? What if it's a different type?"""

[[exercises]]
name = "variables3"
dir = "01_variables"
test = false
hint = """
In this exercise, we have a variable binding that we've created in the `main`
function, and we're trying to use it in the next line, but we haven't given it
a value.

We can't print out something that isn't there; try giving `x` a value!

This is an error that can cause bugs that's very easy to make in any
programming language -- thankfully the Rust compiler has caught this for us!"""

[[exercises]]
name = "variables4"
dir = "01_variables"
test = false
hint = """
In Rust, variable bindings are immutable by default. But here, we're trying
to reassign a different value to `x`! There's a keyword we can use to make
a variable binding mutable instead."""

[[exercises]]
name = "variables5"
dir = "01_variables"
test = false
hint = """
In `variables4` we already learned how to make an immutable variable mutable
using a special keyword. Unfortunately this doesn't help us much in this
exercise because we want to assign a different typed value to an existing
variable. Sometimes you may also like to reuse existing variable names because
you are just converting values to different types like in this exercise.

Fortunately Rust has a powerful solution to this problem: 'Shadowing'!
You can read more about 'Shadowing' in the book's section 'Variables and
Mutability':
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#shadowing

Try to solve this exercise afterwards using this technique."""

[[exercises]]
name = "variables6"
dir = "01_variables"
test = false
hint = """
We know about variables and mutability, but there is another important type of
variable available: constants.

Constants are always immutable. They are declared with the keyword `const`
instead of `let`.

The type of Constants must always be annotated.

Read more about constants and the differences between variables and constants
under 'Constants' in the book's section 'Variables and Mutability':
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#constants"""

# FUNCTIONS

[[exercises]]
name = "functions1"
dir = "02_functions"
test = false
hint = """
This `main` function is calling a function that it expects to exist, but the
function doesn't exist. It expects this function to have the name `call_me`.
It also expects this function to not take any arguments and not return a value.
Sounds a lot like `main`, doesn't it?"""

[[exercises]]
name = "functions2"
dir = "02_functions"
test = false
hint = """
Rust requires that all parts of a function's signature have type annotations,
but `call_me` is missing the type annotation of `num`."""

[[exercises]]
name = "functions3"
dir = "02_functions"
test = false
hint = """
This time, the function *declaration* is okay, but there's something wrong
with the place where we are calling the function."""

[[exercises]]
name = "functions4"
dir = "02_functions"
test = false
hint = """
The error message points to the function `sale_price` and says it expects a type
after `->`. This is where the function's return type should be.
Take a look at the `is_even` function for an example!"""

[[exercises]]
name = "functions5"
dir = "02_functions"
test = false
hint = """
This is a really common error that can be fixed by removing one character.
It happens because Rust distinguishes between expressions and statements:
Expressions return a value based on their operand(s), and statements simply
return a `()` type which behaves just like `void` in C/C++.

We want to return a value with the type `i32` from the `square` function, but
it is returning the type `()`.

There are two solutions:
1. Add the `return` keyword before `num * num;`
2. Remove the semicolon `;` after `num * num`"""

# IF

[[exercises]]
name = "if1"
dir = "03_if"
hint = """
It's possible to do this in one line if you would like!

Some similar examples from other languages:
- In C(++) this would be: `a > b ? a : b`
- In Python this would be:  `a if a > b else b`

Remember in Rust that:
- The `if` condition does not need to be surrounded by parentheses
- `if`/`else` conditionals are expressions
- Each condition is followed by a `{}` block"""

[[exercises]]
name = "if2"
dir = "03_if"
hint = """
For that first compiler error, it's important in Rust that each conditional
block returns the same type!

To get the tests passing, you will need a couple conditions checking different
input values. Read the tests to find out what they expect."""

[[exercises]]
name = "if3"
dir = "03_if"
hint = """
In Rust, every arm of an `if` expression has to return the same type of value.
Make sure the type is consistent across all arms."""

# QUIZ 1

[[exercises]]
name = "quiz1"
dir = "quizzes"
hint = "No hints this time ;)"

# PRIMITIVE TYPES

[[exercises]]
name = "primitive_types1"
dir = "04_primitive_types"
test = false
hint = """
In Rust, a boolean can be negated using the operator `!` before it.
Example: `!true == false`
This also works with boolean variables."""

[[exercises]]
name = "primitive_types2"
dir = "04_primitive_types"
test = false
hint = "No hints this time ;)"

[[exercises]]
name = "primitive_types3"
dir = "04_primitive_types"
test = false
hint = """
There's a shorthand to initialize arrays with a certain size that doesn't
require you to type in 100 items (but you certainly can if you want!).

For example, you can do:
```
let array = ["Are we there yet?"; 100];
```

Bonus: what are some other things you could have that would return `true`
for `a.len() >= 100`?"""

[[exercises]]
name = "primitive_types4"
dir = "04_primitive_types"
hint = """
Take a look at the 'Understanding Ownership -> Slices -> Other Slices' section
of the book: https://doc.rust-lang.org/book/ch04-03-slices.html and use the
starting and ending (plus one) indices of the items in the array that you want
to end up in the slice.

If you're curious why the first argument of `assert_eq!` does not have an
ampersand for a reference since the second argument is a reference, take a look
at the coercion chapter of the nomicon:
https://doc.rust-lang.org/nomicon/coercions.html"""

[[exercises]]
name = "primitive_types5"
dir = "04_primitive_types"
test = false
hint = """
Take a look at the 'Data Types -> The Tuple Type' section of the book:
https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type
Particularly the part about destructuring (second to last example in the
section).

You'll need to make a pattern to bind `name` and `age` to the appropriate parts
of the tuple."""

[[exercises]]
name = "primitive_types6"
dir = "04_primitive_types"
hint = """
While you could use a destructuring `let` for the tuple here, try
indexing into it instead, as explained in the last example of the
'Data Types -> The Tuple Type' section of the book:
https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type
Now, you have another tool in your toolbox!"""

# VECS

[[exercises]]
name = "vecs1"
dir = "05_vecs"
hint = """
In Rust, there are two ways to define a Vector.
1. One way is to use the `Vec::new()` function to create a new vector
   and fill it with the `push()` method.
2. The second way is to use the `vec![]` macro and define your elements
   inside the square brackets. This way is simpler when you exactly know
   the initial values.

Check this chapter: https://doc.rust-lang.org/book/ch08-01-vectors.html
of the Rust book to learn more."""

[[exercises]]
name = "vecs2"
dir = "05_vecs"
hint = """
Use the `.push()` method on the vector to push new elements to it."""

# MOVE SEMANTICS

[[exercises]]
name = "move_semantics1"
dir = "06_move_semantics"
hint = """
So you've got the "cannot borrow `vec` as mutable, as it is not declared as
mutable" error on the line where we push an element to the vector, right?

The fix for this is going to be adding one keyword, and the addition is NOT on
the line where we push to the vector (where the error is).

Try accessing `vec0` after having called `fill_vec()`. See what happens!"""

[[exercises]]
name = "move_semantics2"
dir = "06_move_semantics"
hint = """
When running this exercise for the first time, you'll notice an error about
"borrow of moved value". In Rust, when an argument is passed to a function and
it's not explicitly returned, you can't use the original variable anymore.
We call this "moving" a variable. When we pass `vec0` into `fill_vec`, it's
being "moved" into `vec1`, meaning we can't access `vec0` anymore.

You could make another, separate version of the data that's in `vec0` and
pass it to `fill_vec` instead. This is called cloning in Rust."""

[[exercises]]
name = "move_semantics3"
dir = "06_move_semantics"
hint = """
The difference between this one and the previous ones is that the first line
of `fn fill_vec` that had `let mut vec = vec;` is no longer there. You can,
instead of adding that line back, add `mut` in one place that will change
an existing binding to be a mutable binding instead of an immutable one :)"""

[[exercises]]
name = "move_semantics4"
dir = "06_move_semantics"
hint = """
Carefully reason about the range in which each mutable reference is in
scope. Does it help to update the value of `x` immediately after
the mutable reference is taken?
Read more about 'Mutable References' in the book's section 'References and
Borrowing':
https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#mutable-references."""

[[exercises]]
name = "move_semantics5"
dir = "06_move_semantics"
test = false
hint = """
To find the answer, you can consult the book section "References and Borrowing":
https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html

The first problem is that `get_char` is taking ownership of the string. So
`data` is moved and can't be used for `string_uppercase`. `data` is moved to
`get_char` first, meaning that `string_uppercase` can't manipulate the data.

Once you've fixed that, `string_uppercase`'s function signature will also need
to be adjusted."""

# STRUCTS

[[exercises]]
name = "structs1"
dir = "07_structs"
hint = """
Rust has more than one type of struct. Three actually, all variants are used to
package related data together.

There are regular structs. These are named collections of related data stored in
fields.

Tuple structs are basically just named tuples.

Finally, unit structs. These don't have any fields and are useful for generics.

In this exercise, you need to complete and implement one of each kind.
Read more about structs in The Book:
https://doc.rust-lang.org/book/ch05-01-defining-structs.html"""

[[exercises]]
name = "structs2"
dir = "07_structs"
hint = """
Creating instances of structs is easy, all you need to do is assign some values
to its fields.

There are however some shortcuts that can be taken when instantiating structs.
Have a look in The Book to find out more:
https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax"""

[[exercises]]
name = "structs3"
dir = "07_structs"
hint = """
For `is_international`: What makes a package international? Seems related to
the places it goes through right?

For `get_fees`: This method takes an additional argument, is there a field in
the `Package` struct that this relates to?

Have a look in The Book to find out more about method implementations:
https://doc.rust-lang.org/book/ch05-03-method-syntax.html"""

# ENUMS

[[exercises]]
name = "enums1"
dir = "08_enums"
test = false
hint = "No hints this time ;)"

[[exercises]]
name = "enums2"
dir = "08_enums"
test = false
hint = """
You can create enumerations that have different variants with different types
such as anonymous structs, structs, a single string, tuples, no data, etc."""

[[exercises]]
name = "enums3"
dir = "08_enums"
hint = """
As a first step, define enums to compile the code without errors.

Then, create a match expression in `process()`.

Note that you need to deconstruct some message variants in the match expression
to get the variant's values."""

# STRINGS

[[exercises]]
name = "strings1"
dir = "09_strings"
test = false
hint = """
The `current_favorite_color` function is currently returning a string slice
with the `'static` lifetime. We know this because the data of the string lives
in our code itself -- it doesn't come from a file or user input or another
program -- so it will live as long as our program lives.

But it is still a string slice. There's one way to create a `String` by
converting a string slice covered in the Strings chapter of the book, and
another way that uses the `From` trait."""

[[exercises]]
name = "strings2"
dir = "09_strings"
test = false
hint = """
Yes, it would be really easy to fix this by just changing the value bound to
`word` to be a string slice instead of a `String`, wouldn't it? There is a way
to add one character to the `if` statement, though, that will coerce the
`String` into a string slice.

Side note: If you're interested in learning about how this kind of reference
conversion works, you can jump ahead in the book and read this part in the
smart pointers chapter:
https://doc.rust-lang.org/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods"""

[[exercises]]
name = "strings3"
dir = "09_strings"
hint = """
There are many useful standard library functions for strings. Let's try and use
some of them:
https://doc.rust-lang.org/std/string/struct.String.html#method.trim

For the `compose_me` method: You can either use the `format!` macro, or convert
the string slice into an owned string, which you can then freely extend.

For the `replace_me` method, you can check out the `replace` method:
https://doc.rust-lang.org/std/string/struct.String.html#method.replace"""

[[exercises]]
name = "strings4"
dir = "09_strings"
test = false
hint = """
Replace `placeholder` with either `string` or `string_slice` in the `main`
function.

Example:
`placeholder("blue");`
should become
`string_slice("blue");`
because "blue" is `&str`, not `String`."""

# MODULES

[[exercises]]
name = "modules1"
dir = "10_modules"
test = false
hint = """
Everything is private in Rust by default. But there's a keyword we can use
to make something public!"""

[[exercises]]
name = "modules2"
dir = "10_modules"
test = false
hint = """
The `delicious_snacks` module is trying to present an external interface that
is different than its internal structure (the `fruits` and `veggies` modules
and associated constants). Complete the `use` statements to fit the uses in
`main` and find the one keyword missing for both constants.

Learn more in The Book:
https://doc.rust-lang.org/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#re-exporting-names-with-pub-use"""

[[exercises]]
name = "modules3"
dir = "10_modules"
test = false
hint = """
`UNIX_EPOCH` and `SystemTime` are declared in the `std::time` module. Add a
`use` statement for these two to bring them into scope. You can use nested
paths to bring these two in using only one line."""

# HASHMAPS

[[exercises]]
name = "hashmaps1"
dir = "11_hashmaps"
hint = """
The number of fruits should be at least 5 and you have to put at least 3
different types of fruits."""

[[exercises]]
name = "hashmaps2"
dir = "11_hashmaps"
hint = """
Use the `entry()` and `or_insert()` methods of `HashMap` to achieve this.

Learn more in The Book:
https://doc.rust-lang.org/book/ch08-03-hash-maps.html#only-inserting-a-value-if-the-key-has-no-value"""

[[exercises]]
name = "hashmaps3"
dir = "11_hashmaps"
hint = """
Hint 1: Use the `entry()` and `or_default()` methods of `HashMap` to insert the
        default value of `TeamScores` if a team doesn't exist in the table yet.

Hint 2: If there is already an entry for a given key, the value returned by
        `entry()` can be updated based on the existing value.

Learn more in The Book:
https://doc.rust-lang.org/book/ch08-03-hash-maps.html#updating-a-value-based-on-the-old-value"""

# QUIZ 2

[[exercises]]
name = "quiz2"
dir = "quizzes"
hint = "The `+` operator can concatenate a `String` with a `&str`."

# OPTIONS

[[exercises]]
name = "options1"
dir = "12_options"
hint = """
Options can have a `Some` value, with an inner value, or a `None` value,
without an inner value.

There are multiple ways to get at the inner value, you can use `unwrap`, or
pattern match. Unwrapping is the easiest, but how do you do it safely so that
it doesn't panic in your face later?"""

[[exercises]]
name = "options2"
dir = "12_options"
hint = """
Check out:

- https://doc.rust-lang.org/rust-by-example/flow_control/if_let.html
- https://doc.rust-lang.org/rust-by-example/flow_control/while_let.html

Remember that `Option`s can be nested in if-let and while-let statements.

For example: `if let Some(Some(x)) = y`

Also see `Option::flatten`"""

[[exercises]]
name = "options3"
dir = "12_options"
test = false
hint = """
The compiler says a partial move happened in the `match` statement. How can
this be avoided? The compiler shows the correction needed.

After making the correction as suggested by the compiler, read the related docs
page:
https://doc.rust-lang.org/std/keyword.ref.html"""

# ERROR HANDLING

[[exercises]]
name = "errors1"
dir = "13_error_handling"
hint = """
`Ok` and `Err` are the two variants of `Result`, so what the tests are saying
is that `generate_nametag_text` should return a `Result` instead of an `Option`.

To make this change, you'll need to:
  - update the return type in the function signature to be a `Result<String,
    String>` that could be the variants `Ok(String)` and `Err(String)`
  - change the body of the function to return `Ok(…)` where it currently
    returns `Some(…)`
  - change the body of the function to return `Err(error message)` where it
    currently returns `None`"""

[[exercises]]
name = "errors2"
dir = "13_error_handling"
hint = """
One way to handle this is using a `match` statement on
`item_quantity.parse::<i32>()` where the cases are `Ok(something)` and
`Err(something)`.

This pattern is very common in Rust, though, so there's the `?` operator that
does pretty much what you would make that match statement do for you!

Take a look at this section of the "Error Handling" chapter:
https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator"""

[[exercises]]
name = "errors3"
dir = "13_error_handling"
test = false
hint = """
If other functions can return a `Result`, why shouldn't `main`? It's a fairly
common convention to return something like `Result<(), ErrorType>` from your
`main` function.

The unit type `()` is there because nothing is really needed in terms of a
positive result."""

[[exercises]]
name = "errors4"
dir = "13_error_handling"
hint = """
`PositiveNonzeroInteger::new` is always creating a new instance and returning
an `Ok` result. But it should be doing some checking, returning an `Err` if
those checks fail, and only returning an `Ok` if those checks determine that
everything is… okay :)"""

[[exercises]]
name = "errors5"
dir = "13_error_handling"
test = false
hint = """
There are two different possible `Result` types produced within the `main`
function, which are propagated using the `?` operators. How do we declare a
return type for the `main` function that allows both?

Under the hood, the `?` operator calls `From::from` on the error value to
convert it to a boxed trait object, a `Box<dyn Error>`. This boxed trait object
is polymorphic, and since all errors implement the `Error` trait, we can capture
lots of different errors in one `Box` object.

Check out this section of The Book:
https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator

Read more about boxing errors:
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/boxing_errors.html

Read more about using the `?` operator with boxed errors:
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html"""

[[exercises]]
name = "errors6"
dir = "13_error_handling"
hint = """
This exercise uses a completed version of `PositiveNonzeroInteger` from the
previous exercises.

Below the line that `TODO` asks you to change, there is an example of using
the `map_err()` method on a `Result` to transform one type of error into
another. Try using something similar on the `Result` from `parse()`. You
can then use the `?` operator to return early.

Read more about `map_err()` in the `std::result` documentation:
https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"""

# Generics

[[exercises]]
name = "generics1"
dir = "14_generics"
test = false
hint = """
Vectors in Rust make use of generics to create dynamically sized arrays of any
type.
If the vector `numbers` has the type `Vec<T>`, then we can only push values of
type `T` to it. By using `into()` before pushing, we ask the compiler to convert
`n1` and `n2` to `T`. But the compiler doesn't know what `T` is yet and needs a
type annotation.

`u8` and `i8` can both be converted to `i16`, `i32` and `i64`. Choose one for
the generic of the vector."""

[[exercises]]
name = "generics2"
dir = "14_generics"
hint = """
Related section in The Book:
https://doc.rust-lang.org/book/ch10-01-syntax.html#in-method-definitions"""

# TRAITS

[[exercises]]
name = "traits1"
dir = "15_traits"
hint = """
More about traits in The Book:
https://doc.rust-lang.org/book/ch10-02-traits.html

The `+` operator can concatenate a `String` with a `&str`."""

[[exercises]]
name = "traits2"
dir = "15_traits"
hint = """
Notice how the trait takes ownership of `self` and returns `Self`.

Although the signature of `append_bar` in the trait takes `self` as argument,
the implementation can take `mut self` instead. This is possible because the
value is owned anyway."""

[[exercises]]
name = "traits3"
dir = "15_traits"
hint = """
Traits can have a default implementation for functions. Data types that
implement the trait can then use the default version of these functions
if they choose not to implement the function themselves.

Related section in The Book:
https://doc.rust-lang.org/book/ch10-02-traits.html#default-implementations"""

[[exercises]]
name = "traits4"
dir = "15_traits"
hint = """
Instead of using concrete types as parameters you can use traits. Try replacing
`???` with `impl [what goes here?]`.

Related section in The Book:
https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters"""

[[exercises]]
name = "traits5"
dir = "15_traits"
hint = """
To ensure a parameter implements multiple traits use the '+ syntax'. Try
replacing `???` with 'impl [what goes here?] + [what goes here?]'.

Related section in The Book:
https://doc.rust-lang.org/book/ch10-02-traits.html#specifying-multiple-trait-bounds-with-the--syntax"""

# QUIZ 3

[[exercises]]
name = "quiz3"
dir = "quizzes"
hint = """
To find the best solution to this challenge, you need to recall your knowledge
of traits, specifically "Trait Bound Syntax":
https://doc.rust-lang.org/book/ch10-02-traits.html#trait-bound-syntax

Here is how to specify a trait bound for an implementation block:
`impl<T: Trait1 + Trait2 + …> for Foo<T> { … }`

You may need this:
`use std::fmt::Display;`"""

# LIFETIMES

[[exercises]]
name = "lifetimes1"
dir = "16_lifetimes"
hint = """
Let the compiler guide you. Also take a look at The Book if you need help:
https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html"""

[[exercises]]
name = "lifetimes2"
dir = "16_lifetimes"
test = false
hint = """
Remember that the generic lifetime `'a` will get the concrete lifetime that is
equal to the smaller of the lifetimes of `x` and `y`.

You can take at least two paths to achieve the desired result while keeping the
inner block:
1. Move the `string2` declaration to make it live as long as `string1` (how is
   `result` declared?)
2. Move `println!` into the inner block"""

[[exercises]]
name = "lifetimes3"
dir = "16_lifetimes"
test = false
hint = """Let the compiler guide you :)"""

# TESTS

[[exercises]]
name = "tests1"
dir = "17_tests"
hint = """
`assert!` is a macro that needs an argument. Depending on the value of the
argument, `assert!` will do nothing (in which case the test will pass) or
`assert!` will panic (in which case the test will fail).

So try giving different values to `assert!` and see which ones compile, which
ones pass, and which ones fail :)

If you want to check for `false`, you can negate the result of what you're
checking using `!`, like `assert!(!…)`."""

[[exercises]]
name = "tests2"
dir = "17_tests"
hint = """
`assert_eq!` is a macro that takes two arguments and compares them. Try giving
it two values that are equal! Try giving it two arguments that are different!
Try switching which argument comes first and which comes second!"""

[[exercises]]
name = "tests3"
dir = "17_tests"
hint = """
We expect the method `Rectangle::new` to panic for negative values.

To handle that, you need to add a special attribute to the test function.

You can refer to the docs:
https://doc.rust-lang.org/book/ch11-01-writing-tests.html#checking-for-panics-with-should_panic"""

# STANDARD LIBRARY TYPES

[[exercises]]
name = "iterators1"
dir = "18_iterators"
hint = """
An iterator goes through all elements in a collection, but what if we've run
out of elements? What should we expect here? If you're stuck, take a look at
https://doc.rust-lang.org/std/iter/trait.Iterator.html"""

[[exercises]]
name = "iterators2"
dir = "18_iterators"
hint = """
`capitalize_first`:

The variable `first` is a `char`. It needs to be capitalized and added to the
remaining characters in `chars` in order to return the correct `String`.

The remaining characters in `chars` can be viewed as a string slice using the
`as_str` method.

The documentation for `char` contains many useful methods.
https://doc.rust-lang.org/std/primitive.char.html

Use `char::to_uppercase`. It returns an iterator that can be converted to a
`String`.

`capitalize_words_vector`:

Create an iterator from the slice. Transform the iterated values by applying
the `capitalize_first` function. Remember to `collect` the iterator.

`capitalize_words_string`:

This is surprisingly similar to the previous solution. `collect` is very
powerful and very general. Rust just needs to know the desired type."""

[[exercises]]
name = "iterators3"
dir = "18_iterators"
hint = """
The `divide` function needs to return the correct error when the divisor is 0 or
when even division is not possible.

The `division_results` variable needs to be collected into a collection type.

The `result_with_list` function needs to return a single `Result` where the
success case is a vector of integers and the failure case is a `DivisionError`.

The `list_of_results` function needs to return a vector of results.

See https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect for
how the `FromIterator` trait is used in `collect()`. This trait is REALLY
powerful! It can make the solution to this exercise much easier."""

[[exercises]]
name = "iterators4"
dir = "18_iterators"
hint = """
In an imperative language, you might write a `for` loop that updates a mutable
variable. Or, you might write code utilizing recursion and a match clause. In
Rust, you can take another functional approach, computing the factorial
elegantly with ranges and iterators.

Check out the `fold` and `rfold` methods!"""

[[exercises]]
name = "iterators5"
dir = "18_iterators"
hint = """
The documentation for the `std::iter::Iterator` trait contains numerous methods
that would be helpful here.

The `collection` variable in `count_collection_iterator` is a slice of
`HashMap`s. It needs to be converted into an iterator in order to use the
iterator methods.

The `fold` method can be useful in the `count_collection_iterator` function.

For a further challenge, consult the documentation for `Iterator` to find
a different method that could make your code more compact than using `fold`."""

# SMART POINTERS

[[exercises]]
name = "box1"
dir = "19_smart_pointers"
hint = """
The compiler's message should help: Since we cannot store the value of the
actual type when working with recursive types, we need to store a reference
(pointer) to its value.

We should, therefore, place our `List` inside a `Box`. More details in The Book:
https://doc.rust-lang.org/book/ch15-01-box.html#enabling-recursive-types-with-boxes

Creating an empty list should be fairly straightforward (Hint: Read the tests).

For a non-empty list, keep in mind that we want to use our `Cons` list builder.
Although the current list is one of integers (`i32`), feel free to change the
definition and try other types!"""

[[exercises]]
name = "rc1"
dir = "19_smart_pointers"
hint = """
This is a straightforward exercise to use the `Rc<T>` type. Each `Planet` has
ownership of the `Sun`, and uses `Rc::clone()` to increment the reference count
of the `Sun`.

After using `drop()` to move the `Planet`s out of scope individually, the
reference count goes down.

In the end, the `Sun` only has one reference again, to itself.

See more at: https://doc.rust-lang.org/book/ch15-04-rc.html

Unfortunately, Pluto is no longer considered a planet :("""

[[exercises]]
name = "arc1"
dir = "19_smart_pointers"
test = false
hint = """
Make `shared_numbers` be an `Arc` from the `numbers` vector. Then, in order
to avoid creating a copy of `numbers`, you'll need to create `child_numbers`
inside the loop but still in the main thread.

`child_numbers` should be a clone of the `Arc` of the numbers instead of a
thread-local copy of the numbers.

This is a simple exercise if you understand the underlying concepts, but if this
is too much of a struggle, consider reading through all of Chapter 16 in The
Book:
https://doc.rust-lang.org/book/ch16-00-concurrency.html"""

[[exercises]]
name = "cow1"
dir = "19_smart_pointers"
hint = """
If `Cow` already owns the data, it doesn't need to clone it when `to_mut()` is
called.

Check out the documentation of the `Cow` type:
https://doc.rust-lang.org/std/borrow/enum.Cow.html"""

# THREADS

[[exercises]]
name = "threads1"
dir = "20_threads"
test = false
hint = """
`JoinHandle` is a struct that is returned from a spawned thread:
https://doc.rust-lang.org/std/thread/fn.spawn.html

A challenge with multi-threaded applications is that the main thread can
finish before the spawned threads are done.
https://doc.rust-lang.org/book/ch16-01-threads.html#waiting-for-all-threads-to-finish-using-join-handles

Use the `JoinHandle`s to wait for each thread to finish and collect their
results.

https://doc.rust-lang.org/std/thread/struct.JoinHandle.html"""

[[exercises]]
name = "threads2"
dir = "20_threads"
test = false
hint = """
`Arc` is an Atomic Reference Counted pointer that allows safe, shared access
to **immutable** data. But we want to *change* the number of `jobs_done` so
we'll need to also use another type that will only allow one thread to mutate
the data at a time. Take a look at this section of the book:
https://doc.rust-lang.org/book/ch16-03-shared-state.html#atomic-reference-counting-with-arct

Keep reading if you'd like more hints :)

Do you now have an `Arc<Mutex<JobStatus>>` at the beginning of `main`? Like:
```
let status = Arc::new(Mutex::new(JobStatus { jobs_done: 0 }));
```

Similar to the code in the following example in The Book:
https://doc.rust-lang.org/book/ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads"""

[[exercises]]
name = "threads3"
dir = "20_threads"
hint = """
An alternate way to handle concurrency between threads is to use an `mpsc`
(multiple producer, single consumer) channel to communicate.

With both a sending end and a receiving end, it's possible to send values in
one thread and receive them in another.

Multiple producers are possible by using `clone()` to create a duplicate of the
original sending end.

Related section in The Book:
https://doc.rust-lang.org/book/ch16-02-message-passing.html"""

# MACROS

[[exercises]]
name = "macros1"
dir = "21_macros"
test = false
hint = """
When you call a macro, you need to add something special compared to a regular
function call."""

[[exercises]]
name = "macros2"
dir = "21_macros"
test = false
hint = """
Macros don't quite play by the same rules as the rest of Rust, in terms of
what's available where.

Unlike other things in Rust, the order of "where you define a macro" versus
"where you use it" actually matters."""

[[exercises]]
name = "macros3"
dir = "21_macros"
test = false
hint = """
In order to use a macro outside of its module, you need to do something
special to the module to lift the macro out into its parent."""

[[exercises]]
name = "macros4"
dir = "21_macros"
test = false
hint = """
You only need to add a single character to make this compile.

The way macros are written, it wants to see something between each "macro arm",
so it can separate them.

That's all the macro exercises we have in here, but it's barely even scratching
the surface of what you can do with Rust's macros. For a more thorough
introduction, you can have a read through 'The Little Book of Rust Macros':
https://veykril.github.io/tlborm/"""

#  CLIPPY

[[exercises]]
name = "clippy1"
dir = "22_clippy"
test = false
strict_clippy = true
hint = """
Rust stores the highest precision version of some long or infinite precision
mathematical constants in the Rust standard library:
https://doc.rust-lang.org/stable/std/f32/consts/index.html

We may be tempted to use our own approximations for certain mathematical
constants, but clippy recognizes those imprecise mathematical constants as a
source of potential error.

See the suggestions of the Clippy warning in the compile output and use the
appropriate replacement constant from `std::f32::consts`."""

[[exercises]]
name = "clippy2"
dir = "22_clippy"
test = false
strict_clippy = true
hint = """
`for` loops over `Option` values are more clearly expressed as an `if-let`
statement.

Not required to solve this exercise, but if you are interested in when iterating
over `Option` can be useful, read the following section in the documentation:
https://doc.rust-lang.org/std/option/#iterating-over-option"""

[[exercises]]
name = "clippy3"
dir = "22_clippy"
test = false
strict_clippy = true
hint = "No hints this time!"

# TYPE CONVERSIONS

[[exercises]]
name = "using_as"
dir = "23_conversions"
hint = """
Use the `as` operator to cast one of the operands in the last line of the
`average` function into the expected return type."""

[[exercises]]
name = "from_into"
dir = "23_conversions"
hint = """
Follow the steps provided right before the `From` implementation."""

[[exercises]]
name = "from_str"
dir = "23_conversions"
hint = """
The implementation of `FromStr` should return an `Ok` with a `Person` object,
or an `Err` with an error if the string is not valid.

This is almost like the previous `from_into` exercise, but returning errors
instead of falling back to a default value.

Another hint: You can use the `map_err` method of `Result` with a function or a
closure to wrap the error from `parse::<u8>`.

Yet another hint: If you would like to propagate errors by using the `?`
operator in your solution, you might want to look at
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html"""

[[exercises]]
name = "try_from_into"
dir = "23_conversions"
hint = """
Is there an implementation of `TryFrom` in the standard library that can both do
the required integer conversion and check the range of the input?

Challenge: Can you make the `TryFrom` implementations generic over many integer
types?"""

[[exercises]]
name = "as_ref_mut"
dir = "23_conversions"
hint = """
Add `AsRef<str>` or `AsMut<u32>` as a trait bound to the functions."""



================================================
FILE: rustlings-macros/src/lib.rs
================================================
use proc_macro::TokenStream;
use quote::quote;
use serde::Deserialize;

#[derive(Deserialize)]
struct ExerciseInfo {
    name: String,
    dir: String,
}

#[derive(Deserialize)]
struct InfoFile {
    exercises: Vec<ExerciseInfo>,
}

#[proc_macro]
pub fn include_files(_: TokenStream) -> TokenStream {
    let info_file = include_str!("../info.toml");
    let exercises = toml::de::from_str::<InfoFile>(info_file)
        .expect("Failed to parse `info.toml`")
        .exercises;

    let exercise_files = exercises
        .iter()
        .map(|exercise| format!("../exercises/{}/{}.rs", exercise.dir, exercise.name));
    let solution_files = exercises
        .iter()
        .map(|exercise| format!("../solutions/{}/{}.rs", exercise.dir, exercise.name));

    let mut dirs = Vec::with_capacity(32);
    let mut dir_inds = vec![0; exercises.len()];

    for (exercise, dir_ind) in exercises.iter().zip(&mut dir_inds) {
        // The directory is often the last one inserted.
        if let Some(ind) = dirs.iter().rev().position(|dir| *dir == exercise.dir) {
            *dir_ind = dirs.len() - 1 - ind;
            continue;
        }

        dirs.push(exercise.dir.as_str());
        *dir_ind = dirs.len() - 1;
    }

    let readmes = dirs
        .iter()
        .map(|dir| format!("../exercises/{dir}/README.md"));

    quote! {
        EmbeddedFiles {
            info_file: #info_file,
            exercise_files: &[#(ExerciseFiles { exercise: include_bytes!(#exercise_files), solution: include_bytes!(#solution_files), dir_ind: #dir_inds }),*],
            exercise_dirs: &[#(ExerciseDir { name: #dirs, readme: include_bytes!(#readmes) }),*]
        }
    }
    .into()
}



================================================
FILE: solutions/README.md
================================================
# Official Rustlings solutions

Before you finish an exercise, its solution file will only contain an empty `main` function.
The content of this file will be automatically replaced by the actual solution once you finish the exercise.

Note that these solutions are often only _one possibility_ to solve an exercise.



================================================
FILE: solutions/00_intro/intro1.rs
================================================
fn main() {
    // Congratulations, you finished the first exercise 🎉
    // As an introduction to Rustlings, the first exercise only required
    // entering `n` in the terminal to go to the next exercise.
}



================================================
FILE: solutions/00_intro/intro2.rs
================================================
fn main() {
    // `println!` instead of `printline!`.
    println!("Hello world!");
}



================================================
FILE: solutions/01_variables/variables1.rs
================================================
fn main() {
    // Declaring variables requires the `let` keyword.
    let x = 5;

    println!("x has the value {x}");
}



================================================
FILE: solutions/01_variables/variables2.rs
================================================
fn main() {
    // The easiest way to fix the compiler error is to initialize the
    // variable `x`. By setting its value to an integer, Rust infers its type
    // as `i32` which is the default type for integers.
    let x = 42;

    // But we can enforce a type different from the default `i32` by adding
    // a type annotation:
    // let x: u8 = 42;

    if x == 10 {
        println!("x is ten!");
    } else {
        println!("x is not ten!");
    }
}



================================================
FILE: solutions/01_variables/variables3.rs
================================================
#![allow(clippy::needless_late_init)]

fn main() {
    // Reading uninitialized variables isn't allowed in Rust!
    // Therefore, we need to assign a value first.
    let x: i32 = 42;

    println!("Number {x}");

    // It is possible to declare a variable and initialize it later.
    // But it can't be used before initialization.
    let y: i32;
    y = 42;
    println!("Number {y}");
}



================================================
FILE: solutions/01_variables/variables4.rs
================================================
fn main() {
    // In Rust, variables are immutable by default.
    // Adding the `mut` keyword after `let` makes the declared variable mutable.
    let mut x = 3;
    println!("Number {x}");

    x = 5;
    println!("Number {x}");
}



================================================
FILE: solutions/01_variables/variables5.rs
================================================
fn main() {
    let number = "T-H-R-E-E";
    println!("Spell a number: {number}");

    // Using variable shadowing
    // https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#shadowing
    let number = 3;
    println!("Number plus two is: {}", number + 2);
}



================================================
FILE: solutions/01_variables/variables6.rs
================================================
// The type of constants must always be annotated.
const NUMBER: u64 = 3;

fn main() {
    println!("Number: {NUMBER}");
}



================================================
FILE: solutions/02_functions/functions1.rs
================================================
// Some function with the name `call_me` without arguments or a return value.
fn call_me() {
    println!("Hello world!");
}

fn main() {
    call_me();
}



================================================
FILE: solutions/02_functions/functions2.rs
================================================
// The type of function arguments must be annotated.
// Added the type annotation `u64`.
fn call_me(num: u64) {
    for i in 0..num {
        println!("Ring! Call number {}", i + 1);
    }
}

fn main() {
    call_me(3);
}



================================================
FILE: solutions/02_functions/functions3.rs
================================================
fn call_me(num: u8) {
    for i in 0..num {
        println!("Ring! Call number {}", i + 1);
    }
}

fn main() {
    // `call_me` expects an argument.
    call_me(5);
}



================================================
FILE: solutions/02_functions/functions4.rs
================================================
fn is_even(num: i64) -> bool {
    num % 2 == 0
}

// The return type must always be annotated.
fn sale_price(price: i64) -> i64 {
    if is_even(price) {
        price - 10
    } else {
        price - 3
    }
}

fn main() {
    let original_price = 51;
    println!("Your sale price is {}", sale_price(original_price));
}



================================================
FILE: solutions/02_functions/functions5.rs
================================================
fn square(num: i32) -> i32 {
    // Removed the semicolon `;` at the end of the line below to implicitly return the result.
    num * num
}

fn main() {
    let answer = square(3);
    println!("The square of 3 is {answer}");
}



================================================
FILE: solutions/03_if/if1.rs
================================================
fn bigger(a: i32, b: i32) -> i32 {
    if a > b { a } else { b }
}

fn main() {
    // You can optionally experiment here.
}

// Don't mind this for now :)
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ten_is_bigger_than_eight() {
        assert_eq!(10, bigger(10, 8));
    }

    #[test]
    fn fortytwo_is_bigger_than_thirtytwo() {
        assert_eq!(42, bigger(32, 42));
    }

    #[test]
    fn equal_numbers() {
        assert_eq!(42, bigger(42, 42));
    }
}



================================================
FILE: solutions/03_if/if2.rs
================================================
fn picky_eater(food: &str) -> &str {
    if food == "strawberry" {
        "Yummy!"
    } else if food == "potato" {
        "I guess I can eat that."
    } else {
        "No thanks!"
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn yummy_food() {
        assert_eq!(picky_eater("strawberry"), "Yummy!");
    }

    #[test]
    fn neutral_food() {
        assert_eq!(picky_eater("potato"), "I guess I can eat that.");
    }

    #[test]
    fn default_disliked_food() {
        assert_eq!(picky_eater("broccoli"), "No thanks!");
        assert_eq!(picky_eater("gummy bears"), "No thanks!");
        assert_eq!(picky_eater("literally anything"), "No thanks!");
    }
}



================================================
FILE: solutions/03_if/if3.rs
================================================
fn animal_habitat(animal: &str) -> &str {
    let identifier = if animal == "crab" {
        1
    } else if animal == "gopher" {
        2
    } else if animal == "snake" {
        3
    } else {
        // Any unused identifier.
        4
    };

    // Instead of such an identifier, you would use an enum in Rust.
    // But we didn't get into enums yet.
    if identifier == 1 {
        "Beach"
    } else if identifier == 2 {
        "Burrow"
    } else if identifier == 3 {
        "Desert"
    } else {
        "Unknown"
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn gopher_lives_in_burrow() {
        assert_eq!(animal_habitat("gopher"), "Burrow")
    }

    #[test]
    fn snake_lives_in_desert() {
        assert_eq!(animal_habitat("snake"), "Desert")
    }

    #[test]
    fn crab_lives_on_beach() {
        assert_eq!(animal_habitat("crab"), "Beach")
    }

    #[test]
    fn unknown_animal() {
        assert_eq!(animal_habitat("dinosaur"), "Unknown")
    }
}



================================================
FILE: solutions/04_primitive_types/primitive_types1.rs
================================================
fn main() {
    let is_morning = true;
    if is_morning {
        println!("Good morning!");
    }

    let is_evening = !is_morning;
    if is_evening {
        println!("Good evening!");
    }
}



================================================
FILE: solutions/04_primitive_types/primitive_types2.rs
================================================
fn main() {
    let my_first_initial = 'C';
    if my_first_initial.is_alphabetic() {
        println!("Alphabetical!");
    } else if my_first_initial.is_numeric() {
        println!("Numerical!");
    } else {
        println!("Neither alphabetic nor numeric!");
    }

    // Example with an emoji.
    let your_character = '🦀';

    if your_character.is_alphabetic() {
        println!("Alphabetical!");
    } else if your_character.is_numeric() {
        println!("Numerical!");
    } else {
        println!("Neither alphabetic nor numeric!");
    }
}



================================================
FILE: solutions/04_primitive_types/primitive_types3.rs
================================================
fn main() {
    // An array with 100 elements of the value 42.
    let a = [42; 100];

    if a.len() >= 100 {
        println!("Wow, that's a big array!");
    } else {
        println!("Meh, I eat arrays like that for breakfast.");
        panic!("Array not big enough, more elements needed");
    }
}



================================================
FILE: solutions/04_primitive_types/primitive_types4.rs
================================================
fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    #[test]
    fn slice_out_of_array() {
        let a = [1, 2, 3, 4, 5];
        //       0  1  2  3  4  <- indices
        //          -------
        //             |
        //             +--- slice

        // Note that the upper index 4 is excluded.
        let nice_slice = &a[1..4];
        assert_eq!([2, 3, 4], nice_slice);

        // The upper index can be included by using the syntax `..=` (with `=` sign)
        let nice_slice = &a[1..=3];
        assert_eq!([2, 3, 4], nice_slice);
    }
}



================================================
FILE: solutions/04_primitive_types/primitive_types5.rs
================================================
fn main() {
    let cat = ("Furry McFurson", 3.5);

    // Destructuring the tuple.
    let (name, age) = cat;

    println!("{name} is {age} years old");
}



================================================
FILE: solutions/04_primitive_types/primitive_types6.rs
================================================
fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    #[test]
    fn indexing_tuple() {
        let numbers = (1, 2, 3);

        // Tuple indexing syntax.
        let second = numbers.1;

        assert_eq!(second, 2, "This is not the 2nd number in the tuple!");
    }
}



================================================
FILE: solutions/05_vecs/vecs1.rs
================================================
fn array_and_vec() -> ([i32; 4], Vec<i32>) {
    let a = [10, 20, 30, 40]; // Array

    // Used the `vec!` macro.
    let v = vec![10, 20, 30, 40];

    (a, v)
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_array_and_vec_similarity() {
        let (a, v) = array_and_vec();
        assert_eq!(a, *v);
    }
}



================================================
FILE: solutions/05_vecs/vecs2.rs
================================================
fn vec_loop(input: &[i32]) -> Vec<i32> {
    let mut output = Vec::new();

    for element in input {
        output.push(2 * element);
    }

    output
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vec_loop() {
        let input = [2, 4, 6, 8, 10];
        let ans = vec_loop(&input);
        assert_eq!(ans, [4, 8, 12, 16, 20]);
    }
}



================================================
FILE: solutions/06_move_semantics/move_semantics1.rs
================================================
fn fill_vec(vec: Vec<i32>) -> Vec<i32> {
    let mut vec = vec;
    //  ^^^ added

    vec.push(88);

    vec
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn move_semantics1() {
        let vec0 = vec![22, 44, 66];
        let vec1 = fill_vec(vec0);
        // `vec0` can't be accessed anymore because it is moved to `fill_vec`.
        assert_eq!(vec1, vec![22, 44, 66, 88]);
    }
}



================================================
FILE: solutions/06_move_semantics/move_semantics2.rs
================================================
fn fill_vec(vec: Vec<i32>) -> Vec<i32> {
    let mut vec = vec;

    vec.push(88);

    vec
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn move_semantics2() {
        let vec0 = vec![22, 44, 66];

        // Cloning `vec0` so that the clone is moved into `fill_vec`, not `vec0`
        // itself.
        let vec1 = fill_vec(vec0.clone());

        assert_eq!(vec0, [22, 44, 66]);
        assert_eq!(vec1, [22, 44, 66, 88]);
    }
}



================================================
FILE: solutions/06_move_semantics/move_semantics3.rs
================================================
fn fill_vec(mut vec: Vec<i32>) -> Vec<i32> {
    //      ^^^ added
    vec.push(88);

    vec
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn move_semantics3() {
        let vec0 = vec![22, 44, 66];
        let vec1 = fill_vec(vec0);
        assert_eq!(vec1, [22, 44, 66, 88]);
    }
}



================================================
FILE: solutions/06_move_semantics/move_semantics4.rs
================================================
fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    #[test]
    fn move_semantics4() {
        let mut x = Vec::new();
        let y = &mut x;
        // `y` used here.
        y.push(42);
        // The mutable reference `y` is not used anymore,
        // therefore a new reference can be created.
        let z = &mut x;
        z.push(13);
        assert_eq!(x, [42, 13]);
    }
}



================================================
FILE: solutions/06_move_semantics/move_semantics5.rs
================================================
#![allow(clippy::ptr_arg)]

// Borrows instead of taking ownership.
// It is recommended to use `&str` instead of `&String` here. But this is
// enough for now because we didn't handle strings yet.
fn get_char(data: &String) -> char {
    data.chars().last().unwrap()
}

// Takes ownership instead of borrowing.
fn string_uppercase(mut data: String) {
    data = data.to_uppercase();

    println!("{data}");
}

fn main() {
    let data = "Rust is great!".to_string();

    get_char(&data);

    string_uppercase(data);
}



================================================
FILE: solutions/07_structs/structs1.rs
================================================
struct ColorRegularStruct {
    red: u8,
    green: u8,
    blue: u8,
}

struct ColorTupleStruct(u8, u8, u8);

#[derive(Debug)]
struct UnitStruct;

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn regular_structs() {
        let green = ColorRegularStruct {
            red: 0,
            green: 255,
            blue: 0,
        };

        assert_eq!(green.red, 0);
        assert_eq!(green.green, 255);
        assert_eq!(green.blue, 0);
    }

    #[test]
    fn tuple_structs() {
        let green = ColorTupleStruct(0, 255, 0);

        assert_eq!(green.0, 0);
        assert_eq!(green.1, 255);
        assert_eq!(green.2, 0);
    }

    #[test]
    fn unit_structs() {
        let unit_struct = UnitStruct;
        let message = format!("{unit_struct:?}s are fun!");

        assert_eq!(message, "UnitStructs are fun!");
    }
}



================================================
FILE: solutions/07_structs/structs2.rs
================================================
#[derive(Debug)]
struct Order {
    name: String,
    year: u32,
    made_by_phone: bool,
    made_by_mobile: bool,
    made_by_email: bool,
    item_number: u32,
    count: u32,
}

fn create_order_template() -> Order {
    Order {
        name: String::from("Bob"),
        year: 2019,
        made_by_phone: false,
        made_by_mobile: false,
        made_by_email: true,
        item_number: 123,
        count: 0,
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn your_order() {
        let order_template = create_order_template();

        let your_order = Order {
            name: String::from("Hacker in Rust"),
            count: 1,
            // Struct update syntax
            ..order_template
        };

        assert_eq!(your_order.name, "Hacker in Rust");
        assert_eq!(your_order.year, order_template.year);
        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);
        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);
        assert_eq!(your_order.made_by_email, order_template.made_by_email);
        assert_eq!(your_order.item_number, order_template.item_number);
        assert_eq!(your_order.count, 1);
    }
}



================================================
FILE: solutions/07_structs/structs3.rs
================================================
#[derive(Debug)]
struct Package {
    sender_country: String,
    recipient_country: String,
    weight_in_grams: u32,
}

impl Package {
    fn new(sender_country: String, recipient_country: String, weight_in_grams: u32) -> Self {
        if weight_in_grams < 10 {
            // This isn't how you should handle errors in Rust, but we will
            // learn about error handling later.
            panic!("Can't ship a package with weight below 10 grams");
        }

        Self {
            sender_country,
            recipient_country,
            weight_in_grams,
        }
    }

    fn is_international(&self) -> bool {
        //                     ^^^^^^^ added
        self.sender_country != self.recipient_country
    }

    fn get_fees(&self, cents_per_gram: u32) -> u32 {
        //                                  ^^^^^^ added
        self.weight_in_grams * cents_per_gram
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn fail_creating_weightless_package() {
        let sender_country = String::from("Spain");
        let recipient_country = String::from("Austria");

        Package::new(sender_country, recipient_country, 5);
    }

    #[test]
    fn create_international_package() {
        let sender_country = String::from("Spain");
        let recipient_country = String::from("Russia");

        let package = Package::new(sender_country, recipient_country, 1200);

        assert!(package.is_international());
    }

    #[test]
    fn create_local_package() {
        let sender_country = String::from("Canada");
        let recipient_country = sender_country.clone();

        let package = Package::new(sender_country, recipient_country, 1200);

        assert!(!package.is_international());
    }

    #[test]
    fn calculate_transport_fees() {
        let sender_country = String::from("Spain");
        let recipient_country = String::from("Spain");

        let cents_per_gram = 3;

        let package = Package::new(sender_country, recipient_country, 1500);

        assert_eq!(package.get_fees(cents_per_gram), 4500);
        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);
    }
}



================================================
FILE: solutions/08_enums/enums1.rs
================================================
#[derive(Debug)]
enum Message {
    Resize,
    Move,
    Echo,
    ChangeColor,
    Quit,
}

fn main() {
    println!("{:?}", Message::Resize);
    println!("{:?}", Message::Move);
    println!("{:?}", Message::Echo);
    println!("{:?}", Message::ChangeColor);
    println!("{:?}", Message::Quit);
}



================================================
FILE: solutions/08_enums/enums2.rs
================================================
#[derive(Debug)]
struct Point {
    x: u64,
    y: u64,
}

#[derive(Debug)]
enum Message {
    Resize { width: u64, height: u64 },
    Move(Point),
    Echo(String),
    ChangeColor(u8, u8, u8),
    Quit,
}

impl Message {
    fn call(&self) {
        println!("{self:?}");
    }
}

fn main() {
    let messages = [
        Message::Resize {
            width: 10,
            height: 30,
        },
        Message::Move(Point { x: 10, y: 15 }),
        Message::Echo(String::from("hello world")),
        Message::ChangeColor(200, 255, 255),
        Message::Quit,
    ];

    for message in &messages {
        message.call();
    }
}



================================================
FILE: solutions/08_enums/enums3.rs
================================================
struct Point {
    x: u64,
    y: u64,
}

enum Message {
    Resize { width: u64, height: u64 },
    Move(Point),
    Echo(String),
    ChangeColor(u8, u8, u8),
    Quit,
}

struct State {
    width: u64,
    height: u64,
    position: Point,
    message: String,
    color: (u8, u8, u8),
    quit: bool,
}

impl State {
    fn resize(&mut self, width: u64, height: u64) {
        self.width = width;
        self.height = height;
    }

    fn move_position(&mut self, point: Point) {
        self.position = point;
    }

    fn echo(&mut self, s: String) {
        self.message = s;
    }

    fn change_color(&mut self, red: u8, green: u8, blue: u8) {
        self.color = (red, green, blue);
    }

    fn quit(&mut self) {
        self.quit = true;
    }

    fn process(&mut self, message: Message) {
        match message {
            Message::Resize { width, height } => self.resize(width, height),
            Message::Move(point) => self.move_position(point),
            Message::Echo(string) => self.echo(string),
            Message::ChangeColor(red, green, blue) => self.change_color(red, green, blue),
            Message::Quit => self.quit(),
        }
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_match_message_call() {
        let mut state = State {
            width: 0,
            height: 0,
            position: Point { x: 0, y: 0 },
            message: String::from("hello world"),
            color: (0, 0, 0),
            quit: false,
        };

        state.process(Message::Resize {
            width: 10,
            height: 30,
        });
        state.process(Message::Move(Point { x: 10, y: 15 }));
        state.process(Message::Echo(String::from("Hello world!")));
        state.process(Message::ChangeColor(255, 0, 255));
        state.process(Message::Quit);

        assert_eq!(state.width, 10);
        assert_eq!(state.height, 30);
        assert_eq!(state.position.x, 10);
        assert_eq!(state.position.y, 15);
        assert_eq!(state.message, "Hello world!");
        assert_eq!(state.color, (255, 0, 255));
        assert!(state.quit);
    }
}



================================================
FILE: solutions/09_strings/strings1.rs
================================================
fn current_favorite_color() -> String {
    // Equivalent to `String::from("blue")`
    "blue".to_string()
}

fn main() {
    let answer = current_favorite_color();
    println!("My current favorite color is {answer}");
}



================================================
FILE: solutions/09_strings/strings2.rs
================================================
fn is_a_color_word(attempt: &str) -> bool {
    attempt == "green" || attempt == "blue" || attempt == "red"
}

fn main() {
    let word = String::from("green");

    if is_a_color_word(&word) {
        //             ^ added to have `&String` which is automatically
        //               coerced to `&str` by the compiler.
        println!("That is a color word I know!");
    } else {
        println!("That is not a color word I know.");
    }
}



================================================
FILE: solutions/09_strings/strings3.rs
================================================
fn trim_me(input: &str) -> &str {
    input.trim()
}

fn compose_me(input: &str) -> String {
    // The macro `format!` has the same syntax as `println!`, but it returns a
    // string instead of printing it to the terminal.
    // Equivalent to `input.to_string() + " world!"`
    format!("{input} world!")
}

fn replace_me(input: &str) -> String {
    input.replace("cars", "balloons")
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn trim_a_string() {
        assert_eq!(trim_me("Hello!     "), "Hello!");
        assert_eq!(trim_me("  What's up!"), "What's up!");
        assert_eq!(trim_me("   Hola!  "), "Hola!");
        assert_eq!(trim_me("Hi!"), "Hi!");
    }

    #[test]
    fn compose_a_string() {
        assert_eq!(compose_me("Hello"), "Hello world!");
        assert_eq!(compose_me("Goodbye"), "Goodbye world!");
    }

    #[test]
    fn replace_a_string() {
        assert_eq!(
            replace_me("I think cars are cool"),
            "I think balloons are cool",
        );
        assert_eq!(
            replace_me("I love to look at cars"),
            "I love to look at balloons",
        );
    }
}



================================================
FILE: solutions/09_strings/strings4.rs
================================================
fn string_slice(arg: &str) {
    println!("{arg}");
}

fn string(arg: String) {
    println!("{arg}");
}

fn main() {
    string_slice("blue");

    string("red".to_string());

    string(String::from("hi"));

    string("rust is fun!".to_owned());

    // Here, both answers work.
    // `.into()` converts a type into an expected type.
    // If it is called where `String` is expected, it will convert `&str` to `String`.
    string("nice weather".into());
    // But if it is called where `&str` is expected, then `&str` is kept `&str` since no conversion is needed.
    // If you remove the `#[allow(…)]` line, then Clippy will tell you to remove `.into()` below since it is a useless conversion.
    #[allow(clippy::useless_conversion)]
    string_slice("nice weather".into());

    string(format!("Interpolation {}", "Station"));

    // WARNING: This is byte indexing, not character indexing.
    // Character indexing can be done using `s.chars().nth(INDEX)`.
    string_slice(&String::from("abc")[0..1]);

    string_slice("  hello there ".trim());

    string("Happy Monday!".replace("Mon", "Tues"));

    string("mY sHiFt KeY iS sTiCkY".to_lowercase());
}



================================================
FILE: solutions/10_modules/modules1.rs
================================================
mod sausage_factory {
    fn get_secret_recipe() -> String {
        String::from("Ginger")
    }

    // Added `pub` before `fn` to make the function accessible outside the module.
    pub fn make_sausage() {
        get_secret_recipe();
        println!("sausage!");
    }
}

fn main() {
    sausage_factory::make_sausage();
}



================================================
FILE: solutions/10_modules/modules2.rs
================================================
mod delicious_snacks {
    // Added `pub` and used the expected alias after `as`.
    pub use self::fruits::PEAR as fruit;
    pub use self::veggies::CUCUMBER as veggie;

    mod fruits {
        pub const PEAR: &str = "Pear";
        pub const APPLE: &str = "Apple";
    }

    mod veggies {
        pub const CUCUMBER: &str = "Cucumber";
        pub const CARROT: &str = "Carrot";
    }
}

fn main() {
    println!(
        "favorite snacks: {} and {}",
        delicious_snacks::fruit,
        delicious_snacks::veggie,
    );
}



================================================
FILE: solutions/10_modules/modules3.rs
================================================
use std::time::{SystemTime, UNIX_EPOCH};

fn main() {
    match SystemTime::now().duration_since(UNIX_EPOCH) {
        Ok(n) => println!("1970-01-01 00:00:00 UTC was {} seconds ago!", n.as_secs()),
        Err(_) => panic!("SystemTime before UNIX EPOCH!"),
    }
}



================================================
FILE: solutions/11_hashmaps/hashmaps1.rs
================================================
// A basket of fruits in the form of a hash map needs to be defined. The key
// represents the name of the fruit and the value represents how many of that
// particular fruit is in the basket. You have to put at least 3 different
// types of fruits (e.g apple, banana, mango) in the basket and the total count
// of all the fruits should be at least 5.

use std::collections::HashMap;

fn fruit_basket() -> HashMap<String, u32> {
    // Declare the hash map.
    let mut basket = HashMap::new();

    // Two bananas are already given for you :)
    basket.insert(String::from("banana"), 2);

    // Put more fruits in your basket.
    basket.insert(String::from("apple"), 3);
    basket.insert(String::from("mango"), 1);

    basket
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn at_least_three_types_of_fruits() {
        let basket = fruit_basket();
        assert!(basket.len() >= 3);
    }

    #[test]
    fn at_least_five_fruits() {
        let basket = fruit_basket();
        assert!(basket.values().sum::<u32>() >= 5);
    }
}



================================================
FILE: solutions/11_hashmaps/hashmaps2.rs
================================================
// We're collecting different fruits to bake a delicious fruit cake. For this,
// we have a basket, which we'll represent in the form of a hash map. The key
// represents the name of each fruit we collect and the value represents how
// many of that particular fruit we have collected. Three types of fruits -
// Apple (4), Mango (2) and Lychee (5) are already in the basket hash map. You
// must add fruit to the basket so that there is at least one of each kind and
// more than 11 in total - we have a lot of mouths to feed. You are not allowed
// to insert any more of the fruits that are already in the basket (Apple,
// Mango, and Lychee).

use std::collections::HashMap;

#[derive(Hash, PartialEq, Eq, Debug)]
enum Fruit {
    Apple,
    Banana,
    Mango,
    Lychee,
    Pineapple,
}

fn fruit_basket(basket: &mut HashMap<Fruit, u32>) {
    let fruit_kinds = [
        Fruit::Apple,
        Fruit::Banana,
        Fruit::Mango,
        Fruit::Lychee,
        Fruit::Pineapple,
    ];

    for fruit in fruit_kinds {
        // If fruit doesn't exist, insert it with some value.
        basket.entry(fruit).or_insert(5);
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    // Don't modify this function!
    fn get_fruit_basket() -> HashMap<Fruit, u32> {
        let content = [(Fruit::Apple, 4), (Fruit::Mango, 2), (Fruit::Lychee, 5)];
        HashMap::from_iter(content)
    }

    #[test]
    fn test_given_fruits_are_not_modified() {
        let mut basket = get_fruit_basket();
        fruit_basket(&mut basket);
        assert_eq!(*basket.get(&Fruit::Apple).unwrap(), 4);
        assert_eq!(*basket.get(&Fruit::Mango).unwrap(), 2);
        assert_eq!(*basket.get(&Fruit::Lychee).unwrap(), 5);
    }

    #[test]
    fn at_least_five_types_of_fruits() {
        let mut basket = get_fruit_basket();
        fruit_basket(&mut basket);
        let count_fruit_kinds = basket.len();
        assert!(count_fruit_kinds >= 5);
    }

    #[test]
    fn greater_than_eleven_fruits() {
        let mut basket = get_fruit_basket();
        fruit_basket(&mut basket);
        let count = basket.values().sum::<u32>();
        assert!(count > 11);
    }

    #[test]
    fn all_fruit_types_in_basket() {
        let fruit_kinds = [
            Fruit::Apple,
            Fruit::Banana,
            Fruit::Mango,
            Fruit::Lychee,
            Fruit::Pineapple,
        ];

        let mut basket = get_fruit_basket();
        fruit_basket(&mut basket);

        for fruit_kind in fruit_kinds {
            let Some(amount) = basket.get(&fruit_kind) else {
                panic!("Fruit kind {fruit_kind:?} was not found in basket");
            };
            assert!(*amount > 0);
        }
    }
}



================================================
FILE: solutions/11_hashmaps/hashmaps3.rs
================================================
// A list of scores (one per line) of a soccer match is given. Each line is of
// the form "<team_1_name>,<team_2_name>,<team_1_goals>,<team_2_goals>"
// Example: "England,France,4,2" (England scored 4 goals, France 2).
//
// You have to build a scores table containing the name of the team, the total
// number of goals the team scored, and the total number of goals the team
// conceded.

use std::collections::HashMap;

// A structure to store the goal details of a team.
#[derive(Default)]
struct TeamScores {
    goals_scored: u8,
    goals_conceded: u8,
}

fn build_scores_table(results: &str) -> HashMap<&str, TeamScores> {
    // The name of the team is the key and its associated struct is the value.
    let mut scores = HashMap::<&str, TeamScores>::new();

    for line in results.lines() {
        let mut split_iterator = line.split(',');
        // NOTE: We use `unwrap` because we didn't deal with error handling yet.
        let team_1_name = split_iterator.next().unwrap();
        let team_2_name = split_iterator.next().unwrap();
        let team_1_score: u8 = split_iterator.next().unwrap().parse().unwrap();
        let team_2_score: u8 = split_iterator.next().unwrap().parse().unwrap();

        // Insert the default with zeros if a team doesn't exist yet.
        let team_1 = scores.entry(team_1_name).or_default();
        // Update the values.
        team_1.goals_scored += team_1_score;
        team_1.goals_conceded += team_2_score;

        // Similarly for the second team.
        let team_2 = scores.entry(team_2_name).or_default();
        team_2.goals_scored += team_2_score;
        team_2.goals_conceded += team_1_score;
    }

    scores
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    const RESULTS: &str = "England,France,4,2
France,Italy,3,1
Poland,Spain,2,0
Germany,England,2,1
England,Spain,1,0";

    #[test]
    fn build_scores() {
        let scores = build_scores_table(RESULTS);

        assert!(
            ["England", "France", "Germany", "Italy", "Poland", "Spain"]
                .into_iter()
                .all(|team_name| scores.contains_key(team_name))
        );
    }

    #[test]
    fn validate_team_score_1() {
        let scores = build_scores_table(RESULTS);
        let team = scores.get("England").unwrap();
        assert_eq!(team.goals_scored, 6);
        assert_eq!(team.goals_conceded, 4);
    }

    #[test]
    fn validate_team_score_2() {
        let scores = build_scores_table(RESULTS);
        let team = scores.get("Spain").unwrap();
        assert_eq!(team.goals_scored, 0);
        assert_eq!(team.goals_conceded, 3);
    }
}



================================================
FILE: solutions/12_options/options1.rs
================================================
// This function returns how much icecream there is left in the fridge.
// If it's before 22:00 (24-hour system), then 5 scoops are left. At 22:00,
// someone eats it all, so no icecream is left (value 0). Return `None` if
// `hour_of_day` is higher than 23.
fn maybe_icecream(hour_of_day: u16) -> Option<u16> {
    match hour_of_day {
        0..=21 => Some(5),
        22..=23 => Some(0),
        _ => None,
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn raw_value() {
        // Using `unwrap` is fine in a test.
        let icecreams = maybe_icecream(12).unwrap();

        assert_eq!(icecreams, 5);
    }

    #[test]
    fn check_icecream() {
        assert_eq!(maybe_icecream(0), Some(5));
        assert_eq!(maybe_icecream(9), Some(5));
        assert_eq!(maybe_icecream(18), Some(5));
        assert_eq!(maybe_icecream(22), Some(0));
        assert_eq!(maybe_icecream(23), Some(0));
        assert_eq!(maybe_icecream(24), None);
        assert_eq!(maybe_icecream(25), None);
    }
}



================================================
FILE: solutions/12_options/options2.rs
================================================
fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    #[test]
    fn simple_option() {
        let target = "rustlings";
        let optional_target = Some(target);

        // if-let
        if let Some(word) = optional_target {
            assert_eq!(word, target);
        }
    }

    #[test]
    fn layered_option() {
        let range = 10;
        let mut optional_integers: Vec<Option<i8>> = vec![None];

        for i in 1..=range {
            optional_integers.push(Some(i));
        }

        let mut cursor = range;

        // while-let with nested pattern matching
        while let Some(Some(integer)) = optional_integers.pop() {
            assert_eq!(integer, cursor);
            cursor -= 1;
        }

        assert_eq!(cursor, 0);
    }
}



================================================
FILE: solutions/12_options/options3.rs
================================================
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let optional_point = Some(Point { x: 100, y: 200 });

    // Solution 1: Matching over the `Option` (not `&Option`) but without moving
    // out of the `Some` variant.
    match optional_point {
        Some(ref p) => println!("Coordinates are {},{}", p.x, p.y),
        //   ^^^ added
        _ => panic!("No match!"),
    }

    // Solution 2: Matching over a reference (`&Option`) by added `&` before
    // `optional_point`.
    match &optional_point {
        //^ added
        Some(p) => println!("Coordinates are {},{}", p.x, p.y),
        _ => panic!("No match!"),
    }

    println!("{optional_point:?}");
}



================================================
FILE: solutions/13_error_handling/errors1.rs
================================================
fn generate_nametag_text(name: String) -> Result<String, String> {
    //                                    ^^^^^^         ^^^^^^
    if name.is_empty() {
        // `Err(String)` instead of `None`.
        Err("Empty names aren't allowed".to_string())
    } else {
        // `Ok` instead of `Some`.
        Ok(format!("Hi! My name is {name}"))
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generates_nametag_text_for_a_nonempty_name() {
        assert_eq!(
            generate_nametag_text("Beyoncé".to_string()).as_deref(),
            Ok("Hi! My name is Beyoncé"),
        );
    }

    #[test]
    fn explains_why_generating_nametag_text_fails() {
        assert_eq!(
            generate_nametag_text(String::new())
                .as_ref()
                .map_err(|e| e.as_str()),
            Err("Empty names aren't allowed"),
        );
    }
}



================================================
FILE: solutions/13_error_handling/errors2.rs
================================================
// Say we're writing a game where you can buy items with tokens. All items cost
// 5 tokens, and whenever you purchase items there is a processing fee of 1
// token. A player of the game will type in how many items they want to buy, and
// the `total_cost` function will calculate the total cost of the items. Since
// the player typed in the quantity, we get it as a string. They might have
// typed anything, not just numbers!
//
// Right now, this function isn't handling the error case at all. What we want
// to do is: If we call the `total_cost` function on a string that is not a
// number, that function will return a `ParseIntError`. In that case, we want to
// immediately return that error from our function and not try to multiply and
// add.
//
// There are at least two ways to implement this that are both correct. But one
// is a lot shorter!

use std::num::ParseIntError;

#[allow(unused_variables, clippy::question_mark)]
fn total_cost(item_quantity: &str) -> Result<i32, ParseIntError> {
    let processing_fee = 1;
    let cost_per_item = 5;

    // Added `?` to propagate the error.
    let qty = item_quantity.parse::<i32>()?;
    //                                    ^ added

    // Equivalent to this verbose version:
    let qty = match item_quantity.parse::<i32>() {
        Ok(v) => v,
        Err(e) => return Err(e),
    };

    Ok(qty * cost_per_item + processing_fee)
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::num::IntErrorKind;

    #[test]
    fn item_quantity_is_a_valid_number() {
        assert_eq!(total_cost("34"), Ok(171));
    }

    #[test]
    fn item_quantity_is_an_invalid_number() {
        assert_eq!(
            total_cost("beep boop").unwrap_err().kind(),
            &IntErrorKind::InvalidDigit,
        );
    }
}



================================================
FILE: solutions/13_error_handling/errors3.rs
================================================
// This is a program that is trying to use a completed version of the
// `total_cost` function from the previous exercise. It's not working though!
// Why not? What should we do to fix it?

use std::num::ParseIntError;

// Don't change this function.
fn total_cost(item_quantity: &str) -> Result<i32, ParseIntError> {
    let processing_fee = 1;
    let cost_per_item = 5;
    let qty = item_quantity.parse::<i32>()?;

    Ok(qty * cost_per_item + processing_fee)
}

fn main() -> Result<(), ParseIntError> {
    //    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ added
    let mut tokens = 100;
    let pretend_user_input = "8";

    let cost = total_cost(pretend_user_input)?;

    if cost > tokens {
        println!("You can't afford that many!");
    } else {
        tokens -= cost;
        println!("You now have {tokens} tokens.");
    }

    // Added this line to return the `Ok` variant of the expected `Result`.
    Ok(())
}



================================================
FILE: solutions/13_error_handling/errors4.rs
================================================
use std::cmp::Ordering;

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

impl PositiveNonzeroInteger {
    fn new(value: i64) -> Result<Self, CreationError> {
        match value.cmp(&0) {
            Ordering::Less => Err(CreationError::Negative),
            Ordering::Equal => Err(CreationError::Zero),
            Ordering::Greater => Ok(Self(value as u64)),
        }
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_creation() {
        assert_eq!(
            PositiveNonzeroInteger::new(10),
            Ok(PositiveNonzeroInteger(10)),
        );
        assert_eq!(
            PositiveNonzeroInteger::new(-10),
            Err(CreationError::Negative),
        );
        assert_eq!(PositiveNonzeroInteger::new(0), Err(CreationError::Zero));
    }
}



================================================
FILE: solutions/13_error_handling/errors5.rs
================================================
// This exercise is an altered version of the `errors4` exercise. It uses some
// concepts that we won't get to until later in the course, like `Box` and the
// `From` trait. It's not important to understand them in detail right now, but
// you can read ahead if you like. For now, think of the `Box<dyn ???>` type as
// an "I want anything that does ???" type.
//
// In short, this particular use case for boxes is for when you want to own a
// value and you care only that it is a type which implements a particular
// trait. To do so, The `Box` is declared as of type `Box<dyn Trait>` where
// `Trait` is the trait the compiler looks for on any value used in that
// context. For this exercise, that context is the potential errors which
// can be returned in a `Result`.

use std::error::Error;
use std::fmt;

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

// This is required so that `CreationError` can implement `Error`.
impl fmt::Display for CreationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let description = match *self {
            CreationError::Negative => "number is negative",
            CreationError::Zero => "number is zero",
        };
        f.write_str(description)
    }
}

impl Error for CreationError {}

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

impl PositiveNonzeroInteger {
    fn new(value: i64) -> Result<PositiveNonzeroInteger, CreationError> {
        match value {
            x if x < 0 => Err(CreationError::Negative),
            0 => Err(CreationError::Zero),
            x => Ok(PositiveNonzeroInteger(x as u64)),
        }
    }
}

fn main() -> Result<(), Box<dyn Error>> {
    let pretend_user_input = "42";
    let x: i64 = pretend_user_input.parse()?;
    println!("output={:?}", PositiveNonzeroInteger::new(x)?);
    Ok(())
}



================================================
FILE: solutions/13_error_handling/errors6.rs
================================================
// Using catch-all error types like `Box<dyn Error>` isn't recommended for
// library code where callers might want to make decisions based on the error
// content instead of printing it out or propagating it further. Here, we define
// a custom error type to make it possible for callers to decide what to do next
// when our function returns an error.

use std::num::ParseIntError;

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

// A custom error type that we will be using in `PositiveNonzeroInteger::parse`.
#[derive(PartialEq, Debug)]
enum ParsePosNonzeroError {
    Creation(CreationError),
    ParseInt(ParseIntError),
}

impl ParsePosNonzeroError {
    fn from_creation(err: CreationError) -> Self {
        Self::Creation(err)
    }

    fn from_parse_int(err: ParseIntError) -> Self {
        Self::ParseInt(err)
    }
}

// As an alternative solution, implementing the `From` trait allows for the
// automatic conversion from a `ParseIntError` into a `ParsePosNonzeroError`
// using the `?` operator, without the need to call `map_err`.
//
// ```
// let x: i64 = s.parse()?;
// ```
//
// Traits like `From` will be dealt with in later exercises.
impl From<ParseIntError> for ParsePosNonzeroError {
    fn from(err: ParseIntError) -> Self {
        ParsePosNonzeroError::ParseInt(err)
    }
}

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

impl PositiveNonzeroInteger {
    fn new(value: i64) -> Result<Self, CreationError> {
        match value {
            x if x < 0 => Err(CreationError::Negative),
            0 => Err(CreationError::Zero),
            x => Ok(Self(x as u64)),
        }
    }

    fn parse(s: &str) -> Result<Self, ParsePosNonzeroError> {
        // Return an appropriate error instead of panicking when `parse()`
        // returns an error.
        let x: i64 = s.parse().map_err(ParsePosNonzeroError::from_parse_int)?;
        //                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        Self::new(x).map_err(ParsePosNonzeroError::from_creation)
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_parse_error() {
        assert!(matches!(
            PositiveNonzeroInteger::parse("not a number"),
            Err(ParsePosNonzeroError::ParseInt(_)),
        ));
    }

    #[test]
    fn test_negative() {
        assert_eq!(
            PositiveNonzeroInteger::parse("-555"),
            Err(ParsePosNonzeroError::Creation(CreationError::Negative)),
        );
    }

    #[test]
    fn test_zero() {
        assert_eq!(
            PositiveNonzeroInteger::parse("0"),
            Err(ParsePosNonzeroError::Creation(CreationError::Zero)),
        );
    }

    #[test]
    fn test_positive() {
        let x = PositiveNonzeroInteger::new(42).unwrap();
        assert_eq!(x.0, 42);
        assert_eq!(PositiveNonzeroInteger::parse("42"), Ok(x));
    }
}



================================================
FILE: solutions/14_generics/generics1.rs
================================================
// `Vec<T>` is generic over the type `T`. In most cases, the compiler is able to
// infer `T`, for example after pushing a value with a concrete type to the vector.
// But in this exercise, the compiler needs some help through a type annotation.

fn main() {
    // `u8` and `i8` can both be converted to `i16`.
    let mut numbers: Vec<i16> = Vec::new();
    //             ^^^^^^^^^^ added

    // Don't change the lines below.
    let n1: u8 = 42;
    numbers.push(n1.into());
    let n2: i8 = -1;
    numbers.push(n2.into());

    println!("{numbers:?}");
}



================================================
FILE: solutions/14_generics/generics2.rs
================================================
struct Wrapper<T> {
    value: T,
}

impl<T> Wrapper<T> {
    fn new(value: T) -> Self {
        Wrapper { value }
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn store_u32_in_wrapper() {
        assert_eq!(Wrapper::new(42).value, 42);
    }

    #[test]
    fn store_str_in_wrapper() {
        assert_eq!(Wrapper::new("Foo").value, "Foo");
    }
}



================================================
FILE: solutions/15_traits/traits1.rs
================================================
// The trait `AppendBar` has only one function which appends "Bar" to any object
// implementing this trait.
trait AppendBar {
    fn append_bar(self) -> Self;
}

impl AppendBar for String {
    fn append_bar(self) -> Self {
        self + "Bar"
    }
}

fn main() {
    let s = String::from("Foo");
    let s = s.append_bar();
    println!("s: {s}");
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_foo_bar() {
        assert_eq!(String::from("Foo").append_bar(), "FooBar");
    }

    #[test]
    fn is_bar_bar() {
        assert_eq!(String::from("").append_bar().append_bar(), "BarBar");
    }
}



================================================
FILE: solutions/15_traits/traits2.rs
================================================
trait AppendBar {
    fn append_bar(self) -> Self;
}

impl AppendBar for Vec<String> {
    fn append_bar(mut self) -> Self {
        //        ^^^ this is important
        self.push(String::from("Bar"));
        self
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_vec_pop_eq_bar() {
        let mut foo = vec![String::from("Foo")].append_bar();
        assert_eq!(foo.pop().unwrap(), "Bar");
        assert_eq!(foo.pop().unwrap(), "Foo");
    }
}



================================================
FILE: solutions/15_traits/traits3.rs
================================================
trait Licensed {
    fn licensing_info(&self) -> String {
        "Default license".to_string()
    }
}

struct SomeSoftware {
    version_number: i32,
}

struct OtherSoftware {
    version_number: String,
}

impl Licensed for SomeSoftware {}
impl Licensed for OtherSoftware {}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_licensing_info_the_same() {
        let licensing_info = "Default license";
        let some_software = SomeSoftware { version_number: 1 };
        let other_software = OtherSoftware {
            version_number: "v2.0.0".to_string(),
        };
        assert_eq!(some_software.licensing_info(), licensing_info);
        assert_eq!(other_software.licensing_info(), licensing_info);
    }
}



================================================
FILE: solutions/15_traits/traits4.rs
================================================
trait Licensed {
    fn licensing_info(&self) -> String {
        "Default license".to_string()
    }
}

struct SomeSoftware;
struct OtherSoftware;

impl Licensed for SomeSoftware {}
impl Licensed for OtherSoftware {}

fn compare_license_types(software1: impl Licensed, software2: impl Licensed) -> bool {
    //                              ^^^^^^^^^^^^^             ^^^^^^^^^^^^^
    software1.licensing_info() == software2.licensing_info()
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn compare_license_information() {
        assert!(compare_license_types(SomeSoftware, OtherSoftware));
    }

    #[test]
    fn compare_license_information_backwards() {
        assert!(compare_license_types(OtherSoftware, SomeSoftware));
    }
}



================================================
FILE: solutions/15_traits/traits5.rs
================================================
trait SomeTrait {
    fn some_function(&self) -> bool {
        true
    }
}

trait OtherTrait {
    fn other_function(&self) -> bool {
        true
    }
}

struct SomeStruct;
impl SomeTrait for SomeStruct {}
impl OtherTrait for SomeStruct {}

struct OtherStruct;
impl SomeTrait for OtherStruct {}
impl OtherTrait for OtherStruct {}

fn some_func(item: impl SomeTrait + OtherTrait) -> bool {
    //             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    item.some_function() && item.other_function()
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_some_func() {
        assert!(some_func(SomeStruct));
        assert!(some_func(OtherStruct));
    }
}



================================================
FILE: solutions/16_lifetimes/lifetimes1.rs
================================================
// The Rust compiler needs to know how to check whether supplied references are
// valid, so that it can let the programmer know if a reference is at risk of
// going out of scope before it is used. Remember, references are borrows and do
// not own their own data. What if their owner goes out of scope?

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    //    ^^^^     ^^          ^^          ^^
    if x.len() > y.len() { x } else { y }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_longest() {
        assert_eq!(longest("abcd", "123"), "abcd");
        assert_eq!(longest("abc", "1234"), "1234");
    }
}



================================================
FILE: solutions/16_lifetimes/lifetimes2.rs
================================================
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

fn main() {
    let string1 = String::from("long string is long");
    // Solution1: You can move `strings2` out of the inner block so that it is
    // not dropped before the print statement.
    let string2 = String::from("xyz");
    let result;
    {
        result = longest(&string1, &string2);
    }
    println!("The longest string is '{result}'");
    // `string2` dropped at the end of the function.

    // =========================================================================

    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(&string1, &string2);
        // Solution2: You can move the print statement into the inner block so
        // that it is executed before `string2` is dropped.
        println!("The longest string is '{result}'");
        // `string2` dropped here (end of the inner scope).
    }
}



================================================
FILE: solutions/16_lifetimes/lifetimes3.rs
================================================
// Lifetimes are also needed when structs hold references.

struct Book<'a> {
    //     ^^^^ added a lifetime annotation
    author: &'a str,
    //       ^^
    title: &'a str,
    //      ^^
}

fn main() {
    let book = Book {
        author: "George Orwell",
        title: "1984",
    };

    println!("{} by {}", book.title, book.author);
}



================================================
FILE: solutions/17_tests/tests1.rs
================================================
// Tests are important to ensure that your code does what you think it should
// do.

fn is_even(n: i64) -> bool {
    n % 2 == 0
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    // When writing unit tests, it is common to import everything from the outer
    // module (`super`) using a wildcard.
    use super::*;

    #[test]
    fn you_can_assert() {
        assert!(is_even(0));
        assert!(!is_even(-1));
        //      ^ You can assert `false` using the negation operator `!`.
    }
}



================================================
FILE: solutions/17_tests/tests2.rs
================================================
// Calculates the power of 2 using a bit shift.
// `1 << n` is equivalent to "2 to the power of n".
fn power_of_2(n: u8) -> u64 {
    1 << n
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn you_can_assert_eq() {
        assert_eq!(power_of_2(0), 1);
        assert_eq!(power_of_2(1), 2);
        assert_eq!(power_of_2(2), 4);
        assert_eq!(power_of_2(3), 8);
    }
}



================================================
FILE: solutions/17_tests/tests3.rs
================================================
struct Rectangle {
    width: i32,
    height: i32,
}

impl Rectangle {
    // Don't change this function.
    fn new(width: i32, height: i32) -> Self {
        if width <= 0 || height <= 0 {
            // Returning a `Result` would be better here. But we want to learn
            // how to test functions that can panic.
            panic!("Rectangle width and height must be positive");
        }

        Rectangle { width, height }
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn correct_width_and_height() {
        let rect = Rectangle::new(10, 20);
        assert_eq!(rect.width, 10); // Check width
        assert_eq!(rect.height, 20); // Check height
    }

    #[test]
    #[should_panic] // Added this attribute to check that the test panics.
    fn negative_width() {
        let _rect = Rectangle::new(-10, 10);
    }

    #[test]
    #[should_panic] // Added this attribute to check that the test panics.
    fn negative_height() {
        let _rect = Rectangle::new(10, -10);
    }
}



================================================
FILE: solutions/18_iterators/iterators1.rs
================================================
// When performing operations on elements within a collection, iterators are
// essential. This module helps you get familiar with the structure of using an
// iterator and how to go through elements within an iterable collection.

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    #[test]
    fn iterators() {
        let my_fav_fruits = ["banana", "custard apple", "avocado", "peach", "raspberry"];

        // Create an iterator over the array.
        let mut fav_fruits_iterator = my_fav_fruits.iter();

        assert_eq!(fav_fruits_iterator.next(), Some(&"banana"));
        assert_eq!(fav_fruits_iterator.next(), Some(&"custard apple"));
        assert_eq!(fav_fruits_iterator.next(), Some(&"avocado"));
        assert_eq!(fav_fruits_iterator.next(), Some(&"peach"));
        assert_eq!(fav_fruits_iterator.next(), Some(&"raspberry"));
        assert_eq!(fav_fruits_iterator.next(), None);
        //                                     ^^^^ reached the end
    }
}



================================================
FILE: solutions/18_iterators/iterators2.rs
================================================
// In this exercise, you'll learn some of the unique advantages that iterators
// can offer.

// "hello" -> "Hello"
fn capitalize_first(input: &str) -> String {
    let mut chars = input.chars();
    match chars.next() {
        None => String::new(),
        Some(first) => first.to_uppercase().to_string() + chars.as_str(),
    }
}

// Apply the `capitalize_first` function to a slice of string slices.
// Return a vector of strings.
// ["hello", "world"] -> ["Hello", "World"]
fn capitalize_words_vector(words: &[&str]) -> Vec<String> {
    words.iter().map(|word| capitalize_first(word)).collect()
}

// Apply the `capitalize_first` function again to a slice of string
// slices. Return a single string.
// ["hello", " ", "world"] -> "Hello World"
fn capitalize_words_string(words: &[&str]) -> String {
    words.iter().map(|word| capitalize_first(word)).collect()
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_success() {
        assert_eq!(capitalize_first("hello"), "Hello");
    }

    #[test]
    fn test_empty() {
        assert_eq!(capitalize_first(""), "");
    }

    #[test]
    fn test_iterate_string_vec() {
        let words = vec!["hello", "world"];
        assert_eq!(capitalize_words_vector(&words), ["Hello", "World"]);
    }

    #[test]
    fn test_iterate_into_string() {
        let words = vec!["hello", " ", "world"];
        assert_eq!(capitalize_words_string(&words), "Hello World");
    }
}



================================================
FILE: solutions/18_iterators/iterators3.rs
================================================
#[derive(Debug, PartialEq, Eq)]
enum DivisionError {
    // Example: 42 / 0
    DivideByZero,
    // Only case for `i64`: `i64::MIN / -1` because the result is `i64::MAX + 1`
    IntegerOverflow,
    // Example: 5 / 2 = 2.5
    NotDivisible,
}

fn divide(a: i64, b: i64) -> Result<i64, DivisionError> {
    if b == 0 {
        return Err(DivisionError::DivideByZero);
    }

    if a == i64::MIN && b == -1 {
        return Err(DivisionError::IntegerOverflow);
    }

    if a % b != 0 {
        return Err(DivisionError::NotDivisible);
    }

    Ok(a / b)
}

fn result_with_list() -> Result<Vec<i64>, DivisionError> {
    //                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    let numbers = [27, 297, 38502, 81];
    let division_results = numbers.into_iter().map(|n| divide(n, 27));
    // Collects to the expected return type. Returns the first error in the
    // division results (if one exists).
    division_results.collect()
}

fn list_of_results() -> Vec<Result<i64, DivisionError>> {
    //               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    let numbers = [27, 297, 38502, 81];
    let division_results = numbers.into_iter().map(|n| divide(n, 27));
    // Collects to the expected return type.
    division_results.collect()
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_success() {
        assert_eq!(divide(81, 9), Ok(9));
        assert_eq!(divide(81, -1), Ok(-81));
        assert_eq!(divide(i64::MIN, i64::MIN), Ok(1));
    }

    #[test]
    fn test_divide_by_0() {
        assert_eq!(divide(81, 0), Err(DivisionError::DivideByZero));
    }

    #[test]
    fn test_integer_overflow() {
        assert_eq!(divide(i64::MIN, -1), Err(DivisionError::IntegerOverflow));
    }

    #[test]
    fn test_not_divisible() {
        assert_eq!(divide(81, 6), Err(DivisionError::NotDivisible));
    }

    #[test]
    fn test_divide_0_by_something() {
        assert_eq!(divide(0, 81), Ok(0));
    }

    #[test]
    fn test_result_with_list() {
        assert_eq!(result_with_list().unwrap(), [1, 11, 1426, 3]);
    }

    #[test]
    fn test_list_of_results() {
        assert_eq!(list_of_results(), [Ok(1), Ok(11), Ok(1426), Ok(3)]);
    }
}



================================================
FILE: solutions/18_iterators/iterators4.rs
================================================
// 3 possible solutions are presented.

// With `for` loop and a mutable variable.
fn factorial_for(num: u64) -> u64 {
    let mut result = 1;

    for x in 2..=num {
        result *= x;
    }

    result
}

// Equivalent to `factorial_for` but shorter and without a `for` loop and
// mutable variables.
fn factorial_fold(num: u64) -> u64 {
    // Case num==0: The iterator 2..=0 is empty
    //              -> The initial value of `fold` is returned which is 1.
    // Case num==1: The iterator 2..=1 is also empty
    //              -> The initial value 1 is returned.
    // Case num==2: The iterator 2..=2 contains one element
    //              -> The initial value 1 is multiplied by 2 and the result
    //                 is returned.
    // Case num==3: The iterator 2..=3 contains 2 elements
    //              -> 1 * 2 is calculated, then the result 2 is multiplied by
    //                 the second element 3 so the result 6 is returned.
    // And so on…
    #[allow(clippy::unnecessary_fold)]
    (2..=num).fold(1, |acc, x| acc * x)
}

// Equivalent to `factorial_fold` but with a built-in method that is suggested
// by Clippy.
fn factorial_product(num: u64) -> u64 {
    (2..=num).product()
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn factorial_of_0() {
        assert_eq!(factorial_for(0), 1);
        assert_eq!(factorial_fold(0), 1);
        assert_eq!(factorial_product(0), 1);
    }

    #[test]
    fn factorial_of_1() {
        assert_eq!(factorial_for(1), 1);
        assert_eq!(factorial_fold(1), 1);
        assert_eq!(factorial_product(1), 1);
    }
    #[test]
    fn factorial_of_2() {
        assert_eq!(factorial_for(2), 2);
        assert_eq!(factorial_fold(2), 2);
        assert_eq!(factorial_product(2), 2);
    }

    #[test]
    fn factorial_of_4() {
        assert_eq!(factorial_for(4), 24);
        assert_eq!(factorial_fold(4), 24);
        assert_eq!(factorial_product(4), 24);
    }
}



================================================
FILE: solutions/18_iterators/iterators5.rs
================================================
// Let's define a simple model to track Rustlings' exercise progress. Progress
// will be modelled using a hash map. The name of the exercise is the key and
// the progress is the value. Two counting functions were created to count the
// number of exercises with a given progress. Recreate this counting
// functionality using iterators. Try to not use imperative loops (for/while).

use std::collections::HashMap;

#[derive(Clone, Copy, PartialEq, Eq)]
enum Progress {
    None,
    Some,
    Complete,
}

fn count_for(map: &HashMap<String, Progress>, value: Progress) -> usize {
    let mut count = 0;
    for val in map.values() {
        if *val == value {
            count += 1;
        }
    }
    count
}

fn count_iterator(map: &HashMap<String, Progress>, value: Progress) -> usize {
    // `map` is a hash map with `String` keys and `Progress` values.
    // map = { "variables1": Complete, "from_str": None, … }
    map.values().filter(|val| **val == value).count()
}

fn count_collection_for(collection: &[HashMap<String, Progress>], value: Progress) -> usize {
    let mut count = 0;
    for map in collection {
        count += count_for(map, value);
    }
    count
}

fn count_collection_iterator(collection: &[HashMap<String, Progress>], value: Progress) -> usize {
    // `collection` is a slice of hash maps.
    // collection = [{ "variables1": Complete, "from_str": None, … },
    //               { "variables2": Complete, … }, … ]
    collection
        .iter()
        .map(|map| count_iterator(map, value))
        .sum()
}

// Equivalent to `count_collection_iterator` and `count_iterator`, iterating as
// if the collection was a single container instead of a container of containers
// (and more accurately, a single iterator instead of an iterator of iterators).
fn count_collection_iterator_flat(
    collection: &[HashMap<String, Progress>],
    value: Progress,
) -> usize {
    // `collection` is a slice of hash maps.
    // collection = [{ "variables1": Complete, "from_str": None, … },
    //               { "variables2": Complete, … }, … ]
    collection
        .iter()
        .flat_map(HashMap::values) // or just `.flatten()` when wanting the default iterator (`HashMap::iter`)
        .filter(|val| **val == value)
        .count()
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;
    use Progress::*;

    fn get_map() -> HashMap<String, Progress> {
        let mut map = HashMap::new();
        map.insert(String::from("variables1"), Complete);
        map.insert(String::from("functions1"), Complete);
        map.insert(String::from("hashmap1"), Complete);
        map.insert(String::from("arc1"), Some);
        map.insert(String::from("as_ref_mut"), None);
        map.insert(String::from("from_str"), None);

        map
    }

    fn get_vec_map() -> Vec<HashMap<String, Progress>> {
        let map = get_map();

        let mut other = HashMap::new();
        other.insert(String::from("variables2"), Complete);
        other.insert(String::from("functions2"), Complete);
        other.insert(String::from("if1"), Complete);
        other.insert(String::from("from_into"), None);
        other.insert(String::from("try_from_into"), None);

        vec![map, other]
    }

    #[test]
    fn count_complete() {
        let map = get_map();
        assert_eq!(count_iterator(&map, Complete), 3);
    }

    #[test]
    fn count_some() {
        let map = get_map();
        assert_eq!(count_iterator(&map, Some), 1);
    }

    #[test]
    fn count_none() {
        let map = get_map();
        assert_eq!(count_iterator(&map, None), 2);
    }

    #[test]
    fn count_complete_equals_for() {
        let map = get_map();
        let progress_states = [Complete, Some, None];
        for progress_state in progress_states {
            assert_eq!(
                count_for(&map, progress_state),
                count_iterator(&map, progress_state),
            );
        }
    }

    #[test]
    fn count_collection_complete() {
        let collection = get_vec_map();
        assert_eq!(count_collection_iterator(&collection, Complete), 6);
        assert_eq!(count_collection_iterator_flat(&collection, Complete), 6);
    }

    #[test]
    fn count_collection_some() {
        let collection = get_vec_map();
        assert_eq!(count_collection_iterator(&collection, Some), 1);
        assert_eq!(count_collection_iterator_flat(&collection, Some), 1);
    }

    #[test]
    fn count_collection_none() {
        let collection = get_vec_map();
        assert_eq!(count_collection_iterator(&collection, None), 4);
        assert_eq!(count_collection_iterator_flat(&collection, None), 4);
    }

    #[test]
    fn count_collection_equals_for() {
        let collection = get_vec_map();
        let progress_states = [Complete, Some, None];

        for progress_state in progress_states {
            assert_eq!(
                count_collection_for(&collection, progress_state),
                count_collection_iterator(&collection, progress_state),
            );
            assert_eq!(
                count_collection_for(&collection, progress_state),
                count_collection_iterator_flat(&collection, progress_state),
            );
        }
    }
}



================================================
FILE: solutions/19_smart_pointers/arc1.rs
================================================
// In this exercise, we are given a `Vec` of `u32` called `numbers` with values
// ranging from 0 to 99. We would like to use this set of numbers within 8
// different threads simultaneously. Each thread is going to get the sum of
// every eighth value with an offset.
//
// The first thread (offset 0), will sum 0, 8, 16, …
// The second thread (offset 1), will sum 1, 9, 17, …
// The third thread (offset 2), will sum 2, 10, 18, …
// …
// The eighth thread (offset 7), will sum 7, 15, 23, …
//
// Each thread should own a reference-counting pointer to the vector of
// numbers. But `Rc` isn't thread-safe. Therefore, we need to use `Arc`.
//
// Don't get distracted by how threads are spawned and joined. We will practice
// that later in the exercises about threads.

// Don't change the lines below.
#![forbid(unused_imports)]
use std::{sync::Arc, thread};

fn main() {
    let numbers: Vec<_> = (0..100u32).collect();

    let shared_numbers = Arc::new(numbers);
    //                   ^^^^^^^^^^^^^^^^^

    let mut join_handles = Vec::new();

    for offset in 0..8 {
        let child_numbers = Arc::clone(&shared_numbers);
        //                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        let handle = thread::spawn(move || {
            let sum: u32 = child_numbers.iter().filter(|&&n| n % 8 == offset).sum();
            println!("Sum of offset {offset} is {sum}");
        });

        join_handles.push(handle);
    }

    for handle in join_handles.into_iter() {
        handle.join().unwrap();
    }
}



================================================
FILE: solutions/19_smart_pointers/box1.rs
================================================
// At compile time, Rust needs to know how much space a type takes up. This
// becomes problematic for recursive types, where a value can have as part of
// itself another value of the same type. To get around the issue, we can use a
// `Box` - a smart pointer used to store data on the heap, which also allows us
// to wrap a recursive type.
//
// The recursive type we're implementing in this exercise is the "cons list", a
// data structure frequently found in functional programming languages. Each
// item in a cons list contains two elements: The value of the current item and
// the next item. The last item is a value called `Nil`.

#[derive(PartialEq, Debug)]
enum List {
    Cons(i32, Box<List>),
    Nil,
}

fn create_empty_list() -> List {
    List::Nil
}

fn create_non_empty_list() -> List {
    List::Cons(42, Box::new(List::Nil))
}

fn main() {
    println!("This is an empty cons list: {:?}", create_empty_list());
    println!(
        "This is a non-empty cons list: {:?}",
        create_non_empty_list(),
    );
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_empty_list() {
        assert_eq!(create_empty_list(), List::Nil);
    }

    #[test]
    fn test_create_non_empty_list() {
        assert_ne!(create_empty_list(), create_non_empty_list());
    }
}



================================================
FILE: solutions/19_smart_pointers/cow1.rs
================================================
// This exercise explores the `Cow` (Clone-On-Write) smart pointer. It can
// enclose and provide immutable access to borrowed data and clone the data
// lazily when mutation or ownership is required. The type is designed to work
// with general borrowed data via the `Borrow` trait.

use std::borrow::Cow;

fn abs_all(input: &mut Cow<[i32]>) {
    for ind in 0..input.len() {
        let value = input[ind];
        if value < 0 {
            // Clones into a vector if not already owned.
            input.to_mut()[ind] = -value;
        }
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn reference_mutation() {
        // Clone occurs because `input` needs to be mutated.
        let vec = vec![-1, 0, 1];
        let mut input = Cow::from(&vec);
        abs_all(&mut input);
        assert!(matches!(input, Cow::Owned(_)));
    }

    #[test]
    fn reference_no_mutation() {
        // No clone occurs because `input` doesn't need to be mutated.
        let vec = vec![0, 1, 2];
        let mut input = Cow::from(&vec);
        abs_all(&mut input);
        assert!(matches!(input, Cow::Borrowed(_)));
        //                      ^^^^^^^^^^^^^^^^
    }

    #[test]
    fn owned_no_mutation() {
        // We can also pass `vec` without `&` so `Cow` owns it directly. In this
        // case, no mutation occurs (all numbers are already absolute) and thus
        // also no clone. But the result is still owned because it was never
        // borrowed or mutated.
        let vec = vec![0, 1, 2];
        let mut input = Cow::from(vec);
        abs_all(&mut input);
        assert!(matches!(input, Cow::Owned(_)));
        //                      ^^^^^^^^^^^^^
    }

    #[test]
    fn owned_mutation() {
        // Of course this is also the case if a mutation does occur (not all
        // numbers are absolute). In this case, the call to `to_mut()` in the
        // `abs_all` function returns a reference to the same data as before.
        let vec = vec![-1, 0, 1];
        let mut input = Cow::from(vec);
        abs_all(&mut input);
        assert!(matches!(input, Cow::Owned(_)));
        //                      ^^^^^^^^^^^^^
    }
}



================================================
FILE: solutions/19_smart_pointers/rc1.rs
================================================
// In this exercise, we want to express the concept of multiple owners via the
// `Rc<T>` type. This is a model of our solar system - there is a `Sun` type and
// multiple `Planet`s. The planets take ownership of the sun, indicating that
// they revolve around the sun.

use std::rc::Rc;

#[derive(Debug)]
struct Sun;

#[derive(Debug)]
enum Planet {
    Mercury(Rc<Sun>),
    Venus(Rc<Sun>),
    Earth(Rc<Sun>),
    Mars(Rc<Sun>),
    Jupiter(Rc<Sun>),
    Saturn(Rc<Sun>),
    Uranus(Rc<Sun>),
    Neptune(Rc<Sun>),
}

impl Planet {
    fn details(&self) {
        println!("Hi from {self:?}!");
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn rc1() {
        let sun = Rc::new(Sun);
        println!("reference count = {}", Rc::strong_count(&sun)); // 1 reference

        let mercury = Planet::Mercury(Rc::clone(&sun));
        println!("reference count = {}", Rc::strong_count(&sun)); // 2 references
        mercury.details();

        let venus = Planet::Venus(Rc::clone(&sun));
        println!("reference count = {}", Rc::strong_count(&sun)); // 3 references
        venus.details();

        let earth = Planet::Earth(Rc::clone(&sun));
        println!("reference count = {}", Rc::strong_count(&sun)); // 4 references
        earth.details();

        let mars = Planet::Mars(Rc::clone(&sun));
        println!("reference count = {}", Rc::strong_count(&sun)); // 5 references
        mars.details();

        let jupiter = Planet::Jupiter(Rc::clone(&sun));
        println!("reference count = {}", Rc::strong_count(&sun)); // 6 references
        jupiter.details();

        let saturn = Planet::Saturn(Rc::clone(&sun));
        println!("reference count = {}", Rc::strong_count(&sun)); // 7 references
        saturn.details();

        let uranus = Planet::Uranus(Rc::clone(&sun));
        println!("reference count = {}", Rc::strong_count(&sun)); // 8 references
        uranus.details();

        let neptune = Planet::Neptune(Rc::clone(&sun));
        println!("reference count = {}", Rc::strong_count(&sun)); // 9 references
        neptune.details();

        assert_eq!(Rc::strong_count(&sun), 9);

        drop(neptune);
        println!("reference count = {}", Rc::strong_count(&sun)); // 8 references

        drop(uranus);
        println!("reference count = {}", Rc::strong_count(&sun)); // 7 references

        drop(saturn);
        println!("reference count = {}", Rc::strong_count(&sun)); // 6 references

        drop(jupiter);
        println!("reference count = {}", Rc::strong_count(&sun)); // 5 references

        drop(mars);
        println!("reference count = {}", Rc::strong_count(&sun)); // 4 references

        drop(earth);
        println!("reference count = {}", Rc::strong_count(&sun)); // 3 references

        drop(venus);
        println!("reference count = {}", Rc::strong_count(&sun)); // 2 references

        drop(mercury);
        println!("reference count = {}", Rc::strong_count(&sun)); // 1 reference

        assert_eq!(Rc::strong_count(&sun), 1);
    }
}



================================================
FILE: solutions/20_threads/threads1.rs
================================================
// This program spawns multiple threads that each runs for at least 250ms, and
// each thread returns how much time it took to complete. The program should
// wait until all the spawned threads have finished and should collect their
// return values into a vector.

use std::{
    thread,
    time::{Duration, Instant},
};

fn main() {
    let mut handles = Vec::new();
    for i in 0..10 {
        let handle = thread::spawn(move || {
            let start = Instant::now();
            thread::sleep(Duration::from_millis(250));
            println!("Thread {i} done");
            start.elapsed().as_millis()
        });
        handles.push(handle);
    }

    let mut results = Vec::new();
    for handle in handles {
        // Collect the results of all threads into the `results` vector.
        results.push(handle.join().unwrap());
    }

    if results.len() != 10 {
        panic!("Oh no! Some thread isn't done yet!");
    }

    println!();
    for (i, result) in results.into_iter().enumerate() {
        println!("Thread {i} took {result}ms");
    }
}



================================================
FILE: solutions/20_threads/threads2.rs
================================================
// Building on the last exercise, we want all of the threads to complete their
// work. But this time, the spawned threads need to be in charge of updating a
// shared value: `JobStatus.jobs_done`

use std::{
    sync::{Arc, Mutex},
    thread,
    time::Duration,
};

struct JobStatus {
    jobs_done: u32,
}

fn main() {
    // `Arc` isn't enough if you want a **mutable** shared state.
    // We need to wrap the value with a `Mutex`.
    let status = Arc::new(Mutex::new(JobStatus { jobs_done: 0 }));
    //                    ^^^^^^^^^^^                          ^

    let mut handles = Vec::new();
    for _ in 0..10 {
        let status_shared = Arc::clone(&status);
        let handle = thread::spawn(move || {
            thread::sleep(Duration::from_millis(250));

            // Lock before you update a shared value.
            status_shared.lock().unwrap().jobs_done += 1;
            //           ^^^^^^^^^^^^^^^^
        });
        handles.push(handle);
    }

    // Waiting for all jobs to complete.
    for handle in handles {
        handle.join().unwrap();
    }

    println!("Jobs done: {}", status.lock().unwrap().jobs_done);
    //                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
}



================================================
FILE: solutions/20_threads/threads3.rs
================================================
use std::{sync::mpsc, thread, time::Duration};

struct Queue {
    first_half: Vec<u32>,
    second_half: Vec<u32>,
}

impl Queue {
    fn new() -> Self {
        Self {
            first_half: vec![1, 2, 3, 4, 5],
            second_half: vec![6, 7, 8, 9, 10],
        }
    }
}

fn send_tx(q: Queue, tx: mpsc::Sender<u32>) {
    // Clone the sender `tx` first.
    let tx_clone = tx.clone();
    thread::spawn(move || {
        for val in q.first_half {
            println!("Sending {val:?}");
            // Then use the clone in the first thread. This means that
            // `tx_clone` is moved to the first thread and `tx` to the second.
            tx_clone.send(val).unwrap();
            thread::sleep(Duration::from_millis(250));
        }
    });

    thread::spawn(move || {
        for val in q.second_half {
            println!("Sending {val:?}");
            tx.send(val).unwrap();
            thread::sleep(Duration::from_millis(250));
        }
    });
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn threads3() {
        let (tx, rx) = mpsc::channel();
        let queue = Queue::new();

        send_tx(queue, tx);

        let mut received = Vec::with_capacity(10);
        for value in rx {
            received.push(value);
        }

        received.sort();
        assert_eq!(received, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    }
}



================================================
FILE: solutions/21_macros/macros1.rs
================================================
macro_rules! my_macro {
    () => {
        println!("Check out my macro!");
    };
}

fn main() {
    my_macro!();
    //      ^
}



================================================
FILE: solutions/21_macros/macros2.rs
================================================
// Moved the macro definition to be before its call.
macro_rules! my_macro {
    () => {
        println!("Check out my macro!");
    };
}

fn main() {
    my_macro!();
}



================================================
FILE: solutions/21_macros/macros3.rs
================================================
// Added the attribute `macro_use` attribute.
#[macro_use]
mod macros {
    macro_rules! my_macro {
        () => {
            println!("Check out my macro!");
        };
    }
}

fn main() {
    my_macro!();
}



================================================
FILE: solutions/21_macros/macros4.rs
================================================
// Added semicolons to separate the macro arms.
#[rustfmt::skip]
macro_rules! my_macro {
    () => {
        println!("Check out my macro!");
    };
    ($val:expr) => {
        println!("Look at this other macro: {}", $val);
    };
}

fn main() {
    my_macro!();
    my_macro!(7777);
}



================================================
FILE: solutions/22_clippy/clippy1.rs
================================================
// The Clippy tool is a collection of lints to analyze your code so you can
// catch common mistakes and improve your Rust code.
//
// For these exercises, the code will fail to compile when there are Clippy
// warnings. Check Clippy's suggestions from the output to solve the exercise.

use std::f32::consts::PI;

fn main() {
    // Use the more accurate `PI` constant.
    let pi = PI;
    let radius: f32 = 5.0;

    let area = pi * radius.powi(2);

    println!("The area of a circle with radius {radius:.2} is {area:.5}");
}



================================================
FILE: solutions/22_clippy/clippy2.rs
================================================
fn main() {
    let mut res = 42;
    let option = Some(12);
    // Use `if-let` instead of iteration.
    if let Some(x) = option {
        res += x;
    }

    println!("{res}");
}



================================================
FILE: solutions/22_clippy/clippy3.rs
================================================
use std::mem;

#[rustfmt::skip]
#[allow(unused_variables, unused_assignments)]
fn main() {
    let my_option: Option<&str> = None;
    // `unwrap` of an `Option` after checking if it is `None` will panic.
    // Use `if-let` instead.
    if let Some(value) = my_option {
        println!("{value}");
    }

    // A comma was missing.
    let my_arr = &[
        -1, -2, -3,
        -4, -5, -6,
    ];
    println!("My array! Here it is: {my_arr:?}");

    let mut my_empty_vec = vec![1, 2, 3, 4, 5];
    // `resize` mutates a vector instead of returning a new one.
    // `resize(0, …)` clears a vector, so it is better to use `clear`.
    my_empty_vec.clear();
    println!("This Vec is empty, see? {my_empty_vec:?}");

    let mut value_a = 45;
    let mut value_b = 66;
    // Use `mem::swap` to correctly swap two values.
    mem::swap(&mut value_a, &mut value_b);
    println!("value a: {value_a}; value b: {value_b}");
}



================================================
FILE: solutions/23_conversions/as_ref_mut.rs
================================================
// AsRef and AsMut allow for cheap reference-to-reference conversions. Read more
// about them at https://doc.rust-lang.org/std/convert/trait.AsRef.html and
// https://doc.rust-lang.org/std/convert/trait.AsMut.html, respectively.

// Obtain the number of bytes (not characters) in the given argument
// (`.len()` returns the number of bytes in a string).
fn byte_counter<T: AsRef<str>>(arg: T) -> usize {
    arg.as_ref().len()
}

// Obtain the number of characters (not bytes) in the given argument.
fn char_counter<T: AsRef<str>>(arg: T) -> usize {
    arg.as_ref().chars().count()
}

// Squares a number using `as_mut()`.
fn num_sq<T: AsMut<u32>>(arg: &mut T) {
    let arg = arg.as_mut();
    *arg *= *arg;
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn different_counts() {
        let s = "Café au lait";
        assert_ne!(char_counter(s), byte_counter(s));
    }

    #[test]
    fn same_counts() {
        let s = "Cafe au lait";
        assert_eq!(char_counter(s), byte_counter(s));
    }

    #[test]
    fn different_counts_using_string() {
        let s = String::from("Café au lait");
        assert_ne!(char_counter(s.clone()), byte_counter(s));
    }

    #[test]
    fn same_counts_using_string() {
        let s = String::from("Cafe au lait");
        assert_eq!(char_counter(s.clone()), byte_counter(s));
    }

    #[test]
    fn mut_box() {
        let mut num: Box<u32> = Box::new(3);
        num_sq(&mut num);
        assert_eq!(*num, 9);
    }
}



================================================
FILE: solutions/23_conversions/from_into.rs
================================================
// The `From` trait is used for value-to-value conversions. If `From` is
// implemented, an implementation of `Into` is automatically provided.
// You can read more about it in the documentation:
// https://doc.rust-lang.org/std/convert/trait.From.html

#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

// We implement the Default trait to use it as a fallback when the provided
// string is not convertible into a `Person` object.
impl Default for Person {
    fn default() -> Self {
        Self {
            name: String::from("John"),
            age: 30,
        }
    }
}

impl From<&str> for Person {
    fn from(s: &str) -> Self {
        let mut split = s.split(',');
        let (Some(name), Some(age), None) = (split.next(), split.next(), split.next()) else {
            //                      ^^^^ there should be no third element
            return Self::default();
        };

        if name.is_empty() {
            return Self::default();
        }

        let Ok(age) = age.parse() else {
            return Self::default();
        };

        Self {
            name: name.into(),
            age,
        }
    }
}

fn main() {
    // Use the `from` function.
    let p1 = Person::from("Mark,20");
    println!("{p1:?}");

    // Since `From` is implemented for Person, we are able to use `Into`.
    let p2: Person = "Gerald,70".into();
    println!("{p2:?}");
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default() {
        let dp = Person::default();
        assert_eq!(dp.name, "John");
        assert_eq!(dp.age, 30);
    }

    #[test]
    fn test_bad_convert() {
        let p = Person::from("");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_good_convert() {
        let p = Person::from("Mark,20");
        assert_eq!(p.name, "Mark");
        assert_eq!(p.age, 20);
    }

    #[test]
    fn test_bad_age() {
        let p = Person::from("Mark,twenty");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_comma_and_age() {
        let p: Person = Person::from("Mark");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_age() {
        let p: Person = Person::from("Mark,");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name() {
        let p: Person = Person::from(",1");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name_and_age() {
        let p: Person = Person::from(",");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name_and_invalid_age() {
        let p: Person = Person::from(",one");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_trailing_comma() {
        let p: Person = Person::from("Mike,32,");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_trailing_comma_and_some_string() {
        let p: Person = Person::from("Mike,32,dog");
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 30);
    }
}



================================================
FILE: solutions/23_conversions/from_str.rs
================================================
// This is similar to the previous `from_into` exercise. But this time, we'll
// implement `FromStr` and return errors instead of falling back to a default
// value. Additionally, upon implementing `FromStr`, you can use the `parse`
// method on strings to generate an object of the implementor type. You can read
// more about it in the documentation:
// https://doc.rust-lang.org/std/str/trait.FromStr.html

use std::num::ParseIntError;
use std::str::FromStr;

#[derive(Debug, PartialEq)]
struct Person {
    name: String,
    age: u8,
}

// We will use this error type for the `FromStr` implementation.
#[derive(Debug, PartialEq)]
enum ParsePersonError {
    // Incorrect number of fields
    BadLen,
    // Empty name field
    NoName,
    // Wrapped error from parse::<u8>()
    ParseInt(ParseIntError),
}

impl FromStr for Person {
    type Err = ParsePersonError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut split = s.split(',');
        let (Some(name), Some(age), None) = (split.next(), split.next(), split.next()) else {
            //                      ^^^^ there should be no third element
            return Err(ParsePersonError::BadLen);
        };

        if name.is_empty() {
            return Err(ParsePersonError::NoName);
        }

        let age = age.parse().map_err(ParsePersonError::ParseInt)?;

        Ok(Self {
            name: name.into(),
            age,
        })
    }
}

fn main() {
    let p = "Mark,20".parse::<Person>();
    println!("{p:?}");
}

#[cfg(test)]
mod tests {
    use super::*;
    use ParsePersonError::*;

    #[test]
    fn empty_input() {
        assert_eq!("".parse::<Person>(), Err(BadLen));
    }

    #[test]
    fn good_input() {
        let p = "John,32".parse::<Person>();
        assert!(p.is_ok());
        let p = p.unwrap();
        assert_eq!(p.name, "John");
        assert_eq!(p.age, 32);
    }

    #[test]
    fn missing_age() {
        assert!(matches!("John,".parse::<Person>(), Err(ParseInt(_))));
    }

    #[test]
    fn invalid_age() {
        assert!(matches!("John,twenty".parse::<Person>(), Err(ParseInt(_))));
    }

    #[test]
    fn missing_comma_and_age() {
        assert_eq!("John".parse::<Person>(), Err(BadLen));
    }

    #[test]
    fn missing_name() {
        assert_eq!(",1".parse::<Person>(), Err(NoName));
    }

    #[test]
    fn missing_name_and_age() {
        assert!(matches!(",".parse::<Person>(), Err(NoName | ParseInt(_))));
    }

    #[test]
    fn missing_name_and_invalid_age() {
        assert!(matches!(
            ",one".parse::<Person>(),
            Err(NoName | ParseInt(_)),
        ));
    }

    #[test]
    fn trailing_comma() {
        assert_eq!("John,32,".parse::<Person>(), Err(BadLen));
    }

    #[test]
    fn trailing_comma_and_some_string() {
        assert_eq!("John,32,man".parse::<Person>(), Err(BadLen));
    }
}



================================================
FILE: solutions/23_conversions/try_from_into.rs
================================================
// `TryFrom` is a simple and safe type conversion that may fail in a controlled
// way under some circumstances. Basically, this is the same as `From`. The main
// difference is that this should return a `Result` type instead of the target
// type itself. You can read more about it in the documentation:
// https://doc.rust-lang.org/std/convert/trait.TryFrom.html

#![allow(clippy::useless_vec)]
use std::convert::{TryFrom, TryInto};

#[derive(Debug, PartialEq)]
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}

// We will use this error type for the `TryFrom` conversions.
#[derive(Debug, PartialEq)]
enum IntoColorError {
    // Incorrect length of slice
    BadLen,
    // Integer conversion error
    IntConversion,
}

impl TryFrom<(i16, i16, i16)> for Color {
    type Error = IntoColorError;

    fn try_from(tuple: (i16, i16, i16)) -> Result<Self, Self::Error> {
        let (Ok(red), Ok(green), Ok(blue)) = (
            u8::try_from(tuple.0),
            u8::try_from(tuple.1),
            u8::try_from(tuple.2),
        ) else {
            return Err(IntoColorError::IntConversion);
        };

        Ok(Self { red, green, blue })
    }
}

impl TryFrom<[i16; 3]> for Color {
    type Error = IntoColorError;

    fn try_from(arr: [i16; 3]) -> Result<Self, Self::Error> {
        // Reuse the implementation for a tuple.
        Self::try_from((arr[0], arr[1], arr[2]))
    }
}

impl TryFrom<&[i16]> for Color {
    type Error = IntoColorError;

    fn try_from(slice: &[i16]) -> Result<Self, Self::Error> {
        // Check the length.
        if slice.len() != 3 {
            return Err(IntoColorError::BadLen);
        }

        // Reuse the implementation for a tuple.
        Self::try_from((slice[0], slice[1], slice[2]))
    }
}

fn main() {
    // Using the `try_from` function.
    let c1 = Color::try_from((183, 65, 14));
    println!("{c1:?}");

    // Since `TryFrom` is implemented for `Color`, we can use `TryInto`.
    let c2: Result<Color, _> = [183, 65, 14].try_into();
    println!("{c2:?}");

    let v = vec![183, 65, 14];
    // With slice we should use the `try_from` function
    let c3 = Color::try_from(&v[..]);
    println!("{c3:?}");
    // or put the slice within round brackets and use `try_into`.
    let c4: Result<Color, _> = (&v[..]).try_into();
    println!("{c4:?}");
}

#[cfg(test)]
mod tests {
    use super::*;
    use IntoColorError::*;

    #[test]
    fn test_tuple_out_of_range_positive() {
        assert_eq!(Color::try_from((256, 1000, 10000)), Err(IntConversion));
    }

    #[test]
    fn test_tuple_out_of_range_negative() {
        assert_eq!(Color::try_from((-1, -10, -256)), Err(IntConversion));
    }

    #[test]
    fn test_tuple_sum() {
        assert_eq!(Color::try_from((-1, 255, 255)), Err(IntConversion));
    }

    #[test]
    fn test_tuple_correct() {
        let c: Result<Color, _> = (183, 65, 14).try_into();
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14,
            }
        );
    }

    #[test]
    fn test_array_out_of_range_positive() {
        let c: Result<Color, _> = [1000, 10000, 256].try_into();
        assert_eq!(c, Err(IntConversion));
    }

    #[test]
    fn test_array_out_of_range_negative() {
        let c: Result<Color, _> = [-10, -256, -1].try_into();
        assert_eq!(c, Err(IntConversion));
    }

    #[test]
    fn test_array_sum() {
        let c: Result<Color, _> = [-1, 255, 255].try_into();
        assert_eq!(c, Err(IntConversion));
    }

    #[test]
    fn test_array_correct() {
        let c: Result<Color, _> = [183, 65, 14].try_into();
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }

    #[test]
    fn test_slice_out_of_range_positive() {
        let arr = [10000, 256, 1000];
        assert_eq!(Color::try_from(&arr[..]), Err(IntConversion));
    }

    #[test]
    fn test_slice_out_of_range_negative() {
        let arr = [-256, -1, -10];
        assert_eq!(Color::try_from(&arr[..]), Err(IntConversion));
    }

    #[test]
    fn test_slice_sum() {
        let arr = [-1, 255, 255];
        assert_eq!(Color::try_from(&arr[..]), Err(IntConversion));
    }

    #[test]
    fn test_slice_correct() {
        let v = vec![183, 65, 14];
        let c: Result<Color, _> = Color::try_from(&v[..]);
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14,
            }
        );
    }

    #[test]
    fn test_slice_excess_length() {
        let v = vec![0, 0, 0, 0];
        assert_eq!(Color::try_from(&v[..]), Err(BadLen));
    }

    #[test]
    fn test_slice_insufficient_length() {
        let v = vec![0, 0];
        assert_eq!(Color::try_from(&v[..]), Err(BadLen));
    }
}



================================================
FILE: solutions/23_conversions/using_as.rs
================================================
// Type casting in Rust is done via the usage of the `as` operator.
// Note that the `as` operator is not only used when type casting. It also helps
// with renaming imports.

fn average(values: &[f64]) -> f64 {
    let total = values.iter().sum::<f64>();
    total / values.len() as f64
    //                   ^^^^^^
}

fn main() {
    let values = [3.5, 0.3, 13.0, 11.7];
    println!("{}", average(&values));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn returns_proper_type_and_value() {
        assert_eq!(average(&[3.5, 0.3, 13.0, 11.7]), 7.125);
    }
}



================================================
FILE: solutions/quizzes/quiz1.rs
================================================
// Mary is buying apples. The price of an apple is calculated as follows:
// - An apple costs 2 rustbucks.
// - However, if Mary buys more than 40 apples, the price of each apple in the
// entire order is reduced to only 1 rustbuck!

fn calculate_price_of_apples(n_apples: u64) -> u64 {
    if n_apples > 40 {
        n_apples
    } else {
        2 * n_apples
    }
}

fn main() {
    // You can optionally experiment here.
}

// Don't change the tests!
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn verify_test() {
        assert_eq!(calculate_price_of_apples(35), 70);
        assert_eq!(calculate_price_of_apples(40), 80);
        assert_eq!(calculate_price_of_apples(41), 41);
        assert_eq!(calculate_price_of_apples(65), 65);
    }
}



================================================
FILE: solutions/quizzes/quiz2.rs
================================================
// Let's build a little machine in the form of a function. As input, we're going
// to give a list of strings and commands. These commands determine what action
// is going to be applied to the string. It can either be:
// - Uppercase the string
// - Trim the string
// - Append "bar" to the string a specified amount of times
//
// The exact form of this will be:
// - The input is going to be a vector of 2-length tuples,
//   the first element is the string, the second one is the command.
// - The output element is going to be a vector of strings.

enum Command {
    Uppercase,
    Trim,
    Append(usize),
}

mod my_module {
    use super::Command;

    // The solution with a loop. Check out `transformer_iter` for a version
    // with iterators.
    pub fn transformer(input: Vec<(String, Command)>) -> Vec<String> {
        let mut output = Vec::new();

        for (string, command) in input {
            // Create the new string.
            let new_string = match command {
                Command::Uppercase => string.to_uppercase(),
                Command::Trim => string.trim().to_string(),
                Command::Append(n) => string + &"bar".repeat(n),
            };

            // Push the new string to the output vector.
            output.push(new_string);
        }

        output
    }

    // Equivalent to `transform` but uses an iterator instead of a loop for
    // comparison. Don't worry, we will practice iterators later ;)
    pub fn transformer_iter(input: Vec<(String, Command)>) -> Vec<String> {
        input
            .into_iter()
            .map(|(string, command)| match command {
                Command::Uppercase => string.to_uppercase(),
                Command::Trim => string.trim().to_string(),
                Command::Append(n) => string + &"bar".repeat(n),
            })
            .collect()
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    // Import `transformer`.
    use super::my_module::transformer;

    use super::Command;
    use super::my_module::transformer_iter;

    #[test]
    fn it_works() {
        for transformer in [transformer, transformer_iter] {
            let input = vec![
                ("hello".to_string(), Command::Uppercase),
                (" all roads lead to rome! ".to_string(), Command::Trim),
                ("foo".to_string(), Command::Append(1)),
                ("bar".to_string(), Command::Append(5)),
            ];
            let output = transformer(input);

            assert_eq!(
                output,
                [
                    "HELLO",
                    "all roads lead to rome!",
                    "foobar",
                    "barbarbarbarbarbar",
                ]
            );
        }
    }
}



================================================
FILE: solutions/quizzes/quiz3.rs
================================================
// An imaginary magical school has a new report card generation system written
// in Rust! Currently, the system only supports creating report cards where the
// student's grade is represented numerically (e.g. 1.0 -> 5.5). However, the
// school also issues alphabetical grades (A+ -> F-) and needs to be able to
// print both types of report card!
//
// Make the necessary code changes in the struct `ReportCard` and the impl
// block to support alphabetical report cards in addition to numerical ones.

use std::fmt::Display;

// Make the struct generic over `T`.
struct ReportCard<T> {
    //           ^^^
    grade: T,
    //     ^
    student_name: String,
    student_age: u8,
}

// To be able to print the grade, it has to implement the `Display` trait.
impl<T: Display> ReportCard<T> {
    //  ^^^^^^^ require that `T` implements `Display`.
    fn print(&self) -> String {
        format!(
            "{} ({}) - achieved a grade of {}",
            &self.student_name, &self.student_age, &self.grade,
        )
    }
}

fn main() {
    // You can optionally experiment here.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generate_numeric_report_card() {
        let report_card = ReportCard {
            grade: 2.1,
            student_name: "Tom Wriggle".to_string(),
            student_age: 12,
        };
        assert_eq!(
            report_card.print(),
            "Tom Wriggle (12) - achieved a grade of 2.1",
        );
    }

    #[test]
    fn generate_alphabetic_report_card() {
        let report_card = ReportCard {
            grade: "A+",
            student_name: "Gary Plotter".to_string(),
            student_age: 11,
        };
        assert_eq!(
            report_card.print(),
            "Gary Plotter (11) - achieved a grade of A+",
        );
    }
}



================================================
FILE: src/app_state.rs
================================================
use anyhow::{Context, Error, Result, bail};
use crossterm::{QueueableCommand, cursor, terminal};
use std::{
    collections::HashSet,
    env,
    fs::{File, OpenOptions},
    io::{Read, Seek, StdoutLock, Write},
    path::{MAIN_SEPARATOR_STR, Path},
    process::{Command, Stdio},
    sync::{
        atomic::{AtomicUsize, Ordering::Relaxed},
        mpsc,
    },
    thread,
};

use crate::{
    clear_terminal,
    cmd::CmdRunner,
    embedded::EMBEDDED_FILES,
    exercise::{Exercise, RunnableExercise},
    info_file::ExerciseInfo,
    term::{self, CheckProgressVisualizer},
};

const STATE_FILE_NAME: &str = ".rustlings-state.txt";
const DEFAULT_CHECK_PARALLELISM: usize = 8;

#[must_use]
pub enum ExercisesProgress {
    // All exercises are done.
    AllDone,
    // A new exercise is now pending.
    NewPending,
    // The current exercise is still pending.
    CurrentPending,
}

pub enum StateFileStatus {
    Read,
    NotRead,
}

#[derive(Clone, Copy)]
pub enum CheckProgress {
    None,
    Checking,
    Done,
    Pending,
}

pub struct AppState {
    current_exercise_ind: usize,
    exercises: Vec<Exercise>,
    // Caches the number of done exercises to avoid iterating over all exercises every time.
    n_done: u16,
    final_message: String,
    state_file: File,
    // Preallocated buffer for reading and writing the state file.
    file_buf: Vec<u8>,
    official_exercises: bool,
    cmd_runner: CmdRunner,
    emit_file_links: bool,
}

impl AppState {
    pub fn new(
        exercise_infos: Vec<ExerciseInfo>,
        final_message: String,
    ) -> Result<(Self, StateFileStatus)> {
        let cmd_runner = CmdRunner::build()?;
        let mut state_file = OpenOptions::new()
            .create(true)
            .read(true)
            .write(true)
            .truncate(false)
            .open(STATE_FILE_NAME)
            .with_context(|| {
                format!("Failed to open or create the state file {STATE_FILE_NAME}")
            })?;

        let dir_canonical_path = term::canonicalize("exercises");
        let mut exercises = exercise_infos
            .into_iter()
            .map(|exercise_info| {
                // Leaking to be able to borrow in the watch mode `Table`.
                // Leaking is not a problem because the `AppState` instance lives until
                // the end of the program.
                let path = exercise_info.path().leak();
                let name = exercise_info.name.leak();
                let dir = exercise_info.dir.map(|dir| &*dir.leak());
                let hint = exercise_info.hint.leak().trim_ascii();

                let canonical_path = dir_canonical_path.as_deref().map(|dir_canonical_path| {
                    let mut canonical_path;
                    if let Some(dir) = dir {
                        canonical_path = String::with_capacity(
                            2 + dir_canonical_path.len() + dir.len() + name.len(),
                        );
                        canonical_path.push_str(dir_canonical_path);
                        canonical_path.push_str(MAIN_SEPARATOR_STR);
                        canonical_path.push_str(dir);
                    } else {
                        canonical_path =
                            String::with_capacity(1 + dir_canonical_path.len() + name.len());
                        canonical_path.push_str(dir_canonical_path);
                    }

                    canonical_path.push_str(MAIN_SEPARATOR_STR);
                    canonical_path.push_str(name);
                    canonical_path.push_str(".rs");
                    canonical_path
                });

                Exercise {
                    dir,
                    name,
                    path,
                    canonical_path,
                    test: exercise_info.test,
                    strict_clippy: exercise_info.strict_clippy,
                    hint,
                    // Updated below.
                    done: false,
                }
            })
            .collect::<Vec<_>>();

        let mut current_exercise_ind = 0;
        let mut n_done = 0;
        let mut file_buf = Vec::with_capacity(2048);
        let state_file_status = 'block: {
            if state_file.read_to_end(&mut file_buf).is_err() {
                break 'block StateFileStatus::NotRead;
            }

            // See `Self::write` for more information about the file format.
            let mut lines = file_buf.split(|c| *c == b'\n').skip(2);

            let Some(current_exercise_name) = lines.next() else {
                break 'block StateFileStatus::NotRead;
            };

            if current_exercise_name.is_empty() || lines.next().is_none() {
                break 'block StateFileStatus::NotRead;
            }

            let mut done_exercises = HashSet::with_capacity(exercises.len());

            for done_exercise_name in lines {
                if done_exercise_name.is_empty() {
                    break;
                }
                done_exercises.insert(done_exercise_name);
            }

            for (ind, exercise) in exercises.iter_mut().enumerate() {
                if done_exercises.contains(exercise.name.as_bytes()) {
                    exercise.done = true;
                    n_done += 1;
                }

                if exercise.name.as_bytes() == current_exercise_name {
                    current_exercise_ind = ind;
                }
            }

            StateFileStatus::Read
        };

        file_buf.clear();
        file_buf.extend_from_slice(STATE_FILE_HEADER);

        let slf = Self {
            current_exercise_ind,
            exercises,
            n_done,
            final_message,
            state_file,
            file_buf,
            official_exercises: !Path::new("info.toml").exists(),
            cmd_runner,
            // VS Code has its own file link handling
            emit_file_links: env::var_os("TERM_PROGRAM").is_none_or(|v| v != "vscode"),
        };

        Ok((slf, state_file_status))
    }

    #[inline]
    pub fn current_exercise_ind(&self) -> usize {
        self.current_exercise_ind
    }

    #[inline]
    pub fn exercises(&self) -> &[Exercise] {
        &self.exercises
    }

    #[inline]
    pub fn n_done(&self) -> u16 {
        self.n_done
    }

    #[inline]
    pub fn n_pending(&self) -> u16 {
        self.exercises.len() as u16 - self.n_done
    }

    #[inline]
    pub fn current_exercise(&self) -> &Exercise {
        &self.exercises[self.current_exercise_ind]
    }

    #[inline]
    pub fn cmd_runner(&self) -> &CmdRunner {
        &self.cmd_runner
    }

    #[inline]
    pub fn emit_file_links(&self) -> bool {
        self.emit_file_links
    }

    // Write the state file.
    // The file's format is very simple:
    // - The first line is a comment.
    // - The second line is an empty line.
    // - The third line is the name of the current exercise. It must end with `\n` even if there
    // are no done exercises.
    // - The fourth line is an empty line.
    // - All remaining lines are the names of done exercises.
    fn write(&mut self) -> Result<()> {
        self.file_buf.truncate(STATE_FILE_HEADER.len());

        self.file_buf
            .extend_from_slice(self.current_exercise().name.as_bytes());
        self.file_buf.push(b'\n');

        for exercise in &self.exercises {
            if exercise.done {
                self.file_buf.push(b'\n');
                self.file_buf.extend_from_slice(exercise.name.as_bytes());
            }
        }

        self.state_file
            .rewind()
            .with_context(|| format!("Failed to rewind the state file {STATE_FILE_NAME}"))?;
        self.state_file
            .set_len(0)
            .with_context(|| format!("Failed to truncate the state file {STATE_FILE_NAME}"))?;
        self.state_file
            .write_all(&self.file_buf)
            .with_context(|| format!("Failed to write the state file {STATE_FILE_NAME}"))?;

        Ok(())
    }

    pub fn set_current_exercise_ind(&mut self, exercise_ind: usize) -> Result<()> {
        if exercise_ind == self.current_exercise_ind {
            return Ok(());
        }

        if exercise_ind >= self.exercises.len() {
            bail!(BAD_INDEX_ERR);
        }

        self.current_exercise_ind = exercise_ind;

        self.write()
    }

    pub fn set_current_exercise_by_name(&mut self, name: &str) -> Result<()> {
        // O(N) is fine since this method is used only once until the program exits.
        // Building a hashmap would have more overhead.
        self.current_exercise_ind = self
            .exercises
            .iter()
            .position(|exercise| exercise.name == name)
            .with_context(|| format!("No exercise found for '{name}'!"))?;

        self.write()
    }

    // Set the status of an exercise without saving. Returns `true` if the
    // status actually changed (and thus needs saving later).
    pub fn set_status(&mut self, exercise_ind: usize, done: bool) -> Result<bool> {
        let exercise = self
            .exercises
            .get_mut(exercise_ind)
            .context(BAD_INDEX_ERR)?;

        if exercise.done == done {
            return Ok(false);
        }

        exercise.done = done;
        if done {
            self.n_done += 1;
        } else {
            self.n_done -= 1;
        }

        Ok(true)
    }

    // Set the status of an exercise to "pending" and save.
    pub fn set_pending(&mut self, exercise_ind: usize) -> Result<()> {
        if self.set_status(exercise_ind, false)? {
            self.write()?;
        }

        Ok(())
    }

    // Official exercises: Dump the original file from the binary.
    // Community exercises: Reset the exercise file with `git stash`.
    fn reset(&self, exercise_ind: usize, path: &str) -> Result<()> {
        if self.official_exercises {
            return EMBEDDED_FILES
                .write_exercise_to_disk(exercise_ind, path)
                .with_context(|| format!("Failed to reset the exercise {path}"));
        }

        let output = Command::new("git")
            .arg("stash")
            .arg("push")
            .arg("--")
            .arg(path)
            .stdin(Stdio::null())
            .stdout(Stdio::null())
            .output()
            .with_context(|| format!("Failed to run `git stash push -- {path}`"))?;

        if !output.status.success() {
            bail!(
                "`git stash push -- {path}` didn't run successfully: {}",
                String::from_utf8_lossy(&output.stderr),
            );
        }

        Ok(())
    }

    pub fn reset_current_exercise(&mut self) -> Result<&'static str> {
        self.set_pending(self.current_exercise_ind)?;
        let exercise = self.current_exercise();
        self.reset(self.current_exercise_ind, exercise.path)?;

        Ok(exercise.path)
    }

    // Reset the exercise by index and return its name.
    pub fn reset_exercise_by_ind(&mut self, exercise_ind: usize) -> Result<&'static str> {
        if exercise_ind >= self.exercises.len() {
            bail!(BAD_INDEX_ERR);
        }

        self.set_pending(exercise_ind)?;
        let exercise = &self.exercises[exercise_ind];
        self.reset(exercise_ind, exercise.path)?;

        Ok(exercise.name)
    }

    // Return the index of the next pending exercise or `None` if all exercises are done.
    fn next_pending_exercise_ind(&self) -> Option<usize> {
        let next_ind = self.current_exercise_ind + 1;
        self.exercises
            // If the exercise done isn't the last, search for pending exercises after it.
            .get(next_ind..)
            .and_then(|later_exercises| {
                later_exercises
                    .iter()
                    .position(|exercise| !exercise.done)
                    .map(|ind| next_ind + ind)
            })
            // Search from the start.
            .or_else(|| {
                self.exercises[..self.current_exercise_ind]
                    .iter()
                    .position(|exercise| !exercise.done)
            })
    }

    /// Official exercises: Dump the solution file from the binary and return its path.
    /// Community exercises: Check if a solution file exists and return its path in that case.
    pub fn current_solution_path(&self) -> Result<Option<String>> {
        if cfg!(debug_assertions) {
            return Ok(None);
        }

        let current_exercise = self.current_exercise();

        if self.official_exercises {
            EMBEDDED_FILES
                .write_solution_to_disk(self.current_exercise_ind, current_exercise.name)
                .map(Some)
        } else {
            let sol_path = current_exercise.sol_path();

            if Path::new(&sol_path).exists() {
                return Ok(Some(sol_path));
            }

            Ok(None)
        }
    }

    fn check_all_exercises_impl(&mut self, stdout: &mut StdoutLock) -> Result<Option<usize>> {
        let term_width = terminal::size()
            .context("Failed to get the terminal size")?
            .0;
        let mut progress_visualizer = CheckProgressVisualizer::build(stdout, term_width)?;

        let next_exercise_ind = AtomicUsize::new(0);
        let mut progresses = vec![CheckProgress::None; self.exercises.len()];

        thread::scope(|s| {
            let (exercise_progress_sender, exercise_progress_receiver) = mpsc::channel();
            let n_threads = thread::available_parallelism()
                .map_or(DEFAULT_CHECK_PARALLELISM, |count| count.get());

            for _ in 0..n_threads {
                let exercise_progress_sender = exercise_progress_sender.clone();
                let next_exercise_ind = &next_exercise_ind;
                let slf = &self;
                thread::Builder::new()
                    .spawn_scoped(s, move || {
                        loop {
                            let exercise_ind = next_exercise_ind.fetch_add(1, Relaxed);
                            let Some(exercise) = slf.exercises.get(exercise_ind) else {
                                // No more exercises.
                                break;
                            };

                            if exercise_progress_sender
                                .send((exercise_ind, CheckProgress::Checking))
                                .is_err()
                            {
                                break;
                            };

                            let success = exercise.run_exercise(None, &slf.cmd_runner);
                            let progress = match success {
                                Ok(true) => CheckProgress::Done,
                                Ok(false) => CheckProgress::Pending,
                                Err(_) => CheckProgress::None,
                            };

                            if exercise_progress_sender
                                .send((exercise_ind, progress))
                                .is_err()
                            {
                                break;
                            }
                        }
                    })
                    .context("Failed to spawn a thread to check all exercises")?;
            }

            // Drop this sender to detect when the last thread is done.
            drop(exercise_progress_sender);

            while let Ok((exercise_ind, progress)) = exercise_progress_receiver.recv() {
                progresses[exercise_ind] = progress;
                progress_visualizer.update(&progresses)?;
            }

            Ok::<_, Error>(())
        })?;

        let mut first_pending_exercise_ind = None;
        for exercise_ind in 0..progresses.len() {
            match progresses[exercise_ind] {
                CheckProgress::Done => {
                    self.set_status(exercise_ind, true)?;
                }
                CheckProgress::Pending => {
                    self.set_status(exercise_ind, false)?;
                    if first_pending_exercise_ind.is_none() {
                        first_pending_exercise_ind = Some(exercise_ind);
                    }
                }
                CheckProgress::None | CheckProgress::Checking => {
                    // If we got an error while checking all exercises in parallel,
                    // it could be because we exceeded the limit of open file descriptors.
                    // Therefore, try running exercises with errors sequentially.
                    progresses[exercise_ind] = CheckProgress::Checking;
                    progress_visualizer.update(&progresses)?;

                    let exercise = &self.exercises[exercise_ind];
                    let success = exercise.run_exercise(None, &self.cmd_runner)?;
                    if success {
                        progresses[exercise_ind] = CheckProgress::Done;
                    } else {
                        progresses[exercise_ind] = CheckProgress::Pending;
                        if first_pending_exercise_ind.is_none() {
                            first_pending_exercise_ind = Some(exercise_ind);
                        }
                    }
                    self.set_status(exercise_ind, success)?;
                    progress_visualizer.update(&progresses)?;
                }
            }
        }

        self.write()?;

        Ok(first_pending_exercise_ind)
    }

    // Return the exercise index of the first pending exercise found.
    pub fn check_all_exercises(&mut self, stdout: &mut StdoutLock) -> Result<Option<usize>> {
        stdout.queue(cursor::Hide)?;
        let res = self.check_all_exercises_impl(stdout);
        stdout.queue(cursor::Show)?;

        res
    }

    /// Mark the current exercise as done and move on to the next pending exercise if one exists.
    /// If all exercises are marked as done, run all of them to make sure that they are actually
    /// done. If an exercise which is marked as done fails, mark it as pending and continue on it.
    pub fn done_current_exercise<const CLEAR_BEFORE_FINAL_CHECK: bool>(
        &mut self,
        stdout: &mut StdoutLock,
    ) -> Result<ExercisesProgress> {
        let exercise = &mut self.exercises[self.current_exercise_ind];
        if !exercise.done {
            exercise.done = true;
            self.n_done += 1;
        }

        if let Some(ind) = self.next_pending_exercise_ind() {
            self.set_current_exercise_ind(ind)?;
            return Ok(ExercisesProgress::NewPending);
        }

        if CLEAR_BEFORE_FINAL_CHECK {
            clear_terminal(stdout)?;
        } else {
            stdout.write_all(b"\n")?;
        }

        if let Some(first_pending_exercise_ind) = self.check_all_exercises(stdout)? {
            self.set_current_exercise_ind(first_pending_exercise_ind)?;

            return Ok(ExercisesProgress::NewPending);
        }

        self.render_final_message(stdout)?;

        Ok(ExercisesProgress::AllDone)
    }

    pub fn render_final_message(&self, stdout: &mut StdoutLock) -> Result<()> {
        clear_terminal(stdout)?;
        stdout.write_all(FENISH_LINE.as_bytes())?;

        let final_message = self.final_message.trim_ascii();
        if !final_message.is_empty() {
            stdout.write_all(final_message.as_bytes())?;
            stdout.write_all(b"\n")?;
        }

        Ok(())
    }
}

const BAD_INDEX_ERR: &str = "The current exercise index is higher than the number of exercises";
const STATE_FILE_HEADER: &[u8] = b"DON'T EDIT THIS FILE!\n\n";
const FENISH_LINE: &str = "+----------------------------------------------------+
|          You made it to the Fe-nish line!          |
+--------------------------  ------------------------+
                           \\/\x1b[31m
     ▒▒          ▒▒▒▒▒▒▒▒      ▒▒▒▒▒▒▒▒          ▒▒
   ▒▒▒▒  ▒▒    ▒▒        ▒▒  ▒▒        ▒▒    ▒▒  ▒▒▒▒
   ▒▒▒▒  ▒▒  ▒▒            ▒▒            ▒▒  ▒▒  ▒▒▒▒
 ░░▒▒▒▒░░▒▒  ▒▒            ▒▒            ▒▒  ▒▒░░▒▒▒▒
   ▓▓▓▓▓▓▓▓  ▓▓      ▓▓██  ▓▓  ▓▓██      ▓▓  ▓▓▓▓▓▓▓▓
     ▒▒▒▒    ▒▒      ████  ▒▒  ████      ▒▒░░  ▒▒▒▒
       ▒▒  ▒▒▒▒▒▒        ▒▒▒▒▒▒        ▒▒▒▒▒▒  ▒▒
         ▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▓▒▒▒▒▒▒▒▒▓▓▓▓▓▓▒▒▒▒▒▒▒▒
           ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
             ▒▒▒▒▒▒▒▒▒▒██▒▒▒▒▒▒██▒▒▒▒▒▒▒▒▒▒
           ▒▒  ▒▒▒▒▒▒▒▒▒▒██████▒▒▒▒▒▒▒▒▒▒  ▒▒
         ▒▒    ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒    ▒▒
       ▒▒    ▒▒    ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒    ▒▒    ▒▒
       ▒▒  ▒▒    ▒▒                  ▒▒    ▒▒  ▒▒
           ▒▒  ▒▒                      ▒▒  ▒▒\x1b[0m

";

#[cfg(test)]
mod tests {
    use super::*;

    fn dummy_exercise() -> Exercise {
        Exercise {
            dir: None,
            name: "0",
            path: "exercises/0.rs",
            canonical_path: None,
            test: false,
            strict_clippy: false,
            hint: "",
            done: false,
        }
    }

    #[test]
    fn next_pending_exercise() {
        let mut app_state = AppState {
            current_exercise_ind: 0,
            exercises: vec![dummy_exercise(), dummy_exercise(), dummy_exercise()],
            n_done: 0,
            final_message: String::new(),
            state_file: tempfile::tempfile().unwrap(),
            file_buf: Vec::new(),
            official_exercises: true,
            cmd_runner: CmdRunner::build().unwrap(),
            emit_file_links: true,
        };

        let mut assert = |done: [bool; 3], expected: [Option<usize>; 3]| {
            for (exercise, done) in app_state.exercises.iter_mut().zip(done) {
                exercise.done = done;
            }
            for (ind, expected) in expected.into_iter().enumerate() {
                app_state.current_exercise_ind = ind;
                assert_eq!(
                    app_state.next_pending_exercise_ind(),
                    expected,
                    "done={done:?}, ind={ind}",
                );
            }
        };

        assert([true, true, true], [None, None, None]);
        assert([false, false, false], [Some(1), Some(2), Some(0)]);
        assert([false, true, true], [None, Some(0), Some(0)]);
        assert([true, false, true], [Some(1), None, Some(1)]);
        assert([true, true, false], [Some(2), Some(2), None]);
        assert([true, false, false], [Some(1), Some(2), Some(1)]);
        assert([false, true, false], [Some(2), Some(2), Some(0)]);
        assert([false, false, true], [Some(1), Some(0), Some(0)]);
    }
}



================================================
FILE: src/cargo_toml.rs
================================================
use anyhow::{Context, Result};
use std::path::Path;

use crate::{exercise::RunnableExercise, info_file::ExerciseInfo};

/// Initial capacity of the bins buffer.
pub const BINS_BUFFER_CAPACITY: usize = 1 << 14;

/// Return the start and end index of the content of the list `bin = […]`.
/// bin = [xxxxxxxxxxxxxxxxx]
///        |start_ind       |
///                         |end_ind
pub fn bins_start_end_ind(cargo_toml: &str) -> Result<(usize, usize)> {
    let start_ind = cargo_toml
        .find("bin = [")
        .context("Failed to find the start of the `bin` list (`bin = [`)")?
        + 7;
    let end_ind = start_ind
        + cargo_toml
            .get(start_ind..)
            .and_then(|slice| slice.as_bytes().iter().position(|c| *c == b']'))
            .context("Failed to find the end of the `bin` list (`]`)")?;

    Ok((start_ind, end_ind))
}

/// Generate and append the content of the `bin` list in `Cargo.toml`.
/// The `exercise_path_prefix` is the prefix of the `path` field of every list entry.
pub fn append_bins(
    buf: &mut Vec<u8>,
    exercise_infos: &[ExerciseInfo],
    exercise_path_prefix: &[u8],
) {
    buf.push(b'\n');
    for exercise_info in exercise_infos {
        buf.extend_from_slice(b"  { name = \"");
        buf.extend_from_slice(exercise_info.name.as_bytes());
        buf.extend_from_slice(b"\", path = \"");
        buf.extend_from_slice(exercise_path_prefix);
        buf.extend_from_slice(b"exercises/");
        if let Some(dir) = &exercise_info.dir {
            buf.extend_from_slice(dir.as_bytes());
            buf.push(b'/');
        }
        buf.extend_from_slice(exercise_info.name.as_bytes());
        buf.extend_from_slice(b".rs\" },\n");

        let sol_path = exercise_info.sol_path();
        if !Path::new(&sol_path).exists() {
            continue;
        }

        buf.extend_from_slice(b"  { name = \"");
        buf.extend_from_slice(exercise_info.name.as_bytes());
        buf.extend_from_slice(b"_sol");
        buf.extend_from_slice(b"\", path = \"");
        buf.extend_from_slice(exercise_path_prefix);
        buf.extend_from_slice(b"solutions/");
        if let Some(dir) = &exercise_info.dir {
            buf.extend_from_slice(dir.as_bytes());
            buf.push(b'/');
        }
        buf.extend_from_slice(exercise_info.name.as_bytes());
        buf.extend_from_slice(b".rs\" },\n");
    }
}

/// Update the `bin` list and leave everything else unchanged.
pub fn updated_cargo_toml(
    exercise_infos: &[ExerciseInfo],
    current_cargo_toml: &str,
    exercise_path_prefix: &[u8],
) -> Result<Vec<u8>> {
    let (bins_start_ind, bins_end_ind) = bins_start_end_ind(current_cargo_toml)?;

    let mut updated_cargo_toml = Vec::with_capacity(BINS_BUFFER_CAPACITY);
    updated_cargo_toml.extend_from_slice(&current_cargo_toml.as_bytes()[..bins_start_ind]);
    append_bins(
        &mut updated_cargo_toml,
        exercise_infos,
        exercise_path_prefix,
    );
    updated_cargo_toml.extend_from_slice(&current_cargo_toml.as_bytes()[bins_end_ind..]);

    Ok(updated_cargo_toml)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_bins_start_end_ind() {
        assert_eq!(bins_start_end_ind("").ok(), None);
        assert_eq!(bins_start_end_ind("[]").ok(), None);
        assert_eq!(bins_start_end_ind("bin = [").ok(), None);
        assert_eq!(bins_start_end_ind("bin = ]").ok(), None);
        assert_eq!(bins_start_end_ind("bin = []").ok(), Some((7, 7)));
        assert_eq!(bins_start_end_ind("bin= []").ok(), None);
        assert_eq!(bins_start_end_ind("bin =[]").ok(), None);
        assert_eq!(bins_start_end_ind("bin=[]").ok(), None);
        assert_eq!(bins_start_end_ind("bin = [\nxxx\n]").ok(), Some((7, 12)));
    }

    #[test]
    fn test_bins() {
        let exercise_infos = [
            ExerciseInfo {
                name: String::from("1"),
                dir: None,
                test: true,
                strict_clippy: true,
                hint: String::new(),
                skip_check_unsolved: false,
            },
            ExerciseInfo {
                name: String::from("2"),
                dir: Some(String::from("d")),
                test: false,
                strict_clippy: false,
                hint: String::new(),
                skip_check_unsolved: false,
            },
        ];

        let mut buf = Vec::with_capacity(128);
        append_bins(&mut buf, &exercise_infos, b"");
        assert_eq!(
            buf,
            br#"
  { name = "1", path = "exercises/1.rs" },
  { name = "2", path = "exercises/d/2.rs" },
"#,
        );

        assert_eq!(
            updated_cargo_toml(
                &exercise_infos,
                "abc\n\
                 bin = [xxx]\n\
                 123",
                b"../"
            )
            .unwrap(),
            br#"abc
bin = [
  { name = "1", path = "../exercises/1.rs" },
  { name = "2", path = "../exercises/d/2.rs" },
]
123"#,
        );
    }
}



================================================
FILE: src/cmd.rs
================================================
use anyhow::{Context, Result, bail};
use serde::Deserialize;
use std::{
    io::{Read, pipe},
    path::PathBuf,
    process::{Command, Stdio},
};

/// Run a command with a description for a possible error and append the merged stdout and stderr.
/// The boolean in the returned `Result` is true if the command's exit status is success.
fn run_cmd(mut cmd: Command, description: &str, output: Option<&mut Vec<u8>>) -> Result<bool> {
    let spawn = |mut cmd: Command| {
        // NOTE: The closure drops `cmd` which prevents a pipe deadlock.
        cmd.stdin(Stdio::null())
            .spawn()
            .with_context(|| format!("Failed to run the command `{description}`"))
    };

    let mut handle = if let Some(output) = output {
        let (mut reader, writer) = pipe().with_context(|| {
            format!("Failed to create a pipe to run the command `{description}``")
        })?;

        let writer_clone = writer.try_clone().with_context(|| {
            format!("Failed to clone the pipe writer for the command `{description}`")
        })?;

        cmd.stdout(writer_clone).stderr(writer);
        let handle = spawn(cmd)?;

        reader
            .read_to_end(output)
            .with_context(|| format!("Failed to read the output of the command `{description}`"))?;

        output.push(b'\n');

        handle
    } else {
        cmd.stdout(Stdio::null()).stderr(Stdio::null());
        spawn(cmd)?
    };

    handle
        .wait()
        .with_context(|| format!("Failed to wait on the command `{description}` to exit"))
        .map(|status| status.success())
}

// Parses parts of the output of `cargo metadata`.
#[derive(Deserialize)]
struct CargoMetadata {
    target_directory: PathBuf,
}

pub struct CmdRunner {
    target_dir: PathBuf,
}

impl CmdRunner {
    pub fn build() -> Result<Self> {
        // Get the target directory from Cargo.
        let metadata_output = Command::new("cargo")
            .arg("metadata")
            .arg("-q")
            .arg("--format-version")
            .arg("1")
            .arg("--no-deps")
            .stdin(Stdio::null())
            .stderr(Stdio::inherit())
            .output()
            .context(CARGO_METADATA_ERR)?;

        if !metadata_output.status.success() {
            bail!("The command `cargo metadata …` failed. Are you in the `rustlings/` directory?");
        }

        let metadata: CargoMetadata = serde_json::de::from_slice(&metadata_output.stdout)
            .context(
                "Failed to read the field `target_directory` from the output of the command `cargo metadata …`",
            )?;

        Ok(Self {
            target_dir: metadata.target_directory,
        })
    }

    pub fn cargo<'out>(
        &self,
        subcommand: &str,
        bin_name: &str,
        output: Option<&'out mut Vec<u8>>,
    ) -> CargoSubcommand<'out> {
        let mut cmd = Command::new("cargo");
        cmd.arg(subcommand).arg("-q").arg("--bin").arg(bin_name);

        // A hack to make `cargo run` work when developing Rustlings.
        #[cfg(debug_assertions)]
        cmd.arg("--manifest-path")
            .arg("dev/Cargo.toml")
            .arg("--target-dir")
            .arg(&self.target_dir);

        if output.is_some() {
            cmd.arg("--color").arg("always");
        }

        CargoSubcommand { cmd, output }
    }

    /// The boolean in the returned `Result` is true if the command's exit status is success.
    pub fn run_debug_bin(&self, bin_name: &str, output: Option<&mut Vec<u8>>) -> Result<bool> {
        // 7 = "/debug/".len()
        let mut bin_path =
            PathBuf::with_capacity(self.target_dir.as_os_str().len() + 7 + bin_name.len());
        bin_path.push(&self.target_dir);
        bin_path.push("debug");
        bin_path.push(bin_name);

        run_cmd(Command::new(&bin_path), &bin_path.to_string_lossy(), output)
    }
}

pub struct CargoSubcommand<'out> {
    cmd: Command,
    output: Option<&'out mut Vec<u8>>,
}

impl CargoSubcommand<'_> {
    #[inline]
    pub fn args<'arg, I>(&mut self, args: I) -> &mut Self
    where
        I: IntoIterator<Item = &'arg str>,
    {
        self.cmd.args(args);
        self
    }

    /// The boolean in the returned `Result` is true if the command's exit status is success.
    #[inline]
    pub fn run(self, description: &str) -> Result<bool> {
        run_cmd(self.cmd, description, self.output)
    }
}

const CARGO_METADATA_ERR: &str = "Failed to run the command `cargo metadata …`
Did you already install Rust?
Try running `cargo --version` to diagnose the problem.";

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_run_cmd() {
        let mut cmd = Command::new("echo");
        cmd.arg("Hello");

        let mut output = Vec::with_capacity(8);
        run_cmd(cmd, "echo …", Some(&mut output)).unwrap();

        assert_eq!(output, b"Hello\n\n");
    }
}



================================================
FILE: src/dev.rs
================================================
use anyhow::{Context, Result, bail};
use clap::Subcommand;
use std::path::PathBuf;

mod check;
mod new;
mod update;

#[derive(Subcommand)]
pub enum DevCommands {
    /// Create a new project for community exercises
    New {
        /// The path to create the project in
        path: PathBuf,
        /// Don't try to initialize a Git repository in the project directory
        #[arg(long)]
        no_git: bool,
    },
    /// Run checks on the exercises
    Check {
        /// Require that every exercise has a solution
        #[arg(short, long)]
        require_solutions: bool,
    },
    /// Update the `Cargo.toml` file for the exercises
    Update,
}

impl DevCommands {
    pub fn run(self) -> Result<()> {
        match self {
            Self::New { path, no_git } => {
                if cfg!(debug_assertions) {
                    bail!("Disabled in the debug build");
                }

                new::new(&path, no_git).context(INIT_ERR)
            }
            Self::Check { require_solutions } => check::check(require_solutions),
            Self::Update => update::update(),
        }
    }
}

const INIT_ERR: &str = "Initialization failed.
After resolving the issue, delete the `rustlings` directory (if it was created) and try again";



================================================
FILE: src/embedded.rs
================================================
use anyhow::{Context, Error, Result};
use std::{
    fs::{self, create_dir},
    io,
};

use crate::info_file::ExerciseInfo;

/// Contains all embedded files.
pub static EMBEDDED_FILES: EmbeddedFiles = rustlings_macros::include_files!();

// Files related to one exercise.
struct ExerciseFiles {
    // The content of the exercise file.
    exercise: &'static [u8],
    // The content of the solution file.
    solution: &'static [u8],
    // Index of the related `ExerciseDir` in `EmbeddedFiles::exercise_dirs`.
    dir_ind: usize,
}

fn create_dir_if_not_exists(path: &str) -> Result<()> {
    if let Err(e) = create_dir(path)
        && e.kind() != io::ErrorKind::AlreadyExists
    {
        return Err(Error::from(e).context(format!("Failed to create the directory {path}")));
    }

    Ok(())
}

// A directory in the `exercises/` directory.
pub struct ExerciseDir {
    pub name: &'static str,
    readme: &'static [u8],
}

impl ExerciseDir {
    fn init_on_disk(&self) -> Result<()> {
        // 20 = 10 + 10
        // exercises/ + /README.md
        let mut dir_path = String::with_capacity(20 + self.name.len());
        dir_path.push_str("exercises/");
        dir_path.push_str(self.name);
        create_dir_if_not_exists(&dir_path)?;

        let mut readme_path = dir_path;
        readme_path.push_str("/README.md");

        fs::write(&readme_path, self.readme)
            .with_context(|| format!("Failed to write the file {readme_path}"))
    }
}

/// All embedded files.
pub struct EmbeddedFiles {
    /// The content of the `info.toml` file.
    pub info_file: &'static str,
    exercise_files: &'static [ExerciseFiles],
    pub exercise_dirs: &'static [ExerciseDir],
}

impl EmbeddedFiles {
    /// Dump all the embedded files of the `exercises/` directory.
    pub fn init_exercises_dir(&self, exercise_infos: &[ExerciseInfo]) -> Result<()> {
        create_dir("exercises").context("Failed to create the directory `exercises`")?;

        fs::write(
            "exercises/README.md",
            include_bytes!("../exercises/README.md"),
        )
        .context("Failed to write the file exercises/README.md")?;

        for dir in self.exercise_dirs {
            dir.init_on_disk()?;
        }

        let mut exercise_path = String::with_capacity(64);
        let prefix = "exercises/";
        exercise_path.push_str(prefix);

        for (exercise_info, exercise_files) in exercise_infos.iter().zip(self.exercise_files) {
            let dir = &self.exercise_dirs[exercise_files.dir_ind];

            exercise_path.truncate(prefix.len());
            exercise_path.push_str(dir.name);
            exercise_path.push('/');
            exercise_path.push_str(&exercise_info.name);
            exercise_path.push_str(".rs");

            fs::write(&exercise_path, exercise_files.exercise)
                .with_context(|| format!("Failed to write the exercise file {exercise_path}"))?;
        }

        Ok(())
    }

    pub fn write_exercise_to_disk(&self, exercise_ind: usize, path: &str) -> Result<()> {
        let exercise_files = &self.exercise_files[exercise_ind];
        let dir = &self.exercise_dirs[exercise_files.dir_ind];

        dir.init_on_disk()?;
        fs::write(path, exercise_files.exercise)
            .with_context(|| format!("Failed to write the exercise file {path}"))
    }

    /// Write the solution file to disk and return its path.
    pub fn write_solution_to_disk(
        &self,
        exercise_ind: usize,
        exercise_name: &str,
    ) -> Result<String> {
        create_dir_if_not_exists("solutions")?;

        let exercise_files = &self.exercise_files[exercise_ind];
        let dir = &self.exercise_dirs[exercise_files.dir_ind];

        // 14 = 10 + 1 + 3
        // solutions/ + / + .rs
        let mut dir_path = String::with_capacity(14 + dir.name.len() + exercise_name.len());
        dir_path.push_str("solutions/");
        dir_path.push_str(dir.name);
        create_dir_if_not_exists(&dir_path)?;

        let mut solution_path = dir_path;
        solution_path.push('/');
        solution_path.push_str(exercise_name);
        solution_path.push_str(".rs");

        fs::write(&solution_path, exercise_files.solution)
            .with_context(|| format!("Failed to write the solution file {solution_path}"))?;

        Ok(solution_path)
    }
}

#[cfg(test)]
mod tests {
    use serde::Deserialize;

    use super::*;

    #[derive(Deserialize)]
    struct ExerciseInfo {
        dir: String,
    }

    #[derive(Deserialize)]
    struct InfoFile {
        exercises: Vec<ExerciseInfo>,
    }

    #[test]
    fn dirs() {
        let exercises = toml::de::from_str::<InfoFile>(EMBEDDED_FILES.info_file)
            .expect("Failed to parse `info.toml`")
            .exercises;

        assert_eq!(exercises.len(), EMBEDDED_FILES.exercise_files.len());

        for (exercise, exercise_files) in exercises.iter().zip(EMBEDDED_FILES.exercise_files) {
            assert_eq!(
                exercise.dir,
                EMBEDDED_FILES.exercise_dirs[exercise_files.dir_ind].name,
            );
        }
    }
}



================================================
FILE: src/exercise.rs
================================================
use anyhow::Result;
use crossterm::{
    QueueableCommand,
    style::{Attribute, Color, ResetColor, SetAttribute, SetForegroundColor},
};
use std::io::{self, StdoutLock, Write};

use crate::{
    cmd::CmdRunner,
    term::{self, CountedWrite, file_path, terminal_file_link, write_ansi},
};

/// The initial capacity of the output buffer.
pub const OUTPUT_CAPACITY: usize = 1 << 14;

pub fn solution_link_line(
    stdout: &mut StdoutLock,
    solution_path: &str,
    emit_file_links: bool,
) -> io::Result<()> {
    stdout.queue(SetAttribute(Attribute::Bold))?;
    stdout.write_all(b"Solution")?;
    stdout.queue(ResetColor)?;
    stdout.write_all(b" for comparison: ")?;
    file_path(stdout, Color::Cyan, |writer| {
        if emit_file_links && let Some(canonical_path) = term::canonicalize(solution_path) {
            terminal_file_link(writer, solution_path, &canonical_path)
        } else {
            writer.stdout().write_all(solution_path.as_bytes())
        }
    })?;
    stdout.write_all(b"\n")
}

// Run an exercise binary and append its output to the `output` buffer.
// Compilation must be done before calling this method.
fn run_bin(
    bin_name: &str,
    mut output: Option<&mut Vec<u8>>,
    cmd_runner: &CmdRunner,
) -> Result<bool> {
    if let Some(output) = output.as_deref_mut() {
        write_ansi(output, SetAttribute(Attribute::Underlined));
        output.extend_from_slice(b"Output");
        write_ansi(output, ResetColor);
        output.push(b'\n');
    }

    let success = cmd_runner.run_debug_bin(bin_name, output.as_deref_mut())?;

    if let Some(output) = output
        && !success
    {
        // This output is important to show the user that something went wrong.
        // Otherwise, calling something like `exit(1)` in an exercise without further output
        // leaves the user confused about why the exercise isn't done yet.
        write_ansi(output, SetAttribute(Attribute::Bold));
        write_ansi(output, SetForegroundColor(Color::Red));
        output.extend_from_slice(b"The exercise didn't run successfully (nonzero exit code)");
        write_ansi(output, ResetColor);
        output.push(b'\n');
    }

    Ok(success)
}

/// See `info_file::ExerciseInfo`
pub struct Exercise {
    pub dir: Option<&'static str>,
    pub name: &'static str,
    /// Path of the exercise file starting with the `exercises/` directory.
    pub path: &'static str,
    pub canonical_path: Option<String>,
    pub test: bool,
    pub strict_clippy: bool,
    pub hint: &'static str,
    pub done: bool,
}

impl Exercise {
    pub fn terminal_file_link<'a>(
        &self,
        writer: &mut impl CountedWrite<'a>,
        emit_file_links: bool,
    ) -> io::Result<()> {
        file_path(writer, Color::Blue, |writer| {
            if emit_file_links && let Some(canonical_path) = self.canonical_path.as_deref() {
                terminal_file_link(writer, self.path, canonical_path)
            } else {
                writer.write_str(self.path)
            }
        })
    }
}

pub trait RunnableExercise {
    fn name(&self) -> &str;
    fn dir(&self) -> Option<&str>;
    fn strict_clippy(&self) -> bool;
    fn test(&self) -> bool;

    // Compile, check and run the exercise or its solution (depending on `bin_name´).
    // The output is written to the `output` buffer after clearing it.
    fn run<const FORCE_STRICT_CLIPPY: bool>(
        &self,
        bin_name: &str,
        mut output: Option<&mut Vec<u8>>,
        cmd_runner: &CmdRunner,
    ) -> Result<bool> {
        if let Some(output) = output.as_deref_mut() {
            output.clear();
        }

        let build_success = cmd_runner
            .cargo("build", bin_name, output.as_deref_mut())
            .run("cargo build …")?;
        if !build_success {
            return Ok(false);
        }

        // Discard the compiler output because it will be shown again by `cargo test` or Clippy.
        if let Some(output) = output.as_deref_mut() {
            output.clear();
        }

        if self.test() {
            let output_is_some = output.is_some();
            let mut test_cmd = cmd_runner.cargo("test", bin_name, output.as_deref_mut());
            if output_is_some {
                test_cmd.args(["--", "--color", "always", "--format", "pretty"]);
            }
            let test_success = test_cmd.run("cargo test …")?;
            if !test_success {
                run_bin(bin_name, output, cmd_runner)?;
                return Ok(false);
            }

            // Discard the compiler output because it will be shown again by Clippy.
            if let Some(output) = output.as_deref_mut() {
                output.clear();
            }
        }

        let mut clippy_cmd = cmd_runner.cargo("clippy", bin_name, output.as_deref_mut());

        // `--profile test` is required to also check code with `#[cfg(test)]`.
        if FORCE_STRICT_CLIPPY || self.strict_clippy() {
            clippy_cmd.args(["--profile", "test", "--", "-D", "warnings"]);
        } else {
            clippy_cmd.args(["--profile", "test"]);
        }

        let clippy_success = clippy_cmd.run("cargo clippy …")?;
        let run_success = run_bin(bin_name, output, cmd_runner)?;

        Ok(clippy_success && run_success)
    }

    /// Compile, check and run the exercise.
    /// The output is written to the `output` buffer after clearing it.
    #[inline]
    fn run_exercise(&self, output: Option<&mut Vec<u8>>, cmd_runner: &CmdRunner) -> Result<bool> {
        self.run::<false>(self.name(), output, cmd_runner)
    }

    /// Compile, check and run the exercise's solution.
    /// The output is written to the `output` buffer after clearing it.
    fn run_solution(&self, output: Option<&mut Vec<u8>>, cmd_runner: &CmdRunner) -> Result<bool> {
        let name = self.name();
        let mut bin_name = String::with_capacity(name.len() + 4);
        bin_name.push_str(name);
        bin_name.push_str("_sol");

        self.run::<true>(&bin_name, output, cmd_runner)
    }

    fn sol_path(&self) -> String {
        let name = self.name();

        let mut path = if let Some(dir) = self.dir() {
            // 14 = 10 + 1 + 3
            // solutions/ + / + .rs
            let mut path = String::with_capacity(14 + dir.len() + name.len());
            path.push_str("solutions/");
            path.push_str(dir);
            path.push('/');
            path
        } else {
            // 13 = 10 + 3
            // solutions/ + .rs
            let mut path = String::with_capacity(13 + name.len());
            path.push_str("solutions/");
            path
        };

        path.push_str(name);
        path.push_str(".rs");

        path
    }
}

impl RunnableExercise for Exercise {
    #[inline]
    fn name(&self) -> &str {
        self.name
    }

    #[inline]
    fn dir(&self) -> Option<&str> {
        self.dir
    }

    #[inline]
    fn strict_clippy(&self) -> bool {
        self.strict_clippy
    }

    #[inline]
    fn test(&self) -> bool {
        self.test
    }
}



================================================
FILE: src/info_file.rs
================================================
use anyhow::{Context, Error, Result, bail};
use serde::Deserialize;
use std::{fs, io::ErrorKind};

use crate::{embedded::EMBEDDED_FILES, exercise::RunnableExercise};

/// Deserialized from the `info.toml` file.
#[derive(Deserialize)]
pub struct ExerciseInfo {
    /// Exercise's unique name.
    pub name: String,
    /// Exercise's directory name inside the `exercises/` directory.
    pub dir: Option<String>,
    /// Run `cargo test` on the exercise.
    #[serde(default = "default_true")]
    pub test: bool,
    /// Deny all Clippy warnings.
    #[serde(default)]
    pub strict_clippy: bool,
    /// The exercise's hint to be shown to the user on request.
    pub hint: String,
    /// The exercise is already solved. Ignore it when checking that all exercises are unsolved.
    #[serde(default)]
    pub skip_check_unsolved: bool,
}
#[inline(always)]
const fn default_true() -> bool {
    true
}

impl ExerciseInfo {
    /// Path to the exercise file starting with the `exercises/` directory.
    pub fn path(&self) -> String {
        let mut path = if let Some(dir) = &self.dir {
            // 14 = 10 + 1 + 3
            // exercises/ + / + .rs
            let mut path = String::with_capacity(14 + dir.len() + self.name.len());
            path.push_str("exercises/");
            path.push_str(dir);
            path.push('/');
            path
        } else {
            // 13 = 10 + 3
            // exercises/ + .rs
            let mut path = String::with_capacity(13 + self.name.len());
            path.push_str("exercises/");
            path
        };

        path.push_str(&self.name);
        path.push_str(".rs");

        path
    }
}

impl RunnableExercise for ExerciseInfo {
    #[inline]
    fn name(&self) -> &str {
        &self.name
    }

    #[inline]
    fn dir(&self) -> Option<&str> {
        self.dir.as_deref()
    }

    #[inline]
    fn strict_clippy(&self) -> bool {
        self.strict_clippy
    }

    #[inline]
    fn test(&self) -> bool {
        self.test
    }
}

/// The deserialized `info.toml` file.
#[derive(Deserialize)]
pub struct InfoFile {
    /// For possible breaking changes in the future for community exercises.
    pub format_version: u8,
    /// Shown to users when starting with the exercises.
    pub welcome_message: Option<String>,
    /// Shown to users after finishing all exercises.
    pub final_message: Option<String>,
    /// List of all exercises.
    pub exercises: Vec<ExerciseInfo>,
}

impl InfoFile {
    /// Official exercises: Parse the embedded `info.toml` file.
    /// Community exercises: Parse the `info.toml` file in the current directory.
    pub fn parse() -> Result<Self> {
        // Read a local `info.toml` if it exists.
        let slf = match fs::read_to_string("info.toml") {
            Ok(file_content) => toml::de::from_str::<Self>(&file_content)
                .context("Failed to parse the `info.toml` file")?,
            Err(e) => {
                if e.kind() == ErrorKind::NotFound {
                    return toml::de::from_str(EMBEDDED_FILES.info_file)
                        .context("Failed to parse the embedded `info.toml` file");
                }

                return Err(Error::from(e).context("Failed to read the `info.toml` file"));
            }
        };

        if slf.exercises.is_empty() {
            bail!("{NO_EXERCISES_ERR}");
        }

        Ok(slf)
    }
}

const NO_EXERCISES_ERR: &str = "There are no exercises yet!
Add at least one exercise before testing.";



================================================
FILE: src/init.rs
================================================
use anyhow::{Context, Result, bail};
use crossterm::{
    QueueableCommand,
    style::{Attribute, Color, ResetColor, SetAttribute, SetForegroundColor},
};
use serde::Deserialize;
use std::{
    env::set_current_dir,
    fs::{self, create_dir},
    io::{self, Write},
    path::{Path, PathBuf},
    process::{Command, Stdio},
};

use crate::{
    cargo_toml::updated_cargo_toml, embedded::EMBEDDED_FILES, exercise::RunnableExercise,
    info_file::InfoFile, term::press_enter_prompt,
};

#[derive(Deserialize)]
struct CargoLocateProject {
    root: PathBuf,
}

pub fn init() -> Result<()> {
    let rustlings_dir = Path::new("rustlings");
    if rustlings_dir.exists() {
        bail!(RUSTLINGS_DIR_ALREADY_EXISTS_ERR);
    }

    let locate_project_output = Command::new("cargo")
        .arg("locate-project")
        .arg("-q")
        .arg("--workspace")
        .stdin(Stdio::null())
        .stderr(Stdio::null())
        .output()
        .context(
            "Failed to run the command `cargo locate-project …`\n\
             Did you already install Rust?\n\
             Try running `cargo --version` to diagnose the problem.",
        )?;

    if !Command::new("cargo")
        .arg("clippy")
        .arg("--version")
        .stdin(Stdio::null())
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .context("Failed to run the command `cargo clippy --version`")?
        .success()
    {
        bail!(
            "Clippy, the official Rust linter, is missing.\n\
             Please install it first before initializing Rustlings."
        )
    }

    let mut stdout = io::stdout().lock();
    let mut init_git = true;

    if locate_project_output.status.success() {
        if Path::new("exercises").exists() && Path::new("solutions").exists() {
            bail!(IN_INITIALIZED_DIR_ERR);
        }

        let workspace_manifest =
            serde_json::de::from_slice::<CargoLocateProject>(&locate_project_output.stdout)
                .context(
                    "Failed to read the field `root` from the output of `cargo locate-project …`",
                )?
                .root;

        let workspace_manifest_content = fs::read_to_string(&workspace_manifest)
            .with_context(|| format!("Failed to read the file {}", workspace_manifest.display()))?;
        if !workspace_manifest_content.contains("[workspace]")
            && !workspace_manifest_content.contains("workspace.")
        {
            bail!(
                "The current directory is already part of a Cargo project.\n\
                 Please initialize Rustlings in a different directory"
            );
        }

        stdout.write_all(b"This command will create the directory `rustlings/` as a member of this Cargo workspace.\n\
                           Press ENTER to continue ")?;
        press_enter_prompt(&mut stdout)?;

        // Make sure "rustlings" is added to `workspace.members` by making
        // Cargo initialize a new project.
        let status = Command::new("cargo")
            .arg("new")
            .arg("-q")
            .arg("--vcs")
            .arg("none")
            .arg("rustlings")
            .stdin(Stdio::null())
            .stdout(Stdio::null())
            .status()?;
        if !status.success() {
            bail!(
                "Failed to initialize a new Cargo workspace member.\n\
                 Please initialize Rustlings in a different directory"
            );
        }

        stdout.write_all(b"The directory `rustlings` has been added to `workspace.members` in the `Cargo.toml` file of this Cargo workspace.\n")?;
        fs::remove_dir_all("rustlings")
            .context("Failed to remove the temporary directory `rustlings/`")?;
        init_git = false;
    } else {
        stdout.write_all(b"This command will create the directory `rustlings/` which will contain the exercises.\n\
                           Press ENTER to continue ")?;
        press_enter_prompt(&mut stdout)?;
    }

    create_dir(rustlings_dir).context("Failed to create the `rustlings/` directory")?;
    set_current_dir(rustlings_dir)
        .context("Failed to change the current directory to `rustlings/`")?;

    let info_file = InfoFile::parse()?;
    EMBEDDED_FILES
        .init_exercises_dir(&info_file.exercises)
        .context("Failed to initialize the `rustlings/exercises` directory")?;

    create_dir("solutions").context("Failed to create the `solutions/` directory")?;
    fs::write(
        "solutions/README.md",
        include_bytes!("../solutions/README.md"),
    )
    .context("Failed to create the file rustlings/solutions/README.md")?;
    for dir in EMBEDDED_FILES.exercise_dirs {
        let mut dir_path = String::with_capacity(10 + dir.name.len());
        dir_path.push_str("solutions/");
        dir_path.push_str(dir.name);
        create_dir(&dir_path)
            .with_context(|| format!("Failed to create the directory {dir_path}"))?;
    }
    for exercise_info in &info_file.exercises {
        let solution_path = exercise_info.sol_path();
        fs::write(&solution_path, INIT_SOLUTION_FILE)
            .with_context(|| format!("Failed to create the file {solution_path}"))?;
    }

    let current_cargo_toml = include_str!("../dev-Cargo.toml");
    // Skip the first line (comment).
    let newline_ind = current_cargo_toml
        .as_bytes()
        .iter()
        .position(|c| *c == b'\n')
        .context("The embedded `Cargo.toml` is empty or contains only one line")?;
    let current_cargo_toml = current_cargo_toml
        .get(newline_ind + 1..)
        .context("The embedded `Cargo.toml` contains only one line")?;
    let updated_cargo_toml = updated_cargo_toml(&info_file.exercises, current_cargo_toml, b"")
        .context("Failed to generate `Cargo.toml`")?;
    fs::write("Cargo.toml", updated_cargo_toml)
        .context("Failed to create the file `rustlings/Cargo.toml`")?;

    fs::write("rust-analyzer.toml", RUST_ANALYZER_TOML)
        .context("Failed to create the file `rustlings/rust-analyzer.toml`")?;

    fs::write(".gitignore", GITIGNORE)
        .context("Failed to create the file `rustlings/.gitignore`")?;

    create_dir(".vscode").context("Failed to create the directory `rustlings/.vscode`")?;
    fs::write(".vscode/extensions.json", VS_CODE_EXTENSIONS_JSON)
        .context("Failed to create the file `rustlings/.vscode/extensions.json`")?;

    if init_git {
        // Ignore any Git error because Git initialization is not required.
        let _ = Command::new("git")
            .arg("init")
            .stdin(Stdio::null())
            .stdout(Stdio::null())
            .stderr(Stdio::null())
            .status();
    }

    stdout.queue(SetForegroundColor(Color::Green))?;
    stdout.write_all("Initialization done ✓".as_bytes())?;
    stdout.queue(ResetColor)?;
    stdout.write_all(b"\n\n")?;

    stdout.queue(SetAttribute(Attribute::Bold))?;
    stdout.write_all(POST_INIT_MSG)?;
    stdout.queue(ResetColor)?;

    Ok(())
}

const INIT_SOLUTION_FILE: &[u8] = b"fn main() {
    // DON'T EDIT THIS SOLUTION FILE!
    // It will be automatically filled after you finish the exercise.
}
";

pub const RUST_ANALYZER_TOML: &[u8] = br#"check.command = "clippy"
check.extraArgs = ["--profile", "test"]
cargo.targetDir = true
"#;

const GITIGNORE: &[u8] = b"Cargo.lock
target/
.vscode/
";

pub const VS_CODE_EXTENSIONS_JSON: &[u8] = br#"{"recommendations":["rust-lang.rust-analyzer"]}"#;

const IN_INITIALIZED_DIR_ERR: &str = "It looks like Rustlings is already initialized in this directory.

If you already initialized Rustlings, run the command `rustlings` for instructions on getting started with the exercises.
Otherwise, please run `rustlings init` again in a different directory.";

const RUSTLINGS_DIR_ALREADY_EXISTS_ERR: &str =
    "A directory with the name `rustlings` already exists in the current directory.
You probably already initialized Rustlings.
Run `cd rustlings`
Then run `rustlings` again";

const POST_INIT_MSG: &[u8] = b"Run `cd rustlings` to go into the generated directory.
Then run `rustlings` to get started.
";



================================================
FILE: src/list.rs
================================================
use anyhow::{Context, Result};
use crossterm::{
    QueueableCommand, cursor,
    event::{
        self, DisableMouseCapture, EnableMouseCapture, Event, KeyCode, KeyEventKind, MouseEventKind,
    },
    terminal::{
        DisableLineWrap, EnableLineWrap, EnterAlternateScreen, LeaveAlternateScreen,
        disable_raw_mode, enable_raw_mode,
    },
};
use std::io::{self, StdoutLock, Write};

use crate::app_state::AppState;

use self::state::{Filter, ListState};

mod scroll_state;
mod state;

fn handle_list(app_state: &mut AppState, stdout: &mut StdoutLock) -> Result<()> {
    let mut list_state = ListState::build(app_state, stdout)?;
    let mut is_searching = false;

    loop {
        match event::read().context("Failed to read terminal event")? {
            Event::Key(key) => {
                match key.kind {
                    KeyEventKind::Release => continue,
                    KeyEventKind::Press | KeyEventKind::Repeat => (),
                }

                list_state.message.clear();

                if is_searching {
                    match key.code {
                        KeyCode::Esc | KeyCode::Enter => {
                            is_searching = false;
                            list_state.search_query.clear();
                        }
                        KeyCode::Char(c) => {
                            list_state.search_query.push(c);
                            list_state.apply_search_query();
                        }
                        KeyCode::Backspace => {
                            list_state.search_query.pop();
                            list_state.apply_search_query();
                        }
                        _ => continue,
                    }

                    list_state.draw(stdout)?;
                    continue;
                }

                match key.code {
                    KeyCode::Char('q') => return Ok(()),
                    KeyCode::Down | KeyCode::Char('j') => list_state.select_next(),
                    KeyCode::Up | KeyCode::Char('k') => list_state.select_previous(),
                    KeyCode::Home | KeyCode::Char('g') => list_state.select_first(),
                    KeyCode::End | KeyCode::Char('G') => list_state.select_last(),
                    KeyCode::Char('d') => {
                        if list_state.filter() == Filter::Done {
                            list_state.set_filter(Filter::None);
                            list_state.message.push_str("Disabled filter DONE");
                        } else {
                            list_state.set_filter(Filter::Done);
                            list_state.message.push_str(
                                "Enabled filter DONE │ Press d again to disable the filter",
                            );
                        }
                    }
                    KeyCode::Char('p') => {
                        if list_state.filter() == Filter::Pending {
                            list_state.set_filter(Filter::None);
                            list_state.message.push_str("Disabled filter PENDING");
                        } else {
                            list_state.set_filter(Filter::Pending);
                            list_state.message.push_str(
                                "Enabled filter PENDING │ Press p again to disable the filter",
                            );
                        }
                    }
                    KeyCode::Char('r') => list_state.reset_selected()?,
                    KeyCode::Char('c') => {
                        if list_state.selected_to_current_exercise()? {
                            return Ok(());
                        }
                    }
                    KeyCode::Char('s' | '/') => {
                        is_searching = true;
                        list_state.apply_search_query();
                    }
                    // Redraw to remove the message.
                    KeyCode::Esc => (),
                    _ => continue,
                }
            }
            Event::Mouse(event) => match event.kind {
                MouseEventKind::ScrollDown => list_state.select_next(),
                MouseEventKind::ScrollUp => list_state.select_previous(),
                _ => continue,
            },
            Event::Resize(width, height) => list_state.set_term_size(width, height),
            // Ignore
            Event::FocusGained | Event::FocusLost => continue,
        }

        list_state.draw(stdout)?;
    }
}

pub fn list(app_state: &mut AppState) -> Result<()> {
    let mut stdout = io::stdout().lock();
    stdout
        .queue(EnterAlternateScreen)?
        .queue(cursor::Hide)?
        .queue(DisableLineWrap)?
        .queue(EnableMouseCapture)?;
    enable_raw_mode()?;

    let res = handle_list(app_state, &mut stdout);

    // Restore the terminal even if we got an error.
    stdout
        .queue(LeaveAlternateScreen)?
        .queue(cursor::Show)?
        .queue(EnableLineWrap)?
        .queue(DisableMouseCapture)?
        .flush()?;
    disable_raw_mode()?;

    res
}



================================================
FILE: src/main.rs
================================================
use anyhow::{Context, Result, bail};
use app_state::StateFileStatus;
use clap::{Parser, Subcommand};
use std::{
    io::{self, IsTerminal, Write},
    path::Path,
    process::ExitCode,
};
use term::{clear_terminal, press_enter_prompt};

use self::{app_state::AppState, dev::DevCommands, info_file::InfoFile};

mod app_state;
mod cargo_toml;
mod cmd;
mod dev;
mod embedded;
mod exercise;
mod info_file;
mod init;
mod list;
mod run;
mod term;
mod watch;

const CURRENT_FORMAT_VERSION: u8 = 1;

/// Rustlings is a collection of small exercises to get you used to writing and reading Rust code
#[derive(Parser)]
#[command(version)]
struct Args {
    #[command(subcommand)]
    command: Option<Subcommands>,
    /// Manually run the current exercise using `r` in the watch mode.
    /// Only use this if Rustlings fails to detect exercise file changes.
    #[arg(long)]
    manual_run: bool,
}

#[derive(Subcommand)]
enum Subcommands {
    /// Initialize the official Rustlings exercises
    Init,
    /// Run a single exercise. Runs the next pending exercise if the exercise name is not specified
    Run {
        /// The name of the exercise
        name: Option<String>,
    },
    /// Check all the exercises, marking them as done or pending accordingly.
    CheckAll,
    /// Reset a single exercise
    Reset {
        /// The name of the exercise
        name: String,
    },
    /// Show a hint. Shows the hint of the next pending exercise if the exercise name is not specified
    Hint {
        /// The name of the exercise
        name: Option<String>,
    },
    /// Commands for developing (community) Rustlings exercises
    #[command(subcommand)]
    Dev(DevCommands),
}

fn main() -> Result<ExitCode> {
    let args = Args::parse();

    if cfg!(not(debug_assertions)) && Path::new("dev/rustlings-repo.txt").exists() {
        bail!("{OLD_METHOD_ERR}");
    }

    'priority_cmd: {
        match args.command {
            Some(Subcommands::Init) => init::init().context("Initialization failed")?,
            Some(Subcommands::Dev(dev_command)) => dev_command.run()?,
            _ => break 'priority_cmd,
        }

        return Ok(ExitCode::SUCCESS);
    }

    if !Path::new("exercises").is_dir() {
        println!("{PRE_INIT_MSG}");
        return Ok(ExitCode::FAILURE);
    }

    let info_file = InfoFile::parse()?;

    if info_file.format_version > CURRENT_FORMAT_VERSION {
        bail!(FORMAT_VERSION_HIGHER_ERR);
    }

    let (mut app_state, state_file_status) = AppState::new(
        info_file.exercises,
        info_file.final_message.unwrap_or_default(),
    )?;

    // Show the welcome message if the state file doesn't exist yet.
    if let Some(welcome_message) = info_file.welcome_message {
        match state_file_status {
            StateFileStatus::NotRead => {
                let mut stdout = io::stdout().lock();
                clear_terminal(&mut stdout)?;

                let welcome_message = welcome_message.trim_ascii();
                write!(
                    stdout,
                    "{welcome_message}\n\n\
                     Press ENTER to continue "
                )?;
                press_enter_prompt(&mut stdout)?;
                clear_terminal(&mut stdout)?;
                // Flush to be able to show errors occurring before printing a newline to stdout.
                stdout.flush()?;
            }
            StateFileStatus::Read => (),
        }
    }

    match args.command {
        None => {
            if !io::stdout().is_terminal() {
                bail!("Unsupported or missing terminal/TTY");
            }

            let notify_exercise_names = if args.manual_run {
                None
            } else {
                // For the notify event handler thread.
                // Leaking is not a problem because the slice lives until the end of the program.
                Some(
                    &*app_state
                        .exercises()
                        .iter()
                        .map(|exercise| exercise.name.as_bytes())
                        .collect::<Vec<_>>()
                        .leak(),
                )
            };

            watch::watch(&mut app_state, notify_exercise_names)?;
        }
        Some(Subcommands::Run { name }) => {
            if let Some(name) = name {
                app_state.set_current_exercise_by_name(&name)?;
            }
            return run::run(&mut app_state);
        }
        Some(Subcommands::CheckAll) => {
            let mut stdout = io::stdout().lock();
            if let Some(first_pending_exercise_ind) = app_state.check_all_exercises(&mut stdout)? {
                if app_state.current_exercise().done {
                    app_state.set_current_exercise_ind(first_pending_exercise_ind)?;
                }

                stdout.write_all(b"\n\n")?;
                let pending = app_state.n_pending();
                if pending == 1 {
                    stdout.write_all(b"One exercise pending: ")?;
                } else {
                    write!(
                        stdout,
                        "{pending}/{} exercises pending. The first: ",
                        app_state.exercises().len(),
                    )?;
                }
                app_state
                    .current_exercise()
                    .terminal_file_link(&mut stdout, app_state.emit_file_links())?;
                stdout.write_all(b"\n")?;

                return Ok(ExitCode::FAILURE);
            } else {
                app_state.render_final_message(&mut stdout)?;
            }
        }
        Some(Subcommands::Reset { name }) => {
            app_state.set_current_exercise_by_name(&name)?;
            let exercise_path = app_state.reset_current_exercise()?;
            println!("The exercise {exercise_path} has been reset");
        }
        Some(Subcommands::Hint { name }) => {
            if let Some(name) = name {
                app_state.set_current_exercise_by_name(&name)?;
            }
            println!("{}", app_state.current_exercise().hint);
        }
        // Handled in an earlier match.
        Some(Subcommands::Init | Subcommands::Dev(_)) => (),
    }

    Ok(ExitCode::SUCCESS)
}

const OLD_METHOD_ERR: &str =
    "You are trying to run Rustlings using the old method before version 6.
The new method doesn't include cloning the Rustlings' repository.
Please follow the instructions in `README.md`:
https://github.com/rust-lang/rustlings#getting-started";

const FORMAT_VERSION_HIGHER_ERR: &str =
    "The format version specified in the `info.toml` file is higher than the last one supported.
It is possible that you have an outdated version of Rustlings.
Try to install the latest Rustlings version first.";

const PRE_INIT_MSG: &str = r"
       Welcome to...
                 _   _ _
  _ __ _   _ ___| |_| (_)_ __   __ _ ___
 | '__| | | / __| __| | | '_ \ / _` / __|
 | |  | |_| \__ \ |_| | | | | | (_| \__ \
 |_|   \__,_|___/\__|_|_|_| |_|\__, |___/
                               |___/

The `exercises/` directory couldn't be found in the current directory.
If you are just starting with Rustlings, run the command `rustlings init` to initialize it.";



================================================
FILE: src/run.rs
================================================
use anyhow::Result;
use crossterm::{
    QueueableCommand,
    style::{Color, ResetColor, SetForegroundColor},
};
use std::{
    io::{self, Write},
    process::ExitCode,
};

use crate::{
    app_state::{AppState, ExercisesProgress},
    exercise::{OUTPUT_CAPACITY, RunnableExercise, solution_link_line},
};

pub fn run(app_state: &mut AppState) -> Result<ExitCode> {
    let exercise = app_state.current_exercise();
    let mut output = Vec::with_capacity(OUTPUT_CAPACITY);
    let success = exercise.run_exercise(Some(&mut output), app_state.cmd_runner())?;

    let mut stdout = io::stdout().lock();
    stdout.write_all(&output)?;

    if !success {
        app_state.set_pending(app_state.current_exercise_ind())?;

        stdout.write_all(b"Ran ")?;
        app_state
            .current_exercise()
            .terminal_file_link(&mut stdout, app_state.emit_file_links())?;
        stdout.write_all(b" with errors\n")?;

        return Ok(ExitCode::FAILURE);
    }

    stdout.queue(SetForegroundColor(Color::Green))?;
    stdout.write_all("✓ Successfully ran ".as_bytes())?;
    stdout.write_all(exercise.path.as_bytes())?;
    stdout.queue(ResetColor)?;
    stdout.write_all(b"\n")?;

    if let Some(solution_path) = app_state.current_solution_path()? {
        stdout.write_all(b"\n")?;
        solution_link_line(&mut stdout, &solution_path, app_state.emit_file_links())?;
        stdout.write_all(b"\n")?;
    }

    match app_state.done_current_exercise::<false>(&mut stdout)? {
        ExercisesProgress::NewPending | ExercisesProgress::CurrentPending => {
            stdout.write_all(b"Next exercise: ")?;
            app_state
                .current_exercise()
                .terminal_file_link(&mut stdout, app_state.emit_file_links())?;
            stdout.write_all(b"\n")?;
        }
        ExercisesProgress::AllDone => (),
    }

    Ok(ExitCode::SUCCESS)
}



================================================
FILE: src/term.rs
================================================
use crossterm::{
    Command, QueueableCommand,
    cursor::MoveTo,
    style::{Attribute, Color, ResetColor, SetAttribute, SetForegroundColor},
    terminal::{Clear, ClearType},
};
use std::{
    fmt, fs,
    io::{self, BufRead, StdoutLock, Write},
};

use crate::app_state::CheckProgress;

pub struct MaxLenWriter<'a, 'lock> {
    pub stdout: &'a mut StdoutLock<'lock>,
    len: usize,
    max_len: usize,
}

impl<'a, 'lock> MaxLenWriter<'a, 'lock> {
    #[inline]
    pub fn new(stdout: &'a mut StdoutLock<'lock>, max_len: usize) -> Self {
        Self {
            stdout,
            len: 0,
            max_len,
        }
    }

    // Additional is for emojis that take more space.
    #[inline]
    pub fn add_to_len(&mut self, additional: usize) {
        self.len += additional;
    }
}

pub trait CountedWrite<'lock> {
    fn write_ascii(&mut self, ascii: &[u8]) -> io::Result<()>;
    fn write_str(&mut self, unicode: &str) -> io::Result<()>;
    fn stdout(&mut self) -> &mut StdoutLock<'lock>;
}

impl<'lock> CountedWrite<'lock> for MaxLenWriter<'_, 'lock> {
    fn write_ascii(&mut self, ascii: &[u8]) -> io::Result<()> {
        let n = ascii.len().min(self.max_len.saturating_sub(self.len));
        if n > 0 {
            self.stdout.write_all(&ascii[..n])?;
            self.len += n;
        }
        Ok(())
    }

    fn write_str(&mut self, unicode: &str) -> io::Result<()> {
        if let Some((ind, c)) = unicode
            .char_indices()
            .take(self.max_len.saturating_sub(self.len))
            .last()
        {
            self.stdout
                .write_all(&unicode.as_bytes()[..ind + c.len_utf8()])?;
            self.len += ind + 1;
        }

        Ok(())
    }

    #[inline]
    fn stdout(&mut self) -> &mut StdoutLock<'lock> {
        self.stdout
    }
}

impl<'a> CountedWrite<'a> for StdoutLock<'a> {
    #[inline]
    fn write_ascii(&mut self, ascii: &[u8]) -> io::Result<()> {
        self.write_all(ascii)
    }

    #[inline]
    fn write_str(&mut self, unicode: &str) -> io::Result<()> {
        self.write_all(unicode.as_bytes())
    }

    #[inline]
    fn stdout(&mut self) -> &mut StdoutLock<'a> {
        self
    }
}

pub struct CheckProgressVisualizer<'a, 'lock> {
    stdout: &'a mut StdoutLock<'lock>,
    n_cols: usize,
}

impl<'a, 'lock> CheckProgressVisualizer<'a, 'lock> {
    const CHECKING_COLOR: Color = Color::Blue;
    const DONE_COLOR: Color = Color::Green;
    const PENDING_COLOR: Color = Color::Red;

    pub fn build(stdout: &'a mut StdoutLock<'lock>, term_width: u16) -> io::Result<Self> {
        clear_terminal(stdout)?;
        stdout.write_all("Checking all exercises…\n".as_bytes())?;

        // Legend
        stdout.write_all(b"Color of exercise number: ")?;
        stdout.queue(SetForegroundColor(Self::CHECKING_COLOR))?;
        stdout.write_all(b"Checking")?;
        stdout.queue(ResetColor)?;
        stdout.write_all(b" - ")?;
        stdout.queue(SetForegroundColor(Self::DONE_COLOR))?;
        stdout.write_all(b"Done")?;
        stdout.queue(ResetColor)?;
        stdout.write_all(b" - ")?;
        stdout.queue(SetForegroundColor(Self::PENDING_COLOR))?;
        stdout.write_all(b"Pending")?;
        stdout.queue(ResetColor)?;
        stdout.write_all(b"\n")?;

        // Exercise numbers with up to 3 digits.
        // +1 because the last column doesn't end with a whitespace.
        let n_cols = usize::from(term_width + 1) / 4;

        Ok(Self { stdout, n_cols })
    }

    pub fn update(&mut self, progresses: &[CheckProgress]) -> io::Result<()> {
        self.stdout.queue(MoveTo(0, 2))?;

        let mut exercise_num = 1;
        for exercise_progress in progresses {
            match exercise_progress {
                CheckProgress::None => (),
                CheckProgress::Checking => {
                    self.stdout
                        .queue(SetForegroundColor(Self::CHECKING_COLOR))?;
                }
                CheckProgress::Done => {
                    self.stdout.queue(SetForegroundColor(Self::DONE_COLOR))?;
                }
                CheckProgress::Pending => {
                    self.stdout.queue(SetForegroundColor(Self::PENDING_COLOR))?;
                }
            }

            write!(self.stdout, "{exercise_num:<3}")?;
            self.stdout.queue(ResetColor)?;

            if exercise_num != progresses.len() {
                if exercise_num % self.n_cols == 0 {
                    self.stdout.write_all(b"\n")?;
                } else {
                    self.stdout.write_all(b" ")?;
                }

                exercise_num += 1;
            }
        }

        self.stdout.flush()
    }
}

pub struct ProgressCounter<'a, 'lock> {
    stdout: &'a mut StdoutLock<'lock>,
    total: usize,
    counter: usize,
}

impl<'a, 'lock> ProgressCounter<'a, 'lock> {
    pub fn new(stdout: &'a mut StdoutLock<'lock>, total: usize) -> io::Result<Self> {
        write!(stdout, "Progress: 0/{total}")?;
        stdout.flush()?;

        Ok(Self {
            stdout,
            total,
            counter: 0,
        })
    }

    pub fn increment(&mut self) -> io::Result<()> {
        self.counter += 1;
        write!(self.stdout, "\rProgress: {}/{}", self.counter, self.total)?;
        self.stdout.flush()
    }
}

impl Drop for ProgressCounter<'_, '_> {
    fn drop(&mut self) {
        let _ = self.stdout.write_all(b"\n\n");
    }
}

pub fn progress_bar<'a>(
    writer: &mut impl CountedWrite<'a>,
    progress: u16,
    total: u16,
    term_width: u16,
) -> io::Result<()> {
    debug_assert!(total <= 999);
    debug_assert!(progress <= total);

    const PREFIX: &[u8] = b"Progress: [";
    const PREFIX_WIDTH: u16 = PREFIX.len() as u16;
    const POSTFIX_WIDTH: u16 = "] xxx/xxx".len() as u16;
    const WRAPPER_WIDTH: u16 = PREFIX_WIDTH + POSTFIX_WIDTH;
    const MIN_LINE_WIDTH: u16 = WRAPPER_WIDTH + 4;

    if term_width < MIN_LINE_WIDTH {
        writer.write_ascii(b"Progress: ")?;
        // Integers are in ASCII.
        return writer.write_ascii(format!("{progress}/{total}").as_bytes());
    }

    let stdout = writer.stdout();
    stdout.write_all(PREFIX)?;

    let width = term_width - WRAPPER_WIDTH;
    let filled = (width * progress) / total;

    stdout.queue(SetForegroundColor(Color::Green))?;
    for _ in 0..filled {
        stdout.write_all(b"#")?;
    }

    if filled < width {
        stdout.write_all(b">")?;
    }

    let width_minus_filled = width - filled;
    if width_minus_filled > 1 {
        let red_part_width = width_minus_filled - 1;
        stdout.queue(SetForegroundColor(Color::Red))?;
        for _ in 0..red_part_width {
            stdout.write_all(b"-")?;
        }
    }

    stdout.queue(SetForegroundColor(Color::Reset))?;

    write!(stdout, "] {progress:>3}/{total}")
}

pub fn clear_terminal(stdout: &mut StdoutLock) -> io::Result<()> {
    stdout
        .queue(MoveTo(0, 0))?
        .queue(Clear(ClearType::All))?
        .queue(Clear(ClearType::Purge))
        .map(|_| ())
}

pub fn press_enter_prompt(stdout: &mut StdoutLock) -> io::Result<()> {
    stdout.flush()?;
    io::stdin().lock().read_until(b'\n', &mut Vec::new())?;
    stdout.write_all(b"\n")
}

/// Canonicalize, convert to string and remove verbatim part on Windows.
pub fn canonicalize(path: &str) -> Option<String> {
    fs::canonicalize(path)
        .ok()?
        .into_os_string()
        .into_string()
        .ok()
        .map(|mut path| {
            // Windows itself can't handle its verbatim paths.
            if cfg!(windows) && path.as_bytes().starts_with(br"\\?\") {
                path.drain(..4);
            }

            path
        })
}

pub fn file_path<'a, W: CountedWrite<'a>>(
    writer: &mut W,
    color: Color,
    f: impl FnOnce(&mut W) -> io::Result<()>,
) -> io::Result<()> {
    writer
        .stdout()
        .queue(SetForegroundColor(color))?
        .queue(SetAttribute(Attribute::Underlined))?;

    f(writer)?;

    writer
        .stdout()
        .queue(SetForegroundColor(Color::Reset))?
        .queue(SetAttribute(Attribute::NoUnderline))?;

    Ok(())
}

pub fn terminal_file_link<'a>(
    writer: &mut impl CountedWrite<'a>,
    path: &str,
    canonical_path: &str,
) -> io::Result<()> {
    writer.stdout().write_all(b"\x1b]8;;file://")?;
    writer.stdout().write_all(canonical_path.as_bytes())?;
    writer.stdout().write_all(b"\x1b\\")?;
    // Only this part is visible.
    writer.write_str(path)?;
    writer.stdout().write_all(b"\x1b]8;;\x1b\\")
}

pub fn write_ansi(output: &mut Vec<u8>, command: impl Command) {
    struct FmtWriter<'a>(&'a mut Vec<u8>);

    impl fmt::Write for FmtWriter<'_> {
        fn write_str(&mut self, s: &str) -> fmt::Result {
            self.0.extend_from_slice(s.as_bytes());
            Ok(())
        }
    }

    let _ = command.write_ansi(&mut FmtWriter(output));
}



================================================
FILE: src/watch.rs
================================================
use anyhow::{Error, Result};
use notify::{Config, RecommendedWatcher, RecursiveMode, Watcher};
use std::{
    io::{self, Write},
    path::Path,
    sync::{
        atomic::{AtomicBool, Ordering::Relaxed},
        mpsc::channel,
    },
    time::Duration,
};

use crate::{
    app_state::{AppState, ExercisesProgress},
    list,
};

use self::{notify_event::NotifyEventHandler, state::WatchState, terminal_event::InputEvent};

mod notify_event;
mod state;
mod terminal_event;

static EXERCISE_RUNNING: AtomicBool = AtomicBool::new(false);

// Private unit type to force using the constructor function.
#[must_use = "When the guard is dropped, the input is unpaused"]
pub struct InputPauseGuard(());

impl InputPauseGuard {
    #[inline]
    pub fn scoped_pause() -> Self {
        EXERCISE_RUNNING.store(true, Relaxed);
        Self(())
    }
}

impl Drop for InputPauseGuard {
    #[inline]
    fn drop(&mut self) {
        EXERCISE_RUNNING.store(false, Relaxed);
    }
}

enum WatchEvent {
    Input(InputEvent),
    FileChange { exercise_ind: usize },
    TerminalResize { width: u16 },
    NotifyErr(notify::Error),
    TerminalEventErr(io::Error),
}

/// Returned by the watch mode to indicate what to do afterwards.
#[must_use]
enum WatchExit {
    /// Exit the program.
    Shutdown,
    /// Enter the list mode and restart the watch mode afterwards.
    List,
}

fn run_watch(
    app_state: &mut AppState,
    notify_exercise_names: Option<&'static [&'static [u8]]>,
) -> Result<WatchExit> {
    let (watch_event_sender, watch_event_receiver) = channel();

    let mut manual_run = false;
    // Prevent dropping the guard until the end of the function.
    // Otherwise, the file watcher exits.
    let _watcher_guard = if let Some(exercise_names) = notify_exercise_names {
        let notify_event_handler =
            NotifyEventHandler::build(watch_event_sender.clone(), exercise_names)?;

        let mut watcher = RecommendedWatcher::new(
            notify_event_handler,
            Config::default()
                .with_follow_symlinks(false)
                .with_poll_interval(Duration::from_secs(1)),
        )
        .inspect_err(|_| eprintln!("{NOTIFY_ERR}"))?;

        watcher
            .watch(Path::new("exercises"), RecursiveMode::Recursive)
            .inspect_err(|_| eprintln!("{NOTIFY_ERR}"))?;

        Some(watcher)
    } else {
        manual_run = true;
        None
    };

    let mut watch_state = WatchState::build(app_state, watch_event_sender, manual_run)?;
    let mut stdout = io::stdout().lock();

    watch_state.run_current_exercise(&mut stdout)?;

    while let Ok(event) = watch_event_receiver.recv() {
        match event {
            WatchEvent::Input(InputEvent::Next) => match watch_state.next_exercise(&mut stdout)? {
                ExercisesProgress::AllDone => break,
                ExercisesProgress::NewPending => watch_state.run_current_exercise(&mut stdout)?,
                ExercisesProgress::CurrentPending => (),
            },
            WatchEvent::Input(InputEvent::Run) => watch_state.run_current_exercise(&mut stdout)?,
            WatchEvent::Input(InputEvent::Hint) => watch_state.show_hint(&mut stdout)?,
            WatchEvent::Input(InputEvent::List) => return Ok(WatchExit::List),
            WatchEvent::Input(InputEvent::CheckAll) => match watch_state
                .check_all_exercises(&mut stdout)?
            {
                ExercisesProgress::AllDone => break,
                ExercisesProgress::NewPending => watch_state.run_current_exercise(&mut stdout)?,
                ExercisesProgress::CurrentPending => watch_state.render(&mut stdout)?,
            },
            WatchEvent::Input(InputEvent::Reset) => watch_state.reset_exercise(&mut stdout)?,
            WatchEvent::Input(InputEvent::Quit) => {
                stdout.write_all(QUIT_MSG)?;
                break;
            }
            WatchEvent::FileChange { exercise_ind } => {
                watch_state.handle_file_change(exercise_ind, &mut stdout)?;
            }
            WatchEvent::TerminalResize { width } => {
                watch_state.update_term_width(width, &mut stdout)?;
            }
            WatchEvent::NotifyErr(e) => return Err(Error::from(e).context(NOTIFY_ERR)),
            WatchEvent::TerminalEventErr(e) => {
                return Err(Error::from(e).context("Terminal event listener failed"));
            }
        }
    }

    Ok(WatchExit::Shutdown)
}

fn watch_list_loop(
    app_state: &mut AppState,
    notify_exercise_names: Option<&'static [&'static [u8]]>,
) -> Result<()> {
    loop {
        match run_watch(app_state, notify_exercise_names)? {
            WatchExit::Shutdown => break Ok(()),
            // It is much easier to exit the watch mode, launch the list mode and then restart
            // the watch mode instead of trying to pause the watch threads and correct the
            // watch state.
            WatchExit::List => list::list(app_state)?,
        }
    }
}

/// `notify_exercise_names` as None activates the manual run mode.
pub fn watch(
    app_state: &mut AppState,
    notify_exercise_names: Option<&'static [&'static [u8]]>,
) -> Result<()> {
    #[cfg(not(windows))]
    {
        let stdin_fd = rustix::stdio::stdin();
        let mut termios = rustix::termios::tcgetattr(stdin_fd)?;
        let original_local_modes = termios.local_modes;
        // Disable stdin line buffering and hide input.
        termios.local_modes -=
            rustix::termios::LocalModes::ICANON | rustix::termios::LocalModes::ECHO;
        rustix::termios::tcsetattr(stdin_fd, rustix::termios::OptionalActions::Now, &termios)?;

        let res = watch_list_loop(app_state, notify_exercise_names);

        termios.local_modes = original_local_modes;
        rustix::termios::tcsetattr(stdin_fd, rustix::termios::OptionalActions::Now, &termios)?;

        res
    }

    #[cfg(windows)]
    watch_list_loop(app_state, notify_exercise_names)
}

const QUIT_MSG: &[u8] = b"

We hope you're enjoying learning Rust!
If you want to continue working on the exercises at a later point, you can simply run `rustlings` again in this directory.
";

const NOTIFY_ERR: &str = "
The automatic detection of exercise file changes failed :(
Please try running `rustlings` again.

If you keep getting this error, run `rustlings --manual-run` to deactivate the file watcher.
You need to manually trigger running the current exercise using `r` then.
";



================================================
FILE: src/dev/check.rs
================================================
use anyhow::{Context, Error, Result, anyhow, bail};
use std::{
    cmp::Ordering,
    collections::HashSet,
    fs::{self, OpenOptions, read_dir},
    io::{self, Read, Write},
    path::{Path, PathBuf},
    process::{Command, Stdio},
    thread,
};

use crate::{
    CURRENT_FORMAT_VERSION,
    cargo_toml::{BINS_BUFFER_CAPACITY, append_bins, bins_start_end_ind},
    cmd::CmdRunner,
    exercise::{OUTPUT_CAPACITY, RunnableExercise},
    info_file::{ExerciseInfo, InfoFile},
    term::ProgressCounter,
};

const MAX_N_EXERCISES: usize = 999;
const MAX_EXERCISE_NAME_LEN: usize = 32;

// Find a char that isn't allowed in the exercise's `name` or `dir`.
fn forbidden_char(input: &str) -> Option<char> {
    input.chars().find(|c| !c.is_alphanumeric() && *c != '_')
}

// Check that the `Cargo.toml` file is up-to-date.
fn check_cargo_toml(
    exercise_infos: &[ExerciseInfo],
    cargo_toml_path: &str,
    exercise_path_prefix: &[u8],
) -> Result<()> {
    let current_cargo_toml = fs::read_to_string(cargo_toml_path)
        .with_context(|| format!("Failed to read the file `{cargo_toml_path}`"))?;

    let (bins_start_ind, bins_end_ind) = bins_start_end_ind(&current_cargo_toml)?;

    let old_bins = &current_cargo_toml.as_bytes()[bins_start_ind..bins_end_ind];
    let mut new_bins = Vec::with_capacity(BINS_BUFFER_CAPACITY);
    append_bins(&mut new_bins, exercise_infos, exercise_path_prefix);

    if old_bins != new_bins {
        if cfg!(debug_assertions) {
            bail!(
                "The file `dev/Cargo.toml` is outdated. Run `cargo dev update` to update it. Then run `cargo run -- dev check` again"
            );
        }

        bail!(
            "The file `Cargo.toml` is outdated. Run `rustlings dev update` to update it. Then run `rustlings dev check` again"
        );
    }

    Ok(())
}

// Check the info of all exercises and return their paths in a set.
fn check_info_file_exercises(info_file: &InfoFile) -> Result<HashSet<PathBuf>> {
    let mut names = HashSet::with_capacity(info_file.exercises.len());
    let mut paths = HashSet::with_capacity(info_file.exercises.len());

    let mut file_buf = String::with_capacity(1 << 14);
    for exercise_info in &info_file.exercises {
        let name = exercise_info.name.as_str();
        if name.is_empty() {
            bail!("Found an empty exercise name in `info.toml`");
        }
        if name.len() > MAX_EXERCISE_NAME_LEN {
            bail!(
                "The length of the exercise name `{name}` is bigger than the maximum {MAX_EXERCISE_NAME_LEN}"
            );
        }
        if let Some(c) = forbidden_char(name) {
            bail!("Char `{c}` in the exercise name `{name}` is not allowed");
        }

        if let Some(dir) = &exercise_info.dir {
            if dir.is_empty() {
                bail!("The exercise `{name}` has an empty dir name in `info.toml`");
            }
            if let Some(c) = forbidden_char(dir) {
                bail!("Char `{c}` in the exercise dir `{dir}` is not allowed");
            }
        }

        if exercise_info.hint.trim_ascii().is_empty() {
            bail!(
                "The exercise `{name}` has an empty hint. Please provide a hint or at least tell the user why a hint isn't needed for this exercise"
            );
        }

        if !names.insert(name) {
            bail!("The exercise name `{name}` is duplicated. Exercise names must all be unique");
        }

        let path = exercise_info.path();

        OpenOptions::new()
            .read(true)
            .open(&path)
            .with_context(|| format!("Failed to open the file {path}"))?
            .read_to_string(&mut file_buf)
            .with_context(|| format!("Failed to read the file {path}"))?;

        if !file_buf.contains("fn main()") {
            bail!(
                "The `main` function is missing in the file `{path}`.\n\
                 Create at least an empty `main` function to avoid language server errors"
            );
        }

        if !file_buf.contains("// TODO") {
            bail!(
                "Didn't find any `// TODO` comment in the file `{path}`.\n\
                 You need to have at least one such comment to guide the user."
            );
        }

        let contains_tests = file_buf.contains("#[test]\n");
        if exercise_info.test {
            if !contains_tests {
                bail!(
                    "The file `{path}` doesn't contain any tests. If you don't want to add tests to this exercise, set `test = false` for this exercise in the `info.toml` file"
                );
            }
        } else if contains_tests {
            bail!(
                "The file `{path}` contains tests annotated with `#[test]` but the exercise `{name}` has `test = false` in the `info.toml` file"
            );
        }

        file_buf.clear();

        paths.insert(PathBuf::from(path));
    }

    Ok(paths)
}

// Check `dir` for unexpected files.
// Only Rust files in `allowed_rust_files` and `README.md` files are allowed.
// Only one level of directory nesting is allowed.
fn check_unexpected_files(dir: &str, allowed_rust_files: &HashSet<PathBuf>) -> Result<()> {
    let unexpected_file = |path: &Path| {
        anyhow!(
            "Found the file `{}`. Only `README.md` and Rust files related to an exercise in `info.toml` are allowed in the `{dir}` directory",
            path.display()
        )
    };

    for entry in read_dir(dir).with_context(|| format!("Failed to open the `{dir}` directory"))? {
        let entry = entry.with_context(|| format!("Failed to read the `{dir}` directory"))?;

        if entry.file_type().unwrap().is_file() {
            let path = entry.path();
            let file_name = path.file_name().unwrap();
            if file_name == "README.md" {
                continue;
            }

            if !allowed_rust_files.contains(&path) {
                return Err(unexpected_file(&path));
            }

            continue;
        }

        let dir_path = entry.path();
        for entry in read_dir(&dir_path)
            .with_context(|| format!("Failed to open the directory {}", dir_path.display()))?
        {
            let entry = entry
                .with_context(|| format!("Failed to read the directory {}", dir_path.display()))?;
            let path = entry.path();

            if !entry.file_type().unwrap().is_file() {
                bail!(
                    "Found `{}` but expected only files. Only one level of exercise nesting is allowed",
                    path.display()
                );
            }

            let file_name = path.file_name().unwrap();
            if file_name == "README.md" {
                continue;
            }

            if !allowed_rust_files.contains(&path) {
                return Err(unexpected_file(&path));
            }
        }
    }

    Ok(())
}

fn check_exercises_unsolved(
    info_file: &'static InfoFile,
    cmd_runner: &'static CmdRunner,
) -> Result<()> {
    let mut stdout = io::stdout().lock();
    stdout.write_all(b"Running all exercises to check that they aren't already solved...\n")?;

    let handles = info_file
        .exercises
        .iter()
        .filter_map(|exercise_info| {
            if exercise_info.skip_check_unsolved {
                return None;
            }

            Some(
                thread::Builder::new()
                    .spawn(|| exercise_info.run_exercise(None, cmd_runner))
                    .map(|handle| (exercise_info.name.as_str(), handle)),
            )
        })
        .collect::<Result<Vec<_>, _>>()
        .context("Failed to spawn a thread to check if an exercise is already solved")?;

    let mut progress_counter = ProgressCounter::new(&mut stdout, handles.len())?;

    for (exercise_name, handle) in handles {
        let Ok(result) = handle.join() else {
            bail!("Panic while trying to run the exercise {exercise_name}");
        };

        match result {
            Ok(true) => {
                bail!(
                    "The exercise {exercise_name} is already solved.\n\
                     {SKIP_CHECK_UNSOLVED_HINT}",
                )
            }
            Ok(false) => (),
            Err(e) => return Err(e),
        }

        progress_counter.increment()?;
    }

    Ok(())
}

fn check_exercises(info_file: &'static InfoFile, cmd_runner: &'static CmdRunner) -> Result<()> {
    match info_file.format_version.cmp(&CURRENT_FORMAT_VERSION) {
        Ordering::Less => bail!(
            "`format_version` < {CURRENT_FORMAT_VERSION} (supported version)\n\
             Please migrate to the latest format version"
        ),
        Ordering::Greater => bail!(
            "`format_version` > {CURRENT_FORMAT_VERSION} (supported version)\n\
             Try updating the Rustlings program"
        ),
        Ordering::Equal => (),
    }

    let handle = thread::Builder::new()
        .spawn(move || check_exercises_unsolved(info_file, cmd_runner))
        .context("Failed to spawn a thread to check if any exercise is already solved")?;

    let info_file_paths = check_info_file_exercises(info_file)?;
    check_unexpected_files("exercises", &info_file_paths)?;

    handle.join().unwrap()
}

enum SolutionCheck {
    Success { sol_path: String },
    MissingOptional,
    RunFailure { output: Vec<u8> },
    Err(Error),
}

fn check_solutions(
    require_solutions: bool,
    info_file: &'static InfoFile,
    cmd_runner: &'static CmdRunner,
) -> Result<()> {
    let mut stdout = io::stdout().lock();
    stdout.write_all(b"Running all solutions...\n")?;

    let handles = info_file
        .exercises
        .iter()
        .map(|exercise_info| {
            thread::Builder::new().spawn(move || {
                let sol_path = exercise_info.sol_path();
                if !Path::new(&sol_path).exists() {
                    if require_solutions {
                        return SolutionCheck::Err(anyhow!(
                            "The solution of the exercise {} is missing",
                            exercise_info.name,
                        ));
                    }

                    return SolutionCheck::MissingOptional;
                }

                let mut output = Vec::with_capacity(OUTPUT_CAPACITY);
                match exercise_info.run_solution(Some(&mut output), cmd_runner) {
                    Ok(true) => SolutionCheck::Success { sol_path },
                    Ok(false) => SolutionCheck::RunFailure { output },
                    Err(e) => SolutionCheck::Err(e),
                }
            })
        })
        .collect::<Result<Vec<_>, _>>()
        .context("Failed to spawn a thread to check a solution")?;

    let mut sol_paths = HashSet::with_capacity(info_file.exercises.len());
    let mut fmt_cmd = Command::new("rustfmt");
    fmt_cmd
        .arg("--check")
        .arg("--edition")
        .arg("2024")
        .arg("--color")
        .arg("always")
        .stdin(Stdio::null());

    let mut progress_counter = ProgressCounter::new(&mut stdout, handles.len())?;

    for (exercise_info, handle) in info_file.exercises.iter().zip(handles) {
        let Ok(check_result) = handle.join() else {
            bail!(
                "Panic while trying to run the solution of the exercise {}",
                exercise_info.name,
            );
        };

        match check_result {
            SolutionCheck::Success { sol_path } => {
                fmt_cmd.arg(&sol_path);
                sol_paths.insert(PathBuf::from(sol_path));
            }
            SolutionCheck::MissingOptional => (),
            SolutionCheck::RunFailure { output } => {
                drop(progress_counter);
                stdout.write_all(&output)?;
                bail!(
                    "Running the solution of the exercise {} failed with the error above",
                    exercise_info.name,
                );
            }
            SolutionCheck::Err(e) => return Err(e),
        }

        progress_counter.increment()?;
    }

    let n_solutions = sol_paths.len();
    let handle = thread::Builder::new()
        .spawn(move || check_unexpected_files("solutions", &sol_paths))
        .context(
            "Failed to spawn a thread to check for unexpected files in the solutions directory",
        )?;

    if n_solutions > 0
        && !fmt_cmd
            .status()
            .context("Failed to run `rustfmt` on all solution files")?
            .success()
    {
        bail!("Some solutions aren't formatted. Run `rustfmt` on them");
    }

    handle.join().unwrap()
}

pub fn check(require_solutions: bool) -> Result<()> {
    let info_file = InfoFile::parse()?;

    if info_file.exercises.len() > MAX_N_EXERCISES {
        bail!("The maximum number of exercises is {MAX_N_EXERCISES}");
    }

    if cfg!(debug_assertions) {
        // A hack to make `cargo dev check` work when developing Rustlings.
        check_cargo_toml(&info_file.exercises, "dev/Cargo.toml", b"../")?;
    } else {
        check_cargo_toml(&info_file.exercises, "Cargo.toml", b"")?;
    }

    // Leaking is fine since they are used until the end of the program.
    let cmd_runner = Box::leak(Box::new(CmdRunner::build()?));
    let info_file = Box::leak(Box::new(info_file));

    check_exercises(info_file, cmd_runner)?;
    check_solutions(require_solutions, info_file, cmd_runner)?;

    println!("Everything looks fine!");

    Ok(())
}

const SKIP_CHECK_UNSOLVED_HINT: &str = "If this is an introduction exercise that is intended to be already solved, add `skip_check_unsolved = true` to the exercise's metadata in the `info.toml` file";



================================================
FILE: src/dev/new.rs
================================================
use anyhow::{Context, Result, bail};
use std::{
    env::set_current_dir,
    fs::{self, create_dir},
    path::Path,
    process::Command,
};

use crate::{CURRENT_FORMAT_VERSION, init::RUST_ANALYZER_TOML};

// Create a directory relative to the current directory and print its path.
fn create_rel_dir(dir_name: &str, current_dir: &str) -> Result<()> {
    create_dir(dir_name)
        .with_context(|| format!("Failed to create the directory {current_dir}/{dir_name}"))?;
    println!("Created the directory {current_dir}/{dir_name}");
    Ok(())
}

// Write a file relative to the current directory and print its path.
fn write_rel_file<C>(file_name: &str, current_dir: &str, content: C) -> Result<()>
where
    C: AsRef<[u8]>,
{
    fs::write(file_name, content)
        .with_context(|| format!("Failed to create the file {current_dir}/{file_name}"))?;
    // Space to align with `create_rel_dir`.
    println!("Created the file      {current_dir}/{file_name}");
    Ok(())
}

pub fn new(path: &Path, no_git: bool) -> Result<()> {
    let dir_path_str = path.to_string_lossy();

    create_dir(path).with_context(|| format!("Failed to create the directory {dir_path_str}"))?;
    println!("Created the directory {dir_path_str}");

    set_current_dir(path)
        .with_context(|| format!("Failed to set {dir_path_str} as the current directory"))?;

    if !no_git
        && !Command::new("git")
            .arg("init")
            .status()
            .context("Failed to run `git init`")?
            .success()
    {
        bail!("`git init` didn't run successfully. See the possible error message above");
    }

    write_rel_file(".gitignore", &dir_path_str, GITIGNORE)?;

    create_rel_dir("exercises", &dir_path_str)?;
    create_rel_dir("solutions", &dir_path_str)?;

    write_rel_file(
        "info.toml",
        &dir_path_str,
        format!(
            "{INFO_FILE_BEFORE_FORMAT_VERSION}{CURRENT_FORMAT_VERSION}{INFO_FILE_AFTER_FORMAT_VERSION}"
        ),
    )?;

    write_rel_file("Cargo.toml", &dir_path_str, CARGO_TOML)?;

    write_rel_file("README.md", &dir_path_str, README)?;

    write_rel_file("rust-analyzer.toml", &dir_path_str, RUST_ANALYZER_TOML)?;

    create_rel_dir(".vscode", &dir_path_str)?;
    write_rel_file(
        ".vscode/extensions.json",
        &dir_path_str,
        crate::init::VS_CODE_EXTENSIONS_JSON,
    )?;

    println!("\nInitialization done ✓");

    Ok(())
}

pub const GITIGNORE: &[u8] = b"Cargo.lock
target/
.vscode/
!.vscode/extensions.json
";

const INFO_FILE_BEFORE_FORMAT_VERSION: &str =
    "# The format version is an indicator of the compatibility of community exercises with the
# Rustlings program.
# The format version is not the same as the version of the Rustlings program.
# In case Rustlings makes an unavoidable breaking change to the expected format of community
# exercises, you would need to raise this version and adapt to the new format.
# Otherwise, the newest version of the Rustlings program won't be able to run these exercises.
format_version = ";

const INFO_FILE_AFTER_FORMAT_VERSION: &str = r#"

# Optional multi-line message to be shown to users when just starting with the exercises.
welcome_message = """Welcome to these community Rustlings exercises."""

# Optional multi-line message to be shown to users after finishing all exercises.
final_message = """We hope that you found the exercises helpful :D"""

# Repeat this section for every exercise.
[[exercises]]
# Exercise name which is the exercise file name without the `.rs` extension.
name = "???"

# Optional directory name to be provided if you want to organize exercises in directories.
# If `dir` is specified, the exercise path is `exercises/DIR/NAME.rs`
# Otherwise, the path is `exercises/NAME.rs`
# dir = "???"

# Rustlings expects the exercise to contain tests and run them.
# You can optionally disable testing by setting `test` to `false` (the default is `true`).
# In that case, the exercise will be considered done when it just successfully compiles.
# test = true

# Rustlings will always run Clippy on exercises.
# You can optionally set `strict_clippy` to `true` (the default is `false`) to only consider
# the exercise as done when there are no warnings left.
# strict_clippy = false

# A multi-line hint to be shown to users on request.
hint = """???"""
"#;

const CARGO_TOML: &[u8] =
    br#"# Don't edit the `bin` list manually! It is updated by `rustlings dev update`
bin = []

[package]
name = "exercises"
edition = "2024"
# Don't publish the exercises on crates.io!
publish = false

[dependencies]
"#;

const README: &str = "# Rustlings 🦀

Welcome to these community Rustlings exercises 😃

First, [install Rustlings using the official instructions](https://github.com/rust-lang/rustlings) ✅

Then, clone this repository, open a terminal in this directory and run `rustlings` to get started with the exercises 🚀
";



================================================
FILE: src/dev/update.rs
================================================
use anyhow::{Context, Result};
use std::fs;

use crate::{
    cargo_toml::updated_cargo_toml,
    info_file::{ExerciseInfo, InfoFile},
};

// Update the `Cargo.toml` file.
fn update_cargo_toml(
    exercise_infos: &[ExerciseInfo],
    cargo_toml_path: &str,
    exercise_path_prefix: &[u8],
) -> Result<()> {
    let current_cargo_toml = fs::read_to_string(cargo_toml_path)
        .with_context(|| format!("Failed to read the file `{cargo_toml_path}`"))?;

    let updated_cargo_toml =
        updated_cargo_toml(exercise_infos, &current_cargo_toml, exercise_path_prefix)?;

    fs::write(cargo_toml_path, updated_cargo_toml)
        .context("Failed to write the `Cargo.toml` file")?;

    Ok(())
}

pub fn update() -> Result<()> {
    let info_file = InfoFile::parse()?;

    if cfg!(debug_assertions) {
        // A hack to make `cargo dev update` work when developing Rustlings.
        update_cargo_toml(&info_file.exercises, "dev/Cargo.toml", b"../")
            .context("Failed to update the file `dev/Cargo.toml`")?;

        println!("Updated `dev/Cargo.toml`");
    } else {
        update_cargo_toml(&info_file.exercises, "Cargo.toml", &[])
            .context("Failed to update the file `Cargo.toml`")?;

        println!("Updated `Cargo.toml`");
    }

    Ok(())
}



================================================
FILE: src/list/scroll_state.rs
================================================
pub struct ScrollState {
    n_rows: usize,
    max_n_rows_to_display: usize,
    selected: Option<usize>,
    offset: usize,
    scroll_padding: usize,
    max_scroll_padding: usize,
}

impl ScrollState {
    pub fn new(n_rows: usize, selected: Option<usize>, max_scroll_padding: usize) -> Self {
        Self {
            n_rows,
            max_n_rows_to_display: 0,
            selected,
            offset: selected.map_or(0, |selected| selected.saturating_sub(max_scroll_padding)),
            scroll_padding: 0,
            max_scroll_padding,
        }
    }

    #[inline]
    pub fn offset(&self) -> usize {
        self.offset
    }

    fn update_offset(&mut self) {
        let Some(selected) = self.selected else {
            return;
        };

        let min_offset = (selected + self.scroll_padding)
            .saturating_sub(self.max_n_rows_to_display.saturating_sub(1));
        let max_offset = selected.saturating_sub(self.scroll_padding);
        let global_max_offset = self.n_rows.saturating_sub(self.max_n_rows_to_display);

        self.offset = self
            .offset
            .max(min_offset)
            .min(max_offset)
            .min(global_max_offset);
    }

    #[inline]
    pub fn selected(&self) -> Option<usize> {
        self.selected
    }

    pub fn set_selected(&mut self, selected: usize) {
        self.selected = Some(selected);
        self.update_offset();
    }

    pub fn select_next(&mut self) {
        if let Some(selected) = self.selected {
            self.set_selected((selected + 1).min(self.n_rows - 1));
        }
    }

    pub fn select_previous(&mut self) {
        if let Some(selected) = self.selected {
            self.set_selected(selected.saturating_sub(1));
        }
    }

    pub fn select_first(&mut self) {
        if self.n_rows > 0 {
            self.set_selected(0);
        }
    }

    pub fn select_last(&mut self) {
        if self.n_rows > 0 {
            self.set_selected(self.n_rows - 1);
        }
    }

    pub fn set_n_rows(&mut self, n_rows: usize) {
        self.n_rows = n_rows;

        if self.n_rows == 0 {
            self.selected = None;
            return;
        }

        self.set_selected(self.selected.map_or(0, |selected| selected.min(n_rows - 1)));
    }

    #[inline]
    fn update_scroll_padding(&mut self) {
        self.scroll_padding = (self.max_n_rows_to_display / 4).min(self.max_scroll_padding);
    }

    #[inline]
    pub fn max_n_rows_to_display(&self) -> usize {
        self.max_n_rows_to_display
    }

    pub fn set_max_n_rows_to_display(&mut self, max_n_rows_to_display: usize) {
        self.max_n_rows_to_display = max_n_rows_to_display;
        self.update_scroll_padding();
        self.update_offset();
    }
}



================================================
FILE: src/list/state.rs
================================================
use anyhow::{Context, Result};
use crossterm::{
    QueueableCommand,
    cursor::{MoveTo, MoveToNextLine},
    style::{
        Attribute, Attributes, Color, ResetColor, SetAttribute, SetAttributes, SetForegroundColor,
    },
    terminal::{self, BeginSynchronizedUpdate, Clear, ClearType, EndSynchronizedUpdate},
};
use std::{
    fmt::Write as _,
    io::{self, StdoutLock, Write},
};

use crate::{
    app_state::AppState,
    exercise::Exercise,
    term::{CountedWrite, MaxLenWriter, progress_bar},
};

use super::scroll_state::ScrollState;

const COL_SPACING: usize = 2;
const SELECTED_ROW_ATTRIBUTES: Attributes = Attributes::none()
    .with(Attribute::Reverse)
    .with(Attribute::Bold);

fn next_ln(stdout: &mut StdoutLock) -> io::Result<()> {
    stdout
        .queue(Clear(ClearType::UntilNewLine))?
        .queue(MoveToNextLine(1))?;
    Ok(())
}

#[derive(Copy, Clone, PartialEq, Eq)]
pub enum Filter {
    Done,
    Pending,
    None,
}

pub struct ListState<'a> {
    /// Footer message to be displayed if not empty.
    pub message: String,
    pub search_query: String,
    app_state: &'a mut AppState,
    scroll_state: ScrollState,
    name_col_padding: Vec<u8>,
    path_col_padding: Vec<u8>,
    filter: Filter,
    term_width: u16,
    term_height: u16,
    show_footer: bool,
}

impl<'a> ListState<'a> {
    pub fn build(app_state: &'a mut AppState, stdout: &mut StdoutLock) -> Result<Self> {
        stdout.queue(Clear(ClearType::All))?;

        let name_col_title_len = 4;
        let path_col_title_len = 4;
        let (name_col_width, path_col_width) = app_state.exercises().iter().fold(
            (name_col_title_len, path_col_title_len),
            |(name_col_width, path_col_width), exercise| {
                (
                    name_col_width.max(exercise.name.len()),
                    path_col_width.max(exercise.path.len()),
                )
            },
        );
        let name_col_padding = vec![b' '; name_col_width + COL_SPACING];
        let path_col_padding = vec![b' '; path_col_width];

        let filter = Filter::None;
        let n_rows_with_filter = app_state.exercises().len();
        let selected = app_state.current_exercise_ind();

        let (width, height) = terminal::size().context("Failed to get the terminal size")?;
        let scroll_state = ScrollState::new(n_rows_with_filter, Some(selected), 5);

        let mut slf = Self {
            message: String::with_capacity(128),
            search_query: String::new(),
            app_state,
            scroll_state,
            name_col_padding,
            path_col_padding,
            filter,
            // Set by `set_term_size`
            term_width: 0,
            term_height: 0,
            show_footer: true,
        };

        slf.set_term_size(width, height);
        slf.draw(stdout)?;

        Ok(slf)
    }

    pub fn set_term_size(&mut self, width: u16, height: u16) {
        self.term_width = width;
        self.term_height = height;

        if height == 0 {
            return;
        }

        let header_height = 1;
        // 1 progress bar, 2 footer message lines.
        let footer_height = 3;
        self.show_footer = height > header_height + footer_height;

        self.scroll_state.set_max_n_rows_to_display(
            height.saturating_sub(header_height + u16::from(self.show_footer) * footer_height)
                as usize,
        );
    }

    fn draw_exercise_name(&self, writer: &mut MaxLenWriter, exercise: &Exercise) -> io::Result<()> {
        if !self.search_query.is_empty()
            && let Some((pre_highlight, highlight, post_highlight)) = exercise
                .name
                .find(&self.search_query)
                .and_then(|ind| exercise.name.split_at_checked(ind))
                .and_then(|(pre_highlight, rest)| {
                    rest.split_at_checked(self.search_query.len())
                        .map(|x| (pre_highlight, x.0, x.1))
                })
        {
            writer.write_str(pre_highlight)?;
            writer.stdout.queue(SetForegroundColor(Color::Magenta))?;
            writer.write_str(highlight)?;
            writer.stdout.queue(SetForegroundColor(Color::Reset))?;
            return writer.write_str(post_highlight);
        }

        writer.write_str(exercise.name)
    }

    fn draw_rows(
        &self,
        stdout: &mut StdoutLock,
        filtered_exercises: impl Iterator<Item = (usize, &'a Exercise)>,
    ) -> io::Result<usize> {
        let current_exercise_ind = self.app_state.current_exercise_ind();
        let row_offset = self.scroll_state.offset();
        let mut n_displayed_rows = 0;

        for (exercise_ind, exercise) in filtered_exercises
            .skip(row_offset)
            .take(self.scroll_state.max_n_rows_to_display())
        {
            let mut writer = MaxLenWriter::new(stdout, self.term_width as usize);

            if self.scroll_state.selected() == Some(row_offset + n_displayed_rows) {
                // The crab emoji has the width of two ascii chars.
                writer.add_to_len(2);
                writer.stdout.write_all("🦀".as_bytes())?;
                writer
                    .stdout
                    .queue(SetAttributes(SELECTED_ROW_ATTRIBUTES))?;
            } else {
                writer.write_ascii(b"  ")?;
            }

            if exercise_ind == current_exercise_ind {
                writer.stdout.queue(SetForegroundColor(Color::Red))?;
                writer.write_ascii(b">>>>>>>  ")?;
            } else {
                writer.write_ascii(b"         ")?;
            }

            if exercise.done {
                writer.stdout.queue(SetForegroundColor(Color::Green))?;
                writer.write_ascii(b"DONE   ")?;
            } else {
                writer.stdout.queue(SetForegroundColor(Color::Yellow))?;
                writer.write_ascii(b"PENDING")?;
            }
            writer.stdout.queue(SetForegroundColor(Color::Reset))?;
            writer.write_ascii(b"  ")?;

            self.draw_exercise_name(&mut writer, exercise)?;

            writer.write_ascii(&self.name_col_padding[exercise.name.len()..])?;

            exercise.terminal_file_link(&mut writer, self.app_state.emit_file_links())?;

            writer.write_ascii(&self.path_col_padding[exercise.path.len()..])?;

            next_ln(stdout)?;
            stdout.queue(ResetColor)?;
            n_displayed_rows += 1;
        }

        Ok(n_displayed_rows)
    }

    pub fn draw(&mut self, stdout: &mut StdoutLock) -> io::Result<()> {
        if self.term_height == 0 {
            return Ok(());
        }

        stdout.queue(BeginSynchronizedUpdate)?.queue(MoveTo(0, 0))?;

        // Header
        let mut writer = MaxLenWriter::new(stdout, self.term_width as usize);
        writer.write_ascii(b"  Current  State    Name")?;
        writer.write_ascii(&self.name_col_padding[4..])?;
        writer.write_ascii(b"Path")?;
        next_ln(stdout)?;

        // Rows
        let iter = self.app_state.exercises().iter().enumerate();
        let n_displayed_rows = match self.filter {
            Filter::Done => self.draw_rows(stdout, iter.filter(|(_, exercise)| exercise.done))?,
            Filter::Pending => {
                self.draw_rows(stdout, iter.filter(|(_, exercise)| !exercise.done))?
            }
            Filter::None => self.draw_rows(stdout, iter)?,
        };

        for _ in 0..self.scroll_state.max_n_rows_to_display() - n_displayed_rows {
            next_ln(stdout)?;
        }

        if self.show_footer {
            progress_bar(
                &mut MaxLenWriter::new(stdout, self.term_width as usize),
                self.app_state.n_done(),
                self.app_state.exercises().len() as u16,
                self.term_width,
            )?;
            next_ln(stdout)?;

            let mut writer = MaxLenWriter::new(stdout, self.term_width as usize);
            if self.message.is_empty() {
                // Help footer message
                if self.scroll_state.selected().is_some() {
                    writer.write_str("↓/j ↑/k home/g end/G | <c>ontinue at | <r>eset exercise")?;
                    next_ln(stdout)?;
                    writer = MaxLenWriter::new(stdout, self.term_width as usize);

                    writer.write_ascii(b"<s>earch | filter ")?;
                } else {
                    // Nothing selected (and nothing shown), so only display filter and quit.
                    writer.write_ascii(b"filter ")?;
                }

                match self.filter {
                    Filter::Done => {
                        writer
                            .stdout
                            .queue(SetForegroundColor(Color::Magenta))?
                            .queue(SetAttribute(Attribute::Underlined))?;
                        writer.write_ascii(b"<d>one")?;
                        writer.stdout.queue(ResetColor)?;
                        writer.write_ascii(b"/<p>ending")?;
                    }
                    Filter::Pending => {
                        writer.write_ascii(b"<d>one/")?;
                        writer
                            .stdout
                            .queue(SetForegroundColor(Color::Magenta))?
                            .queue(SetAttribute(Attribute::Underlined))?;
                        writer.write_ascii(b"<p>ending")?;
                        writer.stdout.queue(ResetColor)?;
                    }
                    Filter::None => writer.write_ascii(b"<d>one/<p>ending")?,
                }

                writer.write_ascii(b" | <q>uit list")?;
            } else {
                writer.stdout.queue(SetForegroundColor(Color::Magenta))?;
                writer.write_str(&self.message)?;
                stdout.queue(ResetColor)?;
                next_ln(stdout)?;
            }

            next_ln(stdout)?;
        }

        stdout.queue(EndSynchronizedUpdate)?.flush()
    }

    fn update_rows(&mut self) {
        let n_rows = match self.filter {
            Filter::Done => self
                .app_state
                .exercises()
                .iter()
                .filter(|exercise| exercise.done)
                .count(),
            Filter::Pending => self
                .app_state
                .exercises()
                .iter()
                .filter(|exercise| !exercise.done)
                .count(),
            Filter::None => self.app_state.exercises().len(),
        };

        self.scroll_state.set_n_rows(n_rows);
    }

    #[inline]
    pub fn filter(&self) -> Filter {
        self.filter
    }

    pub fn set_filter(&mut self, filter: Filter) {
        self.filter = filter;
        self.update_rows();
    }

    #[inline]
    pub fn select_next(&mut self) {
        self.scroll_state.select_next();
    }

    #[inline]
    pub fn select_previous(&mut self) {
        self.scroll_state.select_previous();
    }

    #[inline]
    pub fn select_first(&mut self) {
        self.scroll_state.select_first();
    }

    #[inline]
    pub fn select_last(&mut self) {
        self.scroll_state.select_last();
    }

    fn selected_to_exercise_ind(&self, selected: usize) -> Result<usize> {
        match self.filter {
            Filter::Done => self
                .app_state
                .exercises()
                .iter()
                .enumerate()
                .filter(|(_, exercise)| exercise.done)
                .nth(selected)
                .context("Invalid selection index")
                .map(|(ind, _)| ind),
            Filter::Pending => self
                .app_state
                .exercises()
                .iter()
                .enumerate()
                .filter(|(_, exercise)| !exercise.done)
                .nth(selected)
                .context("Invalid selection index")
                .map(|(ind, _)| ind),
            Filter::None => Ok(selected),
        }
    }

    pub fn reset_selected(&mut self) -> Result<()> {
        let Some(selected) = self.scroll_state.selected() else {
            self.message.push_str("Nothing selected to reset!");
            return Ok(());
        };

        let exercise_ind = self.selected_to_exercise_ind(selected)?;
        let exercise_name = self.app_state.reset_exercise_by_ind(exercise_ind)?;
        self.update_rows();
        write!(
            self.message,
            "The exercise `{exercise_name}` has been reset",
        )?;

        Ok(())
    }

    pub fn apply_search_query(&mut self) {
        self.message.push_str("search:");
        self.message.push_str(&self.search_query);
        self.message.push('|');

        if self.search_query.is_empty() {
            return;
        }

        let is_search_result = |exercise: &Exercise| exercise.name.contains(&self.search_query);
        let mut iter = self.app_state.exercises().iter();
        let ind = match self.filter {
            Filter::None => iter.position(is_search_result),
            Filter::Done => iter
                .filter(|exercise| exercise.done)
                .position(is_search_result),
            Filter::Pending => iter
                .filter(|exercise| !exercise.done)
                .position(is_search_result),
        };

        match ind {
            Some(exercise_ind) => self.scroll_state.set_selected(exercise_ind),
            None => self.message.push_str(" (not found)"),
        }
    }

    // Return `true` if there was something to select.
    pub fn selected_to_current_exercise(&mut self) -> Result<bool> {
        let Some(selected) = self.scroll_state.selected() else {
            self.message.push_str("Nothing selected to continue at!");
            return Ok(false);
        };

        let exercise_ind = self.selected_to_exercise_ind(selected)?;
        self.app_state.set_current_exercise_ind(exercise_ind)?;

        Ok(true)
    }
}



================================================
FILE: src/watch/notify_event.rs
================================================
use anyhow::{Context, Result};
use notify::{
    Event, EventKind,
    event::{AccessKind, AccessMode, MetadataKind, ModifyKind, RenameMode},
};
use std::{
    sync::{
        atomic::Ordering::Relaxed,
        mpsc::{RecvTimeoutError, Sender, SyncSender, sync_channel},
    },
    thread,
    time::Duration,
};

use super::{EXERCISE_RUNNING, WatchEvent};

const DEBOUNCE_DURATION: Duration = Duration::from_millis(200);

pub struct NotifyEventHandler {
    error_sender: Sender<WatchEvent>,
    // Sends the index of the updated exercise.
    update_sender: SyncSender<usize>,
    // Used to report which exercise was modified.
    exercise_names: &'static [&'static [u8]],
}

impl NotifyEventHandler {
    pub fn build(
        watch_event_sender: Sender<WatchEvent>,
        exercise_names: &'static [&'static [u8]],
    ) -> Result<Self> {
        let (update_sender, update_receiver) = sync_channel(0);
        let error_sender = watch_event_sender.clone();

        // Debouncer
        thread::Builder::new()
            .spawn(move || {
                let mut exercise_updated = vec![false; exercise_names.len()];

                loop {
                    match update_receiver.recv_timeout(DEBOUNCE_DURATION) {
                        Ok(exercise_ind) => exercise_updated[exercise_ind] = true,
                        Err(RecvTimeoutError::Timeout) => {
                            for (exercise_ind, updated) in exercise_updated.iter_mut().enumerate() {
                                if *updated {
                                    if watch_event_sender
                                        .send(WatchEvent::FileChange { exercise_ind })
                                        .is_err()
                                    {
                                        break;
                                    }

                                    *updated = false;
                                }
                            }
                        }
                        Err(RecvTimeoutError::Disconnected) => break,
                    }
                }
            })
            .context("Failed to spawn a thread to debounce file changes")?;

        Ok(Self {
            error_sender,
            update_sender,
            exercise_names,
        })
    }
}

impl notify::EventHandler for NotifyEventHandler {
    fn handle_event(&mut self, input_event: notify::Result<Event>) {
        if EXERCISE_RUNNING.load(Relaxed) {
            return;
        }

        let input_event = match input_event {
            Ok(v) => v,
            Err(e) => {
                // An error occurs when the receiver is dropped.
                // After dropping the receiver, the watcher guard should also be dropped.
                let _ = self.error_sender.send(WatchEvent::NotifyErr(e));
                return;
            }
        };

        match input_event.kind {
            EventKind::Any => (),
            EventKind::Modify(modify_kind) => match modify_kind {
                ModifyKind::Any | ModifyKind::Data(_) => (),
                ModifyKind::Name(rename_mode) => match rename_mode {
                    RenameMode::Any | RenameMode::To => (),
                    RenameMode::From | RenameMode::Both | RenameMode::Other => return,
                },
                ModifyKind::Metadata(metadata_kind) => match metadata_kind {
                    MetadataKind::Any | MetadataKind::WriteTime => (),
                    MetadataKind::AccessTime
                    | MetadataKind::Permissions
                    | MetadataKind::Ownership
                    | MetadataKind::Extended
                    | MetadataKind::Other => return,
                },
                ModifyKind::Other => return,
            },
            EventKind::Access(access_kind) => match access_kind {
                AccessKind::Any => (),
                AccessKind::Close(access_mode) => match access_mode {
                    AccessMode::Any | AccessMode::Write => (),
                    AccessMode::Execute | AccessMode::Read | AccessMode::Other => return,
                },
                AccessKind::Read | AccessKind::Open(_) | AccessKind::Other => return,
            },
            EventKind::Create(_) | EventKind::Remove(_) | EventKind::Other => return,
        }

        let _ = input_event
            .paths
            .into_iter()
            .filter_map(|path| {
                let file_name = path.file_name()?.to_str()?.as_bytes();

                let [file_name_without_ext @ .., b'.', b'r', b's'] = file_name else {
                    return None;
                };

                self.exercise_names
                    .iter()
                    .position(|exercise_name| *exercise_name == file_name_without_ext)
            })
            .try_for_each(|exercise_ind| self.update_sender.send(exercise_ind));
    }
}



================================================
FILE: src/watch/state.rs
================================================
use anyhow::{Context, Result};
use crossterm::{
    QueueableCommand,
    style::{
        Attribute, Attributes, Color, ResetColor, SetAttribute, SetAttributes, SetForegroundColor,
    },
    terminal,
};
use std::{
    io::{self, Read, StdoutLock, Write},
    sync::mpsc::{Sender, SyncSender, sync_channel},
    thread,
};

use crate::{
    app_state::{AppState, ExercisesProgress},
    clear_terminal,
    exercise::{OUTPUT_CAPACITY, RunnableExercise, solution_link_line},
    term::progress_bar,
};

use super::{InputPauseGuard, WatchEvent, terminal_event::terminal_event_handler};

const HEADING_ATTRIBUTES: Attributes = Attributes::none()
    .with(Attribute::Bold)
    .with(Attribute::Underlined);

#[derive(PartialEq, Eq)]
enum DoneStatus {
    DoneWithSolution(String),
    DoneWithoutSolution,
    Pending,
}

pub struct WatchState<'a> {
    app_state: &'a mut AppState,
    output: Vec<u8>,
    show_hint: bool,
    done_status: DoneStatus,
    manual_run: bool,
    term_width: u16,
    terminal_event_unpause_sender: SyncSender<()>,
}

impl<'a> WatchState<'a> {
    pub fn build(
        app_state: &'a mut AppState,
        watch_event_sender: Sender<WatchEvent>,
        manual_run: bool,
    ) -> Result<Self> {
        let term_width = terminal::size()
            .context("Failed to get the terminal size")?
            .0;

        let (terminal_event_unpause_sender, terminal_event_unpause_receiver) = sync_channel(0);

        thread::Builder::new()
            .spawn(move || {
                terminal_event_handler(
                    watch_event_sender,
                    terminal_event_unpause_receiver,
                    manual_run,
                )
            })
            .context("Failed to spawn a thread to handle terminal events")?;

        Ok(Self {
            app_state,
            output: Vec::with_capacity(OUTPUT_CAPACITY),
            show_hint: false,
            done_status: DoneStatus::Pending,
            manual_run,
            term_width,
            terminal_event_unpause_sender,
        })
    }

    pub fn run_current_exercise(&mut self, stdout: &mut StdoutLock) -> Result<()> {
        // Ignore any input until running the exercise is done.
        let _input_pause_guard = InputPauseGuard::scoped_pause();

        self.show_hint = false;

        writeln!(
            stdout,
            "\nChecking the exercise `{}`. Please wait…",
            self.app_state.current_exercise().name,
        )?;

        let success = self
            .app_state
            .current_exercise()
            .run_exercise(Some(&mut self.output), self.app_state.cmd_runner())?;
        self.output.push(b'\n');
        if success {
            self.done_status =
                if let Some(solution_path) = self.app_state.current_solution_path()? {
                    DoneStatus::DoneWithSolution(solution_path)
                } else {
                    DoneStatus::DoneWithoutSolution
                };
        } else {
            self.app_state
                .set_pending(self.app_state.current_exercise_ind())?;

            self.done_status = DoneStatus::Pending;
        }

        self.render(stdout)?;
        Ok(())
    }

    pub fn reset_exercise(&mut self, stdout: &mut StdoutLock) -> Result<()> {
        clear_terminal(stdout)?;

        stdout.write_all(b"Resetting will undo all your changes to the file ")?;
        stdout.write_all(self.app_state.current_exercise().path.as_bytes())?;
        stdout.write_all(b"\nReset (y/n)? ")?;
        stdout.flush()?;

        {
            let mut stdin = io::stdin().lock();
            let mut answer = [0];
            loop {
                stdin
                    .read_exact(&mut answer)
                    .context("Failed to read the user's input")?;

                match answer[0] {
                    b'y' | b'Y' => {
                        self.app_state.reset_current_exercise()?;

                        // The file watcher reruns the exercise otherwise.
                        if self.manual_run {
                            self.run_current_exercise(stdout)?;
                        }
                    }
                    b'n' | b'N' => self.render(stdout)?,
                    _ => continue,
                }

                break;
            }
        }

        self.terminal_event_unpause_sender.send(())?;

        Ok(())
    }

    pub fn handle_file_change(
        &mut self,
        exercise_ind: usize,
        stdout: &mut StdoutLock,
    ) -> Result<()> {
        if self.app_state.current_exercise_ind() != exercise_ind {
            return Ok(());
        }

        self.run_current_exercise(stdout)
    }

    /// Move on to the next exercise if the current one is done.
    pub fn next_exercise(&mut self, stdout: &mut StdoutLock) -> Result<ExercisesProgress> {
        match self.done_status {
            DoneStatus::DoneWithSolution(_) | DoneStatus::DoneWithoutSolution => (),
            DoneStatus::Pending => return Ok(ExercisesProgress::CurrentPending),
        }

        self.app_state.done_current_exercise::<true>(stdout)
    }

    fn show_prompt(&self, stdout: &mut StdoutLock) -> io::Result<()> {
        if self.done_status != DoneStatus::Pending {
            stdout.queue(SetAttribute(Attribute::Bold))?;
            stdout.write_all(b"n")?;
            stdout.queue(ResetColor)?;
            stdout.write_all(b":")?;
            stdout.queue(SetAttribute(Attribute::Underlined))?;
            stdout.write_all(b"next")?;
            stdout.queue(ResetColor)?;
            stdout.write_all(b" / ")?;
        }

        let mut show_key = |key, postfix| {
            stdout.queue(SetAttribute(Attribute::Bold))?;
            stdout.write_all(&[key])?;
            stdout.queue(ResetColor)?;
            stdout.write_all(postfix)
        };

        if self.manual_run {
            show_key(b'r', b":run / ")?;
        }

        if !self.show_hint {
            show_key(b'h', b":hint / ")?;
        }

        show_key(b'l', b":list / ")?;
        show_key(b'c', b":check all / ")?;
        show_key(b'x', b":reset / ")?;
        show_key(b'q', b":quit ? ")?;

        stdout.flush()
    }

    pub fn render(&self, stdout: &mut StdoutLock) -> io::Result<()> {
        // Prevent having the first line shifted if clearing wasn't successful.
        stdout.write_all(b"\n")?;
        clear_terminal(stdout)?;

        stdout.write_all(&self.output)?;

        if self.show_hint {
            stdout
                .queue(SetAttributes(HEADING_ATTRIBUTES))?
                .queue(SetForegroundColor(Color::Cyan))?;
            stdout.write_all(b"Hint")?;
            stdout.queue(ResetColor)?;
            stdout.write_all(b"\n")?;

            stdout.write_all(self.app_state.current_exercise().hint.as_bytes())?;
            stdout.write_all(b"\n\n")?;
        }

        if self.done_status != DoneStatus::Pending {
            stdout
                .queue(SetAttribute(Attribute::Bold))?
                .queue(SetForegroundColor(Color::Green))?;
            stdout.write_all("Exercise done ✓".as_bytes())?;
            stdout.queue(ResetColor)?;
            stdout.write_all(b"\n")?;

            if let DoneStatus::DoneWithSolution(solution_path) = &self.done_status {
                solution_link_line(stdout, solution_path, self.app_state.emit_file_links())?;
            }

            stdout.write_all(
                "When done experimenting, enter `n` to move on to the next exercise 🦀\n\n"
                    .as_bytes(),
            )?;
        }

        progress_bar(
            stdout,
            self.app_state.n_done(),
            self.app_state.exercises().len() as u16,
            self.term_width,
        )?;

        stdout.write_all(b"\nCurrent exercise: ")?;
        self.app_state
            .current_exercise()
            .terminal_file_link(stdout, self.app_state.emit_file_links())?;
        stdout.write_all(b"\n\n")?;

        self.show_prompt(stdout)?;

        Ok(())
    }

    pub fn show_hint(&mut self, stdout: &mut StdoutLock) -> io::Result<()> {
        if !self.show_hint {
            self.show_hint = true;
            self.render(stdout)?;
        }

        Ok(())
    }

    pub fn check_all_exercises(&mut self, stdout: &mut StdoutLock) -> Result<ExercisesProgress> {
        // Ignore any input until checking all exercises is done.
        let _input_pause_guard = InputPauseGuard::scoped_pause();

        if let Some(first_pending_exercise_ind) = self.app_state.check_all_exercises(stdout)? {
            // Only change exercise if the current one is done.
            if self.app_state.current_exercise().done {
                self.app_state
                    .set_current_exercise_ind(first_pending_exercise_ind)?;
                Ok(ExercisesProgress::NewPending)
            } else {
                Ok(ExercisesProgress::CurrentPending)
            }
        } else {
            self.app_state.render_final_message(stdout)?;
            Ok(ExercisesProgress::AllDone)
        }
    }

    pub fn update_term_width(&mut self, width: u16, stdout: &mut StdoutLock) -> io::Result<()> {
        if self.term_width != width {
            self.term_width = width;
            self.render(stdout)?;
        }

        Ok(())
    }
}



================================================
FILE: src/watch/terminal_event.rs
================================================
use crossterm::event::{self, Event, KeyCode, KeyEventKind};
use std::sync::{
    atomic::Ordering::Relaxed,
    mpsc::{Receiver, Sender},
};

use super::{EXERCISE_RUNNING, WatchEvent};

pub enum InputEvent {
    Next,
    Run,
    Hint,
    List,
    CheckAll,
    Reset,
    Quit,
}

pub fn terminal_event_handler(
    sender: Sender<WatchEvent>,
    unpause_receiver: Receiver<()>,
    manual_run: bool,
) {
    let last_watch_event = loop {
        match event::read() {
            Ok(Event::Key(key)) => {
                match key.kind {
                    KeyEventKind::Release | KeyEventKind::Repeat => continue,
                    KeyEventKind::Press => (),
                }

                if EXERCISE_RUNNING.load(Relaxed) {
                    continue;
                }

                let input_event = match key.code {
                    KeyCode::Char('n') => InputEvent::Next,
                    KeyCode::Char('r') if manual_run => InputEvent::Run,
                    KeyCode::Char('h') => InputEvent::Hint,
                    KeyCode::Char('l') => break WatchEvent::Input(InputEvent::List),
                    KeyCode::Char('c') => InputEvent::CheckAll,
                    KeyCode::Char('x') => {
                        if sender.send(WatchEvent::Input(InputEvent::Reset)).is_err() {
                            return;
                        }

                        // Pause input until quitting the confirmation prompt.
                        if unpause_receiver.recv().is_err() {
                            return;
                        };

                        continue;
                    }
                    KeyCode::Char('q') => break WatchEvent::Input(InputEvent::Quit),
                    _ => continue,
                };

                if sender.send(WatchEvent::Input(input_event)).is_err() {
                    return;
                }
            }
            Ok(Event::Resize(width, _)) => {
                if sender.send(WatchEvent::TerminalResize { width }).is_err() {
                    return;
                }
            }
            Ok(Event::FocusGained | Event::FocusLost | Event::Mouse(_)) => continue,
            Err(e) => break WatchEvent::TerminalEventErr(e),
        }
    };

    let _ = sender.send(last_watch_event);
}



================================================
FILE: tests/integration_tests.rs
================================================
use std::{
    env::{self, consts::EXE_SUFFIX},
    process::{Command, Stdio},
    str::from_utf8,
};

enum Output<'a> {
    FullStdout(&'a str),
    PartialStdout(&'a str),
    PartialStderr(&'a str),
}

use Output::*;

#[derive(Default)]
struct Cmd<'a> {
    current_dir: Option<&'a str>,
    args: &'a [&'a str],
    output: Option<Output<'a>>,
}

impl<'a> Cmd<'a> {
    #[inline]
    fn current_dir(&mut self, current_dir: &'a str) -> &mut Self {
        self.current_dir = Some(current_dir);
        self
    }

    #[inline]
    fn args(&mut self, args: &'a [&'a str]) -> &mut Self {
        self.args = args;
        self
    }

    #[inline]
    fn output(&mut self, output: Output<'a>) -> &mut Self {
        self.output = Some(output);
        self
    }

    fn assert(&self, success: bool) {
        let rustlings_bin = {
            let mut path = env::current_exe().unwrap();
            // Pop test binary name
            path.pop();
            // Pop `/deps`
            path.pop();

            path.push("rustlings");
            let mut path = path.into_os_string();
            path.push(EXE_SUFFIX);
            path
        };

        let mut cmd = Command::new(rustlings_bin);

        if let Some(current_dir) = self.current_dir {
            cmd.current_dir(current_dir);
        }

        cmd.args(self.args).stdin(Stdio::null());

        let status = match self.output {
            None => cmd
                .stdout(Stdio::null())
                .stderr(Stdio::null())
                .status()
                .unwrap(),
            Some(FullStdout(stdout)) => {
                let output = cmd.stderr(Stdio::null()).output().unwrap();
                assert_eq!(from_utf8(&output.stdout).unwrap(), stdout);
                output.status
            }
            Some(PartialStdout(stdout)) => {
                let output = cmd.stderr(Stdio::null()).output().unwrap();
                assert!(from_utf8(&output.stdout).unwrap().contains(stdout));
                output.status
            }
            Some(PartialStderr(stderr)) => {
                let output = cmd.stdout(Stdio::null()).output().unwrap();
                assert!(from_utf8(&output.stderr).unwrap().contains(stderr));
                output.status
            }
        };

        assert_eq!(status.success(), success, "{cmd:?}");
    }

    #[inline]
    fn success(&self) {
        self.assert(true);
    }

    #[inline]
    fn fail(&self) {
        self.assert(false);
    }
}

#[test]
fn run_compilation_success() {
    Cmd::default()
        .current_dir("tests/test_exercises")
        .args(&["run", "compilation_success"])
        .success();
}

#[test]
fn run_compilation_failure() {
    Cmd::default()
        .current_dir("tests/test_exercises")
        .args(&["run", "compilation_failure"])
        .fail();
}

#[test]
fn run_test_success() {
    Cmd::default()
        .current_dir("tests/test_exercises")
        .args(&["run", "test_success"])
        .output(PartialStdout("\nOutput from `main` function\n"))
        .success();
}

#[test]
fn run_test_failure() {
    Cmd::default()
        .current_dir("tests/test_exercises")
        .args(&["run", "test_failure"])
        .fail();
}

#[test]
fn run_exercise_not_in_info() {
    Cmd::default()
        .current_dir("tests/test_exercises")
        .args(&["run", "not_in_info"])
        .fail();
}

#[test]
fn reset_without_exercise_name() {
    Cmd::default().args(&["reset"]).fail();
}

#[test]
fn hint() {
    Cmd::default()
        .current_dir("tests/test_exercises")
        .args(&["hint", "test_failure"])
        .output(FullStdout("The answer to everything: 42\n"))
        .success();
}

#[test]
fn init() {
    let test_dir = tempfile::TempDir::new().unwrap();
    let test_dir = test_dir.path().to_str().unwrap();

    Cmd::default().current_dir(test_dir).fail();

    Cmd::default()
        .current_dir(test_dir)
        .args(&["init"])
        .success();

    // Running `init` after a successful initialization.
    Cmd::default()
        .current_dir(test_dir)
        .args(&["init"])
        .output(PartialStderr("`cd rustlings`"))
        .fail();

    let initialized_dir = format!("{test_dir}/rustlings");

    // Running `init` in the initialized directory.
    Cmd::default()
        .current_dir(&initialized_dir)
        .args(&["init"])
        .output(PartialStderr("already initialized"))
        .fail();
}



================================================
FILE: tests/test_exercises/info.toml
================================================
format_version = 1

[[exercises]]
name = "compilation_success"
test = false
hint = ""

[[exercises]]
name = "compilation_failure"
test = false
hint = ""

[[exercises]]
name = "test_success"
hint = ""

[[exercises]]
name = "test_failure"
hint = "The answer to everything: 42"



================================================
FILE: tests/test_exercises/dev/Cargo.toml
================================================
bin = [
  { name = "compilation_success", path = "../exercises/compilation_success.rs" },
  { name = "compilation_failure", path = "../exercises/compilation_failure.rs" },
  { name = "test_success", path = "../exercises/test_success.rs" },
  { name = "test_failure", path = "../exercises/test_failure.rs" },
]

[package]
name = "test_exercises"
edition = "2024"
publish = false



================================================
FILE: tests/test_exercises/exercises/compilation_failure.rs
================================================
fn main() {
    let
}


================================================
FILE: tests/test_exercises/exercises/compilation_success.rs
================================================
fn main() {}



================================================
FILE: tests/test_exercises/exercises/not_in_info.rs
================================================
fn main() {}



================================================
FILE: tests/test_exercises/exercises/test_failure.rs
================================================
fn main() {}

#[cfg(test)]
mod tests {
    #[test]
    fn fails() {
        assert!(false);
    }
}



================================================
FILE: tests/test_exercises/exercises/test_success.rs
================================================
fn main() {
    println!("Output from `main` function");
}

#[cfg(test)]
mod tests {
    #[test]
    fn passes() {}
}



================================================
FILE: website/config.toml
================================================
base_url = "https://rustlings.rust-lang.org"
title = "Rustlings"
description = "Small exercises to get you used to reading and writing Rust code!"

compile_sass = false
build_search_index = false

[markdown]
highlight_code = true
highlight_theme = "dracula"

insert_anchor_links = "heading"

[extra]
logo_path = "images/happy_ferris.svg"

[[extra.menu_items]]
name = "Rustlings"
url = "@/_index.md"
[[extra.menu_items]]
name = "Setup"
url = "@/setup/index.md"
[[extra.menu_items]]
name = "Usage"
url = "@/usage/index.md"
[[extra.menu_items]]
name = "Community Exercises"
url = "@/community-exercises/index.md"
[[extra.menu_items]]
name = "Q&A"
url = "https://github.com/rust-lang/rustlings/discussions/categories/q-a?discussions_q="

[[extra.footer_items]]
name = "Repository"
url = "https://github.com/rust-lang/rustlings"
[[extra.footer_items]]
name = "Changelog"
url = "https://github.com/rust-lang/rustlings/blob/main/CHANGELOG.md"
[[extra.footer_items]]
name = "MIT License"
url = "https://github.com/rust-lang/rustlings/blob/main/LICENSE"



================================================
FILE: website/input.css
================================================
@import 'tailwindcss';

@layer base {
  h1 {
    @apply text-4xl mt-3 mb-3 font-bold;
  }
  h2 {
    @apply text-3xl mt-4 mb-1.5 font-bold;
  }
  h3 {
    @apply text-2xl mt-5 mb-1.5 font-bold;
  }
  h4 {
    @apply text-xl mt-6 mb-1.5 font-bold;
  }
  p {
    @apply mb-2;
  }
  a {
    @apply text-[#FFC832] underline hover:decoration-orange-400 transition duration-300;
  }
  ul {
    @apply mt-2 mb-3 ml-1 list-disc list-inside marker:text-sky-600;
  }
  ol {
    @apply mt-2 mb-3 ml-1 list-decimal list-inside marker:text-sky-500;
  }
  li {
    @apply my-0.5;
  }
  code {
    @apply bg-white/10 px-1 pb-px pt-1 rounded-md;
  }
  pre code {
    @apply bg-inherit p-0 text-inherit;
  }
  hr {
    @apply my-5 rounded-full;
  }
  img {
    @apply md:w-3/4 lg:w-3/5;
  }
  blockquote {
    @apply px-3 pt-2 pb-0.5 mb-4 mt-2 border-s-4 border-white/80 bg-white/7 rounded-sm;
  }

  pre {
    @apply px-2 pt-2 pb-px overflow-x-auto text-sm sm:text-base rounded-sm mt-2 mb-4 after:content-[attr(data-lang)] after:text-[8px] after:opacity-40 selection:bg-white/15;
  }
  pre code mark {
    @apply pb-0.5 pt-1 pr-px text-inherit rounded-xs;
  }
}




================================================
FILE: website/justfile
================================================
zola:
	zola serve --open

tailwind:
	npx @tailwindcss/cli -w -i input.css -o static/main.css



================================================
FILE: website/package.json
================================================
{
  "dependencies": {
    "@tailwindcss/cli": "^4.1"
  }
}



================================================
FILE: website/content/_index.md
================================================
+++
+++

Small exercises to get you used to reading and writing [Rust](https://www.rust-lang.org) code - _Recommended in parallel to reading [the official Rust book](https://doc.rust-lang.org/book) 📚️_

<script src="https://asciinema.org/a/719805.js" id="asciicast-719805" async="true"></script>

## Quick start

```bash
# Installation
cargo install rustlings
# Initialization
rustlings init
# Moving into new directory
cd rustlings
# Starting Rustlings
rustlings
```

Visit the [**setup**](@/setup/index.md) page for more details 🧰



================================================
FILE: website/content/community-exercises/index.md
================================================
+++
title = "Community Exercises"
+++

## List of Community Exercises

- 🇯🇵 [Japanese Rustlings](https://github.com/sotanengel/rustlings-jp)：A Japanese translation of the Rustlings exercises.
- 🇨🇳 [Simplified Chinese Rustlings](https://github.com/SandmeyerX/rustlings-zh-cn): A simplified Chinese translation of the Rustlings exercises.

> You can use the same `rustlings` program that you installed with `cargo install rustlings` to run community exercises.

## Creating Community Exercises

Rustling's support for community exercises allows you to create your own exercises to focus on some specific topic.
You could also offer a translation of the original Rustlings exercises as community exercises.

### Getting Started

To create community exercises, install Rustlings and run `rustlings dev new PROJECT_NAME`.
This command will, similar to `cargo new PROJECT_NAME`, create the template directory `PROJECT_NAME` with all what you need to get started.

_Read the comments_ in the generated `info.toml` file to understand its format.
It allows you to set a custom welcome and final message and specify the metadata of every exercise.

### Creating an Exercise

Here is an example of the metadata of one exercise:

```toml
[[exercises]]
name = "intro1"
hint = """
To finish this exercise, you need to …
These links might help you …"""
```

After entering this in `info.toml`, create the file `intro1.rs` in the `exercises/` directory.
The exercise needs to contain a `main` function, but it can be empty.
Adding tests is recommended.
Look at the official Rustlings exercises for inspiration.

You can optionally add a solution file `intro1.rs` to the `solutions/` directory.

Now, run `rustlings dev check`.
It will tell you about any issues with your exercises.
For example, it will tell you to run `rustlings dev update` to update the `Cargo.toml` file to include the new exercise `intro1`.

`rustlings dev check` will also run your solutions (if you have any) to make sure that they run successfully.

That's it!
You finished your first exercise 🎉

### Cargo.toml

Except of the `bin` list, you can modify the `Cargo.toml` file as you want.

> The `bin` list is automatically updated by running `rustlings dev update`

- You can add dependencies in the `[dependencies]` table.
- You might want to [configure some lints](https://doc.rust-lang.org/cargo/reference/manifest.html#the-lints-section) for all exercises. You can do so in the `[lints.rust]` and `[lints.clippy]` tables.

### Publishing

Now, add more exercises and publish them as a Git repository.

Users just have to clone that repository and run `rustlings` in it to start working on your exercises (just like the official ones).

One difference to the official exercises is that the solution files will not be hidden until the user finishes an exercise.
But you can trust your users to not open the solution too early 😉

### Sharing

After publishing your community exercises, open an issue or a pull request in the [official Rustlings repository](https://github.com/rust-lang/rustlings) to add your project to the [list of community exercises](#list-of-community-exercises) 😃



================================================
FILE: website/content/setup/index.md
================================================
+++
title = "Setup"
+++

<!-- toc -->

## Installing Rust

Before installing Rustlings, you must have the **latest version of Rust** installed.
Visit [www.rust-lang.org/tools/install](https://www.rust-lang.org/tools/install) for further instructions.
This will also install _Cargo_, Rust's package/project manager.

> 🐧 If you are on **Linux**, make sure you have `gcc` installed (_for a linker_).
>
> Debian: `sudo apt install gcc`\
> Fedora: `sudo dnf install gcc`

> 🍎 If you are on **MacOS**, make sure you have _Xcode and its developer tools_ installed: `xcode-select --install`

## Installing Rustlings

The following command will download and compile Rustlings:

```bash
cargo install rustlings
```

{% details(summary="If the installation fails…") %}

- Make sure you have the latest Rust version by running `rustup update`
- Try adding the `--locked` flag: `cargo install rustlings --locked`
- Otherwise, please [report the issue](https://github.com/rust-lang/rustlings/issues/new)

{% end %}

## Initialization

After installing Rustlings, run the following command to initialize the `rustlings/` directory:

```bash
rustlings init
```

{% details(summary="If the command <code>rustlings</code> can't be found…") %}

You are probably using Linux and installed Rust using your package manager.

Cargo installs binaries to the directory `~/.cargo/bin`.
Sadly, package managers often don't add `~/.cargo/bin` to your `PATH` environment variable.

- Either add `~/.cargo/bin` manually to `PATH`
- Or uninstall Rust from the package manager and [install it using the official way with `rustup`](https://www.rust-lang.org/tools/install)

{% end %}

Now, go into the newly initialized directory and launch Rustlings for further instructions on getting started with the exercises:

```bash
cd rustlings/
rustlings
```

## Working environment

### Editor

Our general recommendation is [VS Code](https://code.visualstudio.com/) with the [rust-analyzer plugin](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer).
But any editor that supports [rust-analyzer](https://rust-analyzer.github.io/) should be enough for working on the exercises.

### Terminal

While working with Rustlings, please use a modern terminal for the best user experience.
The default terminal on Linux and Mac should be sufficient.
On Windows, we recommend the [Windows Terminal](https://aka.ms/terminal).

## Usage

After being done with the setup, visit the [**usage**](@/usage/index.md) page for some info about using Rustlings 🚀



================================================
FILE: website/content/usage/index.md
================================================
+++
title = "Usage"
+++

<!-- toc -->

## Doing exercises

The exercises are sorted by topic and can be found in the subdirectory `exercises/<topic>`.
For every topic, there is an additional `README.md` file with some resources to get you started on the topic.
We highly recommend that you have a look at them before you start 📚️

Most exercises contain an error that keeps them from compiling, and it's up to you to fix it!
Some exercises contain tests that need to pass for the exercise to be done ✅

Search for `TODO` and `todo!()` to find out what you need to change.
Ask for hints by entering `h` in the _watch mode_ 💡

## Watch Mode

After the [initialization](@/setup/index.md#initialization), Rustlings can be launched by simply running the command `rustlings`.

This will start the _watch mode_ which walks you through the exercises in a predefined order (what we think is best for newcomers).
It will rerun the current exercise automatically every time you change the exercise's file in the `exercises/` directory.

{% details(summary="If detecting file changes in the <code>exercises/</code> directory fails…") %}

You can add the **`--manual-run`** flag (`rustlings --manual-run`) to manually rerun the current exercise by entering `r` in the watch mode.

Please [report the issue](https://github.com/rust-lang/rustlings/issues/new) with some information about your operating system and whether you run Rustlings in a container or a virtual machine (e.g. WSL).

{% end %}

## Exercise List

In the [watch mode](#watch-mode) (after launching `rustlings`), you can enter `l` to open the interactive exercise list.

The list allows you to…

- See the status of all exercises (done or pending)
- `c`: Continue at another exercise (temporarily skip some exercises or go back to a previous one)
- `r`: Reset status and file of the selected exercise (you need to _reload/reopen_ its file in your editor afterwards)

See the footer of the list for all possible keys.

## Questions?

If you need any help while doing the exercises and the builtin hints aren't helpful, feel free to ask in the [_Q&A_ discussions](https://github.com/rust-lang/rustlings/discussions/categories/q-a?discussions_q=) if your question isn't answered there 💡

## Continuing On

Once you've completed Rustlings, put your new knowledge to good use!
Continue practicing your Rust skills by building your own projects, contributing to Rustlings, or finding other open-source projects to contribute to.

> If you want to create your own Rustlings exercises, visit the [**community exercises**](@/community-exercises/index.md) page 🏗️



================================================
FILE: website/templates/404.html
================================================
{% extends "base.html" %}

{% block content %}
    <div class="flex flex-col mx-auto text-center">
        <h1>DON'T PANIC!</h1>
        <h2>404: Page not found!</h2>

        <img class="mx-auto max-h-[50vh]"
             src="{{ get_url(path='images/panic.svg') | safe }}"
             alt="">

        <a class="text-2xl font-bold" href="{{ get_url(path='@/_index.md') }}">Back to homepage</a>
    </div>
{% endblock %}



================================================
FILE: website/templates/anchor-link.html
================================================
<a class="text-white no-underline transition-none hover:underline"
   href="#{{ id }}"></a>



================================================
FILE: website/templates/base.html
================================================
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        {%- set timestamp = now(timestamp=true) -%}

        {%- if page.title -%}
            {% set_global title = page.title %}
        {%- elif section.title -%}
            {% set_global title = section.title %}
        {%- else -%}
            {% set_global title = config.title %}
        {%- endif -%}

        {%- if page.description -%}
            {% set_global description = page.description %}
        {%- elif section.description -%}
            {% set_global description = section.description %}
        {%- else -%}
            {% set_global description = config.description %}
        {%- endif -%}

        {%- if page.permalink -%}
            {% set_global permalink = page.permalink %}
        {%- elif section.permalink -%}
            {% set_global permalink = section.permalink %}
        {%- endif %}

        <title>{%- block title -%}{{- title -}}{%- endblock -%}</title>

        <meta name="description"
              content="{%- block description -%}{{- description -}}{%- endblock -%}">

        <link rel="icon"
              type="image/x-icon"
              href="{{ get_url(path=config.extra.logo_path) | safe }}?v={{ timestamp }}">

        <link href="{{ get_url(path='main.css') | safe }}?v={{ timestamp }}"
              rel="stylesheet">

        <meta property="og:title" content="{{ title }}">
        <meta property="og:description" content="{{ description }}">
        <meta property="og:image"
              content="{{ get_url(path=config.extra.logo_path) | safe }}?v={{ timestamp }}">
        {% if permalink %}<meta property="og:url" content="{{ permalink | safe }}">{% endif %}
    </head>

    <body class="flex flex-col p-2 mx-auto min-h-screen text-lg text-white break-words lg:px-5 2xl:container bg-[#2A3439]">
        <header class="flex flex-col gap-x-4 items-center py-2 px-4 mb-1 rounded-sm sm:flex-row sm:rounded-full bg-black/30">
            <a class="transition duration-500 hover:scale-110"
               href="{{ get_url(path='@/_index.md') | safe }}"
               aria-hidden="true">
                <img class="w-12 h-12"
                     src="{{ get_url(path=config.extra.logo_path) | safe }}"
                     alt="">
            </a>

            <nav class="flex flex-col gap-x-6 items-center font-bold sm:flex-row">
                {% for menu_item in config.extra.menu_items %}
                    {%- if menu_item.url is starting_with("@") -%}
                        {% set_global menu_item_url = get_url(path=menu_item.url) %}
                    {%- else -%}
                        {% set_global menu_item_url = menu_item.url %}
                    {%- endif %}

                    <a class="p-1 no-underline" href="{{ menu_item_url | safe }}">{{ menu_item.name }}</a>
                {% endfor %}
            </nav>
        </header>

        <main class="leading-relaxed">
            {% block content %}{% endblock %}
        </main>

        <footer class="pt-2 pb-1 mt-auto text-sm text-center">
            <div class="inline-flex gap-x-1.5 items-center mx-auto mt-2">
                <img class="w-8 h-8"
                     src="{{ get_url(path='images/rust_logo.svg') | safe }}"
                     alt="">
                <div class="italic">Rustlings is an official Rust project</div>
            </div>

            <nav class="flex flex-col gap-y-3 justify-around py-3 mt-3 rounded-sm sm:flex-row sm:rounded-full bg-black/30">
                {% for footer_item in config.extra.footer_items %}
                    <a class="no-underline" href="{{ footer_item.url | safe }}">{{ footer_item.name }}</a>
                {% endfor %}
            </nav>
        </footer>
    </body>
</html>



================================================
FILE: website/templates/index.html
================================================
{% extends "base.html" %}

{% block content %}
    <div class="m-3">
        <h1>Rustlings</h1>

        {{ section.content | safe }}
    </div>
{% endblock %}



================================================
FILE: website/templates/page.html
================================================
{% extends "base.html" %}

{% block content %}
    <article>
        <h1>{{ page.title }}</h1>

        <div class="py-0.5 px-4 my-3 rounded-xl border-double border-s-4">
            <nav>
                <ul class="ml-0 list-none">
                    {% for parent in page.toc %}
                        {% if parent.level == 2 %}
                            <li>
                                {#- -#}
                                <a href="{{ parent.permalink | safe }}">{{ parent.title }}</a>
                                {#- -#}
                                {% if parent.children %}
                                    <ul class="my-0 ml-5 list-none">
                                        {% for child in parent.children %}
                                            {% if child.level == 3 %}
                                                <li>
                                                    {#- -#}
                                                    <a class="text-base" href="{{ child.permalink | safe }}">{{ child.title }}</a>
                                                    {#- -#}
                                                </li>
                                            {% endif %}
                                        {% endfor %}
                                    </ul>
                                {% endif %}
                                {#- -#}
                            </li>
                        {% endif %}
                    {% endfor %}
                </ul>
            </nav>
        </div>

        {{ page.content | safe }}
    </article>
{% endblock %}



================================================
FILE: website/templates/shortcodes/details.html
================================================
<details>
    <summary>
        <strong>{{ summary | safe }}</strong> (<em>click to expand</em>)
    </summary>

    <blockquote class="pt-1 mx-0.5 mt-1 rounded-none border-dashed border-x-3 border-b-3">
        {{ body | markdown | safe }}
    </blockquote>
</details>



================================================
FILE: .cargo/config.toml
================================================
[alias]
dev = ["run", "--", "dev"]



================================================
FILE: .github/workflows/rust.yml
================================================
name: Check

on:
  push:
    branches: [main]
    paths-ignore:
      - website
      - '*.md'
  pull_request:
    branches: [main]
    paths-ignore:
      - website
      - '*.md'

env:
  CARGO_TERM_COLOR: always

jobs:
  clippy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Clippy
        run: cargo clippy -- --deny warnings
  fmt:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: rustfmt
        run: cargo fmt --all --check
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    steps:
      - uses: actions/checkout@v4
      - uses: swatinem/rust-cache@v2
      - name: cargo test
        run: cargo test --workspace
  dev-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: swatinem/rust-cache@v2
      - name: rustlings dev check
        run: cargo dev check --require-solutions



================================================
FILE: .github/workflows/website.yml
================================================
name: Website

on:
  workflow_dispatch:
  push:
    branches: [main]
    paths: [website]

jobs:
  build:
    defaults:
      run:
        working-directory: website
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install TailwindCSS
        run: npm install
      - name: Build CSS
        run: npx @tailwindcss/cli -m -i input.css -o static/main.css
      - name: Download Zola
        run: curl -fsSL https://github.com/getzola/zola/releases/download/v0.20.0/zola-v0.20.0-x86_64-unknown-linux-gnu.tar.gz | tar xz
      - name: Build site
        run: ./zola build
      - name: Upload static files as artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: website/public/

  deploy:
    needs: build
    # Grant GITHUB_TOKEN the permissions required to make a Pages deployment
    permissions:
      pages: write    # to deploy to Pages
      id-token: write # to verify the deployment originates from an appropriate source
    # Deploy to the github-pages environment
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to GitHub Pages
        uses: actions/deploy-pages@v4


