### 🎁 Understanding Option and Some in Rust: The Gift Box Analogy

"Hey, did you check if there's any ice cream in the freezer?"
"Well, I looked and there might be Some(IceCream) or None!" 
That's Option<T> in everyday life! 

//    The Gift Box Metaphor
//    ┌─────────────[?]─────────┐
//    │     Option<T>           │
//    │   ┌───────┴───────┐    │
//    │   Some(T)    None      │
//    │   │               │     │
//    │   📦            📭     │
//    │ Contains     Empty box  │
//    └─────────────────────────┘

```rust

// Example 1: Finding Ice Cream 🍦
fn check_freezer() -> Option<String> {
    let has_ice_cream = true;  // Let's pretend we checked
    if has_ice_cream {
        Some(String::from("Vanilla Ice Cream"))
    } else {
        None
    }
}

// Similarities between None and null:
// 1. Both represent absence of a value
// 2. Used in scenarios where a value might not exist

// Differences:
fn example() {
    // In Rust:
    let optional: Option<i32> = None;
    // 1. None is a variant of Option enum, not a separate type
    // 2. Explicit - type system forces handling of None case
    // 3. No null pointer exceptions
    
    match optional {
        Some(value) => println!("Got {}", value),
        None => println!("No value"),
    }
    // 4. Pattern matching ensures all cases are handled

    // In Java:
    // Integer nullable = null;
    // 1. null is a special value of any reference type
    // 2. Implicit - easy to forget null checks
    // 3. Can lead to NullPointerException
    // 4. No built-in exhaustive checking mechanism

// Some is not a direct replacement for NotNull in Java, but serves a similar purpose
// with additional safety features:

// 1. Option<T> is used instead of nullable references
let name: Option<String> = Some(String::from("Alice"));

// 2. Forced explicit handling
match name {
    Some(n) => println!("Name: {}", n),
    None => println!("No name provided"),
}

// 3. Safe operations without null checks
let uppercase_name = name.map(|n| n.to_uppercase());

// 4. Provides default values safely
let display_name = name.unwrap_or_else(|| String::from("Anonymous"));

// 5. Composable with other Options
let greeting = name.and_then(|n| Some(format!("Hello, {}!", n)));

// Unlike Java's @NotNull, Rust's Option is enforced by the compiler,
// preventing null pointer exceptions at runtime

}


// Example 2: Safe Division ➗
//    Input: 10 ÷ 2 = Some(5)    ✅
//    Input: 10 ÷ 0 = None       ❌
fn safe_division(numerator: f64, denominator: f64) -> Option<f64> {
    if denominator == 0.0 {
        None
    } else {
        Some(numerator / denominator)
    }
}

// Example 3: Working with Option 🛠️
fn main() {
    let ice_cream = check_freezer();
    //    │
    //    └─► Option<String>
    //         ┌─────┴─────┐
    //         Some("...")  None
    
    match ice_cream {
        Some(flavor) => println!("Found {flavor}! 😋"),
        None => println!("No ice cream today 😢")
    }
    
    // Using if let for cleaner matching
    if let Some(flavor) = ice_cream {
        println!("Yum! {flavor}");
    }
}

// 🔑 Key Points:
// 1. Option<T> is like a box that either:
//    - Has something (Some(T)) 📦
//    - Is empty (None) 📭

// 2. Common Methods:
//    ```rust
//    let value = Some(42);
//    value.is_some()  // true  - Has something?
//    value.is_none()  // false - Is empty?
//    value.unwrap()   // 42    - Get value (careful!)
//    ```

// 3. Pattern Matching:
//    ```
//    match result {      if let Some(x) = result {
//      Some(x) => x         // use x
//      None => default      }
//    }


    println!(
        "===f05_some_none===
        extra print {:?}
        ",
        f05_result
    );
    match f05_result {
        Some(f05_result) => println!("Some valid result {:?}", f05_result),
        None => println!("Denominator is 0"),
    }

    // Expanded results for f05_result = Some(0.5):
    println!("is_some(): {}", f05_result.is_some());  // true (contains a value)
    println!("is_none(): {}", f05_result.is_none());  // false (not None)
    println!("unwrap(): {}", f05_result.unwrap());    // 0.5 (extracts the value)
    println!("map(): {:?}", f05_result.map(|x| x * 2));  // Some(1.0) (applies function)

    // If f05_result were None:
    // is_some() would be false
    // is_none() would be true
    // unwrap() would panic
    // map() would return None

// Yes, pattern matching with `Some(f05_result)` does unwrap the value.
// Here's an example to demonstrate:

let optional_value = Some(42);

match optional_value {
    Some(unwrapped) => {
        // 'unwrapped' is now of type i32, not Option<i32>
        println!("Unwrapped value: {}", unwrapped);
        // We can use 'unwrapped' directly without further unwrapping
        let doubled = unwrapped * 2;
        println!("Doubled: {}", doubled);
    },
    None => println!("No value"),
}

// This is equivalent to:
if let Some(unwrapped) = optional_value {
    println!("Unwrapped value: {}", unwrapped);
    let doubled = unwrapped * 2;
    println!("Doubled: {}", doubled);
}


```