 // Start of Selection
 ### üèîÔ∏è Understanding Panics in Rust: A Pyramid Approach
    
 #### 1. **Base Level: What is a Panic**
 *Panic in Rust signifies an unexpected, unrecoverable error that causes the program to terminate.*
    
 ```rust
 fn main() {
     let v = vec![1, 2, 3];
     println!("{}", v[99]); // This will cause a panic
 }
 ```
    
 - **Panic**: Rust's mechanism to handle critical errors by unwinding the stack or aborting the program.
    
 #### 2. **Middle Level: Triggering Panics with `panic!` Macro**
 *Use the `panic!` macro to deliberately cause a panic at runtime when certain conditions are met.*
 
 ```rust
 fn divide(a: i32, b: i32) -> i32 {
     if b == 0 {
         panic!("Division by zero!");
     }
     a / b
 }
    
 fn main() {
     let result = divide(10, 0);
     println!("Result: {}", result);
 }
 ```
    
 - **`panic!` Macro**: Allows developers to explicitly trigger a panic, enforcing program invariants by ensuring that certain conditions or constraints hold true during program execution. These invariants are rules or conditions that must always be true for the program to function correctly, maintaining the integrity and correctness of the program's state.
 - **Unwinding vs. Aborting**: By default, Rust unwinds the stack to clean up resources when a panic occurs, but it can be configured to abort immediately for faster termination without unwinding, which is useful in scenarios where recovery is not feasible or performance is critical.
    
 #### 3. **Top Level: Handling Panics and Recovering with `catch_unwind`**
 *Advanced techniques to handle panics gracefully and potentially recover from them.*
    
 ```rust
 use std::panic;
    
 fn main() {
     // catch_unwind wraps potentially panicking code
     //     ‚îå‚îÄ Closure containing code that might panic
     //     ‚ñº
     let result = panic::catch_unwind(|| {
         println!("About to panic!");
         panic!("This is a panic."); // Deliberately trigger panic
         //     |                |
         //     |                Panic message
         //     panic! macro
     });
     //  |
     //  Result<T,E> is Rust's way of handling success/failure scenarios
     //  Think of it like a package that can contain either:
     //    - Ok(T): The "happy path" with your expected value of type T
     //    - Err(E): The "uh oh" path with an error of type E
     //  
     //  It's like a fork in the road - you either get what you wanted (Ok)
     //  or hit a problem (Err). This pattern shows up everywhere in Rust
     //  because it forces you to explicitly handle both cases.
     //
     //  Here, catch_unwind returns:
     //    - Ok(T) if everything went fine (no panic)
     //    - Err(E) if it caught a panic (E contains panic info)
     //
     //  You'll often see code like:
     //    let result = something_that_might_fail();
     //    match result {
     //        Ok(value) => /* use the value */,
     //        Err(e) => /* handle the error */
     //    }
     
     // Handle the result of catch_unwind
     // result is of type Result<T, Box<dyn Any + Send>> where:
     //   - Result<T,E> is Rust's enum for handling success/failure
     //   - T is a generic type parameter representing the success value
     //   - Box is a smart pointer that stores data on the heap
     //   - dyn Any is a trait object allowing runtime type checking
     //   - Send is a trait indicating the type is safe to send between threads
     //   - () represents the "unit type" - like void in other languages
     //
     // In this case:
     //   - T is () since our closure returns nothing
     //   - Box<dyn Any + Send> contains the panic info if a panic occurred
     //   - The Box is needed because the size of panic info is unknown at compile time
     //   - Any allows us to store any type that was passed to panic!
     //   - Send ensures the panic can be safely transferred between threads
     match result {
         // match is an expression that lets us compare a value against patterns
         // and execute code based on which pattern matches
         Ok(value) => {
             // value has type T - the successful return value from the closure
             println!("No panic occurred.");
         },
         Err(panic_payload) => {
             // panic_payload has type Box<dyn Any + Send>
             // it contains information about what caused the panic
             println!("Caught a panic!");
             // We could downcast the payload to get more info:
             // if let Some(s) = panic_payload.downcast_ref::<&str>() {
             //     println!("Panic message: {}", s);
             // }
         }
     }
     
     // Program continues running...
 }
 ```
    
 - **`catch_unwind`**: Captures a panic, allowing the program to handle it without crashing.
 - **Panic Strategies**:
     - **Unwind**: Cleans up resources by unwinding the stack (default).
     - **Abort**: Immediately terminates the program without cleanup, useful for FFI boundaries or reducing binary size.

 ### üìä Panics Pyramid Summary
 ```
 üèîÔ∏è Top Level: Handling Panics and Recovering with `catch_unwind`
     ‚îî‚îÄ Enables capturing and handling panics to maintain program stability

 üåÑ Middle Level: Triggering Panics with `panic!` Macro
     ‚îî‚îÄ Provides mechanisms to enforce program invariants and handle critical errors

 üå± Base Level: What is a Panic
     ‚îî‚îÄ Fundamental concept of error handling in Rust through panics
 ```
    
 ### Pros and Cons of Rust Panics vs Java Exceptions
    
 #### Pros of Rust Panics:
 - **Memory Safety**: Ensures memory safety by unwinding the stack and preventing undefined behavior.
 - **Performance**: Zero-cost when not panicking, minimal runtime overhead.
 - **Simplicity**: Distinct separation between recoverable errors (`Result`) and unrecoverable errors (`panic!`).

 #### Cons of Rust Panics:
 - **Limited Recoverability**: Panics are intended for unrecoverable errors, not for regular error handling.
 - **Stack Unwinding Overhead**: Potential performance cost when a panic occurs due to stack unwinding.

 #### Comparison to Java Exceptions:
 - **Similarity**:
     - Both handle unexpected runtime errors.
     - Allow custom error messages and error propagation.
 - **Difference**:
     - **Recoverability**: Java distinguishes between checked and unchecked exceptions for recoverable errors, whereas Rust uses `Result` for recoverable and `panic!` for unrecoverable.
     - **Performance**: Rust's panic mechanism has less runtime overhead in the non-error path.
     - **Error Handling Paradigm**: Rust emphasizes explicit error handling with enums, promoting safer code by forcing developers to handle potential errors.
 ```