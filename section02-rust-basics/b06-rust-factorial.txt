### 🚀 Understanding Factorials in Rust: A Step-by-Step Guide

#### 1. **Base Level: Recursive Factorial**
*Factorials are a fundamental concept in mathematics, and Rust allows us to implement them recursively.*

```rust
fn factorial(n: u32) -> u32 {
    if n == 0 {
        1
    } else {
        n * factorial(n - 1)
    }
}

fn main() {
    let result = factorial(5);
    println!("Factorial of 5 is {}", result);
}
```

#### 2. **Middle Level: Iterative Factorial**
*Building upon the recursive approach, we can also implement factorials iteratively.*

```rust
fn factorial(n: u32) -> u32 {
    let mut result = 1;
    for i in 1..=n {
        result *= i;
    }
    result
}

fn main() {
    let result = factorial(5);
    println!("Factorial of 5 is {}", result);
}
```

#### 3. **Top Level: Using Iterators for Factorial**
*At the pinnacle, we can leverage Rust's iterators to calculate factorials in a concise and efficient manner.*

```rust
fn factorial(n: u32) -> u32 {
    (1..=n).fold(1, |acc, i| acc * i)
//  |  |   |    |  |     |  |  |
//  |  |   |    |  |     |  |  Multiply accumulator by current value
//  |  |   |    |  |     |  Current value in range
//  |  |   |    |  |     Lambda expression separator
//  |  |   |    |  Accumulator parameter
//  |  |   |    Initial value (1)
//  |  |   fold() method to reduce sequence to single value
//  |  Inclusive range operator (includes n)
//  Range from 1 to n

// Let's walk through how fold() works for factorial(3):
//
// fold() takes two things:
// 1. An initial value (1 in our case)
// 2. A function that takes two params: (accumulator, current_value)
//
// For n=3, here's what happens step by step:
//
// Start:  acc = 1 (initial value)
// Step 1: acc = 1 * 1 = 1  (first number in range)
// Step 2: acc = 1 * 2 = 2  (second number)
// Step 3: acc = 2 * 3 = 6  (final number)
//
// The range 1..=3 generates numbers 1,2,3
// fold() processes each number, updating acc each time
// The |acc, i| acc * i part is just saying "multiply acc by i"
//
// Generic fold syntax:
// collection.fold(initial_value, |accumulator, current_item| {
//     // operation that returns new accumulator value
// })
//
// It's like having a running total (acc) and multiplying it
// by each number as we go. Super clean way to do factorial!


// Let's chat about why this is cool! In Java, you'd typically write this with a for loop or stream().reduce().
// The Rust version is not just shorter - it's actually doing something pretty smart under the hood.
//
// In Java, streams are basically a wrapper around collections. When you do:
// IntStream.rangeClosed(1, n).reduce(1, (a,b) -> a*b)
// 
// You're creating an actual collection in memory first. Rust's ranges are different - they're lazy iterators
// that generate values on demand. No memory allocation needed! The fold() operation just walks through these
// values one by one.
//
// This ties into Rust's zero-cost abstractions philosophy - you get clean, functional-style code that compiles
// down to the same efficient machine code as a raw loop. Java's stream operations, while convenient, do have
// some runtime overhead.
//
// Plus, Rust's type system ensures this is totally safe at compile time - no null checks or exception handling
// needed. Pretty neat how it combines safety, elegance and performance, right?

    
    // Memory visualization:
    // For n = 5:
    // ┌─────┬─────┬─────┬─────┬─────┐
    // │  1  │  2  │  3  │  4  │  5  │  <- Range values
    // └─────┴─────┴─────┴─────┴─────┘
    //    ↓     ↓     ↓     ↓     ↓
    // acc=1 acc=1 acc=2 acc=6 acc=24 -> 120
    //   *1   *2   *3   *4    *5
}

fn main() {
    let result = factorial(5);
    println!("Factorial of 5 is {}", result);
}

```
